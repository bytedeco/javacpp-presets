// Targeted by JavaCPP version 1.2.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class gsl extends org.bytedeco.javacpp.presets.gsl {
    static { Loader.load(); }

// Parsed from gsl/gsl_types.h

/* gsl_types.h
 * 
 * Copyright (C) 2001, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_TYPES_H__
// #define __GSL_TYPES_H__

// #ifndef GSL_VAR

// #ifdef WIN32
// #  ifdef GSL_DLL
// #    ifdef DLL_EXPORT
// #      define GSL_VAR extern __declspec(dllexport)
// #    else
// #      define GSL_VAR extern __declspec(dllimport)
// #    endif
// #  else
// #    define GSL_VAR extern
// #  endif
// #else
// #  define GSL_VAR extern
// #endif

// #endif

// #endif /* __GSL_TYPES_H__ */


// Parsed from gsl/gsl_errno.h

/* err/gsl_errno.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_ERRNO_H__
// #define __GSL_ERRNO_H__

// #include <stdio.h>
// #include <errno.h>
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/** enum  */
public static final int 
  GSL_SUCCESS  = 0, 
  GSL_FAILURE  = -1,
  GSL_CONTINUE = -2,  /* iteration has not converged */
  GSL_EDOM     = 1,   /* input domain error, e.g sqrt(-1) */
  GSL_ERANGE   = 2,   /* output range error, e.g. exp(1e100) */
  GSL_EFAULT   = 3,   /* invalid pointer */
  GSL_EINVAL   = 4,   /* invalid argument supplied by user */
  GSL_EFAILED  = 5,   /* generic failure */
  GSL_EFACTOR  = 6,   /* factorization failed */
  GSL_ESANITY  = 7,   /* sanity check failed - shouldn't happen */
  GSL_ENOMEM   = 8,   /* malloc failed */
  GSL_EBADFUNC = 9,   /* problem with user-supplied function */
  GSL_ERUNAWAY = 10,  /* iterative process is out of control */
  GSL_EMAXITER = 11,  /* exceeded max number of iterations */
  GSL_EZERODIV = 12,  /* tried to divide by zero */
  GSL_EBADTOL  = 13,  /* user specified an invalid tolerance */
  GSL_ETOL     = 14,  /* failed to reach the specified tolerance */
  GSL_EUNDRFLW = 15,  /* underflow */
  GSL_EOVRFLW  = 16,  /* overflow  */
  GSL_ELOSS    = 17,  /* loss of accuracy */
  GSL_EROUND   = 18,  /* failed because of roundoff error */
  GSL_EBADLEN  = 19,  /* matrix, vector lengths are not conformant */
  GSL_ENOTSQR  = 20,  /* matrix not square */
  GSL_ESING    = 21,  /* apparent singularity detected */
  GSL_EDIVERGE = 22,  /* integral or series is divergent */
  GSL_EUNSUP   = 23,  /* requested feature is not supported by the hardware */
  GSL_EUNIMPL  = 24,  /* requested feature not (yet) implemented */
  GSL_ECACHE   = 25,  /* cache limit exceeded */
  GSL_ETABLE   = 26,  /* table limit exceeded */
  GSL_ENOPROG  = 27,  /* iteration is not making progress towards solution */
  GSL_ENOPROGJ = 28,  /* jacobian evaluations are not improving the solution */
  GSL_ETOLF    = 29,  /* cannot reach the specified tolerance in F */
  GSL_ETOLX    = 30,  /* cannot reach the specified tolerance in X */
  GSL_ETOLG    = 31,  /* cannot reach the specified tolerance in gradient */
  GSL_EOF      = 32 ;   /* end of file */

public static native void gsl_error(@Cast("const char*") BytePointer reason, @Cast("const char*") BytePointer file, int line,
                int gsl_errno);
public static native void gsl_error(String reason, String file, int line,
                int gsl_errno);

public static native void gsl_stream_printf(@Cast("const char*") BytePointer label, @Cast("const char*") BytePointer file,
                        int line, @Cast("const char*") BytePointer reason);
public static native void gsl_stream_printf(String label, String file,
                        int line, String reason);

public static native @Cast("const char*") BytePointer gsl_strerror(int gsl_errno);

public static class gsl_error_handler_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_error_handler_t(Pointer p) { super(p); }
    protected gsl_error_handler_t() { allocate(); }
    private native void allocate();
    public native void call(@Cast("const char*") BytePointer reason, @Cast("const char*") BytePointer file,
                                  int line, int gsl_errno);
}

public static class gsl_stream_handler_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_stream_handler_t(Pointer p) { super(p); }
    protected gsl_stream_handler_t() { allocate(); }
    private native void allocate();
    public native void call(@Cast("const char*") BytePointer label, @Cast("const char*") BytePointer file,
                                   int line, @Cast("const char*") BytePointer reason);
}

public static native gsl_error_handler_t gsl_set_error_handler(gsl_error_handler_t new_handler);

public static native gsl_error_handler_t gsl_set_error_handler_off();

public static native gsl_stream_handler_t gsl_set_stream_handler(gsl_stream_handler_t new_handler);

public static native @Cast("FILE*") Pointer gsl_set_stream(@Cast("FILE*") Pointer new_stream);

/* GSL_ERROR: call the error handler, and return the error code */

// #define GSL_ERROR(reason, gsl_errno)
//        do {
//        gsl_error (reason, __FILE__, __LINE__, gsl_errno) ;
//        return gsl_errno ;
//        } while (0)

/* GSL_ERROR_VAL: call the error handler, and return the given value */

// #define GSL_ERROR_VAL(reason, gsl_errno, value)
//        do {
//        gsl_error (reason, __FILE__, __LINE__, gsl_errno) ;
//        return value ;
//        } while (0)

/* GSL_ERROR_VOID: call the error handler, and then return
   (for void functions which still need to generate an error) */

// #define GSL_ERROR_VOID(reason, gsl_errno)
//        do {
//        gsl_error (reason, __FILE__, __LINE__, gsl_errno) ;
//        return ;
//        } while (0)

/* GSL_ERROR_NULL suitable for out-of-memory conditions */

// #define GSL_ERROR_NULL(reason, gsl_errno) GSL_ERROR_VAL(reason, gsl_errno, 0)

/* Sometimes you have several status results returned from
 * function calls and you want to combine them in some sensible
 * way. You cannot produce a "total" status condition, but you can
 * pick one from a set of conditions based on an implied hierarchy.
 *
 * In other words:
 *    you have: status_a, status_b, ...
 *    you want: status = (status_a if it is bad, or status_b if it is bad,...)
 *
 * In this example you consider status_a to be more important and
 * it is checked first, followed by the others in the order specified.
 *
 * Here are some dumb macros to do this.
 */
// #define GSL_ERROR_SELECT_2(a,b)       ((a) != GSL_SUCCESS ? (a) : ((b) != GSL_SUCCESS ? (b) : GSL_SUCCESS))
// #define GSL_ERROR_SELECT_3(a,b,c)     ((a) != GSL_SUCCESS ? (a) : GSL_ERROR_SELECT_2(b,c))
// #define GSL_ERROR_SELECT_4(a,b,c,d)   ((a) != GSL_SUCCESS ? (a) : GSL_ERROR_SELECT_3(b,c,d))
// #define GSL_ERROR_SELECT_5(a,b,c,d,e) ((a) != GSL_SUCCESS ? (a) : GSL_ERROR_SELECT_4(b,c,d,e))

// #define GSL_STATUS_UPDATE(sp, s) do { if ((s) != GSL_SUCCESS) *(sp) = (s);} while(0)

// #endif /* __GSL_ERRNO_H__ */


// Parsed from gsl/gsl_ieee_utils.h

/* ieee-utils/gsl_ieee_utils.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_IEEE_UTILS_H__
// #define __GSL_IEEE_UTILS_H__
// #include <stdio.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/** enum  */
public static final int
  GSL_IEEE_TYPE_NAN = 1,
  GSL_IEEE_TYPE_INF = 2,
  GSL_IEEE_TYPE_NORMAL = 3,
  GSL_IEEE_TYPE_DENORMAL = 4,
  GSL_IEEE_TYPE_ZERO = 5 ;

 public static class gsl_ieee_float_rep extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_ieee_float_rep() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_ieee_float_rep(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_ieee_float_rep(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_ieee_float_rep position(long position) {
        return (gsl_ieee_float_rep)super.position(position);
    }

  public native int sign(); public native gsl_ieee_float_rep sign(int sign);
  public native @Cast("char") byte mantissa(int i); public native gsl_ieee_float_rep mantissa(int i, byte mantissa);
  @MemberGetter public native @Cast("char*") BytePointer mantissa(); /* Actual bits are 0..22, element 23 is \0 */
  public native int exponent(); public native gsl_ieee_float_rep exponent(int exponent);
  public native int type(); public native gsl_ieee_float_rep type(int type);
} 

 public static class gsl_ieee_double_rep extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_ieee_double_rep() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_ieee_double_rep(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_ieee_double_rep(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_ieee_double_rep position(long position) {
        return (gsl_ieee_double_rep)super.position(position);
    }

  public native int sign(); public native gsl_ieee_double_rep sign(int sign);
  public native @Cast("char") byte mantissa(int i); public native gsl_ieee_double_rep mantissa(int i, byte mantissa);
  @MemberGetter public native @Cast("char*") BytePointer mantissa(); /* Actual bits are 0..51, element 52 is \0 */
  public native int exponent(); public native gsl_ieee_double_rep exponent(int exponent);
  public native int type(); public native gsl_ieee_double_rep type(int type);
} 


public static native void gsl_ieee_printf_float(@Const FloatPointer x);
public static native void gsl_ieee_printf_float(@Const FloatBuffer x);
public static native void gsl_ieee_printf_float(@Const float[] x);
public static native void gsl_ieee_printf_double(@Const DoublePointer x);
public static native void gsl_ieee_printf_double(@Const DoubleBuffer x);
public static native void gsl_ieee_printf_double(@Const double[] x);

public static native void gsl_ieee_fprintf_float(@Cast("FILE*") Pointer stream, @Const FloatPointer x);
public static native void gsl_ieee_fprintf_float(@Cast("FILE*") Pointer stream, @Const FloatBuffer x);
public static native void gsl_ieee_fprintf_float(@Cast("FILE*") Pointer stream, @Const float[] x);
public static native void gsl_ieee_fprintf_double(@Cast("FILE*") Pointer stream, @Const DoublePointer x);
public static native void gsl_ieee_fprintf_double(@Cast("FILE*") Pointer stream, @Const DoubleBuffer x);
public static native void gsl_ieee_fprintf_double(@Cast("FILE*") Pointer stream, @Const double[] x);

public static native void gsl_ieee_float_to_rep(@Const FloatPointer x, gsl_ieee_float_rep r);
public static native void gsl_ieee_float_to_rep(@Const FloatBuffer x, gsl_ieee_float_rep r);
public static native void gsl_ieee_float_to_rep(@Const float[] x, gsl_ieee_float_rep r);
public static native void gsl_ieee_double_to_rep(@Const DoublePointer x, gsl_ieee_double_rep r);
public static native void gsl_ieee_double_to_rep(@Const DoubleBuffer x, gsl_ieee_double_rep r);
public static native void gsl_ieee_double_to_rep(@Const double[] x, gsl_ieee_double_rep r);

/** enum  */
public static final int
  GSL_IEEE_SINGLE_PRECISION = 1,
  GSL_IEEE_DOUBLE_PRECISION = 2,
  GSL_IEEE_EXTENDED_PRECISION = 3 ;

/** enum  */
public static final int
  GSL_IEEE_ROUND_TO_NEAREST = 1,
  GSL_IEEE_ROUND_DOWN = 2,
  GSL_IEEE_ROUND_UP = 3,
  GSL_IEEE_ROUND_TO_ZERO = 4 ;

/** enum  */
public static final int
  GSL_IEEE_MASK_INVALID = 1,
  GSL_IEEE_MASK_DENORMALIZED = 2,
  GSL_IEEE_MASK_DIVISION_BY_ZERO = 4,
  GSL_IEEE_MASK_OVERFLOW = 8,
  GSL_IEEE_MASK_UNDERFLOW = 16,
  GSL_IEEE_MASK_ALL = 31,
  GSL_IEEE_TRAP_INEXACT = 32 ;

public static native void gsl_ieee_env_setup();
public static native int gsl_ieee_read_mode_string(@Cast("const char*") BytePointer description, IntPointer precision,
                               IntPointer rounding, IntPointer exception_mask);
public static native int gsl_ieee_read_mode_string(String description, IntBuffer precision,
                               IntBuffer rounding, IntBuffer exception_mask);
public static native int gsl_ieee_read_mode_string(@Cast("const char*") BytePointer description, int[] precision,
                               int[] rounding, int[] exception_mask);
public static native int gsl_ieee_read_mode_string(String description, IntPointer precision,
                               IntPointer rounding, IntPointer exception_mask);
public static native int gsl_ieee_read_mode_string(@Cast("const char*") BytePointer description, IntBuffer precision,
                               IntBuffer rounding, IntBuffer exception_mask);
public static native int gsl_ieee_read_mode_string(String description, int[] precision,
                               int[] rounding, int[] exception_mask);
public static native int gsl_ieee_set_mode(int precision, int rounding, int exception_mask);

// #endif /* __GSL_IEEE_UTILS_H__ */



// Parsed from gsl/gsl_inline.h

/* gsl_inline.h
 * 
 * Copyright (C) 2008, 2009 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_INLINE_H__
// #define __GSL_INLINE_H__

/* In recent versiions of GCC, the inline keyword has two different
   forms: GNU and C99.

   In GNU mode we can use 'extern inline' to make inline functions
   work like macros.  The function is only inlined--it is never output
   as a definition in an object file.

   In the new C99 mode 'extern inline' has a different meaning--it
   causes the definition of the function to be output in each object
   file where it is used.  This will result in multiple-definition
   errors on linking.  The 'inline' keyword on its own (without
   extern) has the same behavior as the original GNU 'extern inline'.

   The C99 style is the default with -std=c99 in GCC 4.3.  

   This header file allows either form of inline to be used by
   redefining the macros INLINE_DECL and INLINE_FUN.  These are used
   in the public header files as

        INLINE_DECL double gsl_foo (double x);
	#ifdef HAVE_INLINE
	INLINE_FUN double gsl_foo (double x) { return x+1.0; } ;
        #endif
   
*/

// #ifdef HAVE_INLINE
// #  if defined(__GNUC_STDC_INLINE__) || defined(GSL_C99_INLINE) || defined(HAVE_C99_INLINE)
// #    define INLINE_DECL inline  /* use C99 inline */
// #    define INLINE_FUN inline
// #  else
// #    define INLINE_DECL         /* use GNU extern inline */
// #    define INLINE_FUN extern inline
// #  endif
// #else
// #  define INLINE_DECL /* */
// #endif

/* Range checking conditions in headers do not require any run-time
   tests of the global variable gsl_check_range.  They are enabled or
   disabled in user code at compile time with GSL_RANGE_CHECK macro.
   See also build.h. */
// #define GSL_RANGE_COND(x) (x)

// #endif /* __GSL_INLINE_H__ */


// Parsed from gsl/gsl_message.h

/* err/gsl_message.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MESSAGE_H__
// #define __GSL_MESSAGE_H__
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* Provide a general messaging service for client use.  Messages can
 * be selectively turned off at compile time by defining an
 * appropriate message mask. Client code which uses the GSL_MESSAGE()
 * macro must provide a mask which is or'ed with the GSL_MESSAGE_MASK.
 *
 * The messaging service can be completely turned off
 * by defining GSL_MESSAGING_OFF.  */

public static native void gsl_message(@Cast("const char*") BytePointer message, @Cast("const char*") BytePointer file, int line,
                 @Cast("unsigned int") int mask);
public static native void gsl_message(String message, String file, int line,
                 @Cast("unsigned int") int mask);

// #ifndef GSL_MESSAGE_MASK
public static final int GSL_MESSAGE_MASK = 0xffffffff; /* default all messages allowed */
// #endif

public static native @Cast("unsigned int") int gsl_message_mask(); public static native void gsl_message_mask(int gsl_message_mask);

/* Provide some symolic masks for client ease of use. */

/** enum  */
public static final int
  GSL_MESSAGE_MASK_A = 1,
  GSL_MESSAGE_MASK_B = 2,
  GSL_MESSAGE_MASK_C = 4,
  GSL_MESSAGE_MASK_D = 8,
  GSL_MESSAGE_MASK_E = 16,
  GSL_MESSAGE_MASK_F = 32,
  GSL_MESSAGE_MASK_G = 64,
  GSL_MESSAGE_MASK_H = 128 ;

// #ifdef GSL_MESSAGING_OFF        /* throw away messages */ 
// #define GSL_MESSAGE(message, mask) do { } while(0)
// #else                           /* output all messages */
// #define GSL_MESSAGE(message, mask)
//        do {
//        if (mask & GSL_MESSAGE_MASK)
//          gsl_message (message, __FILE__, __LINE__, mask) ;
//        } while (0)
// #endif

// #endif /* __GSL_MESSAGE_H__ */




// Parsed from gsl/gsl_complex.h

/* complex/gsl_complex.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_COMPLEX_H__
// #define __GSL_COMPLEX_H__

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* two consecutive built-in types as a complex number */


/* 2N consecutive built-in types as N complex numbers */


/* Yes... this seems weird. Trust us. The point is just that
   sometimes you want to make it obvious that something is
   an output value. The fact that it lacks a 'const' may not
   be enough of a clue for people in some contexts.
 */


public static class gsl_complex_long_double extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_complex_long_double() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_complex_long_double(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_complex_long_double(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_complex_long_double position(long position) {
        return (gsl_complex_long_double)super.position(position);
    }

    public native @Cast("long double") double dat(int i); public native gsl_complex_long_double dat(int i, double dat);
    @MemberGetter public native @Cast("long double*") Pointer dat();
  }

public static class gsl_complex extends DoublePointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_complex() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_complex(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_complex(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_complex position(long position) {
        return (gsl_complex)super.position(position);
    }

    public native double dat(int i); public native gsl_complex dat(int i, double dat);
    @MemberGetter public native DoublePointer dat();
  }

public static class gsl_complex_float extends FloatPointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_complex_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_complex_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_complex_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_complex_float position(long position) {
        return (gsl_complex_float)super.position(position);
    }

    public native float dat(int i); public native gsl_complex_float dat(int i, float dat);
    @MemberGetter public native FloatPointer dat();
  }

// #define GSL_REAL(z)     ((z).dat[0])
// #define GSL_IMAG(z)     ((z).dat[1])
// #define GSL_COMPLEX_P(zp) ((zp)->dat)
// #define GSL_COMPLEX_P_REAL(zp)  ((zp)->dat[0])
// #define GSL_COMPLEX_P_IMAG(zp)  ((zp)->dat[1])
// #define GSL_COMPLEX_EQ(z1,z2) (((z1).dat[0] == (z2).dat[0]) && ((z1).dat[1] == (z2).dat[1]))

// #define GSL_SET_COMPLEX(zp,x,y) do {(zp)->dat[0]=(x); (zp)->dat[1]=(y);} while(0)
// #define GSL_SET_REAL(zp,x) do {(zp)->dat[0]=(x);} while(0)
// #define GSL_SET_IMAG(zp,y) do {(zp)->dat[1]=(y);} while(0)

// #define GSL_SET_COMPLEX_PACKED(zp,n,x,y) do {*((zp)+2*(n))=(x); *((zp)+(2*(n)+1))=(y);} while(0)

// #endif /* __GSL_COMPLEX_H__ */


// Parsed from gsl/gsl_complex_math.h

/* complex/gsl_complex_math.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007 Jorma Olavi Tï¿½htinen, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_COMPLEX_MATH_H__
// #define __GSL_COMPLEX_MATH_H__
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_complex.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// #define __BEGIN_DECLS extern "C" {
// #define __END_DECLS }
// #else
// #endif

/* Complex numbers */

public static native @ByVal gsl_complex gsl_complex_polar(double r, double theta); /* r= r e^(i theta) */

/* */ public static native @ByVal gsl_complex gsl_complex_rect(double x, double y);  /* r= real+i*imag */

// #ifdef HAVE_INLINE
// #endif

public static native @MemberGetter @ByVal gsl_complex GSL_COMPLEX_ONE();
public static final gsl_complex GSL_COMPLEX_ONE = GSL_COMPLEX_ONE();
public static native @MemberGetter @ByVal gsl_complex GSL_COMPLEX_ZERO();
public static final gsl_complex GSL_COMPLEX_ZERO = GSL_COMPLEX_ZERO();
public static native @MemberGetter @ByVal gsl_complex GSL_COMPLEX_NEGONE();
public static final gsl_complex GSL_COMPLEX_NEGONE = GSL_COMPLEX_NEGONE();

/* Properties of complex numbers */

public static native double gsl_complex_arg(@ByVal gsl_complex z); /* return arg(z), -pi< arg(z) <=+pi */
public static native double gsl_complex_abs(@ByVal gsl_complex z);   /* return |z|   */
public static native double gsl_complex_abs2(@ByVal gsl_complex z);  /* return |z|^2 */
public static native double gsl_complex_logabs(@ByVal gsl_complex z); /* return log|z| */

/* Complex arithmetic operators */

public static native @ByVal gsl_complex gsl_complex_add(@ByVal gsl_complex a, @ByVal gsl_complex b);  /* r=a+b */
public static native @ByVal gsl_complex gsl_complex_sub(@ByVal gsl_complex a, @ByVal gsl_complex b);  /* r=a-b */
public static native @ByVal gsl_complex gsl_complex_mul(@ByVal gsl_complex a, @ByVal gsl_complex b);  /* r=a*b */
public static native @ByVal gsl_complex gsl_complex_div(@ByVal gsl_complex a, @ByVal gsl_complex b);  /* r=a/b */
                                                           
public static native @ByVal gsl_complex gsl_complex_add_real(@ByVal gsl_complex a, double x);  /* r=a+x */
public static native @ByVal gsl_complex gsl_complex_sub_real(@ByVal gsl_complex a, double x);  /* r=a-x */
public static native @ByVal gsl_complex gsl_complex_mul_real(@ByVal gsl_complex a, double x);  /* r=a*x */
public static native @ByVal gsl_complex gsl_complex_div_real(@ByVal gsl_complex a, double x);  /* r=a/x */

public static native @ByVal gsl_complex gsl_complex_add_imag(@ByVal gsl_complex a, double y);  /* r=a+iy */
public static native @ByVal gsl_complex gsl_complex_sub_imag(@ByVal gsl_complex a, double y);  /* r=a-iy */
public static native @ByVal gsl_complex gsl_complex_mul_imag(@ByVal gsl_complex a, double y);  /* r=a*iy */
public static native @ByVal gsl_complex gsl_complex_div_imag(@ByVal gsl_complex a, double y);  /* r=a/iy */

public static native @ByVal gsl_complex gsl_complex_conjugate(@ByVal gsl_complex z);  /* r=conj(z) */
public static native @ByVal gsl_complex gsl_complex_inverse(@ByVal gsl_complex a);    /* r=1/a */
public static native @ByVal gsl_complex gsl_complex_negative(@ByVal gsl_complex a);    /* r=-a */

/* Elementary Complex Functions */

public static native @ByVal gsl_complex gsl_complex_sqrt(@ByVal gsl_complex z);  /* r=sqrt(z) */
public static native @ByVal gsl_complex gsl_complex_sqrt_real(double x);  /* r=sqrt(x) (x<0 ok) */

public static native @ByVal gsl_complex gsl_complex_pow(@ByVal gsl_complex a, @ByVal gsl_complex b);  /* r=a^b */
public static native @ByVal gsl_complex gsl_complex_pow_real(@ByVal gsl_complex a, double b);  /* r=a^b */

public static native @ByVal gsl_complex gsl_complex_exp(@ByVal gsl_complex a);    /* r=exp(a) */
public static native @ByVal gsl_complex gsl_complex_log(@ByVal gsl_complex a);    /* r=log(a) (base e) */
public static native @ByVal gsl_complex gsl_complex_log10(@ByVal gsl_complex a);  /* r=log10(a) (base 10) */
public static native @ByVal gsl_complex gsl_complex_log_b(@ByVal gsl_complex a, @ByVal gsl_complex b);   /* r=log_b(a) (base=b) */

/* Complex Trigonometric Functions */

public static native @ByVal gsl_complex gsl_complex_sin(@ByVal gsl_complex a);  /* r=sin(a) */
public static native @ByVal gsl_complex gsl_complex_cos(@ByVal gsl_complex a);  /* r=cos(a) */
public static native @ByVal gsl_complex gsl_complex_sec(@ByVal gsl_complex a);  /* r=sec(a) */
public static native @ByVal gsl_complex gsl_complex_csc(@ByVal gsl_complex a);  /* r=csc(a) */
public static native @ByVal gsl_complex gsl_complex_tan(@ByVal gsl_complex a);  /* r=tan(a) */
public static native @ByVal gsl_complex gsl_complex_cot(@ByVal gsl_complex a);  /* r=cot(a) */

/* Inverse Complex Trigonometric Functions */

public static native @ByVal gsl_complex gsl_complex_arcsin(@ByVal gsl_complex a);  /* r=arcsin(a) */
public static native @ByVal gsl_complex gsl_complex_arcsin_real(double a);  /* r=arcsin(a) */
public static native @ByVal gsl_complex gsl_complex_arccos(@ByVal gsl_complex a);  /* r=arccos(a) */
public static native @ByVal gsl_complex gsl_complex_arccos_real(double a);  /* r=arccos(a) */
public static native @ByVal gsl_complex gsl_complex_arcsec(@ByVal gsl_complex a);  /* r=arcsec(a) */
public static native @ByVal gsl_complex gsl_complex_arcsec_real(double a);  /* r=arcsec(a) */
public static native @ByVal gsl_complex gsl_complex_arccsc(@ByVal gsl_complex a);  /* r=arccsc(a) */
public static native @ByVal gsl_complex gsl_complex_arccsc_real(double a);  /* r=arccsc(a) */
public static native @ByVal gsl_complex gsl_complex_arctan(@ByVal gsl_complex a);  /* r=arctan(a) */
public static native @ByVal gsl_complex gsl_complex_arccot(@ByVal gsl_complex a);  /* r=arccot(a) */

/* Complex Hyperbolic Functions */

public static native @ByVal gsl_complex gsl_complex_sinh(@ByVal gsl_complex a);  /* r=sinh(a) */
public static native @ByVal gsl_complex gsl_complex_cosh(@ByVal gsl_complex a);  /* r=coshh(a) */
public static native @ByVal gsl_complex gsl_complex_sech(@ByVal gsl_complex a);  /* r=sech(a) */
public static native @ByVal gsl_complex gsl_complex_csch(@ByVal gsl_complex a);  /* r=csch(a) */
public static native @ByVal gsl_complex gsl_complex_tanh(@ByVal gsl_complex a);  /* r=tanh(a) */
public static native @ByVal gsl_complex gsl_complex_coth(@ByVal gsl_complex a);  /* r=coth(a) */

/* Inverse Complex Hyperbolic Functions */

public static native @ByVal gsl_complex gsl_complex_arcsinh(@ByVal gsl_complex a);  /* r=arcsinh(a) */
public static native @ByVal gsl_complex gsl_complex_arccosh(@ByVal gsl_complex a);  /* r=arccosh(a) */
public static native @ByVal gsl_complex gsl_complex_arccosh_real(double a);  /* r=arccosh(a) */
public static native @ByVal gsl_complex gsl_complex_arcsech(@ByVal gsl_complex a);  /* r=arcsech(a) */
public static native @ByVal gsl_complex gsl_complex_arccsch(@ByVal gsl_complex a);  /* r=arccsch(a) */
public static native @ByVal gsl_complex gsl_complex_arctanh(@ByVal gsl_complex a);  /* r=arctanh(a) */
public static native @ByVal gsl_complex gsl_complex_arctanh_real(double a);  /* r=arctanh(a) */
public static native @ByVal gsl_complex gsl_complex_arccoth(@ByVal gsl_complex a);  /* r=arccoth(a) */

// #endif /* __GSL_COMPLEX_MATH_H__ */


// Parsed from gsl/gsl_check_range.h

/* vector/gsl_check_range.h
 * 
 * Copyright (C) 2003, 2004, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_CHECK_RANGE_H__
// #define __GSL_CHECK_RANGE_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_check_range(); public static native void gsl_check_range(int gsl_check_range);

/* Turn range checking on by default, unless the user defines
   GSL_RANGE_CHECK_OFF, or defines GSL_RANGE_CHECK to 0 explicitly */

// #ifdef GSL_RANGE_CHECK_OFF
// # ifndef GSL_RANGE_CHECK
// #  define GSL_RANGE_CHECK 0
// # else
// # endif
// #else
// # ifndef GSL_RANGE_CHECK
// #  define GSL_RANGE_CHECK 1
// # endif
// #endif

// #endif /* __GSL_CHECK_RANGE_H__ */


// Parsed from gsl/gsl_sys.h

/* sys/gsl_sys.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SYS_H__
// #define __GSL_SYS_H__

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_log1p(double x);
public static native double gsl_expm1(double x);
public static native double gsl_hypot(double x, double y);
public static native double gsl_hypot3(double x, double y, double z);
public static native double gsl_acosh(double x);
public static native double gsl_asinh(double x);
public static native double gsl_atanh(double x);

public static native int gsl_isnan(double x);
public static native int gsl_isinf(double x);
public static native int gsl_finite(double x);

public static native double gsl_nan();
public static native double gsl_posinf();
public static native double gsl_neginf();
public static native double gsl_fdiv(double x, double y);

public static native double gsl_coerce_double(double x);
public static native float gsl_coerce_float(float x);
public static native @Cast("long double") double gsl_coerce_long_double(@Cast("const long double") double x);

public static native double gsl_ldexp(double x, int e);
public static native double gsl_frexp(double x, IntPointer e);
public static native double gsl_frexp(double x, IntBuffer e);
public static native double gsl_frexp(double x, int[] e);

public static native int gsl_fcmp(double x1, double x2, double epsilon);

// #endif /* __GSL_SYS_H__ */


// Parsed from gsl/gsl_machine.h

/* Author:  B. Gough and G. Jungman */
// #ifndef __GSL_MACHINE_H__
// #define __GSL_MACHINE_H__

// #include <limits.h>
// #include <float.h>

/* magic constants; mostly for the benefit of the implementation */

/* -*-MACHINE CONSTANTS-*-
 *
 * PLATFORM: Whiz-O-Matic 9000
 * FP_PLATFORM: IEEE-Virtual
 * HOSTNAME: nnn.lanl.gov
 * DATE: Fri Nov 20 17:53:26 MST 1998
 */
public static final double GSL_DBL_EPSILON =        2.2204460492503131e-16;
public static final double GSL_SQRT_DBL_EPSILON =   1.4901161193847656e-08;
public static final double GSL_ROOT3_DBL_EPSILON =  6.0554544523933429e-06;
public static final double GSL_ROOT4_DBL_EPSILON =  1.2207031250000000e-04;
public static final double GSL_ROOT5_DBL_EPSILON =  7.4009597974140505e-04;
public static final double GSL_ROOT6_DBL_EPSILON =  2.4607833005759251e-03;
public static final double GSL_LOG_DBL_EPSILON =   (-3.6043653389117154e+01);

public static final double GSL_DBL_MIN =        2.2250738585072014e-308;
public static final double GSL_SQRT_DBL_MIN =   1.4916681462400413e-154;
public static final double GSL_ROOT3_DBL_MIN =  2.8126442852362996e-103;
public static final double GSL_ROOT4_DBL_MIN =  1.2213386697554620e-77;
public static final double GSL_ROOT5_DBL_MIN =  2.9476022969691763e-62;
public static final double GSL_ROOT6_DBL_MIN =  5.3034368905798218e-52;
public static final double GSL_LOG_DBL_MIN =   (-7.0839641853226408e+02);

public static final double GSL_DBL_MAX =        1.7976931348623157e+308;
public static final double GSL_SQRT_DBL_MAX =   1.3407807929942596e+154;
public static final double GSL_ROOT3_DBL_MAX =  5.6438030941222897e+102;
public static final double GSL_ROOT4_DBL_MAX =  1.1579208923731620e+77;
public static final double GSL_ROOT5_DBL_MAX =  4.4765466227572707e+61;
public static final double GSL_ROOT6_DBL_MAX =  2.3756689782295612e+51;
public static final double GSL_LOG_DBL_MAX =    7.0978271289338397e+02;

public static final double GSL_FLT_EPSILON =        1.1920928955078125e-07;
public static final double GSL_SQRT_FLT_EPSILON =   3.4526698300124393e-04;
public static final double GSL_ROOT3_FLT_EPSILON =  4.9215666011518501e-03;
public static final double GSL_ROOT4_FLT_EPSILON =  1.8581361171917516e-02;
public static final double GSL_ROOT5_FLT_EPSILON =  4.1234622211652937e-02;
public static final double GSL_ROOT6_FLT_EPSILON =  7.0153878019335827e-02;
public static final double GSL_LOG_FLT_EPSILON =   (-1.5942385152878742e+01);

public static final double GSL_FLT_MIN =        1.1754943508222875e-38;
public static final double GSL_SQRT_FLT_MIN =   1.0842021724855044e-19;
public static final double GSL_ROOT3_FLT_MIN =  2.2737367544323241e-13;
public static final double GSL_ROOT4_FLT_MIN =  3.2927225399135965e-10;
public static final double GSL_ROOT5_FLT_MIN =  2.5944428542140822e-08;
public static final double GSL_ROOT6_FLT_MIN =  4.7683715820312542e-07;
public static final double GSL_LOG_FLT_MIN =   (-8.7336544750553102e+01);

public static final double GSL_FLT_MAX =        3.4028234663852886e+38;
public static final double GSL_SQRT_FLT_MAX =   1.8446743523953730e+19;
public static final double GSL_ROOT3_FLT_MAX =  6.9814635196223242e+12;
public static final double GSL_ROOT4_FLT_MAX =  4.2949672319999986e+09;
public static final double GSL_ROOT5_FLT_MAX =  5.0859007855960041e+07;
public static final double GSL_ROOT6_FLT_MAX =  2.6422459233807749e+06;
public static final double GSL_LOG_FLT_MAX =    8.8722839052068352e+01;

public static final double GSL_SFLT_EPSILON =        4.8828125000000000e-04;
public static final double GSL_SQRT_SFLT_EPSILON =   2.2097086912079612e-02;
public static final double GSL_ROOT3_SFLT_EPSILON =  7.8745065618429588e-02;
public static final double GSL_ROOT4_SFLT_EPSILON =  1.4865088937534013e-01;
public static final double GSL_ROOT5_SFLT_EPSILON =  2.1763764082403100e-01;
public static final double GSL_ROOT6_SFLT_EPSILON =  2.8061551207734325e-01;
public static final double GSL_LOG_SFLT_EPSILON =   (-7.6246189861593985e+00);

/* !MACHINE CONSTANTS! */


/* a little internal backwards compatibility */
public static final double GSL_MACH_EPS =  GSL_DBL_EPSILON;



/* Here are the constants related to or derived from
 * machine constants. These are not to be confused with
 * the constants that define various precision levels
 * for the precision/error system.
 *
 * This information is determined at configure time
 * and is platform dependent. Edit at your own risk.
 *
 * PLATFORM: WHIZ-O-MATIC
 * CONFIG-DATE: Thu Nov 19 19:27:18 MST 1998
 * CONFIG-HOST: nnn.lanl.gov
 */

/* machine precision constants */
/* #define GSL_MACH_EPS         1.0e-15 */
public static final double GSL_SQRT_MACH_EPS =       3.2e-08;
public static final double GSL_ROOT3_MACH_EPS =      1.0e-05;
public static final double GSL_ROOT4_MACH_EPS =      0.000178;
public static final double GSL_ROOT5_MACH_EPS =      0.00100;
public static final double GSL_ROOT6_MACH_EPS =      0.00316;
public static final double GSL_LOG_MACH_EPS =       (-34.54);


// #endif /* __GSL_MACHINE_H__ */


// Parsed from gsl/gsl_precision.h

/* gsl_precision.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  B. Gough and G. Jungman */

// #ifndef __GSL_PRECISION_H__
// #define __GSL_PRECISION_H__
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* A type for the precision indicator.
 * This is mainly for pedagogy.
 */


/* The number of precision types.
 * Remember that precision-mode
 * can index an array.
 */
public static final int _GSL_PREC_T_NUM = 3;


/* Arrays containing derived
 * precision constants for the
 * different precision levels.
 */
@MemberGetter public static native double gsl_prec_eps(int i);
@MemberGetter public static native @Const DoublePointer gsl_prec_eps();
@MemberGetter public static native double gsl_prec_sqrt_eps(int i);
@MemberGetter public static native @Const DoublePointer gsl_prec_sqrt_eps();
@MemberGetter public static native double gsl_prec_root3_eps(int i);
@MemberGetter public static native @Const DoublePointer gsl_prec_root3_eps();
@MemberGetter public static native double gsl_prec_root4_eps(int i);
@MemberGetter public static native @Const DoublePointer gsl_prec_root4_eps();
@MemberGetter public static native double gsl_prec_root5_eps(int i);
@MemberGetter public static native @Const DoublePointer gsl_prec_root5_eps();
@MemberGetter public static native double gsl_prec_root6_eps(int i);
@MemberGetter public static native @Const DoublePointer gsl_prec_root6_eps();

// #endif /* __GSL_PRECISION_H__ */


// Parsed from gsl/gsl_nan.h

/* gsl_nan.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_NAN_H__
// #define __GSL_NAN_H__

// #ifdef INFINITY
// #elif defined(HUGE_VAL)
// #else
public static native @MemberGetter int GSL_POSINF();
public static final int GSL_POSINF = GSL_POSINF();
public static native @MemberGetter int GSL_NEGINF();
public static final int GSL_NEGINF = GSL_NEGINF();
// #endif

// #ifdef NAN
// #elif defined(INFINITY)
// #else
public static native @MemberGetter int GSL_NAN();
public static final int GSL_NAN = GSL_NAN();
// #endif

public static final double GSL_POSZERO = (+0.0);
public static final double GSL_NEGZERO = (-0.0);

// #endif /* __GSL_NAN_H__ */


// Parsed from gsl/gsl_pow_int.h

/* gsl_pow_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_POW_INT_H__
// #define __GSL_POW_INT_H__
// #include <gsl/gsl_inline.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* */ public static native double gsl_pow_2(double x);
/* */ public static native double gsl_pow_3(double x);
/* */ public static native double gsl_pow_4(double x);
/* */ public static native double gsl_pow_5(double x);
/* */ public static native double gsl_pow_6(double x);
/* */ public static native double gsl_pow_7(double x);
/* */ public static native double gsl_pow_8(double x);
/* */ public static native double gsl_pow_9(double x);

// #ifdef HAVE_INLINE
// #endif

public static native double gsl_pow_int(double x, int n);
public static native double gsl_pow_uint(double x, @Cast("unsigned int") int n);

// #endif /* __GSL_POW_INT_H__ */


// Parsed from gsl/gsl_math.h

/* gsl_math.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATH_H__
// #define __GSL_MATH_H__
// #include <math.h>
// #include <gsl/gsl_sys.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_machine.h>
// #include <gsl/gsl_precision.h>
// #include <gsl/gsl_nan.h>
// #include <gsl/gsl_pow_int.h>
// #include <gsl/gsl_minmax.h>

// #ifndef M_E
public static final double M_E =        2.71828182845904523536028747135;      /* e */
// #endif

// #ifndef M_LOG2E
public static final double M_LOG2E =    1.44269504088896340735992468100;      /* log_2 (e) */
// #endif

// #ifndef M_LOG10E
public static final double M_LOG10E =   0.43429448190325182765112891892;      /* log_10 (e) */
// #endif

// #ifndef M_SQRT2
public static final double M_SQRT2 =    1.41421356237309504880168872421;      /* sqrt(2) */
// #endif

// #ifndef M_SQRT1_2
public static final double M_SQRT1_2 =  0.70710678118654752440084436210;      /* sqrt(1/2) */
// #endif


// #ifndef M_SQRT3
public static final double M_SQRT3 =    1.73205080756887729352744634151;      /* sqrt(3) */
// #endif

// #ifndef M_PI
public static final double M_PI =       3.14159265358979323846264338328;      /* pi */
// #endif

// #ifndef M_PI_2
public static final double M_PI_2 =     1.57079632679489661923132169164;      /* pi/2 */
// #endif

// #ifndef M_PI_4
public static final double M_PI_4 =     0.78539816339744830961566084582;     /* pi/4 */
// #endif

// #ifndef M_SQRTPI
public static final double M_SQRTPI =   1.77245385090551602729816748334;      /* sqrt(pi) */
// #endif

// #ifndef M_2_SQRTPI
public static final double M_2_SQRTPI = 1.12837916709551257389615890312;      /* 2/sqrt(pi) */
// #endif

// #ifndef M_1_PI
public static final double M_1_PI =     0.31830988618379067153776752675;      /* 1/pi */
// #endif

// #ifndef M_2_PI
public static final double M_2_PI =     0.63661977236758134307553505349;      /* 2/pi */
// #endif

// #ifndef M_LN10
public static final double M_LN10 =     2.30258509299404568401799145468;      /* ln(10) */
// #endif

// #ifndef M_LN2
public static final double M_LN2 =      0.69314718055994530941723212146;      /* ln(2) */
// #endif

// #ifndef M_LNPI
public static final double M_LNPI =     1.14472988584940017414342735135;      /* ln(pi) */
// #endif

// #ifndef M_EULER
public static final double M_EULER =    0.57721566490153286060651209008;      /* Euler constant */
// #endif

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* other needlessly compulsive abstractions */

// #define GSL_IS_ODD(n)  ((n) & 1)
// #define GSL_IS_EVEN(n) (!(GSL_IS_ODD(n)))
// #define GSL_SIGN(x)    ((x) >= 0.0 ? 1 : -1)

/* Return nonzero if x is a real number, i.e. non NaN or infinite. */
// #define GSL_IS_REAL(x) (gsl_finite(x))

/* Definition of an arbitrary function with parameters */

@Name("gsl_function_struct") public static class gsl_function extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_function() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_function(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_function(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_function position(long position) {
        return (gsl_function)super.position(position);
    }

  public static class Function_double_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Function_double_Pointer(Pointer p) { super(p); }
      protected Function_double_Pointer() { allocate(); }
      private native void allocate();
      public native double call(double x, Pointer params);
  }
  public native Function_double_Pointer function(); public native gsl_function function(Function_double_Pointer function);
  public native Pointer params(); public native gsl_function params(Pointer params);
}

// #define GSL_FN_EVAL(F,x) (*((F)->function))(x,(F)->params)

/* Definition of an arbitrary function returning two values, r1, r2 */

@Name("gsl_function_fdf_struct") public static class gsl_function_fdf extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_function_fdf() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_function_fdf(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_function_fdf(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_function_fdf position(long position) {
        return (gsl_function_fdf)super.position(position);
    }

  public static class F_double_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    F_double_Pointer(Pointer p) { super(p); }
      protected F_double_Pointer() { allocate(); }
      private native void allocate();
      public native double call(double x, Pointer params);
  }
  public native F_double_Pointer f(); public native gsl_function_fdf f(F_double_Pointer f);
  public static class Df_double_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Df_double_Pointer(Pointer p) { super(p); }
      protected Df_double_Pointer() { allocate(); }
      private native void allocate();
      public native double call(double x, Pointer params);
  }
  public native Df_double_Pointer df(); public native gsl_function_fdf df(Df_double_Pointer df);
  public static class Fdf_double_Pointer_DoublePointer_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Fdf_double_Pointer_DoublePointer_DoublePointer(Pointer p) { super(p); }
      protected Fdf_double_Pointer_DoublePointer_DoublePointer() { allocate(); }
      private native void allocate();
      public native void call(double x, Pointer params, DoublePointer f, DoublePointer df);
  }
  public native Fdf_double_Pointer_DoublePointer_DoublePointer fdf(); public native gsl_function_fdf fdf(Fdf_double_Pointer_DoublePointer_DoublePointer fdf);
  public native Pointer params(); public native gsl_function_fdf params(Pointer params);
}

// #define GSL_FN_FDF_EVAL_F(FDF,x) (*((FDF)->f))(x,(FDF)->params)
// #define GSL_FN_FDF_EVAL_DF(FDF,x) (*((FDF)->df))(x,(FDF)->params)
// #define GSL_FN_FDF_EVAL_F_DF(FDF,x,y,dy) (*((FDF)->fdf))(x,(FDF)->params,(y),(dy))


/* Definition of an arbitrary vector-valued function with parameters */

@Name("gsl_function_vec_struct") public static class gsl_function_vec extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_function_vec() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_function_vec(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_function_vec(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_function_vec position(long position) {
        return (gsl_function_vec)super.position(position);
    }

  public static class Function_double_DoublePointer_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Function_double_DoublePointer_Pointer(Pointer p) { super(p); }
      protected Function_double_DoublePointer_Pointer() { allocate(); }
      private native void allocate();
      public native int call(double x, DoublePointer y, Pointer params);
  }
  public native Function_double_DoublePointer_Pointer function(); public native gsl_function_vec function(Function_double_DoublePointer_Pointer function);
  public native Pointer params(); public native gsl_function_vec params(Pointer params);
}

// #define GSL_FN_VEC_EVAL(F,x,y) (*((F)->function))(x,y,(F)->params)

// #endif /* __GSL_MATH_H__ */


// Parsed from gsl/gsl_min.h

/* min/gsl_min.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007, 2009 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MIN_H__
// #define __GSL_MIN_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_math.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_min_fminimizer_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_min_fminimizer_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_min_fminimizer_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_min_fminimizer_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_min_fminimizer_type position(long position) {
        return (gsl_min_fminimizer_type)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native @Cast("size_t") long size(); public native gsl_min_fminimizer_type size(long size);
    public static class Set_Pointer_gsl_function_double_double_double_double_double_double extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Set_Pointer_gsl_function_double_double_double_double_double_double(Pointer p) { super(p); }
        protected Set_Pointer_gsl_function_double_double_double_double_double_double() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_function f, double x_minimum, double f_minimum, double x_lower, double f_lower, double x_upper, double f_upper);
    }
    public native Set_Pointer_gsl_function_double_double_double_double_double_double set(); public native gsl_min_fminimizer_type set(Set_Pointer_gsl_function_double_double_double_double_double_double set);
    public static class Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer(Pointer p) { super(p); }
        protected Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_function f, DoublePointer x_minimum, DoublePointer f_minimum, DoublePointer x_lower, DoublePointer f_lower, DoublePointer x_upper, DoublePointer f_upper);
    }
    public native Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer iterate(); public native gsl_min_fminimizer_type iterate(Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer_DoublePointer iterate);
  }

public static class gsl_min_fminimizer extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_min_fminimizer() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_min_fminimizer(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_min_fminimizer(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_min_fminimizer position(long position) {
        return (gsl_min_fminimizer)super.position(position);
    }

    @MemberGetter public native @Const gsl_min_fminimizer_type type();
    public native gsl_function function(); public native gsl_min_fminimizer function(gsl_function function);
    public native double x_minimum(); public native gsl_min_fminimizer x_minimum(double x_minimum);
    public native double x_lower(); public native gsl_min_fminimizer x_lower(double x_lower);
    public native double x_upper(); public native gsl_min_fminimizer x_upper(double x_upper);
    public native double f_minimum(); public native gsl_min_fminimizer f_minimum(double f_minimum);
    public native double f_lower(); public native gsl_min_fminimizer f_lower(double f_lower);
    public native double f_upper(); public native gsl_min_fminimizer f_upper(double f_upper);
    public native Pointer state(); public native gsl_min_fminimizer state(Pointer state);
  }

public static native gsl_min_fminimizer gsl_min_fminimizer_alloc(@Const gsl_min_fminimizer_type T);
                                      
public static native void gsl_min_fminimizer_free(gsl_min_fminimizer s);

public static native int gsl_min_fminimizer_set(gsl_min_fminimizer s, 
                            gsl_function f, double x_minimum, 
                            double x_lower, double x_upper);

public static native int gsl_min_fminimizer_set_with_values(gsl_min_fminimizer s, 
                                        gsl_function f, 
                                        double x_minimum, double f_minimum,
                                        double x_lower, double f_lower,
                                        double x_upper, double f_upper);

public static native int gsl_min_fminimizer_iterate(gsl_min_fminimizer s);

public static native @Cast("const char*") BytePointer gsl_min_fminimizer_name(@Const gsl_min_fminimizer s);

public static native double gsl_min_fminimizer_x_minimum(@Const gsl_min_fminimizer s);
public static native double gsl_min_fminimizer_x_lower(@Const gsl_min_fminimizer s);
public static native double gsl_min_fminimizer_x_upper(@Const gsl_min_fminimizer s);
public static native double gsl_min_fminimizer_f_minimum(@Const gsl_min_fminimizer s);
public static native double gsl_min_fminimizer_f_lower(@Const gsl_min_fminimizer s);
public static native double gsl_min_fminimizer_f_upper(@Const gsl_min_fminimizer s);

/* Deprecated, use x_minimum instead */
public static native double gsl_min_fminimizer_minimum(@Const gsl_min_fminimizer s);

public static native int gsl_min_test_interval(double x_lower, double x_upper, double epsabs, double epsrel);

@MemberGetter public static native @Const gsl_min_fminimizer_type gsl_min_fminimizer_goldensection();
@MemberGetter public static native @Const gsl_min_fminimizer_type gsl_min_fminimizer_brent();
@MemberGetter public static native @Const gsl_min_fminimizer_type gsl_min_fminimizer_quad_golden();

public static class gsl_min_bracketing_function extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_min_bracketing_function(Pointer p) { super(p); }
    protected gsl_min_bracketing_function() { allocate(); }
    private native void allocate();
    public native int call(gsl_function f,
                                   DoublePointer x_minimum,DoublePointer f_minimum,
                                   DoublePointer x_lower, DoublePointer f_lower,
                                   DoublePointer x_upper, DoublePointer f_upper,
                                   @Cast("size_t") long eval_max);
}

public static native int gsl_min_find_bracket(gsl_function f,DoublePointer x_minimum,DoublePointer f_minimum,
                     DoublePointer x_lower, DoublePointer f_lower,
                     DoublePointer x_upper, DoublePointer f_upper,
                     @Cast("size_t") long eval_max);
public static native int gsl_min_find_bracket(gsl_function f,DoubleBuffer x_minimum,DoubleBuffer f_minimum,
                     DoubleBuffer x_lower, DoubleBuffer f_lower,
                     DoubleBuffer x_upper, DoubleBuffer f_upper,
                     @Cast("size_t") long eval_max);
public static native int gsl_min_find_bracket(gsl_function f,double[] x_minimum,double[] f_minimum,
                     double[] x_lower, double[] f_lower,
                     double[] x_upper, double[] f_upper,
                     @Cast("size_t") long eval_max);

// #endif /* __GSL_MIN_H__ */


// Parsed from gsl/gsl_minmax.h

/* gsl_minmax.h
 * 
 * Copyright (C) 2008 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MINMAX_H__
// #define __GSL_MINMAX_H__
// #include <gsl/gsl_inline.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* Define MAX and MIN macros/functions if they don't exist. */

/* plain old macros for general use */
// #define GSL_MAX(a,b) ((a) > (b) ? (a) : (b))
// #define GSL_MIN(a,b) ((a) < (b) ? (a) : (b))

/* function versions of the above, in case they are needed */
public static native double gsl_max(double a, double b);
public static native double gsl_min(double a, double b);

/* inline-friendly strongly typed versions */
// #ifdef HAVE_INLINE

public static native int GSL_MAX_INT(int a, int b);
public static native int GSL_MIN_INT(int a, int b);
public static native double GSL_MAX_DBL(double a, double b);
public static native double GSL_MIN_DBL(double a, double b);
public static native @Cast("long double") double GSL_MAX_LDBL(@Cast("long double") double a, @Cast("long double") double b);
public static native @Cast("long double") double GSL_MIN_LDBL(@Cast("long double") double a, @Cast("long double") double b);
// #else
// #define GSL_MAX_INT(a,b)   GSL_MAX(a,b)
// #define GSL_MIN_INT(a,b)   GSL_MIN(a,b)
// #define GSL_MAX_DBL(a,b)   GSL_MAX(a,b)
// #define GSL_MIN_DBL(a,b)   GSL_MIN(a,b)
// #define GSL_MAX_LDBL(a,b)  GSL_MAX(a,b)
// #define GSL_MIN_LDBL(a,b)  GSL_MIN(a,b)
// #endif /* HAVE_INLINE */

// #endif /* __GSL_POW_INT_H__ */


// Parsed from gsl/gsl_mode.h

/* gsl_mode.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  B. Gough and G. Jungman */

// #ifndef __GSL_MODE_H__
// #define __GSL_MODE_H__
// #include <gsl/gsl_inline.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Some functions can take a mode argument. This
 * is a rough method to do things like control
 * the precision of the algorithm. This mainly
 * occurs in special functions, but we figured
 * it was ok to have a general facility.
 *
 * The mode type is 32-bit field. Most of
 * the fields are currently unused. Users
 * '|' various predefined constants to get
 * a desired mode.
 */


/* Here are the predefined constants.
 * Note that the precision constants
 * are special because they are used
 * to index arrays, so do not change
 * them. The precision information is
 * in the low order 3 bits of gsl_mode_t
 * (the third bit is currently unused).
 */

/* Note that "0" is double precision,
 * so that you get that by default if
 * you forget a flag.
 */
public static final int GSL_PREC_DOUBLE =  0;
public static final int GSL_PREC_SINGLE =  1;
public static final int GSL_PREC_APPROX =  2;

// #ifdef HAVE_INLINE
public static native @Cast("unsigned int") int GSL_MODE_PREC(@Cast("gsl_mode_t") int mt);
// #else  /* HAVE_INLINE */
// #define GSL_MODE_PREC(mt) ((mt) & (unsigned int)7)
// #endif /* HAVE_INLINE */


/* Here are some predefined generic modes.
 */
public static final int GSL_MODE_DEFAULT =  0;

// #endif /* __GSL_MODE_H__ */


// Parsed from gsl/gsl_test.h

/* err/gsl_test.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_TEST_H__
// #define __GSL_TEST_H__

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_test(int status, @Cast("const char*") BytePointer test_description);
public static native void gsl_test(int status, String test_description);

public static native void gsl_test_rel(double result, double expected, double relative_error,
              @Cast("const char*") BytePointer test_description);
public static native void gsl_test_rel(double result, double expected, double relative_error,
              String test_description);

public static native void gsl_test_abs(double result, double expected, double absolute_error,
              @Cast("const char*") BytePointer test_description);
public static native void gsl_test_abs(double result, double expected, double absolute_error,
              String test_description);

public static native void gsl_test_factor(double result, double expected, double factor,
                 @Cast("const char*") BytePointer test_description);
public static native void gsl_test_factor(double result, double expected, double factor,
                 String test_description);

public static native void gsl_test_int(int result, int expected, @Cast("const char*") BytePointer test_description);
public static native void gsl_test_int(int result, int expected, String test_description);

public static native void gsl_test_str(@Cast("const char*") BytePointer result, @Cast("const char*") BytePointer expected, 
              @Cast("const char*") BytePointer test_description);
public static native void gsl_test_str(String result, String expected, 
              String test_description);

public static native void gsl_test_verbose(int verbose);

public static native int gsl_test_summary();

// #endif /* __GSL_TEST_H__ */


// Parsed from gsl/gsl_version.h

// #ifndef __GSL_VERSION_H__
// #define __GSL_VERSION_H__

// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


public static final String GSL_VERSION = "2.2.1";
public static final int GSL_MAJOR_VERSION = 2;
public static final int GSL_MINOR_VERSION = 2;

@MemberGetter public static native @Cast("const char*") BytePointer gsl_version();

// #endif /* __GSL_VERSION_H__ */


// Parsed from gsl/gsl_block.h

// #ifndef __GSL_BLOCK_H__
// #define __GSL_BLOCK_H__

// #include <gsl/gsl_block_complex_long_double.h>
// #include <gsl/gsl_block_complex_double.h>
// #include <gsl/gsl_block_complex_float.h>

// #include <gsl/gsl_block_long_double.h>
// #include <gsl/gsl_block_double.h>
// #include <gsl/gsl_block_float.h>

// #include <gsl/gsl_block_ulong.h>
// #include <gsl/gsl_block_long.h>

// #include <gsl/gsl_block_uint.h>
// #include <gsl/gsl_block_int.h>

// #include <gsl/gsl_block_ushort.h>
// #include <gsl/gsl_block_short.h>

// #include <gsl/gsl_block_uchar.h>
// #include <gsl/gsl_block_char.h>

// #endif /* __GSL_BLOCK_H__ */


// Parsed from gsl/gsl_block_complex_double.h

/* block/gsl_block_complex_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_COMPLEX_DOUBLE_H__
// #define __GSL_BLOCK_COMPLEX_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_complex_struct") public static class gsl_block_complex extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_complex() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_complex(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_complex(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_complex position(long position) {
        return (gsl_block_complex)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_complex size(long size);
  public native DoublePointer data(); public native gsl_block_complex data(DoublePointer data);
}

public static native gsl_block_complex gsl_block_complex_alloc(@Cast("const size_t") long n);
public static native gsl_block_complex gsl_block_complex_calloc(@Cast("const size_t") long n);
public static native void gsl_block_complex_free(gsl_block_complex b);

public static native int gsl_block_complex_fread(@Cast("FILE*") Pointer stream, gsl_block_complex b);
public static native int gsl_block_complex_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_complex b);
public static native int gsl_block_complex_fscanf(@Cast("FILE*") Pointer stream, gsl_block_complex b);
public static native int gsl_block_complex_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_complex b, @Cast("const char*") BytePointer format);
public static native int gsl_block_complex_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_complex b, String format);

public static native int gsl_block_complex_raw_fread(@Cast("FILE*") Pointer stream, DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_raw_fread(@Cast("FILE*") Pointer stream, DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_raw_fread(@Cast("FILE*") Pointer stream, double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_raw_fwrite(@Cast("FILE*") Pointer stream, @Const DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_raw_fwrite(@Cast("FILE*") Pointer stream, @Const DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_raw_fwrite(@Cast("FILE*") Pointer stream, @Const double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_raw_fscanf(@Cast("FILE*") Pointer stream, DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_raw_fscanf(@Cast("FILE*") Pointer stream, DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_raw_fscanf(@Cast("FILE*") Pointer stream, double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_raw_fprintf(@Cast("FILE*") Pointer stream, @Const DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_complex_raw_fprintf(@Cast("FILE*") Pointer stream, @Const DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_complex_raw_fprintf(@Cast("FILE*") Pointer stream, @Const double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_complex_raw_fprintf(@Cast("FILE*") Pointer stream, @Const DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_complex_raw_fprintf(@Cast("FILE*") Pointer stream, @Const DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_complex_raw_fprintf(@Cast("FILE*") Pointer stream, @Const double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_complex_size(@Const gsl_block_complex b);
public static native DoublePointer gsl_block_complex_data(@Const gsl_block_complex b);

// #endif /* __GSL_BLOCK_COMPLEX_DOUBLE_H__ */


// Parsed from gsl/gsl_block_complex_float.h

/* block/gsl_block_complex_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_COMPLEX_FLOAT_H__
// #define __GSL_BLOCK_COMPLEX_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_complex_float_struct") public static class gsl_block_complex_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_complex_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_complex_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_complex_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_complex_float position(long position) {
        return (gsl_block_complex_float)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_complex_float size(long size);
  public native FloatPointer data(); public native gsl_block_complex_float data(FloatPointer data);
}

public static native gsl_block_complex_float gsl_block_complex_float_alloc(@Cast("const size_t") long n);
public static native gsl_block_complex_float gsl_block_complex_float_calloc(@Cast("const size_t") long n);
public static native void gsl_block_complex_float_free(gsl_block_complex_float b);

public static native int gsl_block_complex_float_fread(@Cast("FILE*") Pointer stream, gsl_block_complex_float b);
public static native int gsl_block_complex_float_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_complex_float b);
public static native int gsl_block_complex_float_fscanf(@Cast("FILE*") Pointer stream, gsl_block_complex_float b);
public static native int gsl_block_complex_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_complex_float b, @Cast("const char*") BytePointer format);
public static native int gsl_block_complex_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_complex_float b, String format);

public static native int gsl_block_complex_float_raw_fread(@Cast("FILE*") Pointer stream, FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_float_raw_fread(@Cast("FILE*") Pointer stream, FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_float_raw_fread(@Cast("FILE*") Pointer stream, float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_float_raw_fwrite(@Cast("FILE*") Pointer stream, @Const FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_float_raw_fwrite(@Cast("FILE*") Pointer stream, @Const FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_float_raw_fwrite(@Cast("FILE*") Pointer stream, @Const float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_float_raw_fscanf(@Cast("FILE*") Pointer stream, FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_float_raw_fscanf(@Cast("FILE*") Pointer stream, FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_float_raw_fscanf(@Cast("FILE*") Pointer stream, float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_complex_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_complex_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_complex_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_complex_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_complex_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_complex_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_complex_float_size(@Const gsl_block_complex_float b);
public static native FloatPointer gsl_block_complex_float_data(@Const gsl_block_complex_float b);

// #endif /* __GSL_BLOCK_COMPLEX_FLOAT_H__ */


// Parsed from gsl/gsl_block_double.h

/* block/gsl_block_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_DOUBLE_H__
// #define __GSL_BLOCK_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_struct") public static class gsl_block extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block position(long position) {
        return (gsl_block)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block size(long size);
  public native DoublePointer data(); public native gsl_block data(DoublePointer data);
}

public static native gsl_block gsl_block_alloc(@Cast("const size_t") long n);
public static native gsl_block gsl_block_calloc(@Cast("const size_t") long n);
public static native void gsl_block_free(gsl_block b);

public static native int gsl_block_fread(@Cast("FILE*") Pointer stream, gsl_block b);
public static native int gsl_block_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block b);
public static native int gsl_block_fscanf(@Cast("FILE*") Pointer stream, gsl_block b);
public static native int gsl_block_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block b, @Cast("const char*") BytePointer format);
public static native int gsl_block_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block b, String format);

public static native int gsl_block_raw_fread(@Cast("FILE*") Pointer stream, DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_raw_fread(@Cast("FILE*") Pointer stream, DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_raw_fread(@Cast("FILE*") Pointer stream, double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_raw_fwrite(@Cast("FILE*") Pointer stream, @Const DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_raw_fwrite(@Cast("FILE*") Pointer stream, @Const DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_raw_fwrite(@Cast("FILE*") Pointer stream, @Const double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_raw_fscanf(@Cast("FILE*") Pointer stream, DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_raw_fscanf(@Cast("FILE*") Pointer stream, DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_raw_fscanf(@Cast("FILE*") Pointer stream, double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_raw_fprintf(@Cast("FILE*") Pointer stream, @Const DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_raw_fprintf(@Cast("FILE*") Pointer stream, @Const DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_raw_fprintf(@Cast("FILE*") Pointer stream, @Const double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_raw_fprintf(@Cast("FILE*") Pointer stream, @Const DoublePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_raw_fprintf(@Cast("FILE*") Pointer stream, @Const DoubleBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_raw_fprintf(@Cast("FILE*") Pointer stream, @Const double[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_size(@Const gsl_block b);
public static native DoublePointer gsl_block_data(@Const gsl_block b);

// #endif /* __GSL_BLOCK_DOUBLE_H__ */


// Parsed from gsl/gsl_block_float.h

/* block/gsl_block_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_FLOAT_H__
// #define __GSL_BLOCK_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_float_struct") public static class gsl_block_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_float position(long position) {
        return (gsl_block_float)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_float size(long size);
  public native FloatPointer data(); public native gsl_block_float data(FloatPointer data);
}

public static native gsl_block_float gsl_block_float_alloc(@Cast("const size_t") long n);
public static native gsl_block_float gsl_block_float_calloc(@Cast("const size_t") long n);
public static native void gsl_block_float_free(gsl_block_float b);

public static native int gsl_block_float_fread(@Cast("FILE*") Pointer stream, gsl_block_float b);
public static native int gsl_block_float_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_float b);
public static native int gsl_block_float_fscanf(@Cast("FILE*") Pointer stream, gsl_block_float b);
public static native int gsl_block_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_float b, @Cast("const char*") BytePointer format);
public static native int gsl_block_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_float b, String format);

public static native int gsl_block_float_raw_fread(@Cast("FILE*") Pointer stream, FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_float_raw_fread(@Cast("FILE*") Pointer stream, FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_float_raw_fread(@Cast("FILE*") Pointer stream, float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_float_raw_fwrite(@Cast("FILE*") Pointer stream, @Const FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_float_raw_fwrite(@Cast("FILE*") Pointer stream, @Const FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_float_raw_fwrite(@Cast("FILE*") Pointer stream, @Const float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_float_raw_fscanf(@Cast("FILE*") Pointer stream, FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_float_raw_fscanf(@Cast("FILE*") Pointer stream, FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_float_raw_fscanf(@Cast("FILE*") Pointer stream, float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const FloatPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const FloatBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_float_raw_fprintf(@Cast("FILE*") Pointer stream, @Const float[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_float_size(@Const gsl_block_float b);
public static native FloatPointer gsl_block_float_data(@Const gsl_block_float b);

// #endif /* __GSL_BLOCK_FLOAT_H__ */


// Parsed from gsl/gsl_block_ulong.h

/* block/gsl_block_ulong.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_ULONG_H__
// #define __GSL_BLOCK_ULONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_ulong_struct") public static class gsl_block_ulong extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_ulong() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_ulong(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_ulong(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_ulong position(long position) {
        return (gsl_block_ulong)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_ulong size(long size);
  public native @Cast("unsigned long*") CLongPointer data(); public native gsl_block_ulong data(CLongPointer data);
}

public static native gsl_block_ulong gsl_block_ulong_alloc(@Cast("const size_t") long n);
public static native gsl_block_ulong gsl_block_ulong_calloc(@Cast("const size_t") long n);
public static native void gsl_block_ulong_free(gsl_block_ulong b);

public static native int gsl_block_ulong_fread(@Cast("FILE*") Pointer stream, gsl_block_ulong b);
public static native int gsl_block_ulong_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_ulong b);
public static native int gsl_block_ulong_fscanf(@Cast("FILE*") Pointer stream, gsl_block_ulong b);
public static native int gsl_block_ulong_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_ulong b, @Cast("const char*") BytePointer format);
public static native int gsl_block_ulong_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_ulong b, String format);

public static native int gsl_block_ulong_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned long*") CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ulong_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned long*") CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ulong_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned long*") CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ulong_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned long*") CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_ulong_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned long*") CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_ulong_size(@Const gsl_block_ulong b);
public static native @Cast("unsigned long*") CLongPointer gsl_block_ulong_data(@Const gsl_block_ulong b);

// #endif /* __GSL_BLOCK_ULONG_H__ */


// Parsed from gsl/gsl_block_long.h

/* block/gsl_block_long.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_LONG_H__
// #define __GSL_BLOCK_LONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_long_struct") public static class gsl_block_long extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_long() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_long(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_long(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_long position(long position) {
        return (gsl_block_long)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_long size(long size);
  public native CLongPointer data(); public native gsl_block_long data(CLongPointer data);
}

public static native gsl_block_long gsl_block_long_alloc(@Cast("const size_t") long n);
public static native gsl_block_long gsl_block_long_calloc(@Cast("const size_t") long n);
public static native void gsl_block_long_free(gsl_block_long b);

public static native int gsl_block_long_fread(@Cast("FILE*") Pointer stream, gsl_block_long b);
public static native int gsl_block_long_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_long b);
public static native int gsl_block_long_fscanf(@Cast("FILE*") Pointer stream, gsl_block_long b);
public static native int gsl_block_long_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_long b, @Cast("const char*") BytePointer format);
public static native int gsl_block_long_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_long b, String format);

public static native int gsl_block_long_raw_fread(@Cast("FILE*") Pointer stream, CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_long_raw_fwrite(@Cast("FILE*") Pointer stream, @Const CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_long_raw_fscanf(@Cast("FILE*") Pointer stream, CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_long_raw_fprintf(@Cast("FILE*") Pointer stream, @Const CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_long_raw_fprintf(@Cast("FILE*") Pointer stream, @Const CLongPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_long_size(@Const gsl_block_long b);
public static native CLongPointer gsl_block_long_data(@Const gsl_block_long b);

// #endif /* __GSL_BLOCK_LONG_H__ */


// Parsed from gsl/gsl_block_uint.h

/* block/gsl_block_uint.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_UINT_H__
// #define __GSL_BLOCK_UINT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_uint_struct") public static class gsl_block_uint extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_uint() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_uint(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_uint(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_uint position(long position) {
        return (gsl_block_uint)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_uint size(long size);
  public native @Cast("unsigned int*") IntPointer data(); public native gsl_block_uint data(IntPointer data);
}

public static native gsl_block_uint gsl_block_uint_alloc(@Cast("const size_t") long n);
public static native gsl_block_uint gsl_block_uint_calloc(@Cast("const size_t") long n);
public static native void gsl_block_uint_free(gsl_block_uint b);

public static native int gsl_block_uint_fread(@Cast("FILE*") Pointer stream, gsl_block_uint b);
public static native int gsl_block_uint_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_uint b);
public static native int gsl_block_uint_fscanf(@Cast("FILE*") Pointer stream, gsl_block_uint b);
public static native int gsl_block_uint_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_uint b, @Cast("const char*") BytePointer format);
public static native int gsl_block_uint_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_uint b, String format);

public static native int gsl_block_uint_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned int*") IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uint_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned int*") IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uint_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned int*") int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uint_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned int*") IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uint_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned int*") IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uint_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned int*") int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uint_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned int*") IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uint_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned int*") IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uint_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned int*") int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uint_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned int*") IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_uint_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned int*") IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_uint_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned int*") int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_uint_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned int*") IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_uint_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned int*") IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_uint_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned int*") int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_uint_size(@Const gsl_block_uint b);
public static native @Cast("unsigned int*") IntPointer gsl_block_uint_data(@Const gsl_block_uint b);

// #endif /* __GSL_BLOCK_UINT_H__ */


// Parsed from gsl/gsl_block_int.h

/* block/gsl_block_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_INT_H__
// #define __GSL_BLOCK_INT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_int_struct") public static class gsl_block_int extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_int() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_int(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_int(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_int position(long position) {
        return (gsl_block_int)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_int size(long size);
  public native IntPointer data(); public native gsl_block_int data(IntPointer data);
}

public static native gsl_block_int gsl_block_int_alloc(@Cast("const size_t") long n);
public static native gsl_block_int gsl_block_int_calloc(@Cast("const size_t") long n);
public static native void gsl_block_int_free(gsl_block_int b);

public static native int gsl_block_int_fread(@Cast("FILE*") Pointer stream, gsl_block_int b);
public static native int gsl_block_int_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_int b);
public static native int gsl_block_int_fscanf(@Cast("FILE*") Pointer stream, gsl_block_int b);
public static native int gsl_block_int_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_int b, @Cast("const char*") BytePointer format);
public static native int gsl_block_int_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_int b, String format);

public static native int gsl_block_int_raw_fread(@Cast("FILE*") Pointer stream, IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_int_raw_fread(@Cast("FILE*") Pointer stream, IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_int_raw_fread(@Cast("FILE*") Pointer stream, int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_int_raw_fwrite(@Cast("FILE*") Pointer stream, @Const IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_int_raw_fwrite(@Cast("FILE*") Pointer stream, @Const IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_int_raw_fwrite(@Cast("FILE*") Pointer stream, @Const int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_int_raw_fscanf(@Cast("FILE*") Pointer stream, IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_int_raw_fscanf(@Cast("FILE*") Pointer stream, IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_int_raw_fscanf(@Cast("FILE*") Pointer stream, int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_int_raw_fprintf(@Cast("FILE*") Pointer stream, @Const IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_int_raw_fprintf(@Cast("FILE*") Pointer stream, @Const IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_int_raw_fprintf(@Cast("FILE*") Pointer stream, @Const int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_int_raw_fprintf(@Cast("FILE*") Pointer stream, @Const IntPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_int_raw_fprintf(@Cast("FILE*") Pointer stream, @Const IntBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_int_raw_fprintf(@Cast("FILE*") Pointer stream, @Const int[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_int_size(@Const gsl_block_int b);
public static native IntPointer gsl_block_int_data(@Const gsl_block_int b);

// #endif /* __GSL_BLOCK_INT_H__ */


// Parsed from gsl/gsl_block_ushort.h

/* block/gsl_block_ushort.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_USHORT_H__
// #define __GSL_BLOCK_USHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_ushort_struct") public static class gsl_block_ushort extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_ushort() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_ushort(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_ushort(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_ushort position(long position) {
        return (gsl_block_ushort)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_ushort size(long size);
  public native @Cast("unsigned short*") ShortPointer data(); public native gsl_block_ushort data(ShortPointer data);
}

public static native gsl_block_ushort gsl_block_ushort_alloc(@Cast("const size_t") long n);
public static native gsl_block_ushort gsl_block_ushort_calloc(@Cast("const size_t") long n);
public static native void gsl_block_ushort_free(gsl_block_ushort b);

public static native int gsl_block_ushort_fread(@Cast("FILE*") Pointer stream, gsl_block_ushort b);
public static native int gsl_block_ushort_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_ushort b);
public static native int gsl_block_ushort_fscanf(@Cast("FILE*") Pointer stream, gsl_block_ushort b);
public static native int gsl_block_ushort_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_ushort b, @Cast("const char*") BytePointer format);
public static native int gsl_block_ushort_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_ushort b, String format);

public static native int gsl_block_ushort_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned short*") ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ushort_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned short*") ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ushort_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned short*") short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ushort_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned short*") ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ushort_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned short*") ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ushort_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned short*") short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ushort_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned short*") ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ushort_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned short*") ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ushort_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned short*") short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_ushort_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned short*") ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_ushort_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned short*") ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_ushort_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned short*") short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_ushort_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned short*") ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_ushort_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned short*") ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_ushort_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned short*") short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_ushort_size(@Const gsl_block_ushort b);
public static native @Cast("unsigned short*") ShortPointer gsl_block_ushort_data(@Const gsl_block_ushort b);

// #endif /* __GSL_BLOCK_USHORT_H__ */


// Parsed from gsl/gsl_block_short.h

/* block/gsl_block_short.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_SHORT_H__
// #define __GSL_BLOCK_SHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_short_struct") public static class gsl_block_short extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_short() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_short(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_short(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_short position(long position) {
        return (gsl_block_short)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_short size(long size);
  public native ShortPointer data(); public native gsl_block_short data(ShortPointer data);
}

public static native gsl_block_short gsl_block_short_alloc(@Cast("const size_t") long n);
public static native gsl_block_short gsl_block_short_calloc(@Cast("const size_t") long n);
public static native void gsl_block_short_free(gsl_block_short b);

public static native int gsl_block_short_fread(@Cast("FILE*") Pointer stream, gsl_block_short b);
public static native int gsl_block_short_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_short b);
public static native int gsl_block_short_fscanf(@Cast("FILE*") Pointer stream, gsl_block_short b);
public static native int gsl_block_short_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_short b, @Cast("const char*") BytePointer format);
public static native int gsl_block_short_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_short b, String format);

public static native int gsl_block_short_raw_fread(@Cast("FILE*") Pointer stream, ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_short_raw_fread(@Cast("FILE*") Pointer stream, ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_short_raw_fread(@Cast("FILE*") Pointer stream, short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_short_raw_fwrite(@Cast("FILE*") Pointer stream, @Const ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_short_raw_fwrite(@Cast("FILE*") Pointer stream, @Const ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_short_raw_fwrite(@Cast("FILE*") Pointer stream, @Const short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_short_raw_fscanf(@Cast("FILE*") Pointer stream, ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_short_raw_fscanf(@Cast("FILE*") Pointer stream, ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_short_raw_fscanf(@Cast("FILE*") Pointer stream, short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_short_raw_fprintf(@Cast("FILE*") Pointer stream, @Const ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_short_raw_fprintf(@Cast("FILE*") Pointer stream, @Const ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_short_raw_fprintf(@Cast("FILE*") Pointer stream, @Const short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_short_raw_fprintf(@Cast("FILE*") Pointer stream, @Const ShortPointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_short_raw_fprintf(@Cast("FILE*") Pointer stream, @Const ShortBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_short_raw_fprintf(@Cast("FILE*") Pointer stream, @Const short[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_short_size(@Const gsl_block_short b);
public static native ShortPointer gsl_block_short_data(@Const gsl_block_short b);

// #endif /* __GSL_BLOCK_SHORT_H__ */


// Parsed from gsl/gsl_block_uchar.h

/* block/gsl_block_uchar.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_UCHAR_H__
// #define __GSL_BLOCK_UCHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_uchar_struct") public static class gsl_block_uchar extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_uchar() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_uchar(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_uchar(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_uchar position(long position) {
        return (gsl_block_uchar)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_uchar size(long size);
  public native @Cast("unsigned char*") BytePointer data(); public native gsl_block_uchar data(BytePointer data);
}

public static native gsl_block_uchar gsl_block_uchar_alloc(@Cast("const size_t") long n);
public static native gsl_block_uchar gsl_block_uchar_calloc(@Cast("const size_t") long n);
public static native void gsl_block_uchar_free(gsl_block_uchar b);

public static native int gsl_block_uchar_fread(@Cast("FILE*") Pointer stream, gsl_block_uchar b);
public static native int gsl_block_uchar_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_uchar b);
public static native int gsl_block_uchar_fscanf(@Cast("FILE*") Pointer stream, gsl_block_uchar b);
public static native int gsl_block_uchar_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_uchar b, @Cast("const char*") BytePointer format);
public static native int gsl_block_uchar_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_uchar b, String format);

public static native int gsl_block_uchar_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned char*") BytePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uchar_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned char*") ByteBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uchar_raw_fread(@Cast("FILE*") Pointer stream, @Cast("unsigned char*") byte[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uchar_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned char*") BytePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uchar_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned char*") ByteBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uchar_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const unsigned char*") byte[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uchar_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned char*") BytePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uchar_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned char*") ByteBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uchar_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("unsigned char*") byte[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_uchar_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned char*") BytePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_uchar_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned char*") ByteBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_uchar_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned char*") byte[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_uchar_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned char*") BytePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);
public static native int gsl_block_uchar_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned char*") ByteBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_uchar_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const unsigned char*") byte[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_uchar_size(@Const gsl_block_uchar b);
public static native @Cast("unsigned char*") BytePointer gsl_block_uchar_data(@Const gsl_block_uchar b);

// #endif /* __GSL_BLOCK_UCHAR_H__ */


// Parsed from gsl/gsl_block_char.h

/* block/gsl_block_char.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BLOCK_CHAR_H__
// #define __GSL_BLOCK_CHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_block_char_struct") public static class gsl_block_char extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_block_char() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_block_char(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_block_char(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_block_char position(long position) {
        return (gsl_block_char)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_block_char size(long size);
  public native @Cast("char*") BytePointer data(); public native gsl_block_char data(BytePointer data);
}

public static native gsl_block_char gsl_block_char_alloc(@Cast("const size_t") long n);
public static native gsl_block_char gsl_block_char_calloc(@Cast("const size_t") long n);
public static native void gsl_block_char_free(gsl_block_char b);

public static native int gsl_block_char_fread(@Cast("FILE*") Pointer stream, gsl_block_char b);
public static native int gsl_block_char_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_block_char b);
public static native int gsl_block_char_fscanf(@Cast("FILE*") Pointer stream, gsl_block_char b);
public static native int gsl_block_char_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_char b, @Cast("const char*") BytePointer format);
public static native int gsl_block_char_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_block_char b, String format);

public static native int gsl_block_char_raw_fread(@Cast("FILE*") Pointer stream, @Cast("char*") BytePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_char_raw_fread(@Cast("FILE*") Pointer stream, @Cast("char*") ByteBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_char_raw_fread(@Cast("FILE*") Pointer stream, @Cast("char*") byte[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_char_raw_fwrite(@Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_char_raw_fwrite(@Cast("FILE*") Pointer stream, String b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_char_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("char*") BytePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_char_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("char*") ByteBuffer b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_char_raw_fscanf(@Cast("FILE*") Pointer stream, @Cast("char*") byte[] b, @Cast("const size_t") long n, @Cast("const size_t") long stride);
public static native int gsl_block_char_raw_fprintf(@Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer b, @Cast("const size_t") long n, @Cast("const size_t") long stride, @Cast("const char*") BytePointer format);
public static native int gsl_block_char_raw_fprintf(@Cast("FILE*") Pointer stream, String b, @Cast("const size_t") long n, @Cast("const size_t") long stride, String format);

public static native @Cast("size_t") long gsl_block_char_size(@Const gsl_block_char b);
public static native @Cast("char*") BytePointer gsl_block_char_data(@Const gsl_block_char b);

// #endif /* __GSL_BLOCK_CHAR_H__ */


// Parsed from gsl/gsl_vector_complex.h

// #ifndef __GSL_VECTOR_COMPLEX_H__
// #define __GSL_VECTOR_COMPLEX_H__

// #define  GSL_VECTOR_REAL(z, i)  ((z)->data[2*(i)*(z)->stride])
// #define  GSL_VECTOR_IMAG(z, i)  ((z)->data[2*(i)*(z)->stride + 1])

// #if GSL_RANGE_CHECK
// #else
// #define GSL_VECTOR_COMPLEX(zv, i) (*GSL_COMPLEX_AT((zv),(i)))
// #endif

// #define GSL_COMPLEX_AT(zv,i) ((gsl_complex*)&((zv)->data[2*(i)*(zv)->stride]))
// #define GSL_COMPLEX_FLOAT_AT(zv,i) ((gsl_complex_float*)&((zv)->data[2*(i)*(zv)->stride]))
// #define GSL_COMPLEX_LONG_DOUBLE_AT(zv,i) ((gsl_complex_long_double*)&((zv)->data[2*(i)*(zv)->stride]))

// #endif /* __GSL_VECTOR_COMPLEX_H__ */


// Parsed from gsl/gsl_vector.h

// #ifndef __GSL_VECTOR_H__
// #define __GSL_VECTOR_H__

// #include <gsl/gsl_vector_complex_long_double.h>
// #include <gsl/gsl_vector_complex_double.h>
// #include <gsl/gsl_vector_complex_float.h>

// #include <gsl/gsl_vector_long_double.h>
// #include <gsl/gsl_vector_double.h>
// #include <gsl/gsl_vector_float.h>

// #include <gsl/gsl_vector_ulong.h>
// #include <gsl/gsl_vector_long.h>

// #include <gsl/gsl_vector_uint.h>
// #include <gsl/gsl_vector_int.h>

// #include <gsl/gsl_vector_ushort.h>
// #include <gsl/gsl_vector_short.h>

// #include <gsl/gsl_vector_uchar.h>
// #include <gsl/gsl_vector_char.h>


// #endif /* __GSL_VECTOR_H__ */


// Parsed from gsl/gsl_vector_complex_double.h

/* vector/gsl_vector_complex_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_COMPLEX_DOUBLE_H__
// #define __GSL_VECTOR_COMPLEX_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_double.h>
// #include <gsl/gsl_vector_complex.h>
// #include <gsl/gsl_block_complex_double.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_complex extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_complex() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_complex(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_complex(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_complex position(long position) {
        return (gsl_vector_complex)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_complex size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_complex stride(long stride);
  public native DoublePointer data(); public native gsl_vector_complex data(DoublePointer data);
  public native gsl_block_complex block(); public native gsl_vector_complex block(gsl_block_complex block);
  public native int owner(); public native gsl_vector_complex owner(int owner);
}

public static class _gsl_vector_complex_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_complex_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_complex_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_complex_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_complex_view position(long position) {
        return (_gsl_vector_complex_view)super.position(position);
    }

  public native @ByRef gsl_vector_complex vector(); public native _gsl_vector_complex_view vector(gsl_vector_complex vector);
}

public static class _gsl_vector_complex_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_complex_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_complex_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_complex_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_complex_const_view position(long position) {
        return (_gsl_vector_complex_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_complex vector(); public native _gsl_vector_complex_const_view vector(gsl_vector_complex vector);
}

/* Allocation */

public static native gsl_vector_complex gsl_vector_complex_alloc(@Cast("const size_t") long n);
public static native gsl_vector_complex gsl_vector_complex_calloc(@Cast("const size_t") long n);

public static native gsl_vector_complex gsl_vector_complex_alloc_from_block(gsl_block_complex b, 
                                           @Cast("const size_t") long offset, 
                                           @Cast("const size_t") long n, 
                                           @Cast("const size_t") long stride);

public static native gsl_vector_complex gsl_vector_complex_alloc_from_vector(gsl_vector_complex v, 
                                             @Cast("const size_t") long offset, 
                                             @Cast("const size_t") long n, 
                                             @Cast("const size_t") long stride);

public static native void gsl_vector_complex_free(gsl_vector_complex v);

/* Views */

public static native @ByVal _gsl_vector_complex_view gsl_vector_complex_view_array(DoublePointer base,
                                     @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_view gsl_vector_complex_view_array(DoubleBuffer base,
                                     @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_view gsl_vector_complex_view_array(double[] base,
                                     @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_view gsl_vector_complex_view_array_with_stride(DoublePointer base,
                                                 @Cast("size_t") long stride,
                                                 @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_view gsl_vector_complex_view_array_with_stride(DoubleBuffer base,
                                                 @Cast("size_t") long stride,
                                                 @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_view gsl_vector_complex_view_array_with_stride(double[] base,
                                                 @Cast("size_t") long stride,
                                                 @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_const_view gsl_vector_complex_const_view_array(@Const DoublePointer base,
                                           @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_const_view gsl_vector_complex_const_view_array(@Const DoubleBuffer base,
                                           @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_const_view gsl_vector_complex_const_view_array(@Const double[] base,
                                           @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_const_view gsl_vector_complex_const_view_array_with_stride(@Const DoublePointer base,
                                                       @Cast("size_t") long stride,
                                                       @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_const_view gsl_vector_complex_const_view_array_with_stride(@Const DoubleBuffer base,
                                                       @Cast("size_t") long stride,
                                                       @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_const_view gsl_vector_complex_const_view_array_with_stride(@Const double[] base,
                                                       @Cast("size_t") long stride,
                                                       @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_view gsl_vector_complex_subvector(gsl_vector_complex base,
                                         @Cast("size_t") long i, 
                                         @Cast("size_t") long n);


public static native @ByVal _gsl_vector_complex_view gsl_vector_complex_subvector_with_stride(gsl_vector_complex v, 
                                                @Cast("size_t") long i, 
                                                @Cast("size_t") long stride, 
                                                @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_const_view gsl_vector_complex_const_subvector(@Const gsl_vector_complex base,
                                               @Cast("size_t") long i, 
                                               @Cast("size_t") long n);


public static native @ByVal _gsl_vector_complex_const_view gsl_vector_complex_const_subvector_with_stride(@Const gsl_vector_complex v, 
                                                      @Cast("size_t") long i, 
                                                      @Cast("size_t") long stride, 
                                                      @Cast("size_t") long n);

public static native @ByVal _gsl_vector_view gsl_vector_complex_real(gsl_vector_complex v);

public static native @ByVal _gsl_vector_view gsl_vector_complex_imag(gsl_vector_complex v);

public static native @ByVal _gsl_vector_const_view gsl_vector_complex_const_real(@Const gsl_vector_complex v);

public static native @ByVal _gsl_vector_const_view gsl_vector_complex_const_imag(@Const gsl_vector_complex v);


/* Operations */

public static native void gsl_vector_complex_set_zero(gsl_vector_complex v);
public static native void gsl_vector_complex_set_all(gsl_vector_complex v,
                                       @ByVal gsl_complex z);
public static native int gsl_vector_complex_set_basis(gsl_vector_complex v, @Cast("size_t") long i);

public static native int gsl_vector_complex_fread(@Cast("FILE*") Pointer stream,
                                    gsl_vector_complex v);
public static native int gsl_vector_complex_fwrite(@Cast("FILE*") Pointer stream,
                                     @Const gsl_vector_complex v);
public static native int gsl_vector_complex_fscanf(@Cast("FILE*") Pointer stream,
                                     gsl_vector_complex v);
public static native int gsl_vector_complex_fprintf(@Cast("FILE*") Pointer stream,
                                      @Const gsl_vector_complex v,
                                      @Cast("const char*") BytePointer format);
public static native int gsl_vector_complex_fprintf(@Cast("FILE*") Pointer stream,
                                      @Const gsl_vector_complex v,
                                      String format);

public static native int gsl_vector_complex_memcpy(gsl_vector_complex dest, @Const gsl_vector_complex src);

public static native int gsl_vector_complex_reverse(gsl_vector_complex v);

public static native int gsl_vector_complex_swap(gsl_vector_complex v, gsl_vector_complex w);
public static native int gsl_vector_complex_swap_elements(gsl_vector_complex v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native int gsl_vector_complex_equal(@Const gsl_vector_complex u, 
                                    @Const gsl_vector_complex v);

public static native int gsl_vector_complex_isnull(@Const gsl_vector_complex v);
public static native int gsl_vector_complex_ispos(@Const gsl_vector_complex v);
public static native int gsl_vector_complex_isneg(@Const gsl_vector_complex v);
public static native int gsl_vector_complex_isnonneg(@Const gsl_vector_complex v);

public static native int gsl_vector_complex_add(gsl_vector_complex a, @Const gsl_vector_complex b);
public static native int gsl_vector_complex_sub(gsl_vector_complex a, @Const gsl_vector_complex b);
public static native int gsl_vector_complex_mul(gsl_vector_complex a, @Const gsl_vector_complex b);
public static native int gsl_vector_complex_div(gsl_vector_complex a, @Const gsl_vector_complex b);
public static native int gsl_vector_complex_scale(gsl_vector_complex a, @Const @ByVal gsl_complex x);
public static native int gsl_vector_complex_add_constant(gsl_vector_complex a, @Const @ByVal gsl_complex x);

/* */ public static native @ByVal gsl_complex gsl_vector_complex_get(@Const gsl_vector_complex v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_complex_set(gsl_vector_complex v, @Cast("const size_t") long i, @ByVal gsl_complex z);
/* */ public static native gsl_complex gsl_vector_complex_ptr(gsl_vector_complex v, @Cast("const size_t") long i);
/* */ public static native @Const gsl_complex gsl_vector_complex_const_ptr(@Const gsl_vector_complex v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE


// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_COMPLEX_DOUBLE_H__ */


// Parsed from gsl/gsl_vector_complex_float.h

/* vector/gsl_vector_complex_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_COMPLEX_FLOAT_H__
// #define __GSL_VECTOR_COMPLEX_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_float.h>
// #include <gsl/gsl_vector_complex.h>
// #include <gsl/gsl_block_complex_float.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_complex_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_complex_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_complex_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_complex_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_complex_float position(long position) {
        return (gsl_vector_complex_float)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_complex_float size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_complex_float stride(long stride);
  public native FloatPointer data(); public native gsl_vector_complex_float data(FloatPointer data);
  public native gsl_block_complex_float block(); public native gsl_vector_complex_float block(gsl_block_complex_float block);
  public native int owner(); public native gsl_vector_complex_float owner(int owner);
}

public static class _gsl_vector_complex_float_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_complex_float_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_complex_float_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_complex_float_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_complex_float_view position(long position) {
        return (_gsl_vector_complex_float_view)super.position(position);
    }

  public native @ByRef gsl_vector_complex_float vector(); public native _gsl_vector_complex_float_view vector(gsl_vector_complex_float vector);
}

public static class _gsl_vector_complex_float_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_complex_float_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_complex_float_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_complex_float_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_complex_float_const_view position(long position) {
        return (_gsl_vector_complex_float_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_complex_float vector(); public native _gsl_vector_complex_float_const_view vector(gsl_vector_complex_float vector);
}

/* Allocation */

public static native gsl_vector_complex_float gsl_vector_complex_float_alloc(@Cast("const size_t") long n);
public static native gsl_vector_complex_float gsl_vector_complex_float_calloc(@Cast("const size_t") long n);

public static native gsl_vector_complex_float gsl_vector_complex_float_alloc_from_block(gsl_block_complex_float b, 
                                           @Cast("const size_t") long offset, 
                                           @Cast("const size_t") long n, 
                                           @Cast("const size_t") long stride);

public static native gsl_vector_complex_float gsl_vector_complex_float_alloc_from_vector(gsl_vector_complex_float v, 
                                             @Cast("const size_t") long offset, 
                                             @Cast("const size_t") long n, 
                                             @Cast("const size_t") long stride);

public static native void gsl_vector_complex_float_free(gsl_vector_complex_float v);

/* Views */

public static native @ByVal _gsl_vector_complex_float_view gsl_vector_complex_float_view_array(FloatPointer base,
                                     @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_float_view gsl_vector_complex_float_view_array(FloatBuffer base,
                                     @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_float_view gsl_vector_complex_float_view_array(float[] base,
                                     @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_float_view gsl_vector_complex_float_view_array_with_stride(FloatPointer base,
                                                 @Cast("size_t") long stride,
                                                 @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_float_view gsl_vector_complex_float_view_array_with_stride(FloatBuffer base,
                                                 @Cast("size_t") long stride,
                                                 @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_float_view gsl_vector_complex_float_view_array_with_stride(float[] base,
                                                 @Cast("size_t") long stride,
                                                 @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_vector_complex_float_const_view_array(@Const FloatPointer base,
                                           @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_float_const_view gsl_vector_complex_float_const_view_array(@Const FloatBuffer base,
                                           @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_float_const_view gsl_vector_complex_float_const_view_array(@Const float[] base,
                                           @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_vector_complex_float_const_view_array_with_stride(@Const FloatPointer base,
                                                       @Cast("size_t") long stride,
                                                       @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_float_const_view gsl_vector_complex_float_const_view_array_with_stride(@Const FloatBuffer base,
                                                       @Cast("size_t") long stride,
                                                       @Cast("size_t") long n);
public static native @ByVal _gsl_vector_complex_float_const_view gsl_vector_complex_float_const_view_array_with_stride(@Const float[] base,
                                                       @Cast("size_t") long stride,
                                                       @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_float_view gsl_vector_complex_float_subvector(gsl_vector_complex_float base,
                                         @Cast("size_t") long i, 
                                         @Cast("size_t") long n);


public static native @ByVal _gsl_vector_complex_float_view gsl_vector_complex_float_subvector_with_stride(gsl_vector_complex_float v, 
                                                @Cast("size_t") long i, 
                                                @Cast("size_t") long stride, 
                                                @Cast("size_t") long n);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_vector_complex_float_const_subvector(@Const gsl_vector_complex_float base,
                                               @Cast("size_t") long i, 
                                               @Cast("size_t") long n);


public static native @ByVal _gsl_vector_complex_float_const_view gsl_vector_complex_float_const_subvector_with_stride(@Const gsl_vector_complex_float v, 
                                                      @Cast("size_t") long i, 
                                                      @Cast("size_t") long stride, 
                                                      @Cast("size_t") long n);

public static native @ByVal _gsl_vector_float_view gsl_vector_complex_float_real(gsl_vector_complex_float v);

public static native @ByVal _gsl_vector_float_view gsl_vector_complex_float_imag(gsl_vector_complex_float v);

public static native @ByVal _gsl_vector_float_const_view gsl_vector_complex_float_const_real(@Const gsl_vector_complex_float v);

public static native @ByVal _gsl_vector_float_const_view gsl_vector_complex_float_const_imag(@Const gsl_vector_complex_float v);


/* Operations */

public static native void gsl_vector_complex_float_set_zero(gsl_vector_complex_float v);
public static native void gsl_vector_complex_float_set_all(gsl_vector_complex_float v,
                                       @ByVal gsl_complex_float z);
public static native int gsl_vector_complex_float_set_basis(gsl_vector_complex_float v, @Cast("size_t") long i);

public static native int gsl_vector_complex_float_fread(@Cast("FILE*") Pointer stream,
                                    gsl_vector_complex_float v);
public static native int gsl_vector_complex_float_fwrite(@Cast("FILE*") Pointer stream,
                                     @Const gsl_vector_complex_float v);
public static native int gsl_vector_complex_float_fscanf(@Cast("FILE*") Pointer stream,
                                     gsl_vector_complex_float v);
public static native int gsl_vector_complex_float_fprintf(@Cast("FILE*") Pointer stream,
                                      @Const gsl_vector_complex_float v,
                                      @Cast("const char*") BytePointer format);
public static native int gsl_vector_complex_float_fprintf(@Cast("FILE*") Pointer stream,
                                      @Const gsl_vector_complex_float v,
                                      String format);

public static native int gsl_vector_complex_float_memcpy(gsl_vector_complex_float dest, @Const gsl_vector_complex_float src);

public static native int gsl_vector_complex_float_reverse(gsl_vector_complex_float v);

public static native int gsl_vector_complex_float_swap(gsl_vector_complex_float v, gsl_vector_complex_float w);
public static native int gsl_vector_complex_float_swap_elements(gsl_vector_complex_float v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native int gsl_vector_complex_float_equal(@Const gsl_vector_complex_float u, 
                                    @Const gsl_vector_complex_float v);

public static native int gsl_vector_complex_float_isnull(@Const gsl_vector_complex_float v);
public static native int gsl_vector_complex_float_ispos(@Const gsl_vector_complex_float v);
public static native int gsl_vector_complex_float_isneg(@Const gsl_vector_complex_float v);
public static native int gsl_vector_complex_float_isnonneg(@Const gsl_vector_complex_float v);

public static native int gsl_vector_complex_float_add(gsl_vector_complex_float a, @Const gsl_vector_complex_float b);
public static native int gsl_vector_complex_float_sub(gsl_vector_complex_float a, @Const gsl_vector_complex_float b);
public static native int gsl_vector_complex_float_mul(gsl_vector_complex_float a, @Const gsl_vector_complex_float b);
public static native int gsl_vector_complex_float_div(gsl_vector_complex_float a, @Const gsl_vector_complex_float b);
public static native int gsl_vector_complex_float_scale(gsl_vector_complex_float a, @Const @ByVal gsl_complex_float x);
public static native int gsl_vector_complex_float_add_constant(gsl_vector_complex_float a, @Const @ByVal gsl_complex_float x);

/* */ public static native @ByVal gsl_complex_float gsl_vector_complex_float_get(@Const gsl_vector_complex_float v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_complex_float_set(gsl_vector_complex_float v, @Cast("const size_t") long i, @ByVal gsl_complex_float z);
/* */ public static native gsl_complex_float gsl_vector_complex_float_ptr(gsl_vector_complex_float v, @Cast("const size_t") long i);
/* */ public static native @Const gsl_complex_float gsl_vector_complex_float_const_ptr(@Const gsl_vector_complex_float v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE


// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_COMPLEX_FLOAT_H__ */


// Parsed from gsl/gsl_vector_double.h

/* vector/gsl_vector_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_DOUBLE_H__
// #define __GSL_VECTOR_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_double.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector position(long position) {
        return (gsl_vector)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector stride(long stride);
  public native DoublePointer data(); public native gsl_vector data(DoublePointer data);
  public native gsl_block block(); public native gsl_vector block(gsl_block block);
  public native int owner(); public native gsl_vector owner(int owner);
}

public static class _gsl_vector_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_view position(long position) {
        return (_gsl_vector_view)super.position(position);
    }

  public native @ByRef gsl_vector vector(); public native _gsl_vector_view vector(gsl_vector vector);
}

public static class _gsl_vector_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_const_view position(long position) {
        return (_gsl_vector_const_view)super.position(position);
    }

  public native @ByRef gsl_vector vector(); public native _gsl_vector_const_view vector(gsl_vector vector);
}


/* Allocation */

public static native gsl_vector gsl_vector_alloc(@Cast("const size_t") long n);
public static native gsl_vector gsl_vector_calloc(@Cast("const size_t") long n);

public static native gsl_vector gsl_vector_alloc_from_block(gsl_block b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector gsl_vector_alloc_from_vector(gsl_vector v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_free(gsl_vector v);

/* Views */

public static native @ByVal _gsl_vector_view gsl_vector_view_array(DoublePointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_view gsl_vector_view_array(DoubleBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_view gsl_vector_view_array(double[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_view gsl_vector_view_array_with_stride(DoublePointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_view gsl_vector_view_array_with_stride(DoubleBuffer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_view gsl_vector_view_array_with_stride(double[] base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_const_view gsl_vector_const_view_array(@Const DoublePointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_const_view gsl_vector_const_view_array(@Const DoubleBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_const_view gsl_vector_const_view_array(@Const double[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_const_view gsl_vector_const_view_array_with_stride(@Const DoublePointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_const_view gsl_vector_const_view_array_with_stride(@Const DoubleBuffer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_const_view gsl_vector_const_view_array_with_stride(@Const double[] base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_view gsl_vector_subvector(gsl_vector v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_view gsl_vector_subvector_with_stride(gsl_vector v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_const_view gsl_vector_const_subvector(@Const gsl_vector v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_const_view gsl_vector_const_subvector_with_stride(@Const gsl_vector v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_set_zero(gsl_vector v);
public static native void gsl_vector_set_all(gsl_vector v, double x);
public static native int gsl_vector_set_basis(gsl_vector v, @Cast("size_t") long i);

public static native int gsl_vector_fread(@Cast("FILE*") Pointer stream, gsl_vector v);
public static native int gsl_vector_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector v);
public static native int gsl_vector_fscanf(@Cast("FILE*") Pointer stream, gsl_vector v);
public static native int gsl_vector_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector v,
                              String format);

public static native int gsl_vector_memcpy(gsl_vector dest, @Const gsl_vector src);

public static native int gsl_vector_reverse(gsl_vector v);

public static native int gsl_vector_swap(gsl_vector v, gsl_vector w);
public static native int gsl_vector_swap_elements(gsl_vector v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native double gsl_vector_max(@Const gsl_vector v);
public static native double gsl_vector_min(@Const gsl_vector v);
public static native void gsl_vector_minmax(@Const gsl_vector v, DoublePointer min_out, DoublePointer max_out);
public static native void gsl_vector_minmax(@Const gsl_vector v, DoubleBuffer min_out, DoubleBuffer max_out);
public static native void gsl_vector_minmax(@Const gsl_vector v, double[] min_out, double[] max_out);

public static native @Cast("size_t") long gsl_vector_max_index(@Const gsl_vector v);
public static native @Cast("size_t") long gsl_vector_min_index(@Const gsl_vector v);
public static native void gsl_vector_minmax_index(@Const gsl_vector v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_add(gsl_vector a, @Const gsl_vector b);
public static native int gsl_vector_sub(gsl_vector a, @Const gsl_vector b);
public static native int gsl_vector_mul(gsl_vector a, @Const gsl_vector b);
public static native int gsl_vector_div(gsl_vector a, @Const gsl_vector b);
public static native int gsl_vector_scale(gsl_vector a, double x);
public static native int gsl_vector_add_constant(gsl_vector a, double x);

public static native int gsl_vector_equal(@Const gsl_vector u, 
                            @Const gsl_vector v);

public static native int gsl_vector_isnull(@Const gsl_vector v);
public static native int gsl_vector_ispos(@Const gsl_vector v);
public static native int gsl_vector_isneg(@Const gsl_vector v);
public static native int gsl_vector_isnonneg(@Const gsl_vector v);

/* */ public static native double gsl_vector_get(@Const gsl_vector v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_set(gsl_vector v, @Cast("const size_t") long i, double x);
/* */ public static native DoublePointer gsl_vector_ptr(gsl_vector v, @Cast("const size_t") long i);
/* */ public static native @Const DoublePointer gsl_vector_const_ptr(@Const gsl_vector v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_DOUBLE_H__ */




// Parsed from gsl/gsl_vector_float.h

/* vector/gsl_vector_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_FLOAT_H__
// #define __GSL_VECTOR_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_float.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_float position(long position) {
        return (gsl_vector_float)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_float size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_float stride(long stride);
  public native FloatPointer data(); public native gsl_vector_float data(FloatPointer data);
  public native gsl_block_float block(); public native gsl_vector_float block(gsl_block_float block);
  public native int owner(); public native gsl_vector_float owner(int owner);
}

public static class _gsl_vector_float_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_float_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_float_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_float_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_float_view position(long position) {
        return (_gsl_vector_float_view)super.position(position);
    }

  public native @ByRef gsl_vector_float vector(); public native _gsl_vector_float_view vector(gsl_vector_float vector);
}

public static class _gsl_vector_float_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_float_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_float_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_float_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_float_const_view position(long position) {
        return (_gsl_vector_float_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_float vector(); public native _gsl_vector_float_const_view vector(gsl_vector_float vector);
}


/* Allocation */

public static native gsl_vector_float gsl_vector_float_alloc(@Cast("const size_t") long n);
public static native gsl_vector_float gsl_vector_float_calloc(@Cast("const size_t") long n);

public static native gsl_vector_float gsl_vector_float_alloc_from_block(gsl_block_float b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector_float gsl_vector_float_alloc_from_vector(gsl_vector_float v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_float_free(gsl_vector_float v);

/* Views */

public static native @ByVal _gsl_vector_float_view gsl_vector_float_view_array(FloatPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_float_view gsl_vector_float_view_array(FloatBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_float_view gsl_vector_float_view_array(float[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_float_view gsl_vector_float_view_array_with_stride(FloatPointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_float_view gsl_vector_float_view_array_with_stride(FloatBuffer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_float_view gsl_vector_float_view_array_with_stride(float[] base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_float_const_view gsl_vector_float_const_view_array(@Const FloatPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_float_const_view gsl_vector_float_const_view_array(@Const FloatBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_float_const_view gsl_vector_float_const_view_array(@Const float[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_float_const_view gsl_vector_float_const_view_array_with_stride(@Const FloatPointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_float_const_view gsl_vector_float_const_view_array_with_stride(@Const FloatBuffer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_float_const_view gsl_vector_float_const_view_array_with_stride(@Const float[] base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_float_view gsl_vector_float_subvector(gsl_vector_float v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_float_view gsl_vector_float_subvector_with_stride(gsl_vector_float v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_float_const_view gsl_vector_float_const_subvector(@Const gsl_vector_float v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_float_const_view gsl_vector_float_const_subvector_with_stride(@Const gsl_vector_float v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_float_set_zero(gsl_vector_float v);
public static native void gsl_vector_float_set_all(gsl_vector_float v, float x);
public static native int gsl_vector_float_set_basis(gsl_vector_float v, @Cast("size_t") long i);

public static native int gsl_vector_float_fread(@Cast("FILE*") Pointer stream, gsl_vector_float v);
public static native int gsl_vector_float_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector_float v);
public static native int gsl_vector_float_fscanf(@Cast("FILE*") Pointer stream, gsl_vector_float v);
public static native int gsl_vector_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_float v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_float v,
                              String format);

public static native int gsl_vector_float_memcpy(gsl_vector_float dest, @Const gsl_vector_float src);

public static native int gsl_vector_float_reverse(gsl_vector_float v);

public static native int gsl_vector_float_swap(gsl_vector_float v, gsl_vector_float w);
public static native int gsl_vector_float_swap_elements(gsl_vector_float v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native float gsl_vector_float_max(@Const gsl_vector_float v);
public static native float gsl_vector_float_min(@Const gsl_vector_float v);
public static native void gsl_vector_float_minmax(@Const gsl_vector_float v, FloatPointer min_out, FloatPointer max_out);
public static native void gsl_vector_float_minmax(@Const gsl_vector_float v, FloatBuffer min_out, FloatBuffer max_out);
public static native void gsl_vector_float_minmax(@Const gsl_vector_float v, float[] min_out, float[] max_out);

public static native @Cast("size_t") long gsl_vector_float_max_index(@Const gsl_vector_float v);
public static native @Cast("size_t") long gsl_vector_float_min_index(@Const gsl_vector_float v);
public static native void gsl_vector_float_minmax_index(@Const gsl_vector_float v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_float_add(gsl_vector_float a, @Const gsl_vector_float b);
public static native int gsl_vector_float_sub(gsl_vector_float a, @Const gsl_vector_float b);
public static native int gsl_vector_float_mul(gsl_vector_float a, @Const gsl_vector_float b);
public static native int gsl_vector_float_div(gsl_vector_float a, @Const gsl_vector_float b);
public static native int gsl_vector_float_scale(gsl_vector_float a, double x);
public static native int gsl_vector_float_add_constant(gsl_vector_float a, double x);

public static native int gsl_vector_float_equal(@Const gsl_vector_float u, 
                            @Const gsl_vector_float v);

public static native int gsl_vector_float_isnull(@Const gsl_vector_float v);
public static native int gsl_vector_float_ispos(@Const gsl_vector_float v);
public static native int gsl_vector_float_isneg(@Const gsl_vector_float v);
public static native int gsl_vector_float_isnonneg(@Const gsl_vector_float v);

/* */ public static native float gsl_vector_float_get(@Const gsl_vector_float v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_float_set(gsl_vector_float v, @Cast("const size_t") long i, float x);
/* */ public static native FloatPointer gsl_vector_float_ptr(gsl_vector_float v, @Cast("const size_t") long i);
/* */ public static native @Const FloatPointer gsl_vector_float_const_ptr(@Const gsl_vector_float v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_FLOAT_H__ */




// Parsed from gsl/gsl_vector_ulong.h

/* vector/gsl_vector_ulong.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_ULONG_H__
// #define __GSL_VECTOR_ULONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_ulong.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_ulong extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_ulong() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_ulong(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_ulong(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_ulong position(long position) {
        return (gsl_vector_ulong)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_ulong size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_ulong stride(long stride);
  public native @Cast("unsigned long*") CLongPointer data(); public native gsl_vector_ulong data(CLongPointer data);
  public native gsl_block_ulong block(); public native gsl_vector_ulong block(gsl_block_ulong block);
  public native int owner(); public native gsl_vector_ulong owner(int owner);
}

public static class _gsl_vector_ulong_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_ulong_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_ulong_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_ulong_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_ulong_view position(long position) {
        return (_gsl_vector_ulong_view)super.position(position);
    }

  public native @ByRef gsl_vector_ulong vector(); public native _gsl_vector_ulong_view vector(gsl_vector_ulong vector);
}

public static class _gsl_vector_ulong_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_ulong_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_ulong_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_ulong_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_ulong_const_view position(long position) {
        return (_gsl_vector_ulong_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_ulong vector(); public native _gsl_vector_ulong_const_view vector(gsl_vector_ulong vector);
}


/* Allocation */

public static native gsl_vector_ulong gsl_vector_ulong_alloc(@Cast("const size_t") long n);
public static native gsl_vector_ulong gsl_vector_ulong_calloc(@Cast("const size_t") long n);

public static native gsl_vector_ulong gsl_vector_ulong_alloc_from_block(gsl_block_ulong b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector_ulong gsl_vector_ulong_alloc_from_vector(gsl_vector_ulong v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_ulong_free(gsl_vector_ulong v);

/* Views */

public static native @ByVal _gsl_vector_ulong_view gsl_vector_ulong_view_array(@Cast("unsigned long*") CLongPointer v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ulong_view gsl_vector_ulong_view_array_with_stride(@Cast("unsigned long*") CLongPointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ulong_const_view gsl_vector_ulong_const_view_array(@Cast("const unsigned long*") CLongPointer v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ulong_const_view gsl_vector_ulong_const_view_array_with_stride(@Cast("const unsigned long*") CLongPointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ulong_view gsl_vector_ulong_subvector(gsl_vector_ulong v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ulong_view gsl_vector_ulong_subvector_with_stride(gsl_vector_ulong v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ulong_const_view gsl_vector_ulong_const_subvector(@Const gsl_vector_ulong v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ulong_const_view gsl_vector_ulong_const_subvector_with_stride(@Const gsl_vector_ulong v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_ulong_set_zero(gsl_vector_ulong v);
public static native void gsl_vector_ulong_set_all(gsl_vector_ulong v, @Cast("unsigned long") long x);
public static native int gsl_vector_ulong_set_basis(gsl_vector_ulong v, @Cast("size_t") long i);

public static native int gsl_vector_ulong_fread(@Cast("FILE*") Pointer stream, gsl_vector_ulong v);
public static native int gsl_vector_ulong_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector_ulong v);
public static native int gsl_vector_ulong_fscanf(@Cast("FILE*") Pointer stream, gsl_vector_ulong v);
public static native int gsl_vector_ulong_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_ulong v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_ulong_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_ulong v,
                              String format);

public static native int gsl_vector_ulong_memcpy(gsl_vector_ulong dest, @Const gsl_vector_ulong src);

public static native int gsl_vector_ulong_reverse(gsl_vector_ulong v);

public static native int gsl_vector_ulong_swap(gsl_vector_ulong v, gsl_vector_ulong w);
public static native int gsl_vector_ulong_swap_elements(gsl_vector_ulong v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native @Cast("unsigned long") long gsl_vector_ulong_max(@Const gsl_vector_ulong v);
public static native @Cast("unsigned long") long gsl_vector_ulong_min(@Const gsl_vector_ulong v);
public static native void gsl_vector_ulong_minmax(@Const gsl_vector_ulong v, @Cast("unsigned long*") CLongPointer min_out, @Cast("unsigned long*") CLongPointer max_out);

public static native @Cast("size_t") long gsl_vector_ulong_max_index(@Const gsl_vector_ulong v);
public static native @Cast("size_t") long gsl_vector_ulong_min_index(@Const gsl_vector_ulong v);
public static native void gsl_vector_ulong_minmax_index(@Const gsl_vector_ulong v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_ulong_add(gsl_vector_ulong a, @Const gsl_vector_ulong b);
public static native int gsl_vector_ulong_sub(gsl_vector_ulong a, @Const gsl_vector_ulong b);
public static native int gsl_vector_ulong_mul(gsl_vector_ulong a, @Const gsl_vector_ulong b);
public static native int gsl_vector_ulong_div(gsl_vector_ulong a, @Const gsl_vector_ulong b);
public static native int gsl_vector_ulong_scale(gsl_vector_ulong a, double x);
public static native int gsl_vector_ulong_add_constant(gsl_vector_ulong a, double x);

public static native int gsl_vector_ulong_equal(@Const gsl_vector_ulong u, 
                            @Const gsl_vector_ulong v);

public static native int gsl_vector_ulong_isnull(@Const gsl_vector_ulong v);
public static native int gsl_vector_ulong_ispos(@Const gsl_vector_ulong v);
public static native int gsl_vector_ulong_isneg(@Const gsl_vector_ulong v);
public static native int gsl_vector_ulong_isnonneg(@Const gsl_vector_ulong v);

/* */ public static native @Cast("unsigned long") long gsl_vector_ulong_get(@Const gsl_vector_ulong v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_ulong_set(gsl_vector_ulong v, @Cast("const size_t") long i, @Cast("unsigned long") long x);
/* */ public static native @Cast("unsigned long*") CLongPointer gsl_vector_ulong_ptr(gsl_vector_ulong v, @Cast("const size_t") long i);
/* */ public static native @Cast("const unsigned long*") CLongPointer gsl_vector_ulong_const_ptr(@Const gsl_vector_ulong v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_ULONG_H__ */




// Parsed from gsl/gsl_vector_long.h

/* vector/gsl_vector_long.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_LONG_H__
// #define __GSL_VECTOR_LONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_long.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_long extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_long() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_long(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_long(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_long position(long position) {
        return (gsl_vector_long)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_long size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_long stride(long stride);
  public native CLongPointer data(); public native gsl_vector_long data(CLongPointer data);
  public native gsl_block_long block(); public native gsl_vector_long block(gsl_block_long block);
  public native int owner(); public native gsl_vector_long owner(int owner);
}

public static class _gsl_vector_long_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_long_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_long_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_long_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_long_view position(long position) {
        return (_gsl_vector_long_view)super.position(position);
    }

  public native @ByRef gsl_vector_long vector(); public native _gsl_vector_long_view vector(gsl_vector_long vector);
}

public static class _gsl_vector_long_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_long_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_long_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_long_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_long_const_view position(long position) {
        return (_gsl_vector_long_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_long vector(); public native _gsl_vector_long_const_view vector(gsl_vector_long vector);
}


/* Allocation */

public static native gsl_vector_long gsl_vector_long_alloc(@Cast("const size_t") long n);
public static native gsl_vector_long gsl_vector_long_calloc(@Cast("const size_t") long n);

public static native gsl_vector_long gsl_vector_long_alloc_from_block(gsl_block_long b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector_long gsl_vector_long_alloc_from_vector(gsl_vector_long v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_long_free(gsl_vector_long v);

/* Views */

public static native @ByVal _gsl_vector_long_view gsl_vector_long_view_array(CLongPointer v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_long_view gsl_vector_long_view_array_with_stride(CLongPointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_long_const_view gsl_vector_long_const_view_array(@Const CLongPointer v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_long_const_view gsl_vector_long_const_view_array_with_stride(@Const CLongPointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_long_view gsl_vector_long_subvector(gsl_vector_long v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_long_view gsl_vector_long_subvector_with_stride(gsl_vector_long v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_long_const_view gsl_vector_long_const_subvector(@Const gsl_vector_long v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_long_const_view gsl_vector_long_const_subvector_with_stride(@Const gsl_vector_long v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_long_set_zero(gsl_vector_long v);
public static native void gsl_vector_long_set_all(gsl_vector_long v, long x);
public static native int gsl_vector_long_set_basis(gsl_vector_long v, @Cast("size_t") long i);

public static native int gsl_vector_long_fread(@Cast("FILE*") Pointer stream, gsl_vector_long v);
public static native int gsl_vector_long_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector_long v);
public static native int gsl_vector_long_fscanf(@Cast("FILE*") Pointer stream, gsl_vector_long v);
public static native int gsl_vector_long_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_long v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_long_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_long v,
                              String format);

public static native int gsl_vector_long_memcpy(gsl_vector_long dest, @Const gsl_vector_long src);

public static native int gsl_vector_long_reverse(gsl_vector_long v);

public static native int gsl_vector_long_swap(gsl_vector_long v, gsl_vector_long w);
public static native int gsl_vector_long_swap_elements(gsl_vector_long v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native long gsl_vector_long_max(@Const gsl_vector_long v);
public static native long gsl_vector_long_min(@Const gsl_vector_long v);
public static native void gsl_vector_long_minmax(@Const gsl_vector_long v, CLongPointer min_out, CLongPointer max_out);

public static native @Cast("size_t") long gsl_vector_long_max_index(@Const gsl_vector_long v);
public static native @Cast("size_t") long gsl_vector_long_min_index(@Const gsl_vector_long v);
public static native void gsl_vector_long_minmax_index(@Const gsl_vector_long v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_long_add(gsl_vector_long a, @Const gsl_vector_long b);
public static native int gsl_vector_long_sub(gsl_vector_long a, @Const gsl_vector_long b);
public static native int gsl_vector_long_mul(gsl_vector_long a, @Const gsl_vector_long b);
public static native int gsl_vector_long_div(gsl_vector_long a, @Const gsl_vector_long b);
public static native int gsl_vector_long_scale(gsl_vector_long a, double x);
public static native int gsl_vector_long_add_constant(gsl_vector_long a, double x);

public static native int gsl_vector_long_equal(@Const gsl_vector_long u, 
                            @Const gsl_vector_long v);

public static native int gsl_vector_long_isnull(@Const gsl_vector_long v);
public static native int gsl_vector_long_ispos(@Const gsl_vector_long v);
public static native int gsl_vector_long_isneg(@Const gsl_vector_long v);
public static native int gsl_vector_long_isnonneg(@Const gsl_vector_long v);

/* */ public static native long gsl_vector_long_get(@Const gsl_vector_long v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_long_set(gsl_vector_long v, @Cast("const size_t") long i, long x);
/* */ public static native CLongPointer gsl_vector_long_ptr(gsl_vector_long v, @Cast("const size_t") long i);
/* */ public static native @Const CLongPointer gsl_vector_long_const_ptr(@Const gsl_vector_long v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_LONG_H__ */




// Parsed from gsl/gsl_vector_uint.h

/* vector/gsl_vector_uint.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_UINT_H__
// #define __GSL_VECTOR_UINT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_uint.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_uint extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_uint() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_uint(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_uint(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_uint position(long position) {
        return (gsl_vector_uint)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_uint size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_uint stride(long stride);
  public native @Cast("unsigned int*") IntPointer data(); public native gsl_vector_uint data(IntPointer data);
  public native gsl_block_uint block(); public native gsl_vector_uint block(gsl_block_uint block);
  public native int owner(); public native gsl_vector_uint owner(int owner);
}

public static class _gsl_vector_uint_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_uint_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_uint_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_uint_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_uint_view position(long position) {
        return (_gsl_vector_uint_view)super.position(position);
    }

  public native @ByRef gsl_vector_uint vector(); public native _gsl_vector_uint_view vector(gsl_vector_uint vector);
}

public static class _gsl_vector_uint_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_uint_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_uint_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_uint_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_uint_const_view position(long position) {
        return (_gsl_vector_uint_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_uint vector(); public native _gsl_vector_uint_const_view vector(gsl_vector_uint vector);
}


/* Allocation */

public static native gsl_vector_uint gsl_vector_uint_alloc(@Cast("const size_t") long n);
public static native gsl_vector_uint gsl_vector_uint_calloc(@Cast("const size_t") long n);

public static native gsl_vector_uint gsl_vector_uint_alloc_from_block(gsl_block_uint b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector_uint gsl_vector_uint_alloc_from_vector(gsl_vector_uint v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_uint_free(gsl_vector_uint v);

/* Views */

public static native @ByVal _gsl_vector_uint_view gsl_vector_uint_view_array(@Cast("unsigned int*") IntPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uint_view gsl_vector_uint_view_array(@Cast("unsigned int*") IntBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uint_view gsl_vector_uint_view_array(@Cast("unsigned int*") int[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uint_view gsl_vector_uint_view_array_with_stride(@Cast("unsigned int*") IntPointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uint_view gsl_vector_uint_view_array_with_stride(@Cast("unsigned int*") IntBuffer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uint_view gsl_vector_uint_view_array_with_stride(@Cast("unsigned int*") int[] base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uint_const_view gsl_vector_uint_const_view_array(@Cast("const unsigned int*") IntPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uint_const_view gsl_vector_uint_const_view_array(@Cast("const unsigned int*") IntBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uint_const_view gsl_vector_uint_const_view_array(@Cast("const unsigned int*") int[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uint_const_view gsl_vector_uint_const_view_array_with_stride(@Cast("const unsigned int*") IntPointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uint_const_view gsl_vector_uint_const_view_array_with_stride(@Cast("const unsigned int*") IntBuffer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uint_const_view gsl_vector_uint_const_view_array_with_stride(@Cast("const unsigned int*") int[] base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uint_view gsl_vector_uint_subvector(gsl_vector_uint v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uint_view gsl_vector_uint_subvector_with_stride(gsl_vector_uint v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uint_const_view gsl_vector_uint_const_subvector(@Const gsl_vector_uint v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uint_const_view gsl_vector_uint_const_subvector_with_stride(@Const gsl_vector_uint v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_uint_set_zero(gsl_vector_uint v);
public static native void gsl_vector_uint_set_all(gsl_vector_uint v, @Cast("unsigned int") int x);
public static native int gsl_vector_uint_set_basis(gsl_vector_uint v, @Cast("size_t") long i);

public static native int gsl_vector_uint_fread(@Cast("FILE*") Pointer stream, gsl_vector_uint v);
public static native int gsl_vector_uint_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector_uint v);
public static native int gsl_vector_uint_fscanf(@Cast("FILE*") Pointer stream, gsl_vector_uint v);
public static native int gsl_vector_uint_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_uint v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_uint_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_uint v,
                              String format);

public static native int gsl_vector_uint_memcpy(gsl_vector_uint dest, @Const gsl_vector_uint src);

public static native int gsl_vector_uint_reverse(gsl_vector_uint v);

public static native int gsl_vector_uint_swap(gsl_vector_uint v, gsl_vector_uint w);
public static native int gsl_vector_uint_swap_elements(gsl_vector_uint v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native @Cast("unsigned int") int gsl_vector_uint_max(@Const gsl_vector_uint v);
public static native @Cast("unsigned int") int gsl_vector_uint_min(@Const gsl_vector_uint v);
public static native void gsl_vector_uint_minmax(@Const gsl_vector_uint v, @Cast("unsigned int*") IntPointer min_out, @Cast("unsigned int*") IntPointer max_out);
public static native void gsl_vector_uint_minmax(@Const gsl_vector_uint v, @Cast("unsigned int*") IntBuffer min_out, @Cast("unsigned int*") IntBuffer max_out);
public static native void gsl_vector_uint_minmax(@Const gsl_vector_uint v, @Cast("unsigned int*") int[] min_out, @Cast("unsigned int*") int[] max_out);

public static native @Cast("size_t") long gsl_vector_uint_max_index(@Const gsl_vector_uint v);
public static native @Cast("size_t") long gsl_vector_uint_min_index(@Const gsl_vector_uint v);
public static native void gsl_vector_uint_minmax_index(@Const gsl_vector_uint v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_uint_add(gsl_vector_uint a, @Const gsl_vector_uint b);
public static native int gsl_vector_uint_sub(gsl_vector_uint a, @Const gsl_vector_uint b);
public static native int gsl_vector_uint_mul(gsl_vector_uint a, @Const gsl_vector_uint b);
public static native int gsl_vector_uint_div(gsl_vector_uint a, @Const gsl_vector_uint b);
public static native int gsl_vector_uint_scale(gsl_vector_uint a, double x);
public static native int gsl_vector_uint_add_constant(gsl_vector_uint a, double x);

public static native int gsl_vector_uint_equal(@Const gsl_vector_uint u, 
                            @Const gsl_vector_uint v);

public static native int gsl_vector_uint_isnull(@Const gsl_vector_uint v);
public static native int gsl_vector_uint_ispos(@Const gsl_vector_uint v);
public static native int gsl_vector_uint_isneg(@Const gsl_vector_uint v);
public static native int gsl_vector_uint_isnonneg(@Const gsl_vector_uint v);

/* */ public static native @Cast("unsigned int") int gsl_vector_uint_get(@Const gsl_vector_uint v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_uint_set(gsl_vector_uint v, @Cast("const size_t") long i, @Cast("unsigned int") int x);
/* */ public static native @Cast("unsigned int*") IntPointer gsl_vector_uint_ptr(gsl_vector_uint v, @Cast("const size_t") long i);
/* */ public static native @Cast("const unsigned int*") IntPointer gsl_vector_uint_const_ptr(@Const gsl_vector_uint v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_UINT_H__ */




// Parsed from gsl/gsl_vector_int.h

/* vector/gsl_vector_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_INT_H__
// #define __GSL_VECTOR_INT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_int.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_int extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_int() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_int(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_int(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_int position(long position) {
        return (gsl_vector_int)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_int size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_int stride(long stride);
  public native IntPointer data(); public native gsl_vector_int data(IntPointer data);
  public native gsl_block_int block(); public native gsl_vector_int block(gsl_block_int block);
  public native int owner(); public native gsl_vector_int owner(int owner);
}

public static class _gsl_vector_int_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_int_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_int_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_int_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_int_view position(long position) {
        return (_gsl_vector_int_view)super.position(position);
    }

  public native @ByRef gsl_vector_int vector(); public native _gsl_vector_int_view vector(gsl_vector_int vector);
}

public static class _gsl_vector_int_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_int_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_int_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_int_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_int_const_view position(long position) {
        return (_gsl_vector_int_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_int vector(); public native _gsl_vector_int_const_view vector(gsl_vector_int vector);
}


/* Allocation */

public static native gsl_vector_int gsl_vector_int_alloc(@Cast("const size_t") long n);
public static native gsl_vector_int gsl_vector_int_calloc(@Cast("const size_t") long n);

public static native gsl_vector_int gsl_vector_int_alloc_from_block(gsl_block_int b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector_int gsl_vector_int_alloc_from_vector(gsl_vector_int v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_int_free(gsl_vector_int v);

/* Views */

public static native @ByVal _gsl_vector_int_view gsl_vector_int_view_array(IntPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_int_view gsl_vector_int_view_array(IntBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_int_view gsl_vector_int_view_array(int[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_int_view gsl_vector_int_view_array_with_stride(IntPointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_int_view gsl_vector_int_view_array_with_stride(IntBuffer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_int_view gsl_vector_int_view_array_with_stride(int[] base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_int_const_view gsl_vector_int_const_view_array(@Const IntPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_int_const_view gsl_vector_int_const_view_array(@Const IntBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_int_const_view gsl_vector_int_const_view_array(@Const int[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_int_const_view gsl_vector_int_const_view_array_with_stride(@Const IntPointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_int_const_view gsl_vector_int_const_view_array_with_stride(@Const IntBuffer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_int_const_view gsl_vector_int_const_view_array_with_stride(@Const int[] base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_int_view gsl_vector_int_subvector(gsl_vector_int v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_int_view gsl_vector_int_subvector_with_stride(gsl_vector_int v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_int_const_view gsl_vector_int_const_subvector(@Const gsl_vector_int v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_int_const_view gsl_vector_int_const_subvector_with_stride(@Const gsl_vector_int v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_int_set_zero(gsl_vector_int v);
public static native void gsl_vector_int_set_all(gsl_vector_int v, int x);
public static native int gsl_vector_int_set_basis(gsl_vector_int v, @Cast("size_t") long i);

public static native int gsl_vector_int_fread(@Cast("FILE*") Pointer stream, gsl_vector_int v);
public static native int gsl_vector_int_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector_int v);
public static native int gsl_vector_int_fscanf(@Cast("FILE*") Pointer stream, gsl_vector_int v);
public static native int gsl_vector_int_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_int v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_int_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_int v,
                              String format);

public static native int gsl_vector_int_memcpy(gsl_vector_int dest, @Const gsl_vector_int src);

public static native int gsl_vector_int_reverse(gsl_vector_int v);

public static native int gsl_vector_int_swap(gsl_vector_int v, gsl_vector_int w);
public static native int gsl_vector_int_swap_elements(gsl_vector_int v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native int gsl_vector_int_max(@Const gsl_vector_int v);
public static native int gsl_vector_int_min(@Const gsl_vector_int v);
public static native void gsl_vector_int_minmax(@Const gsl_vector_int v, IntPointer min_out, IntPointer max_out);
public static native void gsl_vector_int_minmax(@Const gsl_vector_int v, IntBuffer min_out, IntBuffer max_out);
public static native void gsl_vector_int_minmax(@Const gsl_vector_int v, int[] min_out, int[] max_out);

public static native @Cast("size_t") long gsl_vector_int_max_index(@Const gsl_vector_int v);
public static native @Cast("size_t") long gsl_vector_int_min_index(@Const gsl_vector_int v);
public static native void gsl_vector_int_minmax_index(@Const gsl_vector_int v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_int_add(gsl_vector_int a, @Const gsl_vector_int b);
public static native int gsl_vector_int_sub(gsl_vector_int a, @Const gsl_vector_int b);
public static native int gsl_vector_int_mul(gsl_vector_int a, @Const gsl_vector_int b);
public static native int gsl_vector_int_div(gsl_vector_int a, @Const gsl_vector_int b);
public static native int gsl_vector_int_scale(gsl_vector_int a, double x);
public static native int gsl_vector_int_add_constant(gsl_vector_int a, double x);

public static native int gsl_vector_int_equal(@Const gsl_vector_int u, 
                            @Const gsl_vector_int v);

public static native int gsl_vector_int_isnull(@Const gsl_vector_int v);
public static native int gsl_vector_int_ispos(@Const gsl_vector_int v);
public static native int gsl_vector_int_isneg(@Const gsl_vector_int v);
public static native int gsl_vector_int_isnonneg(@Const gsl_vector_int v);

/* */ public static native int gsl_vector_int_get(@Const gsl_vector_int v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_int_set(gsl_vector_int v, @Cast("const size_t") long i, int x);
/* */ public static native IntPointer gsl_vector_int_ptr(gsl_vector_int v, @Cast("const size_t") long i);
/* */ public static native @Const IntPointer gsl_vector_int_const_ptr(@Const gsl_vector_int v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_INT_H__ */




// Parsed from gsl/gsl_vector_ushort.h

/* vector/gsl_vector_ushort.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_USHORT_H__
// #define __GSL_VECTOR_USHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_ushort.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_ushort extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_ushort() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_ushort(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_ushort(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_ushort position(long position) {
        return (gsl_vector_ushort)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_ushort size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_ushort stride(long stride);
  public native @Cast("unsigned short*") ShortPointer data(); public native gsl_vector_ushort data(ShortPointer data);
  public native gsl_block_ushort block(); public native gsl_vector_ushort block(gsl_block_ushort block);
  public native int owner(); public native gsl_vector_ushort owner(int owner);
}

public static class _gsl_vector_ushort_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_ushort_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_ushort_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_ushort_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_ushort_view position(long position) {
        return (_gsl_vector_ushort_view)super.position(position);
    }

  public native @ByRef gsl_vector_ushort vector(); public native _gsl_vector_ushort_view vector(gsl_vector_ushort vector);
}

public static class _gsl_vector_ushort_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_ushort_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_ushort_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_ushort_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_ushort_const_view position(long position) {
        return (_gsl_vector_ushort_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_ushort vector(); public native _gsl_vector_ushort_const_view vector(gsl_vector_ushort vector);
}


/* Allocation */

public static native gsl_vector_ushort gsl_vector_ushort_alloc(@Cast("const size_t") long n);
public static native gsl_vector_ushort gsl_vector_ushort_calloc(@Cast("const size_t") long n);

public static native gsl_vector_ushort gsl_vector_ushort_alloc_from_block(gsl_block_ushort b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector_ushort gsl_vector_ushort_alloc_from_vector(gsl_vector_ushort v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_ushort_free(gsl_vector_ushort v);

/* Views */

public static native @ByVal _gsl_vector_ushort_view gsl_vector_ushort_view_array(@Cast("unsigned short*") ShortPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_ushort_view gsl_vector_ushort_view_array(@Cast("unsigned short*") ShortBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_ushort_view gsl_vector_ushort_view_array(@Cast("unsigned short*") short[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ushort_view gsl_vector_ushort_view_array_with_stride(@Cast("unsigned short*") ShortPointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_ushort_view gsl_vector_ushort_view_array_with_stride(@Cast("unsigned short*") ShortBuffer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_ushort_view gsl_vector_ushort_view_array_with_stride(@Cast("unsigned short*") short[] base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ushort_const_view gsl_vector_ushort_const_view_array(@Cast("const unsigned short*") ShortPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_ushort_const_view gsl_vector_ushort_const_view_array(@Cast("const unsigned short*") ShortBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_ushort_const_view gsl_vector_ushort_const_view_array(@Cast("const unsigned short*") short[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ushort_const_view gsl_vector_ushort_const_view_array_with_stride(@Cast("const unsigned short*") ShortPointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_ushort_const_view gsl_vector_ushort_const_view_array_with_stride(@Cast("const unsigned short*") ShortBuffer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_ushort_const_view gsl_vector_ushort_const_view_array_with_stride(@Cast("const unsigned short*") short[] base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ushort_view gsl_vector_ushort_subvector(gsl_vector_ushort v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ushort_view gsl_vector_ushort_subvector_with_stride(gsl_vector_ushort v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ushort_const_view gsl_vector_ushort_const_subvector(@Const gsl_vector_ushort v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_ushort_const_view gsl_vector_ushort_const_subvector_with_stride(@Const gsl_vector_ushort v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_ushort_set_zero(gsl_vector_ushort v);
public static native void gsl_vector_ushort_set_all(gsl_vector_ushort v, @Cast("unsigned short") short x);
public static native int gsl_vector_ushort_set_basis(gsl_vector_ushort v, @Cast("size_t") long i);

public static native int gsl_vector_ushort_fread(@Cast("FILE*") Pointer stream, gsl_vector_ushort v);
public static native int gsl_vector_ushort_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector_ushort v);
public static native int gsl_vector_ushort_fscanf(@Cast("FILE*") Pointer stream, gsl_vector_ushort v);
public static native int gsl_vector_ushort_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_ushort v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_ushort_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_ushort v,
                              String format);

public static native int gsl_vector_ushort_memcpy(gsl_vector_ushort dest, @Const gsl_vector_ushort src);

public static native int gsl_vector_ushort_reverse(gsl_vector_ushort v);

public static native int gsl_vector_ushort_swap(gsl_vector_ushort v, gsl_vector_ushort w);
public static native int gsl_vector_ushort_swap_elements(gsl_vector_ushort v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native @Cast("unsigned short") short gsl_vector_ushort_max(@Const gsl_vector_ushort v);
public static native @Cast("unsigned short") short gsl_vector_ushort_min(@Const gsl_vector_ushort v);
public static native void gsl_vector_ushort_minmax(@Const gsl_vector_ushort v, @Cast("unsigned short*") ShortPointer min_out, @Cast("unsigned short*") ShortPointer max_out);
public static native void gsl_vector_ushort_minmax(@Const gsl_vector_ushort v, @Cast("unsigned short*") ShortBuffer min_out, @Cast("unsigned short*") ShortBuffer max_out);
public static native void gsl_vector_ushort_minmax(@Const gsl_vector_ushort v, @Cast("unsigned short*") short[] min_out, @Cast("unsigned short*") short[] max_out);

public static native @Cast("size_t") long gsl_vector_ushort_max_index(@Const gsl_vector_ushort v);
public static native @Cast("size_t") long gsl_vector_ushort_min_index(@Const gsl_vector_ushort v);
public static native void gsl_vector_ushort_minmax_index(@Const gsl_vector_ushort v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_ushort_add(gsl_vector_ushort a, @Const gsl_vector_ushort b);
public static native int gsl_vector_ushort_sub(gsl_vector_ushort a, @Const gsl_vector_ushort b);
public static native int gsl_vector_ushort_mul(gsl_vector_ushort a, @Const gsl_vector_ushort b);
public static native int gsl_vector_ushort_div(gsl_vector_ushort a, @Const gsl_vector_ushort b);
public static native int gsl_vector_ushort_scale(gsl_vector_ushort a, double x);
public static native int gsl_vector_ushort_add_constant(gsl_vector_ushort a, double x);

public static native int gsl_vector_ushort_equal(@Const gsl_vector_ushort u, 
                            @Const gsl_vector_ushort v);

public static native int gsl_vector_ushort_isnull(@Const gsl_vector_ushort v);
public static native int gsl_vector_ushort_ispos(@Const gsl_vector_ushort v);
public static native int gsl_vector_ushort_isneg(@Const gsl_vector_ushort v);
public static native int gsl_vector_ushort_isnonneg(@Const gsl_vector_ushort v);

/* */ public static native @Cast("unsigned short") short gsl_vector_ushort_get(@Const gsl_vector_ushort v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_ushort_set(gsl_vector_ushort v, @Cast("const size_t") long i, @Cast("unsigned short") short x);
/* */ public static native @Cast("unsigned short*") ShortPointer gsl_vector_ushort_ptr(gsl_vector_ushort v, @Cast("const size_t") long i);
/* */ public static native @Cast("const unsigned short*") ShortPointer gsl_vector_ushort_const_ptr(@Const gsl_vector_ushort v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_USHORT_H__ */




// Parsed from gsl/gsl_vector_short.h

/* vector/gsl_vector_short.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_SHORT_H__
// #define __GSL_VECTOR_SHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_short.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_short extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_short() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_short(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_short(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_short position(long position) {
        return (gsl_vector_short)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_short size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_short stride(long stride);
  public native ShortPointer data(); public native gsl_vector_short data(ShortPointer data);
  public native gsl_block_short block(); public native gsl_vector_short block(gsl_block_short block);
  public native int owner(); public native gsl_vector_short owner(int owner);
}

public static class _gsl_vector_short_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_short_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_short_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_short_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_short_view position(long position) {
        return (_gsl_vector_short_view)super.position(position);
    }

  public native @ByRef gsl_vector_short vector(); public native _gsl_vector_short_view vector(gsl_vector_short vector);
}

public static class _gsl_vector_short_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_short_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_short_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_short_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_short_const_view position(long position) {
        return (_gsl_vector_short_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_short vector(); public native _gsl_vector_short_const_view vector(gsl_vector_short vector);
}


/* Allocation */

public static native gsl_vector_short gsl_vector_short_alloc(@Cast("const size_t") long n);
public static native gsl_vector_short gsl_vector_short_calloc(@Cast("const size_t") long n);

public static native gsl_vector_short gsl_vector_short_alloc_from_block(gsl_block_short b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector_short gsl_vector_short_alloc_from_vector(gsl_vector_short v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_short_free(gsl_vector_short v);

/* Views */

public static native @ByVal _gsl_vector_short_view gsl_vector_short_view_array(ShortPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_short_view gsl_vector_short_view_array(ShortBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_short_view gsl_vector_short_view_array(short[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_short_view gsl_vector_short_view_array_with_stride(ShortPointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_short_view gsl_vector_short_view_array_with_stride(ShortBuffer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_short_view gsl_vector_short_view_array_with_stride(short[] base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_short_const_view gsl_vector_short_const_view_array(@Const ShortPointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_short_const_view gsl_vector_short_const_view_array(@Const ShortBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_short_const_view gsl_vector_short_const_view_array(@Const short[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_short_const_view gsl_vector_short_const_view_array_with_stride(@Const ShortPointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_short_const_view gsl_vector_short_const_view_array_with_stride(@Const ShortBuffer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_short_const_view gsl_vector_short_const_view_array_with_stride(@Const short[] base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_short_view gsl_vector_short_subvector(gsl_vector_short v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_short_view gsl_vector_short_subvector_with_stride(gsl_vector_short v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_short_const_view gsl_vector_short_const_subvector(@Const gsl_vector_short v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_short_const_view gsl_vector_short_const_subvector_with_stride(@Const gsl_vector_short v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_short_set_zero(gsl_vector_short v);
public static native void gsl_vector_short_set_all(gsl_vector_short v, short x);
public static native int gsl_vector_short_set_basis(gsl_vector_short v, @Cast("size_t") long i);

public static native int gsl_vector_short_fread(@Cast("FILE*") Pointer stream, gsl_vector_short v);
public static native int gsl_vector_short_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector_short v);
public static native int gsl_vector_short_fscanf(@Cast("FILE*") Pointer stream, gsl_vector_short v);
public static native int gsl_vector_short_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_short v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_short_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_short v,
                              String format);

public static native int gsl_vector_short_memcpy(gsl_vector_short dest, @Const gsl_vector_short src);

public static native int gsl_vector_short_reverse(gsl_vector_short v);

public static native int gsl_vector_short_swap(gsl_vector_short v, gsl_vector_short w);
public static native int gsl_vector_short_swap_elements(gsl_vector_short v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native short gsl_vector_short_max(@Const gsl_vector_short v);
public static native short gsl_vector_short_min(@Const gsl_vector_short v);
public static native void gsl_vector_short_minmax(@Const gsl_vector_short v, ShortPointer min_out, ShortPointer max_out);
public static native void gsl_vector_short_minmax(@Const gsl_vector_short v, ShortBuffer min_out, ShortBuffer max_out);
public static native void gsl_vector_short_minmax(@Const gsl_vector_short v, short[] min_out, short[] max_out);

public static native @Cast("size_t") long gsl_vector_short_max_index(@Const gsl_vector_short v);
public static native @Cast("size_t") long gsl_vector_short_min_index(@Const gsl_vector_short v);
public static native void gsl_vector_short_minmax_index(@Const gsl_vector_short v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_short_add(gsl_vector_short a, @Const gsl_vector_short b);
public static native int gsl_vector_short_sub(gsl_vector_short a, @Const gsl_vector_short b);
public static native int gsl_vector_short_mul(gsl_vector_short a, @Const gsl_vector_short b);
public static native int gsl_vector_short_div(gsl_vector_short a, @Const gsl_vector_short b);
public static native int gsl_vector_short_scale(gsl_vector_short a, double x);
public static native int gsl_vector_short_add_constant(gsl_vector_short a, double x);

public static native int gsl_vector_short_equal(@Const gsl_vector_short u, 
                            @Const gsl_vector_short v);

public static native int gsl_vector_short_isnull(@Const gsl_vector_short v);
public static native int gsl_vector_short_ispos(@Const gsl_vector_short v);
public static native int gsl_vector_short_isneg(@Const gsl_vector_short v);
public static native int gsl_vector_short_isnonneg(@Const gsl_vector_short v);

/* */ public static native short gsl_vector_short_get(@Const gsl_vector_short v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_short_set(gsl_vector_short v, @Cast("const size_t") long i, short x);
/* */ public static native ShortPointer gsl_vector_short_ptr(gsl_vector_short v, @Cast("const size_t") long i);
/* */ public static native @Const ShortPointer gsl_vector_short_const_ptr(@Const gsl_vector_short v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_SHORT_H__ */




// Parsed from gsl/gsl_vector_uchar.h

/* vector/gsl_vector_uchar.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_UCHAR_H__
// #define __GSL_VECTOR_UCHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_uchar.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_uchar extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_uchar() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_uchar(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_uchar(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_uchar position(long position) {
        return (gsl_vector_uchar)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_uchar size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_uchar stride(long stride);
  public native @Cast("unsigned char*") BytePointer data(); public native gsl_vector_uchar data(BytePointer data);
  public native gsl_block_uchar block(); public native gsl_vector_uchar block(gsl_block_uchar block);
  public native int owner(); public native gsl_vector_uchar owner(int owner);
}

public static class _gsl_vector_uchar_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_uchar_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_uchar_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_uchar_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_uchar_view position(long position) {
        return (_gsl_vector_uchar_view)super.position(position);
    }

  public native @ByRef gsl_vector_uchar vector(); public native _gsl_vector_uchar_view vector(gsl_vector_uchar vector);
}

public static class _gsl_vector_uchar_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_uchar_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_uchar_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_uchar_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_uchar_const_view position(long position) {
        return (_gsl_vector_uchar_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_uchar vector(); public native _gsl_vector_uchar_const_view vector(gsl_vector_uchar vector);
}


/* Allocation */

public static native gsl_vector_uchar gsl_vector_uchar_alloc(@Cast("const size_t") long n);
public static native gsl_vector_uchar gsl_vector_uchar_calloc(@Cast("const size_t") long n);

public static native gsl_vector_uchar gsl_vector_uchar_alloc_from_block(gsl_block_uchar b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector_uchar gsl_vector_uchar_alloc_from_vector(gsl_vector_uchar v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_uchar_free(gsl_vector_uchar v);

/* Views */

public static native @ByVal _gsl_vector_uchar_view gsl_vector_uchar_view_array(@Cast("unsigned char*") BytePointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uchar_view gsl_vector_uchar_view_array(@Cast("unsigned char*") ByteBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uchar_view gsl_vector_uchar_view_array(@Cast("unsigned char*") byte[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uchar_view gsl_vector_uchar_view_array_with_stride(@Cast("unsigned char*") BytePointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uchar_view gsl_vector_uchar_view_array_with_stride(@Cast("unsigned char*") ByteBuffer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uchar_view gsl_vector_uchar_view_array_with_stride(@Cast("unsigned char*") byte[] base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uchar_const_view gsl_vector_uchar_const_view_array(@Cast("const unsigned char*") BytePointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uchar_const_view gsl_vector_uchar_const_view_array(@Cast("const unsigned char*") ByteBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uchar_const_view gsl_vector_uchar_const_view_array(@Cast("const unsigned char*") byte[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uchar_const_view gsl_vector_uchar_const_view_array_with_stride(@Cast("const unsigned char*") BytePointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uchar_const_view gsl_vector_uchar_const_view_array_with_stride(@Cast("const unsigned char*") ByteBuffer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_uchar_const_view gsl_vector_uchar_const_view_array_with_stride(@Cast("const unsigned char*") byte[] base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uchar_view gsl_vector_uchar_subvector(gsl_vector_uchar v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uchar_view gsl_vector_uchar_subvector_with_stride(gsl_vector_uchar v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uchar_const_view gsl_vector_uchar_const_subvector(@Const gsl_vector_uchar v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_uchar_const_view gsl_vector_uchar_const_subvector_with_stride(@Const gsl_vector_uchar v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_uchar_set_zero(gsl_vector_uchar v);
public static native void gsl_vector_uchar_set_all(gsl_vector_uchar v, @Cast("unsigned char") byte x);
public static native int gsl_vector_uchar_set_basis(gsl_vector_uchar v, @Cast("size_t") long i);

public static native int gsl_vector_uchar_fread(@Cast("FILE*") Pointer stream, gsl_vector_uchar v);
public static native int gsl_vector_uchar_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector_uchar v);
public static native int gsl_vector_uchar_fscanf(@Cast("FILE*") Pointer stream, gsl_vector_uchar v);
public static native int gsl_vector_uchar_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_uchar v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_uchar_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_uchar v,
                              String format);

public static native int gsl_vector_uchar_memcpy(gsl_vector_uchar dest, @Const gsl_vector_uchar src);

public static native int gsl_vector_uchar_reverse(gsl_vector_uchar v);

public static native int gsl_vector_uchar_swap(gsl_vector_uchar v, gsl_vector_uchar w);
public static native int gsl_vector_uchar_swap_elements(gsl_vector_uchar v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native @Cast("unsigned char") byte gsl_vector_uchar_max(@Const gsl_vector_uchar v);
public static native @Cast("unsigned char") byte gsl_vector_uchar_min(@Const gsl_vector_uchar v);
public static native void gsl_vector_uchar_minmax(@Const gsl_vector_uchar v, @Cast("unsigned char*") BytePointer min_out, @Cast("unsigned char*") BytePointer max_out);
public static native void gsl_vector_uchar_minmax(@Const gsl_vector_uchar v, @Cast("unsigned char*") ByteBuffer min_out, @Cast("unsigned char*") ByteBuffer max_out);
public static native void gsl_vector_uchar_minmax(@Const gsl_vector_uchar v, @Cast("unsigned char*") byte[] min_out, @Cast("unsigned char*") byte[] max_out);

public static native @Cast("size_t") long gsl_vector_uchar_max_index(@Const gsl_vector_uchar v);
public static native @Cast("size_t") long gsl_vector_uchar_min_index(@Const gsl_vector_uchar v);
public static native void gsl_vector_uchar_minmax_index(@Const gsl_vector_uchar v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_uchar_add(gsl_vector_uchar a, @Const gsl_vector_uchar b);
public static native int gsl_vector_uchar_sub(gsl_vector_uchar a, @Const gsl_vector_uchar b);
public static native int gsl_vector_uchar_mul(gsl_vector_uchar a, @Const gsl_vector_uchar b);
public static native int gsl_vector_uchar_div(gsl_vector_uchar a, @Const gsl_vector_uchar b);
public static native int gsl_vector_uchar_scale(gsl_vector_uchar a, double x);
public static native int gsl_vector_uchar_add_constant(gsl_vector_uchar a, double x);

public static native int gsl_vector_uchar_equal(@Const gsl_vector_uchar u, 
                            @Const gsl_vector_uchar v);

public static native int gsl_vector_uchar_isnull(@Const gsl_vector_uchar v);
public static native int gsl_vector_uchar_ispos(@Const gsl_vector_uchar v);
public static native int gsl_vector_uchar_isneg(@Const gsl_vector_uchar v);
public static native int gsl_vector_uchar_isnonneg(@Const gsl_vector_uchar v);

/* */ public static native @Cast("unsigned char") byte gsl_vector_uchar_get(@Const gsl_vector_uchar v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_uchar_set(gsl_vector_uchar v, @Cast("const size_t") long i, @Cast("unsigned char") byte x);
/* */ public static native @Cast("unsigned char*") BytePointer gsl_vector_uchar_ptr(gsl_vector_uchar v, @Cast("const size_t") long i);
/* */ public static native @Cast("const unsigned char*") BytePointer gsl_vector_uchar_const_ptr(@Const gsl_vector_uchar v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_UCHAR_H__ */




// Parsed from gsl/gsl_vector_char.h

/* vector/gsl_vector_char.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_VECTOR_CHAR_H__
// #define __GSL_VECTOR_CHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_block_char.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_vector_char extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_vector_char() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_vector_char(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_vector_char(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_vector_char position(long position) {
        return (gsl_vector_char)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_vector_char size(long size);
  public native @Cast("size_t") long stride(); public native gsl_vector_char stride(long stride);
  public native @Cast("char*") BytePointer data(); public native gsl_vector_char data(BytePointer data);
  public native gsl_block_char block(); public native gsl_vector_char block(gsl_block_char block);
  public native int owner(); public native gsl_vector_char owner(int owner);
}

public static class _gsl_vector_char_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_char_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_char_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_char_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_char_view position(long position) {
        return (_gsl_vector_char_view)super.position(position);
    }

  public native @ByRef gsl_vector_char vector(); public native _gsl_vector_char_view vector(gsl_vector_char vector);
}

public static class _gsl_vector_char_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_vector_char_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_vector_char_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_vector_char_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_vector_char_const_view position(long position) {
        return (_gsl_vector_char_const_view)super.position(position);
    }

  public native @ByRef gsl_vector_char vector(); public native _gsl_vector_char_const_view vector(gsl_vector_char vector);
}


/* Allocation */

public static native gsl_vector_char gsl_vector_char_alloc(@Cast("const size_t") long n);
public static native gsl_vector_char gsl_vector_char_calloc(@Cast("const size_t") long n);

public static native gsl_vector_char gsl_vector_char_alloc_from_block(gsl_block_char b,
                                                     @Cast("const size_t") long offset, 
                                                     @Cast("const size_t") long n, 
                                                     @Cast("const size_t") long stride);

public static native gsl_vector_char gsl_vector_char_alloc_from_vector(gsl_vector_char v,
                                                      @Cast("const size_t") long offset, 
                                                      @Cast("const size_t") long n, 
                                                      @Cast("const size_t") long stride);

public static native void gsl_vector_char_free(gsl_vector_char v);

/* Views */

public static native @ByVal _gsl_vector_char_view gsl_vector_char_view_array(@Cast("char*") BytePointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_char_view gsl_vector_char_view_array(@Cast("char*") ByteBuffer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_char_view gsl_vector_char_view_array(@Cast("char*") byte[] v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_char_view gsl_vector_char_view_array_with_stride(@Cast("char*") BytePointer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_char_view gsl_vector_char_view_array_with_stride(@Cast("char*") ByteBuffer base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);
public static native @ByVal _gsl_vector_char_view gsl_vector_char_view_array_with_stride(@Cast("char*") byte[] base,
                                         @Cast("size_t") long stride,
                                         @Cast("size_t") long n);

public static native @ByVal _gsl_vector_char_const_view gsl_vector_char_const_view_array(@Cast("const char*") BytePointer v, @Cast("size_t") long n);
public static native @ByVal _gsl_vector_char_const_view gsl_vector_char_const_view_array(String v, @Cast("size_t") long n);

public static native @ByVal _gsl_vector_char_const_view gsl_vector_char_const_view_array_with_stride(@Cast("const char*") BytePointer base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);
public static native @ByVal _gsl_vector_char_const_view gsl_vector_char_const_view_array_with_stride(String base,
                                               @Cast("size_t") long stride,
                                               @Cast("size_t") long n);

public static native @ByVal _gsl_vector_char_view gsl_vector_char_subvector(gsl_vector_char v, 
                            @Cast("size_t") long i, 
                            @Cast("size_t") long n);

public static native @ByVal _gsl_vector_char_view gsl_vector_char_subvector_with_stride(gsl_vector_char v, 
                                        @Cast("size_t") long i,
                                        @Cast("size_t") long stride,
                                        @Cast("size_t") long n);

public static native @ByVal _gsl_vector_char_const_view gsl_vector_char_const_subvector(@Const gsl_vector_char v, 
                                  @Cast("size_t") long i, 
                                  @Cast("size_t") long n);

public static native @ByVal _gsl_vector_char_const_view gsl_vector_char_const_subvector_with_stride(@Const gsl_vector_char v, 
                                              @Cast("size_t") long i, 
                                              @Cast("size_t") long stride,
                                              @Cast("size_t") long n);

/* Operations */

public static native void gsl_vector_char_set_zero(gsl_vector_char v);
public static native void gsl_vector_char_set_all(gsl_vector_char v, @Cast("char") byte x);
public static native int gsl_vector_char_set_basis(gsl_vector_char v, @Cast("size_t") long i);

public static native int gsl_vector_char_fread(@Cast("FILE*") Pointer stream, gsl_vector_char v);
public static native int gsl_vector_char_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_vector_char v);
public static native int gsl_vector_char_fscanf(@Cast("FILE*") Pointer stream, gsl_vector_char v);
public static native int gsl_vector_char_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_char v,
                              @Cast("const char*") BytePointer format);
public static native int gsl_vector_char_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_vector_char v,
                              String format);

public static native int gsl_vector_char_memcpy(gsl_vector_char dest, @Const gsl_vector_char src);

public static native int gsl_vector_char_reverse(gsl_vector_char v);

public static native int gsl_vector_char_swap(gsl_vector_char v, gsl_vector_char w);
public static native int gsl_vector_char_swap_elements(gsl_vector_char v, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native @Cast("char") byte gsl_vector_char_max(@Const gsl_vector_char v);
public static native @Cast("char") byte gsl_vector_char_min(@Const gsl_vector_char v);
public static native void gsl_vector_char_minmax(@Const gsl_vector_char v, @Cast("char*") BytePointer min_out, @Cast("char*") BytePointer max_out);
public static native void gsl_vector_char_minmax(@Const gsl_vector_char v, @Cast("char*") ByteBuffer min_out, @Cast("char*") ByteBuffer max_out);
public static native void gsl_vector_char_minmax(@Const gsl_vector_char v, @Cast("char*") byte[] min_out, @Cast("char*") byte[] max_out);

public static native @Cast("size_t") long gsl_vector_char_max_index(@Const gsl_vector_char v);
public static native @Cast("size_t") long gsl_vector_char_min_index(@Const gsl_vector_char v);
public static native void gsl_vector_char_minmax_index(@Const gsl_vector_char v, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer imax);

public static native int gsl_vector_char_add(gsl_vector_char a, @Const gsl_vector_char b);
public static native int gsl_vector_char_sub(gsl_vector_char a, @Const gsl_vector_char b);
public static native int gsl_vector_char_mul(gsl_vector_char a, @Const gsl_vector_char b);
public static native int gsl_vector_char_div(gsl_vector_char a, @Const gsl_vector_char b);
public static native int gsl_vector_char_scale(gsl_vector_char a, double x);
public static native int gsl_vector_char_add_constant(gsl_vector_char a, double x);

public static native int gsl_vector_char_equal(@Const gsl_vector_char u, 
                            @Const gsl_vector_char v);

public static native int gsl_vector_char_isnull(@Const gsl_vector_char v);
public static native int gsl_vector_char_ispos(@Const gsl_vector_char v);
public static native int gsl_vector_char_isneg(@Const gsl_vector_char v);
public static native int gsl_vector_char_isnonneg(@Const gsl_vector_char v);

/* */ public static native @Cast("char") byte gsl_vector_char_get(@Const gsl_vector_char v, @Cast("const size_t") long i);
/* */ public static native void gsl_vector_char_set(gsl_vector_char v, @Cast("const size_t") long i, @Cast("char") byte x);
/* */ public static native @Cast("char*") BytePointer gsl_vector_char_ptr(gsl_vector_char v, @Cast("const size_t") long i);
/* */ public static native @Cast("const char*") BytePointer gsl_vector_char_const_ptr(@Const gsl_vector_char v, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_VECTOR_CHAR_H__ */




// Parsed from gsl/gsl_matrix.h

// #ifndef __GSL_MATRIX_H__
// #define __GSL_MATRIX_H__

// #include <gsl/gsl_matrix_complex_long_double.h>
// #include <gsl/gsl_matrix_complex_double.h>
// #include <gsl/gsl_matrix_complex_float.h>

// #include <gsl/gsl_matrix_long_double.h>
// #include <gsl/gsl_matrix_double.h>
// #include <gsl/gsl_matrix_float.h>

// #include <gsl/gsl_matrix_ulong.h>
// #include <gsl/gsl_matrix_long.h>

// #include <gsl/gsl_matrix_uint.h>
// #include <gsl/gsl_matrix_int.h>

// #include <gsl/gsl_matrix_ushort.h>
// #include <gsl/gsl_matrix_short.h>

// #include <gsl/gsl_matrix_uchar.h>
// #include <gsl/gsl_matrix_char.h>


// #endif /* __GSL_MATRIX_H__ */


// Parsed from gsl/gsl_matrix_complex_double.h

/* matrix/gsl_matrix_complex_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_COMPLEX_DOUBLE_H__
// #define __GSL_MATRIX_COMPLEX_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_complex_double.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

 public static class gsl_matrix_complex extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_complex() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_complex(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_complex(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_complex position(long position) {
        return (gsl_matrix_complex)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_complex size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_complex size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_complex tda(long tda);
  public native DoublePointer data(); public native gsl_matrix_complex data(DoublePointer data);
  public native gsl_block_complex block(); public native gsl_matrix_complex block(gsl_block_complex block);
  public native int owner(); public native gsl_matrix_complex owner(int owner);
} 

public static class _gsl_matrix_complex_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_complex_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_complex_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_complex_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_complex_view position(long position) {
        return (_gsl_matrix_complex_view)super.position(position);
    }

  public native @ByRef gsl_matrix_complex matrix(); public native _gsl_matrix_complex_view matrix(gsl_matrix_complex matrix);
}

public static class _gsl_matrix_complex_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_complex_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_complex_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_complex_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_complex_const_view position(long position) {
        return (_gsl_matrix_complex_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_complex matrix(); public native _gsl_matrix_complex_const_view matrix(gsl_matrix_complex matrix);
}


/* Allocation */

public static native gsl_matrix_complex gsl_matrix_complex_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_complex gsl_matrix_complex_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_complex gsl_matrix_complex_alloc_from_block(gsl_block_complex b, 
                                           @Cast("const size_t") long offset, 
                                           @Cast("const size_t") long n1, @Cast("const size_t") long n2, @Cast("const size_t") long d2);

public static native gsl_matrix_complex gsl_matrix_complex_alloc_from_matrix(gsl_matrix_complex b,
                                            @Cast("const size_t") long k1, @Cast("const size_t") long k2,
                                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_vector_complex gsl_vector_complex_alloc_row_from_matrix(gsl_matrix_complex m,
                                                @Cast("const size_t") long i);

public static native gsl_vector_complex gsl_vector_complex_alloc_col_from_matrix(gsl_matrix_complex m,
                                                @Cast("const size_t") long j);

public static native void gsl_matrix_complex_free(gsl_matrix_complex m);

/* Views */

public static native @ByVal _gsl_matrix_complex_view gsl_matrix_complex_submatrix(gsl_matrix_complex m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_complex_view gsl_matrix_complex_row(gsl_matrix_complex m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_complex_view gsl_matrix_complex_column(gsl_matrix_complex m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_complex_view gsl_matrix_complex_diagonal(gsl_matrix_complex m);

public static native @ByVal _gsl_vector_complex_view gsl_matrix_complex_subdiagonal(gsl_matrix_complex m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_complex_view gsl_matrix_complex_superdiagonal(gsl_matrix_complex m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_complex_view gsl_matrix_complex_subrow(gsl_matrix_complex m,
                                 @Cast("const size_t") long i, @Cast("const size_t") long offset,
                                 @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_complex_view gsl_matrix_complex_subcolumn(gsl_matrix_complex m,
                                    @Cast("const size_t") long j, @Cast("const size_t") long offset,
                                    @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_complex_view gsl_matrix_complex_view_array(DoublePointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_complex_view gsl_matrix_complex_view_array(DoubleBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_complex_view gsl_matrix_complex_view_array(double[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_complex_view gsl_matrix_complex_view_array_with_tda(DoublePointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_complex_view gsl_matrix_complex_view_array_with_tda(DoubleBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_complex_view gsl_matrix_complex_view_array_with_tda(double[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_complex_view gsl_matrix_complex_view_vector(gsl_vector_complex v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_complex_view gsl_matrix_complex_view_vector_with_tda(gsl_vector_complex v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_complex_const_view gsl_matrix_complex_const_submatrix(@Const gsl_matrix_complex m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_complex_const_view gsl_matrix_complex_const_row(@Const gsl_matrix_complex m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_complex_const_view gsl_matrix_complex_const_column(@Const gsl_matrix_complex m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_complex_const_view gsl_matrix_complex_const_diagonal(@Const gsl_matrix_complex m);

public static native @ByVal _gsl_vector_complex_const_view gsl_matrix_complex_const_subdiagonal(@Const gsl_matrix_complex m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_complex_const_view gsl_matrix_complex_const_superdiagonal(@Const gsl_matrix_complex m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_complex_const_view gsl_matrix_complex_const_subrow(@Const gsl_matrix_complex m,
                                       @Cast("const size_t") long i, @Cast("const size_t") long offset,
                                       @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_complex_const_view gsl_matrix_complex_const_subcolumn(@Const gsl_matrix_complex m,
                                          @Cast("const size_t") long j, @Cast("const size_t") long offset,
                                          @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_complex_const_view gsl_matrix_complex_const_view_array(@Const DoublePointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_complex_const_view gsl_matrix_complex_const_view_array(@Const DoubleBuffer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_complex_const_view gsl_matrix_complex_const_view_array(@Const double[] base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_complex_const_view gsl_matrix_complex_const_view_array_with_tda(@Const DoublePointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_complex_const_view gsl_matrix_complex_const_view_array_with_tda(@Const DoubleBuffer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_complex_const_view gsl_matrix_complex_const_view_array_with_tda(@Const double[] base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_complex_const_view gsl_matrix_complex_const_view_vector(@Const gsl_vector_complex v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_complex_const_view gsl_matrix_complex_const_view_vector_with_tda(@Const gsl_vector_complex v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_complex_set_zero(gsl_matrix_complex m);
public static native void gsl_matrix_complex_set_identity(gsl_matrix_complex m);
public static native void gsl_matrix_complex_set_all(gsl_matrix_complex m, @ByVal gsl_complex x);

public static native int gsl_matrix_complex_fread(@Cast("FILE*") Pointer stream, gsl_matrix_complex m);
public static native int gsl_matrix_complex_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_complex m);
public static native int gsl_matrix_complex_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_complex m);
public static native int gsl_matrix_complex_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_complex m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_complex_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_complex m, String format);

public static native int gsl_matrix_complex_memcpy(gsl_matrix_complex dest, @Const gsl_matrix_complex src);
public static native int gsl_matrix_complex_swap(gsl_matrix_complex m1, gsl_matrix_complex m2);
public static native int gsl_matrix_complex_tricpy(byte uplo_src, int copy_diag, gsl_matrix_complex dest, @Const gsl_matrix_complex src);

public static native int gsl_matrix_complex_swap_rows(gsl_matrix_complex m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_complex_swap_columns(gsl_matrix_complex m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_complex_swap_rowcol(gsl_matrix_complex m, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native int gsl_matrix_complex_transpose(gsl_matrix_complex m);
public static native int gsl_matrix_complex_transpose_memcpy(gsl_matrix_complex dest, @Const gsl_matrix_complex src);
public static native int gsl_matrix_complex_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_complex dest, @Const gsl_matrix_complex src);

public static native int gsl_matrix_complex_equal(@Const gsl_matrix_complex a, @Const gsl_matrix_complex b);

public static native int gsl_matrix_complex_isnull(@Const gsl_matrix_complex m);
public static native int gsl_matrix_complex_ispos(@Const gsl_matrix_complex m);
public static native int gsl_matrix_complex_isneg(@Const gsl_matrix_complex m);
public static native int gsl_matrix_complex_isnonneg(@Const gsl_matrix_complex m);

public static native int gsl_matrix_complex_add(gsl_matrix_complex a, @Const gsl_matrix_complex b);
public static native int gsl_matrix_complex_sub(gsl_matrix_complex a, @Const gsl_matrix_complex b);
public static native int gsl_matrix_complex_mul_elements(gsl_matrix_complex a, @Const gsl_matrix_complex b);
public static native int gsl_matrix_complex_div_elements(gsl_matrix_complex a, @Const gsl_matrix_complex b);
public static native int gsl_matrix_complex_scale(gsl_matrix_complex a, @Const @ByVal gsl_complex x);
public static native int gsl_matrix_complex_add_constant(gsl_matrix_complex a, @Const @ByVal gsl_complex x);
public static native int gsl_matrix_complex_add_diagonal(gsl_matrix_complex a, @Const @ByVal gsl_complex x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_complex_get_row(gsl_vector_complex v, @Const gsl_matrix_complex m, @Cast("const size_t") long i);
public static native int gsl_matrix_complex_get_col(gsl_vector_complex v, @Const gsl_matrix_complex m, @Cast("const size_t") long j);
public static native int gsl_matrix_complex_set_row(gsl_matrix_complex m, @Cast("const size_t") long i, @Const gsl_vector_complex v);
public static native int gsl_matrix_complex_set_col(gsl_matrix_complex m, @Cast("const size_t") long j, @Const gsl_vector_complex v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native @ByVal gsl_complex gsl_matrix_complex_get(@Const gsl_matrix_complex m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_complex_set(gsl_matrix_complex m, @Cast("const size_t") long i, @Cast("const size_t") long j, @Const @ByVal gsl_complex x);

/* */ public static native gsl_complex gsl_matrix_complex_ptr(gsl_matrix_complex m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Const gsl_complex gsl_matrix_complex_const_ptr(@Const gsl_matrix_complex m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif /* HAVE_INLINE */

// #endif /* __GSL_MATRIX_COMPLEX_DOUBLE_H__ */


// Parsed from gsl/gsl_matrix_complex_float.h

/* matrix/gsl_matrix_complex_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_COMPLEX_FLOAT_H__
// #define __GSL_MATRIX_COMPLEX_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_complex_float.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

 public static class gsl_matrix_complex_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_complex_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_complex_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_complex_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_complex_float position(long position) {
        return (gsl_matrix_complex_float)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_complex_float size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_complex_float size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_complex_float tda(long tda);
  public native FloatPointer data(); public native gsl_matrix_complex_float data(FloatPointer data);
  public native gsl_block_complex_float block(); public native gsl_matrix_complex_float block(gsl_block_complex_float block);
  public native int owner(); public native gsl_matrix_complex_float owner(int owner);
} 

public static class _gsl_matrix_complex_float_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_complex_float_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_complex_float_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_complex_float_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_complex_float_view position(long position) {
        return (_gsl_matrix_complex_float_view)super.position(position);
    }

  public native @ByRef gsl_matrix_complex_float matrix(); public native _gsl_matrix_complex_float_view matrix(gsl_matrix_complex_float matrix);
}

public static class _gsl_matrix_complex_float_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_complex_float_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_complex_float_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_complex_float_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_complex_float_const_view position(long position) {
        return (_gsl_matrix_complex_float_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_complex_float matrix(); public native _gsl_matrix_complex_float_const_view matrix(gsl_matrix_complex_float matrix);
}


/* Allocation */

public static native gsl_matrix_complex_float gsl_matrix_complex_float_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_complex_float gsl_matrix_complex_float_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_complex_float gsl_matrix_complex_float_alloc_from_block(gsl_block_complex_float b, 
                                           @Cast("const size_t") long offset, 
                                           @Cast("const size_t") long n1, @Cast("const size_t") long n2, @Cast("const size_t") long d2);

public static native gsl_matrix_complex_float gsl_matrix_complex_float_alloc_from_matrix(gsl_matrix_complex_float b,
                                            @Cast("const size_t") long k1, @Cast("const size_t") long k2,
                                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_vector_complex_float gsl_vector_complex_float_alloc_row_from_matrix(gsl_matrix_complex_float m,
                                                @Cast("const size_t") long i);

public static native gsl_vector_complex_float gsl_vector_complex_float_alloc_col_from_matrix(gsl_matrix_complex_float m,
                                                @Cast("const size_t") long j);

public static native void gsl_matrix_complex_float_free(gsl_matrix_complex_float m);

/* Views */

public static native @ByVal _gsl_matrix_complex_float_view gsl_matrix_complex_float_submatrix(gsl_matrix_complex_float m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_complex_float_view gsl_matrix_complex_float_row(gsl_matrix_complex_float m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_complex_float_view gsl_matrix_complex_float_column(gsl_matrix_complex_float m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_complex_float_view gsl_matrix_complex_float_diagonal(gsl_matrix_complex_float m);

public static native @ByVal _gsl_vector_complex_float_view gsl_matrix_complex_float_subdiagonal(gsl_matrix_complex_float m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_complex_float_view gsl_matrix_complex_float_superdiagonal(gsl_matrix_complex_float m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_complex_float_view gsl_matrix_complex_float_subrow(gsl_matrix_complex_float m,
                                 @Cast("const size_t") long i, @Cast("const size_t") long offset,
                                 @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_complex_float_view gsl_matrix_complex_float_subcolumn(gsl_matrix_complex_float m,
                                    @Cast("const size_t") long j, @Cast("const size_t") long offset,
                                    @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_complex_float_view gsl_matrix_complex_float_view_array(FloatPointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_complex_float_view gsl_matrix_complex_float_view_array(FloatBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_complex_float_view gsl_matrix_complex_float_view_array(float[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_complex_float_view gsl_matrix_complex_float_view_array_with_tda(FloatPointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_complex_float_view gsl_matrix_complex_float_view_array_with_tda(FloatBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_complex_float_view gsl_matrix_complex_float_view_array_with_tda(float[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_complex_float_view gsl_matrix_complex_float_view_vector(gsl_vector_complex_float v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_complex_float_view gsl_matrix_complex_float_view_vector_with_tda(gsl_vector_complex_float v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_submatrix(@Const gsl_matrix_complex_float m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_matrix_complex_float_const_row(@Const gsl_matrix_complex_float m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_matrix_complex_float_const_column(@Const gsl_matrix_complex_float m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_matrix_complex_float_const_diagonal(@Const gsl_matrix_complex_float m);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_matrix_complex_float_const_subdiagonal(@Const gsl_matrix_complex_float m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_matrix_complex_float_const_superdiagonal(@Const gsl_matrix_complex_float m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_matrix_complex_float_const_subrow(@Const gsl_matrix_complex_float m,
                                       @Cast("const size_t") long i, @Cast("const size_t") long offset,
                                       @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_complex_float_const_view gsl_matrix_complex_float_const_subcolumn(@Const gsl_matrix_complex_float m,
                                          @Cast("const size_t") long j, @Cast("const size_t") long offset,
                                          @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_view_array(@Const FloatPointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_view_array(@Const FloatBuffer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_view_array(@Const float[] base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_view_array_with_tda(@Const FloatPointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_view_array_with_tda(@Const FloatBuffer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_view_array_with_tda(@Const float[] base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_view_vector(@Const gsl_vector_complex_float v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_view_vector_with_tda(@Const gsl_vector_complex_float v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_complex_float_set_zero(gsl_matrix_complex_float m);
public static native void gsl_matrix_complex_float_set_identity(gsl_matrix_complex_float m);
public static native void gsl_matrix_complex_float_set_all(gsl_matrix_complex_float m, @ByVal gsl_complex_float x);

public static native int gsl_matrix_complex_float_fread(@Cast("FILE*") Pointer stream, gsl_matrix_complex_float m);
public static native int gsl_matrix_complex_float_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_complex_float m);
public static native int gsl_matrix_complex_float_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_complex_float m);
public static native int gsl_matrix_complex_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_complex_float m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_complex_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_complex_float m, String format);

public static native int gsl_matrix_complex_float_memcpy(gsl_matrix_complex_float dest, @Const gsl_matrix_complex_float src);
public static native int gsl_matrix_complex_float_swap(gsl_matrix_complex_float m1, gsl_matrix_complex_float m2);
public static native int gsl_matrix_complex_float_tricpy(byte uplo_src, int copy_diag, gsl_matrix_complex_float dest, @Const gsl_matrix_complex_float src);

public static native int gsl_matrix_complex_float_swap_rows(gsl_matrix_complex_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_complex_float_swap_columns(gsl_matrix_complex_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_complex_float_swap_rowcol(gsl_matrix_complex_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native int gsl_matrix_complex_float_transpose(gsl_matrix_complex_float m);
public static native int gsl_matrix_complex_float_transpose_memcpy(gsl_matrix_complex_float dest, @Const gsl_matrix_complex_float src);
public static native int gsl_matrix_complex_float_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_complex_float dest, @Const gsl_matrix_complex_float src);

public static native int gsl_matrix_complex_float_equal(@Const gsl_matrix_complex_float a, @Const gsl_matrix_complex_float b);

public static native int gsl_matrix_complex_float_isnull(@Const gsl_matrix_complex_float m);
public static native int gsl_matrix_complex_float_ispos(@Const gsl_matrix_complex_float m);
public static native int gsl_matrix_complex_float_isneg(@Const gsl_matrix_complex_float m);
public static native int gsl_matrix_complex_float_isnonneg(@Const gsl_matrix_complex_float m);

public static native int gsl_matrix_complex_float_add(gsl_matrix_complex_float a, @Const gsl_matrix_complex_float b);
public static native int gsl_matrix_complex_float_sub(gsl_matrix_complex_float a, @Const gsl_matrix_complex_float b);
public static native int gsl_matrix_complex_float_mul_elements(gsl_matrix_complex_float a, @Const gsl_matrix_complex_float b);
public static native int gsl_matrix_complex_float_div_elements(gsl_matrix_complex_float a, @Const gsl_matrix_complex_float b);
public static native int gsl_matrix_complex_float_scale(gsl_matrix_complex_float a, @Const @ByVal gsl_complex_float x);
public static native int gsl_matrix_complex_float_add_constant(gsl_matrix_complex_float a, @Const @ByVal gsl_complex_float x);
public static native int gsl_matrix_complex_float_add_diagonal(gsl_matrix_complex_float a, @Const @ByVal gsl_complex_float x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_complex_float_get_row(gsl_vector_complex_float v, @Const gsl_matrix_complex_float m, @Cast("const size_t") long i);
public static native int gsl_matrix_complex_float_get_col(gsl_vector_complex_float v, @Const gsl_matrix_complex_float m, @Cast("const size_t") long j);
public static native int gsl_matrix_complex_float_set_row(gsl_matrix_complex_float m, @Cast("const size_t") long i, @Const gsl_vector_complex_float v);
public static native int gsl_matrix_complex_float_set_col(gsl_matrix_complex_float m, @Cast("const size_t") long j, @Const gsl_vector_complex_float v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native @ByVal gsl_complex_float gsl_matrix_complex_float_get(@Const gsl_matrix_complex_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_complex_float_set(gsl_matrix_complex_float m, @Cast("const size_t") long i, @Cast("const size_t") long j, @Const @ByVal gsl_complex_float x);

/* */ public static native gsl_complex_float gsl_matrix_complex_float_ptr(gsl_matrix_complex_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Const gsl_complex_float gsl_matrix_complex_float_const_ptr(@Const gsl_matrix_complex_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif /* HAVE_INLINE */

// #endif /* __GSL_MATRIX_COMPLEX_FLOAT_H__ */


// Parsed from gsl/gsl_matrix_double.h

/* matrix/gsl_matrix_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_DOUBLE_H__
// #define __GSL_MATRIX_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_double.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix position(long position) {
        return (gsl_matrix)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix tda(long tda);
  public native DoublePointer data(); public native gsl_matrix data(DoublePointer data);
  public native gsl_block block(); public native gsl_matrix block(gsl_block block);
  public native int owner(); public native gsl_matrix owner(int owner);
}

public static class _gsl_matrix_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_view position(long position) {
        return (_gsl_matrix_view)super.position(position);
    }

  public native @ByRef gsl_matrix matrix(); public native _gsl_matrix_view matrix(gsl_matrix matrix);
}

public static class _gsl_matrix_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_const_view position(long position) {
        return (_gsl_matrix_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix matrix(); public native _gsl_matrix_const_view matrix(gsl_matrix matrix);
}

/* Allocation */

public static native gsl_matrix gsl_matrix_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix gsl_matrix_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix gsl_matrix_alloc_from_block(gsl_block b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix gsl_matrix_alloc_from_matrix(gsl_matrix m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector gsl_vector_alloc_row_from_matrix(gsl_matrix m,
                                        @Cast("const size_t") long i);

public static native gsl_vector gsl_vector_alloc_col_from_matrix(gsl_matrix m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_free(gsl_matrix m);

/* Views */

public static native @ByVal _gsl_matrix_view gsl_matrix_submatrix(gsl_matrix m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_view gsl_matrix_row(gsl_matrix m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_view gsl_matrix_column(gsl_matrix m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_view gsl_matrix_diagonal(gsl_matrix m);

public static native @ByVal _gsl_vector_view gsl_matrix_subdiagonal(gsl_matrix m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_view gsl_matrix_superdiagonal(gsl_matrix m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_view gsl_matrix_subrow(gsl_matrix m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_view gsl_matrix_subcolumn(gsl_matrix m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_view gsl_matrix_view_array(DoublePointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_view gsl_matrix_view_array(DoubleBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_view gsl_matrix_view_array(double[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_view gsl_matrix_view_array_with_tda(DoublePointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_view gsl_matrix_view_array_with_tda(DoubleBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_view gsl_matrix_view_array_with_tda(double[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_view gsl_matrix_view_vector(gsl_vector v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_view gsl_matrix_view_vector_with_tda(gsl_vector v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_const_view gsl_matrix_const_submatrix(@Const gsl_matrix m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_const_view gsl_matrix_const_row(@Const gsl_matrix m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_const_view gsl_matrix_const_column(@Const gsl_matrix m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_const_view gsl_matrix_const_diagonal(@Const gsl_matrix m);

public static native @ByVal _gsl_vector_const_view gsl_matrix_const_subdiagonal(@Const gsl_matrix m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_const_view gsl_matrix_const_superdiagonal(@Const gsl_matrix m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_const_view gsl_matrix_const_subrow(@Const gsl_matrix m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_const_view gsl_matrix_const_subcolumn(@Const gsl_matrix m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_const_view gsl_matrix_const_view_array(@Const DoublePointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_const_view gsl_matrix_const_view_array(@Const DoubleBuffer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_const_view gsl_matrix_const_view_array(@Const double[] base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_const_view gsl_matrix_const_view_array_with_tda(@Const DoublePointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_const_view gsl_matrix_const_view_array_with_tda(@Const DoubleBuffer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_const_view gsl_matrix_const_view_array_with_tda(@Const double[] base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_const_view gsl_matrix_const_view_vector(@Const gsl_vector v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_const_view gsl_matrix_const_view_vector_with_tda(@Const gsl_vector v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_set_zero(gsl_matrix m);
public static native void gsl_matrix_set_identity(gsl_matrix m);
public static native void gsl_matrix_set_all(gsl_matrix m, double x);

public static native int gsl_matrix_fread(@Cast("FILE*") Pointer stream, gsl_matrix m);
public static native int gsl_matrix_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix m);
public static native int gsl_matrix_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix m);
public static native int gsl_matrix_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix m, String format);
 
public static native int gsl_matrix_memcpy(gsl_matrix dest, @Const gsl_matrix src);
public static native int gsl_matrix_swap(gsl_matrix m1, gsl_matrix m2);
public static native int gsl_matrix_tricpy(byte uplo_src, int copy_diag, gsl_matrix dest, @Const gsl_matrix src);

public static native int gsl_matrix_swap_rows(gsl_matrix m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_swap_columns(gsl_matrix m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_swap_rowcol(gsl_matrix m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_transpose(gsl_matrix m);
public static native int gsl_matrix_transpose_memcpy(gsl_matrix dest, @Const gsl_matrix src);
public static native int gsl_matrix_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix dest, @Const gsl_matrix src);

public static native double gsl_matrix_max(@Const gsl_matrix m);
public static native double gsl_matrix_min(@Const gsl_matrix m);
public static native void gsl_matrix_minmax(@Const gsl_matrix m, DoublePointer min_out, DoublePointer max_out);
public static native void gsl_matrix_minmax(@Const gsl_matrix m, DoubleBuffer min_out, DoubleBuffer max_out);
public static native void gsl_matrix_minmax(@Const gsl_matrix m, double[] min_out, double[] max_out);

public static native void gsl_matrix_max_index(@Const gsl_matrix m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_min_index(@Const gsl_matrix m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_minmax_index(@Const gsl_matrix m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_equal(@Const gsl_matrix a, @Const gsl_matrix b);

public static native int gsl_matrix_isnull(@Const gsl_matrix m);
public static native int gsl_matrix_ispos(@Const gsl_matrix m);
public static native int gsl_matrix_isneg(@Const gsl_matrix m);
public static native int gsl_matrix_isnonneg(@Const gsl_matrix m);

public static native int gsl_matrix_add(gsl_matrix a, @Const gsl_matrix b);
public static native int gsl_matrix_sub(gsl_matrix a, @Const gsl_matrix b);
public static native int gsl_matrix_mul_elements(gsl_matrix a, @Const gsl_matrix b);
public static native int gsl_matrix_div_elements(gsl_matrix a, @Const gsl_matrix b);
public static native int gsl_matrix_scale(gsl_matrix a, double x);
public static native int gsl_matrix_add_constant(gsl_matrix a, double x);
public static native int gsl_matrix_add_diagonal(gsl_matrix a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_get_row(gsl_vector v, @Const gsl_matrix m, @Cast("const size_t") long i);
public static native int gsl_matrix_get_col(gsl_vector v, @Const gsl_matrix m, @Cast("const size_t") long j);
public static native int gsl_matrix_set_row(gsl_matrix m, @Cast("const size_t") long i, @Const gsl_vector v);
public static native int gsl_matrix_set_col(gsl_matrix m, @Cast("const size_t") long j, @Const gsl_vector v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native double gsl_matrix_get(@Const gsl_matrix m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_set(gsl_matrix m, @Cast("const size_t") long i, @Cast("const size_t") long j, double x);
/* */ public static native DoublePointer gsl_matrix_ptr(gsl_matrix m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Const DoublePointer gsl_matrix_const_ptr(@Const gsl_matrix m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_DOUBLE_H__ */


// Parsed from gsl/gsl_matrix_float.h

/* matrix/gsl_matrix_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_FLOAT_H__
// #define __GSL_MATRIX_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_float.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_float position(long position) {
        return (gsl_matrix_float)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_float size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_float size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_float tda(long tda);
  public native FloatPointer data(); public native gsl_matrix_float data(FloatPointer data);
  public native gsl_block_float block(); public native gsl_matrix_float block(gsl_block_float block);
  public native int owner(); public native gsl_matrix_float owner(int owner);
}

public static class _gsl_matrix_float_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_float_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_float_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_float_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_float_view position(long position) {
        return (_gsl_matrix_float_view)super.position(position);
    }

  public native @ByRef gsl_matrix_float matrix(); public native _gsl_matrix_float_view matrix(gsl_matrix_float matrix);
}

public static class _gsl_matrix_float_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_float_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_float_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_float_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_float_const_view position(long position) {
        return (_gsl_matrix_float_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_float matrix(); public native _gsl_matrix_float_const_view matrix(gsl_matrix_float matrix);
}

/* Allocation */

public static native gsl_matrix_float gsl_matrix_float_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_float gsl_matrix_float_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_float gsl_matrix_float_alloc_from_block(gsl_block_float b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix_float gsl_matrix_float_alloc_from_matrix(gsl_matrix_float m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector_float gsl_vector_float_alloc_row_from_matrix(gsl_matrix_float m,
                                        @Cast("const size_t") long i);

public static native gsl_vector_float gsl_vector_float_alloc_col_from_matrix(gsl_matrix_float m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_float_free(gsl_matrix_float m);

/* Views */

public static native @ByVal _gsl_matrix_float_view gsl_matrix_float_submatrix(gsl_matrix_float m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_float_view gsl_matrix_float_row(gsl_matrix_float m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_float_view gsl_matrix_float_column(gsl_matrix_float m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_float_view gsl_matrix_float_diagonal(gsl_matrix_float m);

public static native @ByVal _gsl_vector_float_view gsl_matrix_float_subdiagonal(gsl_matrix_float m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_float_view gsl_matrix_float_superdiagonal(gsl_matrix_float m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_float_view gsl_matrix_float_subrow(gsl_matrix_float m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_float_view gsl_matrix_float_subcolumn(gsl_matrix_float m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_float_view gsl_matrix_float_view_array(FloatPointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_float_view gsl_matrix_float_view_array(FloatBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_float_view gsl_matrix_float_view_array(float[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_float_view gsl_matrix_float_view_array_with_tda(FloatPointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_float_view gsl_matrix_float_view_array_with_tda(FloatBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_float_view gsl_matrix_float_view_array_with_tda(float[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_float_view gsl_matrix_float_view_vector(gsl_vector_float v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_float_view gsl_matrix_float_view_vector_with_tda(gsl_vector_float v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_float_const_view gsl_matrix_float_const_submatrix(@Const gsl_matrix_float m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_float_const_view gsl_matrix_float_const_row(@Const gsl_matrix_float m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_float_const_view gsl_matrix_float_const_column(@Const gsl_matrix_float m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_float_const_view gsl_matrix_float_const_diagonal(@Const gsl_matrix_float m);

public static native @ByVal _gsl_vector_float_const_view gsl_matrix_float_const_subdiagonal(@Const gsl_matrix_float m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_float_const_view gsl_matrix_float_const_superdiagonal(@Const gsl_matrix_float m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_float_const_view gsl_matrix_float_const_subrow(@Const gsl_matrix_float m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_float_const_view gsl_matrix_float_const_subcolumn(@Const gsl_matrix_float m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_float_const_view gsl_matrix_float_const_view_array(@Const FloatPointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_float_const_view gsl_matrix_float_const_view_array(@Const FloatBuffer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_float_const_view gsl_matrix_float_const_view_array(@Const float[] base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_float_const_view gsl_matrix_float_const_view_array_with_tda(@Const FloatPointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_float_const_view gsl_matrix_float_const_view_array_with_tda(@Const FloatBuffer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_float_const_view gsl_matrix_float_const_view_array_with_tda(@Const float[] base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_float_const_view gsl_matrix_float_const_view_vector(@Const gsl_vector_float v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_float_const_view gsl_matrix_float_const_view_vector_with_tda(@Const gsl_vector_float v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_float_set_zero(gsl_matrix_float m);
public static native void gsl_matrix_float_set_identity(gsl_matrix_float m);
public static native void gsl_matrix_float_set_all(gsl_matrix_float m, float x);

public static native int gsl_matrix_float_fread(@Cast("FILE*") Pointer stream, gsl_matrix_float m);
public static native int gsl_matrix_float_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_float m);
public static native int gsl_matrix_float_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_float m);
public static native int gsl_matrix_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_float m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_float_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_float m, String format);
 
public static native int gsl_matrix_float_memcpy(gsl_matrix_float dest, @Const gsl_matrix_float src);
public static native int gsl_matrix_float_swap(gsl_matrix_float m1, gsl_matrix_float m2);
public static native int gsl_matrix_float_tricpy(byte uplo_src, int copy_diag, gsl_matrix_float dest, @Const gsl_matrix_float src);

public static native int gsl_matrix_float_swap_rows(gsl_matrix_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_float_swap_columns(gsl_matrix_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_float_swap_rowcol(gsl_matrix_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_float_transpose(gsl_matrix_float m);
public static native int gsl_matrix_float_transpose_memcpy(gsl_matrix_float dest, @Const gsl_matrix_float src);
public static native int gsl_matrix_float_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_float dest, @Const gsl_matrix_float src);

public static native float gsl_matrix_float_max(@Const gsl_matrix_float m);
public static native float gsl_matrix_float_min(@Const gsl_matrix_float m);
public static native void gsl_matrix_float_minmax(@Const gsl_matrix_float m, FloatPointer min_out, FloatPointer max_out);
public static native void gsl_matrix_float_minmax(@Const gsl_matrix_float m, FloatBuffer min_out, FloatBuffer max_out);
public static native void gsl_matrix_float_minmax(@Const gsl_matrix_float m, float[] min_out, float[] max_out);

public static native void gsl_matrix_float_max_index(@Const gsl_matrix_float m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_float_min_index(@Const gsl_matrix_float m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_float_minmax_index(@Const gsl_matrix_float m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_float_equal(@Const gsl_matrix_float a, @Const gsl_matrix_float b);

public static native int gsl_matrix_float_isnull(@Const gsl_matrix_float m);
public static native int gsl_matrix_float_ispos(@Const gsl_matrix_float m);
public static native int gsl_matrix_float_isneg(@Const gsl_matrix_float m);
public static native int gsl_matrix_float_isnonneg(@Const gsl_matrix_float m);

public static native int gsl_matrix_float_add(gsl_matrix_float a, @Const gsl_matrix_float b);
public static native int gsl_matrix_float_sub(gsl_matrix_float a, @Const gsl_matrix_float b);
public static native int gsl_matrix_float_mul_elements(gsl_matrix_float a, @Const gsl_matrix_float b);
public static native int gsl_matrix_float_div_elements(gsl_matrix_float a, @Const gsl_matrix_float b);
public static native int gsl_matrix_float_scale(gsl_matrix_float a, double x);
public static native int gsl_matrix_float_add_constant(gsl_matrix_float a, double x);
public static native int gsl_matrix_float_add_diagonal(gsl_matrix_float a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_float_get_row(gsl_vector_float v, @Const gsl_matrix_float m, @Cast("const size_t") long i);
public static native int gsl_matrix_float_get_col(gsl_vector_float v, @Const gsl_matrix_float m, @Cast("const size_t") long j);
public static native int gsl_matrix_float_set_row(gsl_matrix_float m, @Cast("const size_t") long i, @Const gsl_vector_float v);
public static native int gsl_matrix_float_set_col(gsl_matrix_float m, @Cast("const size_t") long j, @Const gsl_vector_float v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native float gsl_matrix_float_get(@Const gsl_matrix_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_float_set(gsl_matrix_float m, @Cast("const size_t") long i, @Cast("const size_t") long j, float x);
/* */ public static native FloatPointer gsl_matrix_float_ptr(gsl_matrix_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Const FloatPointer gsl_matrix_float_const_ptr(@Const gsl_matrix_float m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_FLOAT_H__ */


// Parsed from gsl/gsl_matrix_ulong.h

/* matrix/gsl_matrix_ulong.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_ULONG_H__
// #define __GSL_MATRIX_ULONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_ulong.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix_ulong extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_ulong() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_ulong(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_ulong(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_ulong position(long position) {
        return (gsl_matrix_ulong)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_ulong size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_ulong size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_ulong tda(long tda);
  public native @Cast("unsigned long*") CLongPointer data(); public native gsl_matrix_ulong data(CLongPointer data);
  public native gsl_block_ulong block(); public native gsl_matrix_ulong block(gsl_block_ulong block);
  public native int owner(); public native gsl_matrix_ulong owner(int owner);
}

public static class _gsl_matrix_ulong_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_ulong_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_ulong_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_ulong_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_ulong_view position(long position) {
        return (_gsl_matrix_ulong_view)super.position(position);
    }

  public native @ByRef gsl_matrix_ulong matrix(); public native _gsl_matrix_ulong_view matrix(gsl_matrix_ulong matrix);
}

public static class _gsl_matrix_ulong_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_ulong_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_ulong_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_ulong_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_ulong_const_view position(long position) {
        return (_gsl_matrix_ulong_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_ulong matrix(); public native _gsl_matrix_ulong_const_view matrix(gsl_matrix_ulong matrix);
}

/* Allocation */

public static native gsl_matrix_ulong gsl_matrix_ulong_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_ulong gsl_matrix_ulong_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_ulong gsl_matrix_ulong_alloc_from_block(gsl_block_ulong b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix_ulong gsl_matrix_ulong_alloc_from_matrix(gsl_matrix_ulong m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector_ulong gsl_vector_ulong_alloc_row_from_matrix(gsl_matrix_ulong m,
                                        @Cast("const size_t") long i);

public static native gsl_vector_ulong gsl_vector_ulong_alloc_col_from_matrix(gsl_matrix_ulong m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_ulong_free(gsl_matrix_ulong m);

/* Views */

public static native @ByVal _gsl_matrix_ulong_view gsl_matrix_ulong_submatrix(gsl_matrix_ulong m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_ulong_view gsl_matrix_ulong_row(gsl_matrix_ulong m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_ulong_view gsl_matrix_ulong_column(gsl_matrix_ulong m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_ulong_view gsl_matrix_ulong_diagonal(gsl_matrix_ulong m);

public static native @ByVal _gsl_vector_ulong_view gsl_matrix_ulong_subdiagonal(gsl_matrix_ulong m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_ulong_view gsl_matrix_ulong_superdiagonal(gsl_matrix_ulong m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_ulong_view gsl_matrix_ulong_subrow(gsl_matrix_ulong m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_ulong_view gsl_matrix_ulong_subcolumn(gsl_matrix_ulong m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_ulong_view gsl_matrix_ulong_view_array(@Cast("unsigned long*") CLongPointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_ulong_view gsl_matrix_ulong_view_array_with_tda(@Cast("unsigned long*") CLongPointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_ulong_view gsl_matrix_ulong_view_vector(gsl_vector_ulong v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_ulong_view gsl_matrix_ulong_view_vector_with_tda(gsl_vector_ulong v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_ulong_const_view gsl_matrix_ulong_const_submatrix(@Const gsl_matrix_ulong m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_ulong_const_view gsl_matrix_ulong_const_row(@Const gsl_matrix_ulong m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_ulong_const_view gsl_matrix_ulong_const_column(@Const gsl_matrix_ulong m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_ulong_const_view gsl_matrix_ulong_const_diagonal(@Const gsl_matrix_ulong m);

public static native @ByVal _gsl_vector_ulong_const_view gsl_matrix_ulong_const_subdiagonal(@Const gsl_matrix_ulong m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_ulong_const_view gsl_matrix_ulong_const_superdiagonal(@Const gsl_matrix_ulong m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_ulong_const_view gsl_matrix_ulong_const_subrow(@Const gsl_matrix_ulong m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_ulong_const_view gsl_matrix_ulong_const_subcolumn(@Const gsl_matrix_ulong m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_ulong_const_view gsl_matrix_ulong_const_view_array(@Cast("const unsigned long*") CLongPointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_ulong_const_view gsl_matrix_ulong_const_view_array_with_tda(@Cast("const unsigned long*") CLongPointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_ulong_const_view gsl_matrix_ulong_const_view_vector(@Const gsl_vector_ulong v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_ulong_const_view gsl_matrix_ulong_const_view_vector_with_tda(@Const gsl_vector_ulong v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_ulong_set_zero(gsl_matrix_ulong m);
public static native void gsl_matrix_ulong_set_identity(gsl_matrix_ulong m);
public static native void gsl_matrix_ulong_set_all(gsl_matrix_ulong m, @Cast("unsigned long") long x);

public static native int gsl_matrix_ulong_fread(@Cast("FILE*") Pointer stream, gsl_matrix_ulong m);
public static native int gsl_matrix_ulong_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_ulong m);
public static native int gsl_matrix_ulong_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_ulong m);
public static native int gsl_matrix_ulong_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_ulong m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_ulong_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_ulong m, String format);
 
public static native int gsl_matrix_ulong_memcpy(gsl_matrix_ulong dest, @Const gsl_matrix_ulong src);
public static native int gsl_matrix_ulong_swap(gsl_matrix_ulong m1, gsl_matrix_ulong m2);
public static native int gsl_matrix_ulong_tricpy(byte uplo_src, int copy_diag, gsl_matrix_ulong dest, @Const gsl_matrix_ulong src);

public static native int gsl_matrix_ulong_swap_rows(gsl_matrix_ulong m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_ulong_swap_columns(gsl_matrix_ulong m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_ulong_swap_rowcol(gsl_matrix_ulong m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_ulong_transpose(gsl_matrix_ulong m);
public static native int gsl_matrix_ulong_transpose_memcpy(gsl_matrix_ulong dest, @Const gsl_matrix_ulong src);
public static native int gsl_matrix_ulong_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_ulong dest, @Const gsl_matrix_ulong src);

public static native @Cast("unsigned long") long gsl_matrix_ulong_max(@Const gsl_matrix_ulong m);
public static native @Cast("unsigned long") long gsl_matrix_ulong_min(@Const gsl_matrix_ulong m);
public static native void gsl_matrix_ulong_minmax(@Const gsl_matrix_ulong m, @Cast("unsigned long*") CLongPointer min_out, @Cast("unsigned long*") CLongPointer max_out);

public static native void gsl_matrix_ulong_max_index(@Const gsl_matrix_ulong m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_ulong_min_index(@Const gsl_matrix_ulong m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_ulong_minmax_index(@Const gsl_matrix_ulong m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_ulong_equal(@Const gsl_matrix_ulong a, @Const gsl_matrix_ulong b);

public static native int gsl_matrix_ulong_isnull(@Const gsl_matrix_ulong m);
public static native int gsl_matrix_ulong_ispos(@Const gsl_matrix_ulong m);
public static native int gsl_matrix_ulong_isneg(@Const gsl_matrix_ulong m);
public static native int gsl_matrix_ulong_isnonneg(@Const gsl_matrix_ulong m);

public static native int gsl_matrix_ulong_add(gsl_matrix_ulong a, @Const gsl_matrix_ulong b);
public static native int gsl_matrix_ulong_sub(gsl_matrix_ulong a, @Const gsl_matrix_ulong b);
public static native int gsl_matrix_ulong_mul_elements(gsl_matrix_ulong a, @Const gsl_matrix_ulong b);
public static native int gsl_matrix_ulong_div_elements(gsl_matrix_ulong a, @Const gsl_matrix_ulong b);
public static native int gsl_matrix_ulong_scale(gsl_matrix_ulong a, double x);
public static native int gsl_matrix_ulong_add_constant(gsl_matrix_ulong a, double x);
public static native int gsl_matrix_ulong_add_diagonal(gsl_matrix_ulong a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_ulong_get_row(gsl_vector_ulong v, @Const gsl_matrix_ulong m, @Cast("const size_t") long i);
public static native int gsl_matrix_ulong_get_col(gsl_vector_ulong v, @Const gsl_matrix_ulong m, @Cast("const size_t") long j);
public static native int gsl_matrix_ulong_set_row(gsl_matrix_ulong m, @Cast("const size_t") long i, @Const gsl_vector_ulong v);
public static native int gsl_matrix_ulong_set_col(gsl_matrix_ulong m, @Cast("const size_t") long j, @Const gsl_vector_ulong v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native @Cast("unsigned long") long gsl_matrix_ulong_get(@Const gsl_matrix_ulong m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_ulong_set(gsl_matrix_ulong m, @Cast("const size_t") long i, @Cast("const size_t") long j, @Cast("const unsigned long") long x);
/* */ public static native @Cast("unsigned long*") CLongPointer gsl_matrix_ulong_ptr(gsl_matrix_ulong m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Cast("const unsigned long*") CLongPointer gsl_matrix_ulong_const_ptr(@Const gsl_matrix_ulong m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_ULONG_H__ */


// Parsed from gsl/gsl_matrix_long.h

/* matrix/gsl_matrix_long.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_LONG_H__
// #define __GSL_MATRIX_LONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_long.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix_long extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_long() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_long(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_long(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_long position(long position) {
        return (gsl_matrix_long)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_long size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_long size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_long tda(long tda);
  public native CLongPointer data(); public native gsl_matrix_long data(CLongPointer data);
  public native gsl_block_long block(); public native gsl_matrix_long block(gsl_block_long block);
  public native int owner(); public native gsl_matrix_long owner(int owner);
}

public static class _gsl_matrix_long_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_long_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_long_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_long_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_long_view position(long position) {
        return (_gsl_matrix_long_view)super.position(position);
    }

  public native @ByRef gsl_matrix_long matrix(); public native _gsl_matrix_long_view matrix(gsl_matrix_long matrix);
}

public static class _gsl_matrix_long_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_long_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_long_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_long_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_long_const_view position(long position) {
        return (_gsl_matrix_long_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_long matrix(); public native _gsl_matrix_long_const_view matrix(gsl_matrix_long matrix);
}

/* Allocation */

public static native gsl_matrix_long gsl_matrix_long_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_long gsl_matrix_long_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_long gsl_matrix_long_alloc_from_block(gsl_block_long b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix_long gsl_matrix_long_alloc_from_matrix(gsl_matrix_long m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector_long gsl_vector_long_alloc_row_from_matrix(gsl_matrix_long m,
                                        @Cast("const size_t") long i);

public static native gsl_vector_long gsl_vector_long_alloc_col_from_matrix(gsl_matrix_long m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_long_free(gsl_matrix_long m);

/* Views */

public static native @ByVal _gsl_matrix_long_view gsl_matrix_long_submatrix(gsl_matrix_long m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_long_view gsl_matrix_long_row(gsl_matrix_long m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_long_view gsl_matrix_long_column(gsl_matrix_long m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_long_view gsl_matrix_long_diagonal(gsl_matrix_long m);

public static native @ByVal _gsl_vector_long_view gsl_matrix_long_subdiagonal(gsl_matrix_long m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_long_view gsl_matrix_long_superdiagonal(gsl_matrix_long m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_long_view gsl_matrix_long_subrow(gsl_matrix_long m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_long_view gsl_matrix_long_subcolumn(gsl_matrix_long m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_long_view gsl_matrix_long_view_array(CLongPointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_long_view gsl_matrix_long_view_array_with_tda(CLongPointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_long_view gsl_matrix_long_view_vector(gsl_vector_long v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_long_view gsl_matrix_long_view_vector_with_tda(gsl_vector_long v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_long_const_view gsl_matrix_long_const_submatrix(@Const gsl_matrix_long m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_long_const_view gsl_matrix_long_const_row(@Const gsl_matrix_long m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_long_const_view gsl_matrix_long_const_column(@Const gsl_matrix_long m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_long_const_view gsl_matrix_long_const_diagonal(@Const gsl_matrix_long m);

public static native @ByVal _gsl_vector_long_const_view gsl_matrix_long_const_subdiagonal(@Const gsl_matrix_long m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_long_const_view gsl_matrix_long_const_superdiagonal(@Const gsl_matrix_long m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_long_const_view gsl_matrix_long_const_subrow(@Const gsl_matrix_long m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_long_const_view gsl_matrix_long_const_subcolumn(@Const gsl_matrix_long m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_long_const_view gsl_matrix_long_const_view_array(@Const CLongPointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_long_const_view gsl_matrix_long_const_view_array_with_tda(@Const CLongPointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_long_const_view gsl_matrix_long_const_view_vector(@Const gsl_vector_long v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_long_const_view gsl_matrix_long_const_view_vector_with_tda(@Const gsl_vector_long v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_long_set_zero(gsl_matrix_long m);
public static native void gsl_matrix_long_set_identity(gsl_matrix_long m);
public static native void gsl_matrix_long_set_all(gsl_matrix_long m, long x);

public static native int gsl_matrix_long_fread(@Cast("FILE*") Pointer stream, gsl_matrix_long m);
public static native int gsl_matrix_long_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_long m);
public static native int gsl_matrix_long_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_long m);
public static native int gsl_matrix_long_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_long m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_long_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_long m, String format);
 
public static native int gsl_matrix_long_memcpy(gsl_matrix_long dest, @Const gsl_matrix_long src);
public static native int gsl_matrix_long_swap(gsl_matrix_long m1, gsl_matrix_long m2);
public static native int gsl_matrix_long_tricpy(byte uplo_src, int copy_diag, gsl_matrix_long dest, @Const gsl_matrix_long src);

public static native int gsl_matrix_long_swap_rows(gsl_matrix_long m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_long_swap_columns(gsl_matrix_long m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_long_swap_rowcol(gsl_matrix_long m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_long_transpose(gsl_matrix_long m);
public static native int gsl_matrix_long_transpose_memcpy(gsl_matrix_long dest, @Const gsl_matrix_long src);
public static native int gsl_matrix_long_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_long dest, @Const gsl_matrix_long src);

public static native long gsl_matrix_long_max(@Const gsl_matrix_long m);
public static native long gsl_matrix_long_min(@Const gsl_matrix_long m);
public static native void gsl_matrix_long_minmax(@Const gsl_matrix_long m, CLongPointer min_out, CLongPointer max_out);

public static native void gsl_matrix_long_max_index(@Const gsl_matrix_long m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_long_min_index(@Const gsl_matrix_long m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_long_minmax_index(@Const gsl_matrix_long m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_long_equal(@Const gsl_matrix_long a, @Const gsl_matrix_long b);

public static native int gsl_matrix_long_isnull(@Const gsl_matrix_long m);
public static native int gsl_matrix_long_ispos(@Const gsl_matrix_long m);
public static native int gsl_matrix_long_isneg(@Const gsl_matrix_long m);
public static native int gsl_matrix_long_isnonneg(@Const gsl_matrix_long m);

public static native int gsl_matrix_long_add(gsl_matrix_long a, @Const gsl_matrix_long b);
public static native int gsl_matrix_long_sub(gsl_matrix_long a, @Const gsl_matrix_long b);
public static native int gsl_matrix_long_mul_elements(gsl_matrix_long a, @Const gsl_matrix_long b);
public static native int gsl_matrix_long_div_elements(gsl_matrix_long a, @Const gsl_matrix_long b);
public static native int gsl_matrix_long_scale(gsl_matrix_long a, double x);
public static native int gsl_matrix_long_add_constant(gsl_matrix_long a, double x);
public static native int gsl_matrix_long_add_diagonal(gsl_matrix_long a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_long_get_row(gsl_vector_long v, @Const gsl_matrix_long m, @Cast("const size_t") long i);
public static native int gsl_matrix_long_get_col(gsl_vector_long v, @Const gsl_matrix_long m, @Cast("const size_t") long j);
public static native int gsl_matrix_long_set_row(gsl_matrix_long m, @Cast("const size_t") long i, @Const gsl_vector_long v);
public static native int gsl_matrix_long_set_col(gsl_matrix_long m, @Cast("const size_t") long j, @Const gsl_vector_long v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native long gsl_matrix_long_get(@Const gsl_matrix_long m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_long_set(gsl_matrix_long m, @Cast("const size_t") long i, @Cast("const size_t") long j, long x);
/* */ public static native CLongPointer gsl_matrix_long_ptr(gsl_matrix_long m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Const CLongPointer gsl_matrix_long_const_ptr(@Const gsl_matrix_long m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_LONG_H__ */


// Parsed from gsl/gsl_matrix_uint.h

/* matrix/gsl_matrix_uint.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_UINT_H__
// #define __GSL_MATRIX_UINT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_uint.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix_uint extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_uint() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_uint(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_uint(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_uint position(long position) {
        return (gsl_matrix_uint)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_uint size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_uint size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_uint tda(long tda);
  public native @Cast("unsigned int*") IntPointer data(); public native gsl_matrix_uint data(IntPointer data);
  public native gsl_block_uint block(); public native gsl_matrix_uint block(gsl_block_uint block);
  public native int owner(); public native gsl_matrix_uint owner(int owner);
}

public static class _gsl_matrix_uint_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_uint_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_uint_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_uint_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_uint_view position(long position) {
        return (_gsl_matrix_uint_view)super.position(position);
    }

  public native @ByRef gsl_matrix_uint matrix(); public native _gsl_matrix_uint_view matrix(gsl_matrix_uint matrix);
}

public static class _gsl_matrix_uint_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_uint_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_uint_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_uint_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_uint_const_view position(long position) {
        return (_gsl_matrix_uint_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_uint matrix(); public native _gsl_matrix_uint_const_view matrix(gsl_matrix_uint matrix);
}

/* Allocation */

public static native gsl_matrix_uint gsl_matrix_uint_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_uint gsl_matrix_uint_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_uint gsl_matrix_uint_alloc_from_block(gsl_block_uint b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix_uint gsl_matrix_uint_alloc_from_matrix(gsl_matrix_uint m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector_uint gsl_vector_uint_alloc_row_from_matrix(gsl_matrix_uint m,
                                        @Cast("const size_t") long i);

public static native gsl_vector_uint gsl_vector_uint_alloc_col_from_matrix(gsl_matrix_uint m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_uint_free(gsl_matrix_uint m);

/* Views */

public static native @ByVal _gsl_matrix_uint_view gsl_matrix_uint_submatrix(gsl_matrix_uint m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_uint_view gsl_matrix_uint_row(gsl_matrix_uint m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_uint_view gsl_matrix_uint_column(gsl_matrix_uint m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_uint_view gsl_matrix_uint_diagonal(gsl_matrix_uint m);

public static native @ByVal _gsl_vector_uint_view gsl_matrix_uint_subdiagonal(gsl_matrix_uint m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_uint_view gsl_matrix_uint_superdiagonal(gsl_matrix_uint m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_uint_view gsl_matrix_uint_subrow(gsl_matrix_uint m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_uint_view gsl_matrix_uint_subcolumn(gsl_matrix_uint m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_uint_view gsl_matrix_uint_view_array(@Cast("unsigned int*") IntPointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_uint_view gsl_matrix_uint_view_array(@Cast("unsigned int*") IntBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_uint_view gsl_matrix_uint_view_array(@Cast("unsigned int*") int[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_uint_view gsl_matrix_uint_view_array_with_tda(@Cast("unsigned int*") IntPointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_uint_view gsl_matrix_uint_view_array_with_tda(@Cast("unsigned int*") IntBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_uint_view gsl_matrix_uint_view_array_with_tda(@Cast("unsigned int*") int[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_uint_view gsl_matrix_uint_view_vector(gsl_vector_uint v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_uint_view gsl_matrix_uint_view_vector_with_tda(gsl_vector_uint v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_uint_const_view gsl_matrix_uint_const_submatrix(@Const gsl_matrix_uint m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_uint_const_view gsl_matrix_uint_const_row(@Const gsl_matrix_uint m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_uint_const_view gsl_matrix_uint_const_column(@Const gsl_matrix_uint m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_uint_const_view gsl_matrix_uint_const_diagonal(@Const gsl_matrix_uint m);

public static native @ByVal _gsl_vector_uint_const_view gsl_matrix_uint_const_subdiagonal(@Const gsl_matrix_uint m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_uint_const_view gsl_matrix_uint_const_superdiagonal(@Const gsl_matrix_uint m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_uint_const_view gsl_matrix_uint_const_subrow(@Const gsl_matrix_uint m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_uint_const_view gsl_matrix_uint_const_subcolumn(@Const gsl_matrix_uint m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_uint_const_view gsl_matrix_uint_const_view_array(@Cast("const unsigned int*") IntPointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_uint_const_view gsl_matrix_uint_const_view_array(@Cast("const unsigned int*") IntBuffer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_uint_const_view gsl_matrix_uint_const_view_array(@Cast("const unsigned int*") int[] base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_uint_const_view gsl_matrix_uint_const_view_array_with_tda(@Cast("const unsigned int*") IntPointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_uint_const_view gsl_matrix_uint_const_view_array_with_tda(@Cast("const unsigned int*") IntBuffer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_uint_const_view gsl_matrix_uint_const_view_array_with_tda(@Cast("const unsigned int*") int[] base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_uint_const_view gsl_matrix_uint_const_view_vector(@Const gsl_vector_uint v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_uint_const_view gsl_matrix_uint_const_view_vector_with_tda(@Const gsl_vector_uint v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_uint_set_zero(gsl_matrix_uint m);
public static native void gsl_matrix_uint_set_identity(gsl_matrix_uint m);
public static native void gsl_matrix_uint_set_all(gsl_matrix_uint m, @Cast("unsigned int") int x);

public static native int gsl_matrix_uint_fread(@Cast("FILE*") Pointer stream, gsl_matrix_uint m);
public static native int gsl_matrix_uint_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_uint m);
public static native int gsl_matrix_uint_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_uint m);
public static native int gsl_matrix_uint_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_uint m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_uint_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_uint m, String format);
 
public static native int gsl_matrix_uint_memcpy(gsl_matrix_uint dest, @Const gsl_matrix_uint src);
public static native int gsl_matrix_uint_swap(gsl_matrix_uint m1, gsl_matrix_uint m2);
public static native int gsl_matrix_uint_tricpy(byte uplo_src, int copy_diag, gsl_matrix_uint dest, @Const gsl_matrix_uint src);

public static native int gsl_matrix_uint_swap_rows(gsl_matrix_uint m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_uint_swap_columns(gsl_matrix_uint m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_uint_swap_rowcol(gsl_matrix_uint m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_uint_transpose(gsl_matrix_uint m);
public static native int gsl_matrix_uint_transpose_memcpy(gsl_matrix_uint dest, @Const gsl_matrix_uint src);
public static native int gsl_matrix_uint_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_uint dest, @Const gsl_matrix_uint src);

public static native @Cast("unsigned int") int gsl_matrix_uint_max(@Const gsl_matrix_uint m);
public static native @Cast("unsigned int") int gsl_matrix_uint_min(@Const gsl_matrix_uint m);
public static native void gsl_matrix_uint_minmax(@Const gsl_matrix_uint m, @Cast("unsigned int*") IntPointer min_out, @Cast("unsigned int*") IntPointer max_out);
public static native void gsl_matrix_uint_minmax(@Const gsl_matrix_uint m, @Cast("unsigned int*") IntBuffer min_out, @Cast("unsigned int*") IntBuffer max_out);
public static native void gsl_matrix_uint_minmax(@Const gsl_matrix_uint m, @Cast("unsigned int*") int[] min_out, @Cast("unsigned int*") int[] max_out);

public static native void gsl_matrix_uint_max_index(@Const gsl_matrix_uint m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_uint_min_index(@Const gsl_matrix_uint m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_uint_minmax_index(@Const gsl_matrix_uint m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_uint_equal(@Const gsl_matrix_uint a, @Const gsl_matrix_uint b);

public static native int gsl_matrix_uint_isnull(@Const gsl_matrix_uint m);
public static native int gsl_matrix_uint_ispos(@Const gsl_matrix_uint m);
public static native int gsl_matrix_uint_isneg(@Const gsl_matrix_uint m);
public static native int gsl_matrix_uint_isnonneg(@Const gsl_matrix_uint m);

public static native int gsl_matrix_uint_add(gsl_matrix_uint a, @Const gsl_matrix_uint b);
public static native int gsl_matrix_uint_sub(gsl_matrix_uint a, @Const gsl_matrix_uint b);
public static native int gsl_matrix_uint_mul_elements(gsl_matrix_uint a, @Const gsl_matrix_uint b);
public static native int gsl_matrix_uint_div_elements(gsl_matrix_uint a, @Const gsl_matrix_uint b);
public static native int gsl_matrix_uint_scale(gsl_matrix_uint a, double x);
public static native int gsl_matrix_uint_add_constant(gsl_matrix_uint a, double x);
public static native int gsl_matrix_uint_add_diagonal(gsl_matrix_uint a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_uint_get_row(gsl_vector_uint v, @Const gsl_matrix_uint m, @Cast("const size_t") long i);
public static native int gsl_matrix_uint_get_col(gsl_vector_uint v, @Const gsl_matrix_uint m, @Cast("const size_t") long j);
public static native int gsl_matrix_uint_set_row(gsl_matrix_uint m, @Cast("const size_t") long i, @Const gsl_vector_uint v);
public static native int gsl_matrix_uint_set_col(gsl_matrix_uint m, @Cast("const size_t") long j, @Const gsl_vector_uint v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native @Cast("unsigned int") int gsl_matrix_uint_get(@Const gsl_matrix_uint m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_uint_set(gsl_matrix_uint m, @Cast("const size_t") long i, @Cast("const size_t") long j, @Cast("const unsigned int") int x);
/* */ public static native @Cast("unsigned int*") IntPointer gsl_matrix_uint_ptr(gsl_matrix_uint m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Cast("const unsigned int*") IntPointer gsl_matrix_uint_const_ptr(@Const gsl_matrix_uint m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_UINT_H__ */


// Parsed from gsl/gsl_matrix_int.h

/* matrix/gsl_matrix_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_INT_H__
// #define __GSL_MATRIX_INT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_int.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix_int extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_int() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_int(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_int(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_int position(long position) {
        return (gsl_matrix_int)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_int size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_int size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_int tda(long tda);
  public native IntPointer data(); public native gsl_matrix_int data(IntPointer data);
  public native gsl_block_int block(); public native gsl_matrix_int block(gsl_block_int block);
  public native int owner(); public native gsl_matrix_int owner(int owner);
}

public static class _gsl_matrix_int_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_int_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_int_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_int_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_int_view position(long position) {
        return (_gsl_matrix_int_view)super.position(position);
    }

  public native @ByRef gsl_matrix_int matrix(); public native _gsl_matrix_int_view matrix(gsl_matrix_int matrix);
}

public static class _gsl_matrix_int_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_int_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_int_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_int_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_int_const_view position(long position) {
        return (_gsl_matrix_int_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_int matrix(); public native _gsl_matrix_int_const_view matrix(gsl_matrix_int matrix);
}

/* Allocation */

public static native gsl_matrix_int gsl_matrix_int_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_int gsl_matrix_int_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_int gsl_matrix_int_alloc_from_block(gsl_block_int b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix_int gsl_matrix_int_alloc_from_matrix(gsl_matrix_int m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector_int gsl_vector_int_alloc_row_from_matrix(gsl_matrix_int m,
                                        @Cast("const size_t") long i);

public static native gsl_vector_int gsl_vector_int_alloc_col_from_matrix(gsl_matrix_int m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_int_free(gsl_matrix_int m);

/* Views */

public static native @ByVal _gsl_matrix_int_view gsl_matrix_int_submatrix(gsl_matrix_int m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_int_view gsl_matrix_int_row(gsl_matrix_int m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_int_view gsl_matrix_int_column(gsl_matrix_int m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_int_view gsl_matrix_int_diagonal(gsl_matrix_int m);

public static native @ByVal _gsl_vector_int_view gsl_matrix_int_subdiagonal(gsl_matrix_int m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_int_view gsl_matrix_int_superdiagonal(gsl_matrix_int m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_int_view gsl_matrix_int_subrow(gsl_matrix_int m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_int_view gsl_matrix_int_subcolumn(gsl_matrix_int m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_int_view gsl_matrix_int_view_array(IntPointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_int_view gsl_matrix_int_view_array(IntBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_int_view gsl_matrix_int_view_array(int[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_int_view gsl_matrix_int_view_array_with_tda(IntPointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_int_view gsl_matrix_int_view_array_with_tda(IntBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_int_view gsl_matrix_int_view_array_with_tda(int[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_int_view gsl_matrix_int_view_vector(gsl_vector_int v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_int_view gsl_matrix_int_view_vector_with_tda(gsl_vector_int v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_int_const_view gsl_matrix_int_const_submatrix(@Const gsl_matrix_int m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_int_const_view gsl_matrix_int_const_row(@Const gsl_matrix_int m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_int_const_view gsl_matrix_int_const_column(@Const gsl_matrix_int m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_int_const_view gsl_matrix_int_const_diagonal(@Const gsl_matrix_int m);

public static native @ByVal _gsl_vector_int_const_view gsl_matrix_int_const_subdiagonal(@Const gsl_matrix_int m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_int_const_view gsl_matrix_int_const_superdiagonal(@Const gsl_matrix_int m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_int_const_view gsl_matrix_int_const_subrow(@Const gsl_matrix_int m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_int_const_view gsl_matrix_int_const_subcolumn(@Const gsl_matrix_int m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_int_const_view gsl_matrix_int_const_view_array(@Const IntPointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_int_const_view gsl_matrix_int_const_view_array(@Const IntBuffer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_int_const_view gsl_matrix_int_const_view_array(@Const int[] base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_int_const_view gsl_matrix_int_const_view_array_with_tda(@Const IntPointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_int_const_view gsl_matrix_int_const_view_array_with_tda(@Const IntBuffer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_int_const_view gsl_matrix_int_const_view_array_with_tda(@Const int[] base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_int_const_view gsl_matrix_int_const_view_vector(@Const gsl_vector_int v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_int_const_view gsl_matrix_int_const_view_vector_with_tda(@Const gsl_vector_int v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_int_set_zero(gsl_matrix_int m);
public static native void gsl_matrix_int_set_identity(gsl_matrix_int m);
public static native void gsl_matrix_int_set_all(gsl_matrix_int m, int x);

public static native int gsl_matrix_int_fread(@Cast("FILE*") Pointer stream, gsl_matrix_int m);
public static native int gsl_matrix_int_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_int m);
public static native int gsl_matrix_int_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_int m);
public static native int gsl_matrix_int_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_int m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_int_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_int m, String format);
 
public static native int gsl_matrix_int_memcpy(gsl_matrix_int dest, @Const gsl_matrix_int src);
public static native int gsl_matrix_int_swap(gsl_matrix_int m1, gsl_matrix_int m2);
public static native int gsl_matrix_int_tricpy(byte uplo_src, int copy_diag, gsl_matrix_int dest, @Const gsl_matrix_int src);

public static native int gsl_matrix_int_swap_rows(gsl_matrix_int m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_int_swap_columns(gsl_matrix_int m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_int_swap_rowcol(gsl_matrix_int m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_int_transpose(gsl_matrix_int m);
public static native int gsl_matrix_int_transpose_memcpy(gsl_matrix_int dest, @Const gsl_matrix_int src);
public static native int gsl_matrix_int_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_int dest, @Const gsl_matrix_int src);

public static native int gsl_matrix_int_max(@Const gsl_matrix_int m);
public static native int gsl_matrix_int_min(@Const gsl_matrix_int m);
public static native void gsl_matrix_int_minmax(@Const gsl_matrix_int m, IntPointer min_out, IntPointer max_out);
public static native void gsl_matrix_int_minmax(@Const gsl_matrix_int m, IntBuffer min_out, IntBuffer max_out);
public static native void gsl_matrix_int_minmax(@Const gsl_matrix_int m, int[] min_out, int[] max_out);

public static native void gsl_matrix_int_max_index(@Const gsl_matrix_int m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_int_min_index(@Const gsl_matrix_int m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_int_minmax_index(@Const gsl_matrix_int m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_int_equal(@Const gsl_matrix_int a, @Const gsl_matrix_int b);

public static native int gsl_matrix_int_isnull(@Const gsl_matrix_int m);
public static native int gsl_matrix_int_ispos(@Const gsl_matrix_int m);
public static native int gsl_matrix_int_isneg(@Const gsl_matrix_int m);
public static native int gsl_matrix_int_isnonneg(@Const gsl_matrix_int m);

public static native int gsl_matrix_int_add(gsl_matrix_int a, @Const gsl_matrix_int b);
public static native int gsl_matrix_int_sub(gsl_matrix_int a, @Const gsl_matrix_int b);
public static native int gsl_matrix_int_mul_elements(gsl_matrix_int a, @Const gsl_matrix_int b);
public static native int gsl_matrix_int_div_elements(gsl_matrix_int a, @Const gsl_matrix_int b);
public static native int gsl_matrix_int_scale(gsl_matrix_int a, double x);
public static native int gsl_matrix_int_add_constant(gsl_matrix_int a, double x);
public static native int gsl_matrix_int_add_diagonal(gsl_matrix_int a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_int_get_row(gsl_vector_int v, @Const gsl_matrix_int m, @Cast("const size_t") long i);
public static native int gsl_matrix_int_get_col(gsl_vector_int v, @Const gsl_matrix_int m, @Cast("const size_t") long j);
public static native int gsl_matrix_int_set_row(gsl_matrix_int m, @Cast("const size_t") long i, @Const gsl_vector_int v);
public static native int gsl_matrix_int_set_col(gsl_matrix_int m, @Cast("const size_t") long j, @Const gsl_vector_int v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native int gsl_matrix_int_get(@Const gsl_matrix_int m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_int_set(gsl_matrix_int m, @Cast("const size_t") long i, @Cast("const size_t") long j, int x);
/* */ public static native IntPointer gsl_matrix_int_ptr(gsl_matrix_int m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Const IntPointer gsl_matrix_int_const_ptr(@Const gsl_matrix_int m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_INT_H__ */


// Parsed from gsl/gsl_matrix_ushort.h

/* matrix/gsl_matrix_ushort.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_USHORT_H__
// #define __GSL_MATRIX_USHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_ushort.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix_ushort extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_ushort() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_ushort(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_ushort(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_ushort position(long position) {
        return (gsl_matrix_ushort)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_ushort size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_ushort size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_ushort tda(long tda);
  public native @Cast("unsigned short*") ShortPointer data(); public native gsl_matrix_ushort data(ShortPointer data);
  public native gsl_block_ushort block(); public native gsl_matrix_ushort block(gsl_block_ushort block);
  public native int owner(); public native gsl_matrix_ushort owner(int owner);
}

public static class _gsl_matrix_ushort_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_ushort_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_ushort_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_ushort_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_ushort_view position(long position) {
        return (_gsl_matrix_ushort_view)super.position(position);
    }

  public native @ByRef gsl_matrix_ushort matrix(); public native _gsl_matrix_ushort_view matrix(gsl_matrix_ushort matrix);
}

public static class _gsl_matrix_ushort_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_ushort_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_ushort_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_ushort_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_ushort_const_view position(long position) {
        return (_gsl_matrix_ushort_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_ushort matrix(); public native _gsl_matrix_ushort_const_view matrix(gsl_matrix_ushort matrix);
}

/* Allocation */

public static native gsl_matrix_ushort gsl_matrix_ushort_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_ushort gsl_matrix_ushort_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_ushort gsl_matrix_ushort_alloc_from_block(gsl_block_ushort b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix_ushort gsl_matrix_ushort_alloc_from_matrix(gsl_matrix_ushort m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector_ushort gsl_vector_ushort_alloc_row_from_matrix(gsl_matrix_ushort m,
                                        @Cast("const size_t") long i);

public static native gsl_vector_ushort gsl_vector_ushort_alloc_col_from_matrix(gsl_matrix_ushort m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_ushort_free(gsl_matrix_ushort m);

/* Views */

public static native @ByVal _gsl_matrix_ushort_view gsl_matrix_ushort_submatrix(gsl_matrix_ushort m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_ushort_view gsl_matrix_ushort_row(gsl_matrix_ushort m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_ushort_view gsl_matrix_ushort_column(gsl_matrix_ushort m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_ushort_view gsl_matrix_ushort_diagonal(gsl_matrix_ushort m);

public static native @ByVal _gsl_vector_ushort_view gsl_matrix_ushort_subdiagonal(gsl_matrix_ushort m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_ushort_view gsl_matrix_ushort_superdiagonal(gsl_matrix_ushort m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_ushort_view gsl_matrix_ushort_subrow(gsl_matrix_ushort m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_ushort_view gsl_matrix_ushort_subcolumn(gsl_matrix_ushort m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_ushort_view gsl_matrix_ushort_view_array(@Cast("unsigned short*") ShortPointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_ushort_view gsl_matrix_ushort_view_array(@Cast("unsigned short*") ShortBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_ushort_view gsl_matrix_ushort_view_array(@Cast("unsigned short*") short[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_ushort_view gsl_matrix_ushort_view_array_with_tda(@Cast("unsigned short*") ShortPointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_ushort_view gsl_matrix_ushort_view_array_with_tda(@Cast("unsigned short*") ShortBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_ushort_view gsl_matrix_ushort_view_array_with_tda(@Cast("unsigned short*") short[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_ushort_view gsl_matrix_ushort_view_vector(gsl_vector_ushort v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_ushort_view gsl_matrix_ushort_view_vector_with_tda(gsl_vector_ushort v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_submatrix(@Const gsl_matrix_ushort m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_ushort_const_view gsl_matrix_ushort_const_row(@Const gsl_matrix_ushort m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_ushort_const_view gsl_matrix_ushort_const_column(@Const gsl_matrix_ushort m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_ushort_const_view gsl_matrix_ushort_const_diagonal(@Const gsl_matrix_ushort m);

public static native @ByVal _gsl_vector_ushort_const_view gsl_matrix_ushort_const_subdiagonal(@Const gsl_matrix_ushort m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_ushort_const_view gsl_matrix_ushort_const_superdiagonal(@Const gsl_matrix_ushort m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_ushort_const_view gsl_matrix_ushort_const_subrow(@Const gsl_matrix_ushort m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_ushort_const_view gsl_matrix_ushort_const_subcolumn(@Const gsl_matrix_ushort m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_view_array(@Cast("const unsigned short*") ShortPointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_view_array(@Cast("const unsigned short*") ShortBuffer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_view_array(@Cast("const unsigned short*") short[] base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_view_array_with_tda(@Cast("const unsigned short*") ShortPointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_view_array_with_tda(@Cast("const unsigned short*") ShortBuffer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_view_array_with_tda(@Cast("const unsigned short*") short[] base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_view_vector(@Const gsl_vector_ushort v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_view_vector_with_tda(@Const gsl_vector_ushort v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_ushort_set_zero(gsl_matrix_ushort m);
public static native void gsl_matrix_ushort_set_identity(gsl_matrix_ushort m);
public static native void gsl_matrix_ushort_set_all(gsl_matrix_ushort m, @Cast("unsigned short") short x);

public static native int gsl_matrix_ushort_fread(@Cast("FILE*") Pointer stream, gsl_matrix_ushort m);
public static native int gsl_matrix_ushort_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_ushort m);
public static native int gsl_matrix_ushort_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_ushort m);
public static native int gsl_matrix_ushort_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_ushort m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_ushort_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_ushort m, String format);
 
public static native int gsl_matrix_ushort_memcpy(gsl_matrix_ushort dest, @Const gsl_matrix_ushort src);
public static native int gsl_matrix_ushort_swap(gsl_matrix_ushort m1, gsl_matrix_ushort m2);
public static native int gsl_matrix_ushort_tricpy(byte uplo_src, int copy_diag, gsl_matrix_ushort dest, @Const gsl_matrix_ushort src);

public static native int gsl_matrix_ushort_swap_rows(gsl_matrix_ushort m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_ushort_swap_columns(gsl_matrix_ushort m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_ushort_swap_rowcol(gsl_matrix_ushort m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_ushort_transpose(gsl_matrix_ushort m);
public static native int gsl_matrix_ushort_transpose_memcpy(gsl_matrix_ushort dest, @Const gsl_matrix_ushort src);
public static native int gsl_matrix_ushort_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_ushort dest, @Const gsl_matrix_ushort src);

public static native @Cast("unsigned short") short gsl_matrix_ushort_max(@Const gsl_matrix_ushort m);
public static native @Cast("unsigned short") short gsl_matrix_ushort_min(@Const gsl_matrix_ushort m);
public static native void gsl_matrix_ushort_minmax(@Const gsl_matrix_ushort m, @Cast("unsigned short*") ShortPointer min_out, @Cast("unsigned short*") ShortPointer max_out);
public static native void gsl_matrix_ushort_minmax(@Const gsl_matrix_ushort m, @Cast("unsigned short*") ShortBuffer min_out, @Cast("unsigned short*") ShortBuffer max_out);
public static native void gsl_matrix_ushort_minmax(@Const gsl_matrix_ushort m, @Cast("unsigned short*") short[] min_out, @Cast("unsigned short*") short[] max_out);

public static native void gsl_matrix_ushort_max_index(@Const gsl_matrix_ushort m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_ushort_min_index(@Const gsl_matrix_ushort m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_ushort_minmax_index(@Const gsl_matrix_ushort m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_ushort_equal(@Const gsl_matrix_ushort a, @Const gsl_matrix_ushort b);

public static native int gsl_matrix_ushort_isnull(@Const gsl_matrix_ushort m);
public static native int gsl_matrix_ushort_ispos(@Const gsl_matrix_ushort m);
public static native int gsl_matrix_ushort_isneg(@Const gsl_matrix_ushort m);
public static native int gsl_matrix_ushort_isnonneg(@Const gsl_matrix_ushort m);

public static native int gsl_matrix_ushort_add(gsl_matrix_ushort a, @Const gsl_matrix_ushort b);
public static native int gsl_matrix_ushort_sub(gsl_matrix_ushort a, @Const gsl_matrix_ushort b);
public static native int gsl_matrix_ushort_mul_elements(gsl_matrix_ushort a, @Const gsl_matrix_ushort b);
public static native int gsl_matrix_ushort_div_elements(gsl_matrix_ushort a, @Const gsl_matrix_ushort b);
public static native int gsl_matrix_ushort_scale(gsl_matrix_ushort a, double x);
public static native int gsl_matrix_ushort_add_constant(gsl_matrix_ushort a, double x);
public static native int gsl_matrix_ushort_add_diagonal(gsl_matrix_ushort a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_ushort_get_row(gsl_vector_ushort v, @Const gsl_matrix_ushort m, @Cast("const size_t") long i);
public static native int gsl_matrix_ushort_get_col(gsl_vector_ushort v, @Const gsl_matrix_ushort m, @Cast("const size_t") long j);
public static native int gsl_matrix_ushort_set_row(gsl_matrix_ushort m, @Cast("const size_t") long i, @Const gsl_vector_ushort v);
public static native int gsl_matrix_ushort_set_col(gsl_matrix_ushort m, @Cast("const size_t") long j, @Const gsl_vector_ushort v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native @Cast("unsigned short") short gsl_matrix_ushort_get(@Const gsl_matrix_ushort m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_ushort_set(gsl_matrix_ushort m, @Cast("const size_t") long i, @Cast("const size_t") long j, @Cast("const unsigned short") short x);
/* */ public static native @Cast("unsigned short*") ShortPointer gsl_matrix_ushort_ptr(gsl_matrix_ushort m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Cast("const unsigned short*") ShortPointer gsl_matrix_ushort_const_ptr(@Const gsl_matrix_ushort m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_USHORT_H__ */


// Parsed from gsl/gsl_matrix_short.h

/* matrix/gsl_matrix_short.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_SHORT_H__
// #define __GSL_MATRIX_SHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_short.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix_short extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_short() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_short(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_short(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_short position(long position) {
        return (gsl_matrix_short)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_short size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_short size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_short tda(long tda);
  public native ShortPointer data(); public native gsl_matrix_short data(ShortPointer data);
  public native gsl_block_short block(); public native gsl_matrix_short block(gsl_block_short block);
  public native int owner(); public native gsl_matrix_short owner(int owner);
}

public static class _gsl_matrix_short_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_short_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_short_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_short_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_short_view position(long position) {
        return (_gsl_matrix_short_view)super.position(position);
    }

  public native @ByRef gsl_matrix_short matrix(); public native _gsl_matrix_short_view matrix(gsl_matrix_short matrix);
}

public static class _gsl_matrix_short_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_short_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_short_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_short_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_short_const_view position(long position) {
        return (_gsl_matrix_short_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_short matrix(); public native _gsl_matrix_short_const_view matrix(gsl_matrix_short matrix);
}

/* Allocation */

public static native gsl_matrix_short gsl_matrix_short_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_short gsl_matrix_short_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_short gsl_matrix_short_alloc_from_block(gsl_block_short b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix_short gsl_matrix_short_alloc_from_matrix(gsl_matrix_short m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector_short gsl_vector_short_alloc_row_from_matrix(gsl_matrix_short m,
                                        @Cast("const size_t") long i);

public static native gsl_vector_short gsl_vector_short_alloc_col_from_matrix(gsl_matrix_short m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_short_free(gsl_matrix_short m);

/* Views */

public static native @ByVal _gsl_matrix_short_view gsl_matrix_short_submatrix(gsl_matrix_short m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_short_view gsl_matrix_short_row(gsl_matrix_short m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_short_view gsl_matrix_short_column(gsl_matrix_short m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_short_view gsl_matrix_short_diagonal(gsl_matrix_short m);

public static native @ByVal _gsl_vector_short_view gsl_matrix_short_subdiagonal(gsl_matrix_short m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_short_view gsl_matrix_short_superdiagonal(gsl_matrix_short m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_short_view gsl_matrix_short_subrow(gsl_matrix_short m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_short_view gsl_matrix_short_subcolumn(gsl_matrix_short m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_short_view gsl_matrix_short_view_array(ShortPointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_short_view gsl_matrix_short_view_array(ShortBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_short_view gsl_matrix_short_view_array(short[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_short_view gsl_matrix_short_view_array_with_tda(ShortPointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_short_view gsl_matrix_short_view_array_with_tda(ShortBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_short_view gsl_matrix_short_view_array_with_tda(short[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_short_view gsl_matrix_short_view_vector(gsl_vector_short v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_short_view gsl_matrix_short_view_vector_with_tda(gsl_vector_short v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_short_const_view gsl_matrix_short_const_submatrix(@Const gsl_matrix_short m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_short_const_view gsl_matrix_short_const_row(@Const gsl_matrix_short m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_short_const_view gsl_matrix_short_const_column(@Const gsl_matrix_short m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_short_const_view gsl_matrix_short_const_diagonal(@Const gsl_matrix_short m);

public static native @ByVal _gsl_vector_short_const_view gsl_matrix_short_const_subdiagonal(@Const gsl_matrix_short m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_short_const_view gsl_matrix_short_const_superdiagonal(@Const gsl_matrix_short m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_short_const_view gsl_matrix_short_const_subrow(@Const gsl_matrix_short m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_short_const_view gsl_matrix_short_const_subcolumn(@Const gsl_matrix_short m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_short_const_view gsl_matrix_short_const_view_array(@Const ShortPointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_short_const_view gsl_matrix_short_const_view_array(@Const ShortBuffer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_short_const_view gsl_matrix_short_const_view_array(@Const short[] base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_short_const_view gsl_matrix_short_const_view_array_with_tda(@Const ShortPointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_short_const_view gsl_matrix_short_const_view_array_with_tda(@Const ShortBuffer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_short_const_view gsl_matrix_short_const_view_array_with_tda(@Const short[] base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_short_const_view gsl_matrix_short_const_view_vector(@Const gsl_vector_short v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_short_const_view gsl_matrix_short_const_view_vector_with_tda(@Const gsl_vector_short v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_short_set_zero(gsl_matrix_short m);
public static native void gsl_matrix_short_set_identity(gsl_matrix_short m);
public static native void gsl_matrix_short_set_all(gsl_matrix_short m, short x);

public static native int gsl_matrix_short_fread(@Cast("FILE*") Pointer stream, gsl_matrix_short m);
public static native int gsl_matrix_short_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_short m);
public static native int gsl_matrix_short_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_short m);
public static native int gsl_matrix_short_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_short m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_short_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_short m, String format);
 
public static native int gsl_matrix_short_memcpy(gsl_matrix_short dest, @Const gsl_matrix_short src);
public static native int gsl_matrix_short_swap(gsl_matrix_short m1, gsl_matrix_short m2);
public static native int gsl_matrix_short_tricpy(byte uplo_src, int copy_diag, gsl_matrix_short dest, @Const gsl_matrix_short src);

public static native int gsl_matrix_short_swap_rows(gsl_matrix_short m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_short_swap_columns(gsl_matrix_short m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_short_swap_rowcol(gsl_matrix_short m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_short_transpose(gsl_matrix_short m);
public static native int gsl_matrix_short_transpose_memcpy(gsl_matrix_short dest, @Const gsl_matrix_short src);
public static native int gsl_matrix_short_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_short dest, @Const gsl_matrix_short src);

public static native short gsl_matrix_short_max(@Const gsl_matrix_short m);
public static native short gsl_matrix_short_min(@Const gsl_matrix_short m);
public static native void gsl_matrix_short_minmax(@Const gsl_matrix_short m, ShortPointer min_out, ShortPointer max_out);
public static native void gsl_matrix_short_minmax(@Const gsl_matrix_short m, ShortBuffer min_out, ShortBuffer max_out);
public static native void gsl_matrix_short_minmax(@Const gsl_matrix_short m, short[] min_out, short[] max_out);

public static native void gsl_matrix_short_max_index(@Const gsl_matrix_short m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_short_min_index(@Const gsl_matrix_short m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_short_minmax_index(@Const gsl_matrix_short m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_short_equal(@Const gsl_matrix_short a, @Const gsl_matrix_short b);

public static native int gsl_matrix_short_isnull(@Const gsl_matrix_short m);
public static native int gsl_matrix_short_ispos(@Const gsl_matrix_short m);
public static native int gsl_matrix_short_isneg(@Const gsl_matrix_short m);
public static native int gsl_matrix_short_isnonneg(@Const gsl_matrix_short m);

public static native int gsl_matrix_short_add(gsl_matrix_short a, @Const gsl_matrix_short b);
public static native int gsl_matrix_short_sub(gsl_matrix_short a, @Const gsl_matrix_short b);
public static native int gsl_matrix_short_mul_elements(gsl_matrix_short a, @Const gsl_matrix_short b);
public static native int gsl_matrix_short_div_elements(gsl_matrix_short a, @Const gsl_matrix_short b);
public static native int gsl_matrix_short_scale(gsl_matrix_short a, double x);
public static native int gsl_matrix_short_add_constant(gsl_matrix_short a, double x);
public static native int gsl_matrix_short_add_diagonal(gsl_matrix_short a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_short_get_row(gsl_vector_short v, @Const gsl_matrix_short m, @Cast("const size_t") long i);
public static native int gsl_matrix_short_get_col(gsl_vector_short v, @Const gsl_matrix_short m, @Cast("const size_t") long j);
public static native int gsl_matrix_short_set_row(gsl_matrix_short m, @Cast("const size_t") long i, @Const gsl_vector_short v);
public static native int gsl_matrix_short_set_col(gsl_matrix_short m, @Cast("const size_t") long j, @Const gsl_vector_short v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native short gsl_matrix_short_get(@Const gsl_matrix_short m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_short_set(gsl_matrix_short m, @Cast("const size_t") long i, @Cast("const size_t") long j, short x);
/* */ public static native ShortPointer gsl_matrix_short_ptr(gsl_matrix_short m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Const ShortPointer gsl_matrix_short_const_ptr(@Const gsl_matrix_short m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_SHORT_H__ */


// Parsed from gsl/gsl_matrix_uchar.h

/* matrix/gsl_matrix_uchar.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_UCHAR_H__
// #define __GSL_MATRIX_UCHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_uchar.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix_uchar extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_uchar() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_uchar(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_uchar(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_uchar position(long position) {
        return (gsl_matrix_uchar)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_uchar size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_uchar size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_uchar tda(long tda);
  public native @Cast("unsigned char*") BytePointer data(); public native gsl_matrix_uchar data(BytePointer data);
  public native gsl_block_uchar block(); public native gsl_matrix_uchar block(gsl_block_uchar block);
  public native int owner(); public native gsl_matrix_uchar owner(int owner);
}

public static class _gsl_matrix_uchar_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_uchar_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_uchar_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_uchar_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_uchar_view position(long position) {
        return (_gsl_matrix_uchar_view)super.position(position);
    }

  public native @ByRef gsl_matrix_uchar matrix(); public native _gsl_matrix_uchar_view matrix(gsl_matrix_uchar matrix);
}

public static class _gsl_matrix_uchar_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_uchar_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_uchar_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_uchar_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_uchar_const_view position(long position) {
        return (_gsl_matrix_uchar_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_uchar matrix(); public native _gsl_matrix_uchar_const_view matrix(gsl_matrix_uchar matrix);
}

/* Allocation */

public static native gsl_matrix_uchar gsl_matrix_uchar_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_uchar gsl_matrix_uchar_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_uchar gsl_matrix_uchar_alloc_from_block(gsl_block_uchar b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix_uchar gsl_matrix_uchar_alloc_from_matrix(gsl_matrix_uchar m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector_uchar gsl_vector_uchar_alloc_row_from_matrix(gsl_matrix_uchar m,
                                        @Cast("const size_t") long i);

public static native gsl_vector_uchar gsl_vector_uchar_alloc_col_from_matrix(gsl_matrix_uchar m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_uchar_free(gsl_matrix_uchar m);

/* Views */

public static native @ByVal _gsl_matrix_uchar_view gsl_matrix_uchar_submatrix(gsl_matrix_uchar m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_uchar_view gsl_matrix_uchar_row(gsl_matrix_uchar m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_uchar_view gsl_matrix_uchar_column(gsl_matrix_uchar m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_uchar_view gsl_matrix_uchar_diagonal(gsl_matrix_uchar m);

public static native @ByVal _gsl_vector_uchar_view gsl_matrix_uchar_subdiagonal(gsl_matrix_uchar m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_uchar_view gsl_matrix_uchar_superdiagonal(gsl_matrix_uchar m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_uchar_view gsl_matrix_uchar_subrow(gsl_matrix_uchar m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_uchar_view gsl_matrix_uchar_subcolumn(gsl_matrix_uchar m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_uchar_view gsl_matrix_uchar_view_array(@Cast("unsigned char*") BytePointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_uchar_view gsl_matrix_uchar_view_array(@Cast("unsigned char*") ByteBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_uchar_view gsl_matrix_uchar_view_array(@Cast("unsigned char*") byte[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_uchar_view gsl_matrix_uchar_view_array_with_tda(@Cast("unsigned char*") BytePointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_uchar_view gsl_matrix_uchar_view_array_with_tda(@Cast("unsigned char*") ByteBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_uchar_view gsl_matrix_uchar_view_array_with_tda(@Cast("unsigned char*") byte[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_uchar_view gsl_matrix_uchar_view_vector(gsl_vector_uchar v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_uchar_view gsl_matrix_uchar_view_vector_with_tda(gsl_vector_uchar v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_submatrix(@Const gsl_matrix_uchar m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_uchar_const_view gsl_matrix_uchar_const_row(@Const gsl_matrix_uchar m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_uchar_const_view gsl_matrix_uchar_const_column(@Const gsl_matrix_uchar m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_uchar_const_view gsl_matrix_uchar_const_diagonal(@Const gsl_matrix_uchar m);

public static native @ByVal _gsl_vector_uchar_const_view gsl_matrix_uchar_const_subdiagonal(@Const gsl_matrix_uchar m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_uchar_const_view gsl_matrix_uchar_const_superdiagonal(@Const gsl_matrix_uchar m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_uchar_const_view gsl_matrix_uchar_const_subrow(@Const gsl_matrix_uchar m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_uchar_const_view gsl_matrix_uchar_const_subcolumn(@Const gsl_matrix_uchar m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_view_array(@Cast("const unsigned char*") BytePointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_view_array(@Cast("const unsigned char*") ByteBuffer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_view_array(@Cast("const unsigned char*") byte[] base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_view_array_with_tda(@Cast("const unsigned char*") BytePointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_view_array_with_tda(@Cast("const unsigned char*") ByteBuffer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_view_array_with_tda(@Cast("const unsigned char*") byte[] base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_view_vector(@Const gsl_vector_uchar v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_view_vector_with_tda(@Const gsl_vector_uchar v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_uchar_set_zero(gsl_matrix_uchar m);
public static native void gsl_matrix_uchar_set_identity(gsl_matrix_uchar m);
public static native void gsl_matrix_uchar_set_all(gsl_matrix_uchar m, @Cast("unsigned char") byte x);

public static native int gsl_matrix_uchar_fread(@Cast("FILE*") Pointer stream, gsl_matrix_uchar m);
public static native int gsl_matrix_uchar_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_uchar m);
public static native int gsl_matrix_uchar_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_uchar m);
public static native int gsl_matrix_uchar_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_uchar m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_uchar_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_uchar m, String format);
 
public static native int gsl_matrix_uchar_memcpy(gsl_matrix_uchar dest, @Const gsl_matrix_uchar src);
public static native int gsl_matrix_uchar_swap(gsl_matrix_uchar m1, gsl_matrix_uchar m2);
public static native int gsl_matrix_uchar_tricpy(byte uplo_src, int copy_diag, gsl_matrix_uchar dest, @Const gsl_matrix_uchar src);

public static native int gsl_matrix_uchar_swap_rows(gsl_matrix_uchar m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_uchar_swap_columns(gsl_matrix_uchar m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_uchar_swap_rowcol(gsl_matrix_uchar m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_uchar_transpose(gsl_matrix_uchar m);
public static native int gsl_matrix_uchar_transpose_memcpy(gsl_matrix_uchar dest, @Const gsl_matrix_uchar src);
public static native int gsl_matrix_uchar_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_uchar dest, @Const gsl_matrix_uchar src);

public static native @Cast("unsigned char") byte gsl_matrix_uchar_max(@Const gsl_matrix_uchar m);
public static native @Cast("unsigned char") byte gsl_matrix_uchar_min(@Const gsl_matrix_uchar m);
public static native void gsl_matrix_uchar_minmax(@Const gsl_matrix_uchar m, @Cast("unsigned char*") BytePointer min_out, @Cast("unsigned char*") BytePointer max_out);
public static native void gsl_matrix_uchar_minmax(@Const gsl_matrix_uchar m, @Cast("unsigned char*") ByteBuffer min_out, @Cast("unsigned char*") ByteBuffer max_out);
public static native void gsl_matrix_uchar_minmax(@Const gsl_matrix_uchar m, @Cast("unsigned char*") byte[] min_out, @Cast("unsigned char*") byte[] max_out);

public static native void gsl_matrix_uchar_max_index(@Const gsl_matrix_uchar m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_uchar_min_index(@Const gsl_matrix_uchar m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_uchar_minmax_index(@Const gsl_matrix_uchar m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_uchar_equal(@Const gsl_matrix_uchar a, @Const gsl_matrix_uchar b);

public static native int gsl_matrix_uchar_isnull(@Const gsl_matrix_uchar m);
public static native int gsl_matrix_uchar_ispos(@Const gsl_matrix_uchar m);
public static native int gsl_matrix_uchar_isneg(@Const gsl_matrix_uchar m);
public static native int gsl_matrix_uchar_isnonneg(@Const gsl_matrix_uchar m);

public static native int gsl_matrix_uchar_add(gsl_matrix_uchar a, @Const gsl_matrix_uchar b);
public static native int gsl_matrix_uchar_sub(gsl_matrix_uchar a, @Const gsl_matrix_uchar b);
public static native int gsl_matrix_uchar_mul_elements(gsl_matrix_uchar a, @Const gsl_matrix_uchar b);
public static native int gsl_matrix_uchar_div_elements(gsl_matrix_uchar a, @Const gsl_matrix_uchar b);
public static native int gsl_matrix_uchar_scale(gsl_matrix_uchar a, double x);
public static native int gsl_matrix_uchar_add_constant(gsl_matrix_uchar a, double x);
public static native int gsl_matrix_uchar_add_diagonal(gsl_matrix_uchar a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_uchar_get_row(gsl_vector_uchar v, @Const gsl_matrix_uchar m, @Cast("const size_t") long i);
public static native int gsl_matrix_uchar_get_col(gsl_vector_uchar v, @Const gsl_matrix_uchar m, @Cast("const size_t") long j);
public static native int gsl_matrix_uchar_set_row(gsl_matrix_uchar m, @Cast("const size_t") long i, @Const gsl_vector_uchar v);
public static native int gsl_matrix_uchar_set_col(gsl_matrix_uchar m, @Cast("const size_t") long j, @Const gsl_vector_uchar v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native @Cast("unsigned char") byte gsl_matrix_uchar_get(@Const gsl_matrix_uchar m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_uchar_set(gsl_matrix_uchar m, @Cast("const size_t") long i, @Cast("const size_t") long j, @Cast("const unsigned char") byte x);
/* */ public static native @Cast("unsigned char*") BytePointer gsl_matrix_uchar_ptr(gsl_matrix_uchar m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Cast("const unsigned char*") BytePointer gsl_matrix_uchar_const_ptr(@Const gsl_matrix_uchar m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_UCHAR_H__ */


// Parsed from gsl/gsl_matrix_char.h

/* matrix/gsl_matrix_char.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MATRIX_CHAR_H__
// #define __GSL_MATRIX_CHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>
// #include <gsl/gsl_vector_char.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_matrix_char extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_matrix_char() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_matrix_char(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_matrix_char(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_matrix_char position(long position) {
        return (gsl_matrix_char)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_matrix_char size1(long size1);
  public native @Cast("size_t") long size2(); public native gsl_matrix_char size2(long size2);
  public native @Cast("size_t") long tda(); public native gsl_matrix_char tda(long tda);
  public native @Cast("char*") BytePointer data(); public native gsl_matrix_char data(BytePointer data);
  public native gsl_block_char block(); public native gsl_matrix_char block(gsl_block_char block);
  public native int owner(); public native gsl_matrix_char owner(int owner);
}

public static class _gsl_matrix_char_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_char_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_char_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_char_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_char_view position(long position) {
        return (_gsl_matrix_char_view)super.position(position);
    }

  public native @ByRef gsl_matrix_char matrix(); public native _gsl_matrix_char_view matrix(gsl_matrix_char matrix);
}

public static class _gsl_matrix_char_const_view extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _gsl_matrix_char_const_view() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _gsl_matrix_char_const_view(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _gsl_matrix_char_const_view(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _gsl_matrix_char_const_view position(long position) {
        return (_gsl_matrix_char_const_view)super.position(position);
    }

  public native @ByRef gsl_matrix_char matrix(); public native _gsl_matrix_char_const_view matrix(gsl_matrix_char matrix);
}

/* Allocation */

public static native gsl_matrix_char gsl_matrix_char_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_char gsl_matrix_char_calloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native gsl_matrix_char gsl_matrix_char_alloc_from_block(gsl_block_char b, 
                                   @Cast("const size_t") long offset, 
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2, 
                                   @Cast("const size_t") long d2);

public static native gsl_matrix_char gsl_matrix_char_alloc_from_matrix(gsl_matrix_char m,
                                    @Cast("const size_t") long k1, 
                                    @Cast("const size_t") long k2,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native gsl_vector_char gsl_vector_char_alloc_row_from_matrix(gsl_matrix_char m,
                                        @Cast("const size_t") long i);

public static native gsl_vector_char gsl_vector_char_alloc_col_from_matrix(gsl_matrix_char m,
                                        @Cast("const size_t") long j);

public static native void gsl_matrix_char_free(gsl_matrix_char m);

/* Views */

public static native @ByVal _gsl_matrix_char_view gsl_matrix_char_submatrix(gsl_matrix_char m, 
                            @Cast("const size_t") long i, @Cast("const size_t") long j, 
                            @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_char_view gsl_matrix_char_row(gsl_matrix_char m, @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_char_view gsl_matrix_char_column(gsl_matrix_char m, @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_char_view gsl_matrix_char_diagonal(gsl_matrix_char m);

public static native @ByVal _gsl_vector_char_view gsl_matrix_char_subdiagonal(gsl_matrix_char m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_char_view gsl_matrix_char_superdiagonal(gsl_matrix_char m, @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_char_view gsl_matrix_char_subrow(gsl_matrix_char m, @Cast("const size_t") long i,
                         @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_char_view gsl_matrix_char_subcolumn(gsl_matrix_char m, @Cast("const size_t") long j,
                            @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_char_view gsl_matrix_char_view_array(@Cast("char*") BytePointer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_char_view gsl_matrix_char_view_array(@Cast("char*") ByteBuffer base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_char_view gsl_matrix_char_view_array(@Cast("char*") byte[] base,
                             @Cast("const size_t") long n1, 
                             @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_char_view gsl_matrix_char_view_array_with_tda(@Cast("char*") BytePointer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_char_view gsl_matrix_char_view_array_with_tda(@Cast("char*") ByteBuffer base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_char_view gsl_matrix_char_view_array_with_tda(@Cast("char*") byte[] base, 
                                      @Cast("const size_t") long n1, 
                                      @Cast("const size_t") long n2,
                                      @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_char_view gsl_matrix_char_view_vector(gsl_vector_char v,
                              @Cast("const size_t") long n1, 
                              @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_char_view gsl_matrix_char_view_vector_with_tda(gsl_vector_char v,
                                       @Cast("const size_t") long n1, 
                                       @Cast("const size_t") long n2,
                                       @Cast("const size_t") long tda);


public static native @ByVal _gsl_matrix_char_const_view gsl_matrix_char_const_submatrix(@Const gsl_matrix_char m, 
                                  @Cast("const size_t") long i, @Cast("const size_t") long j, 
                                  @Cast("const size_t") long n1, @Cast("const size_t") long n2);

public static native @ByVal _gsl_vector_char_const_view gsl_matrix_char_const_row(@Const gsl_matrix_char m, 
                            @Cast("const size_t") long i);

public static native @ByVal _gsl_vector_char_const_view gsl_matrix_char_const_column(@Const gsl_matrix_char m, 
                               @Cast("const size_t") long j);

public static native @ByVal _gsl_vector_char_const_view gsl_matrix_char_const_diagonal(@Const gsl_matrix_char m);

public static native @ByVal _gsl_vector_char_const_view gsl_matrix_char_const_subdiagonal(@Const gsl_matrix_char m, 
                                    @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_char_const_view gsl_matrix_char_const_superdiagonal(@Const gsl_matrix_char m, 
                                      @Cast("const size_t") long k);

public static native @ByVal _gsl_vector_char_const_view gsl_matrix_char_const_subrow(@Const gsl_matrix_char m, @Cast("const size_t") long i,
                               @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_vector_char_const_view gsl_matrix_char_const_subcolumn(@Const gsl_matrix_char m, @Cast("const size_t") long j,
                                  @Cast("const size_t") long offset, @Cast("const size_t") long n);

public static native @ByVal _gsl_matrix_char_const_view gsl_matrix_char_const_view_array(@Cast("const char*") BytePointer base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);
public static native @ByVal _gsl_matrix_char_const_view gsl_matrix_char_const_view_array(String base,
                                   @Cast("const size_t") long n1, 
                                   @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_char_const_view gsl_matrix_char_const_view_array_with_tda(@Cast("const char*") BytePointer base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);
public static native @ByVal _gsl_matrix_char_const_view gsl_matrix_char_const_view_array_with_tda(String base, 
                                            @Cast("const size_t") long n1, 
                                            @Cast("const size_t") long n2,
                                            @Cast("const size_t") long tda);

public static native @ByVal _gsl_matrix_char_const_view gsl_matrix_char_const_view_vector(@Const gsl_vector_char v,
                                    @Cast("const size_t") long n1, 
                                    @Cast("const size_t") long n2);

public static native @ByVal _gsl_matrix_char_const_view gsl_matrix_char_const_view_vector_with_tda(@Const gsl_vector_char v,
                                             @Cast("const size_t") long n1, 
                                             @Cast("const size_t") long n2,
                                             @Cast("const size_t") long tda);

/* Operations */

public static native void gsl_matrix_char_set_zero(gsl_matrix_char m);
public static native void gsl_matrix_char_set_identity(gsl_matrix_char m);
public static native void gsl_matrix_char_set_all(gsl_matrix_char m, @Cast("char") byte x);

public static native int gsl_matrix_char_fread(@Cast("FILE*") Pointer stream, gsl_matrix_char m);
public static native int gsl_matrix_char_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_matrix_char m);
public static native int gsl_matrix_char_fscanf(@Cast("FILE*") Pointer stream, gsl_matrix_char m);
public static native int gsl_matrix_char_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_char m, @Cast("const char*") BytePointer format);
public static native int gsl_matrix_char_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_matrix_char m, String format);
 
public static native int gsl_matrix_char_memcpy(gsl_matrix_char dest, @Const gsl_matrix_char src);
public static native int gsl_matrix_char_swap(gsl_matrix_char m1, gsl_matrix_char m2);
public static native int gsl_matrix_char_tricpy(byte uplo_src, int copy_diag, gsl_matrix_char dest, @Const gsl_matrix_char src);

public static native int gsl_matrix_char_swap_rows(gsl_matrix_char m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_char_swap_columns(gsl_matrix_char m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_char_swap_rowcol(gsl_matrix_char m, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_matrix_char_transpose(gsl_matrix_char m);
public static native int gsl_matrix_char_transpose_memcpy(gsl_matrix_char dest, @Const gsl_matrix_char src);
public static native int gsl_matrix_char_transpose_tricpy(byte uplo_src, int copy_diag, gsl_matrix_char dest, @Const gsl_matrix_char src);

public static native @Cast("char") byte gsl_matrix_char_max(@Const gsl_matrix_char m);
public static native @Cast("char") byte gsl_matrix_char_min(@Const gsl_matrix_char m);
public static native void gsl_matrix_char_minmax(@Const gsl_matrix_char m, @Cast("char*") BytePointer min_out, @Cast("char*") BytePointer max_out);
public static native void gsl_matrix_char_minmax(@Const gsl_matrix_char m, @Cast("char*") ByteBuffer min_out, @Cast("char*") ByteBuffer max_out);
public static native void gsl_matrix_char_minmax(@Const gsl_matrix_char m, @Cast("char*") byte[] min_out, @Cast("char*") byte[] max_out);

public static native void gsl_matrix_char_max_index(@Const gsl_matrix_char m, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);
public static native void gsl_matrix_char_min_index(@Const gsl_matrix_char m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin);
public static native void gsl_matrix_char_minmax_index(@Const gsl_matrix_char m, @Cast("size_t*") SizeTPointer imin, @Cast("size_t*") SizeTPointer jmin, @Cast("size_t*") SizeTPointer imax, @Cast("size_t*") SizeTPointer jmax);

public static native int gsl_matrix_char_equal(@Const gsl_matrix_char a, @Const gsl_matrix_char b);

public static native int gsl_matrix_char_isnull(@Const gsl_matrix_char m);
public static native int gsl_matrix_char_ispos(@Const gsl_matrix_char m);
public static native int gsl_matrix_char_isneg(@Const gsl_matrix_char m);
public static native int gsl_matrix_char_isnonneg(@Const gsl_matrix_char m);

public static native int gsl_matrix_char_add(gsl_matrix_char a, @Const gsl_matrix_char b);
public static native int gsl_matrix_char_sub(gsl_matrix_char a, @Const gsl_matrix_char b);
public static native int gsl_matrix_char_mul_elements(gsl_matrix_char a, @Const gsl_matrix_char b);
public static native int gsl_matrix_char_div_elements(gsl_matrix_char a, @Const gsl_matrix_char b);
public static native int gsl_matrix_char_scale(gsl_matrix_char a, double x);
public static native int gsl_matrix_char_add_constant(gsl_matrix_char a, double x);
public static native int gsl_matrix_char_add_diagonal(gsl_matrix_char a, double x);

/***********************************************************************/
/* The functions below are obsolete                                    */
/***********************************************************************/
public static native int gsl_matrix_char_get_row(gsl_vector_char v, @Const gsl_matrix_char m, @Cast("const size_t") long i);
public static native int gsl_matrix_char_get_col(gsl_vector_char v, @Const gsl_matrix_char m, @Cast("const size_t") long j);
public static native int gsl_matrix_char_set_row(gsl_matrix_char m, @Cast("const size_t") long i, @Const gsl_vector_char v);
public static native int gsl_matrix_char_set_col(gsl_matrix_char m, @Cast("const size_t") long j, @Const gsl_vector_char v);
/***********************************************************************/

/* inline functions if you are using GCC */

/* */ public static native @Cast("char") byte gsl_matrix_char_get(@Const gsl_matrix_char m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native void gsl_matrix_char_set(gsl_matrix_char m, @Cast("const size_t") long i, @Cast("const size_t") long j, byte x);
/* */ public static native @Cast("char*") BytePointer gsl_matrix_char_ptr(gsl_matrix_char m, @Cast("const size_t") long i, @Cast("const size_t") long j);
/* */ public static native @Cast("const char*") BytePointer gsl_matrix_char_const_ptr(@Const gsl_matrix_char m, @Cast("const size_t") long i, @Cast("const size_t") long j);

// #ifdef HAVE_INLINE 

// #endif

// #endif /* __GSL_MATRIX_CHAR_H__ */


// Parsed from gsl/gsl_cblas.h

/* blas/gsl_cblas.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* This is a copy of the CBLAS standard header.
 * We carry this around so we do not have to
 * break our model for flexible BLAS functionality.
 */

// #ifndef __GSL_CBLAS_H__
// #define __GSL_CBLAS_H__
// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// #define __BEGIN_DECLS extern "C" {
// #define __END_DECLS }
// #else
// #endif

/*
 * Enumerated and derived types
 */
// #define CBLAS_INDEX size_t  /* this may vary between platforms */

/** enum CBLAS_ORDER */
public static final int CblasRowMajor= 101, CblasColMajor= 102;
/** enum CBLAS_TRANSPOSE */
public static final int CblasNoTrans= 111, CblasTrans= 112, CblasConjTrans= 113;
/** enum CBLAS_UPLO */
public static final int CblasUpper= 121, CblasLower= 122;
/** enum CBLAS_DIAG */
public static final int CblasNonUnit= 131, CblasUnit= 132;
/** enum CBLAS_SIDE */
public static final int CblasLeft= 141, CblasRight= 142;

/*
 * ===========================================================================
 * Prototypes for level 1 BLAS functions (complex are recast as routines)
 * ===========================================================================
 */
public static native float cblas_sdsdot(int N, float alpha, @Const FloatPointer X,
                    int incX, @Const FloatPointer Y, int incY);
public static native float cblas_sdsdot(int N, float alpha, @Const FloatBuffer X,
                    int incX, @Const FloatBuffer Y, int incY);
public static native float cblas_sdsdot(int N, float alpha, @Const float[] X,
                    int incX, @Const float[] Y, int incY);
public static native double cblas_dsdot(int N, @Const FloatPointer X, int incX, @Const FloatPointer Y,
                   int incY);
public static native double cblas_dsdot(int N, @Const FloatBuffer X, int incX, @Const FloatBuffer Y,
                   int incY);
public static native double cblas_dsdot(int N, @Const float[] X, int incX, @Const float[] Y,
                   int incY);
public static native float cblas_sdot(int N, @Const FloatPointer X, int incX,
                  @Const FloatPointer Y, int incY);
public static native float cblas_sdot(int N, @Const FloatBuffer X, int incX,
                  @Const FloatBuffer Y, int incY);
public static native float cblas_sdot(int N, @Const float[] X, int incX,
                  @Const float[] Y, int incY);
public static native double cblas_ddot(int N, @Const DoublePointer X, int incX,
                  @Const DoublePointer Y, int incY);
public static native double cblas_ddot(int N, @Const DoubleBuffer X, int incX,
                  @Const DoubleBuffer Y, int incY);
public static native double cblas_ddot(int N, @Const double[] X, int incX,
                  @Const double[] Y, int incY);

/*
 * Functions having prefixes Z and C only
 */
public static native void cblas_cdotu_sub(int N, @Const Pointer X, int incX,
                       @Const Pointer Y, int incY, Pointer dotu);
public static native void cblas_cdotc_sub(int N, @Const Pointer X, int incX,
                       @Const Pointer Y, int incY, Pointer dotc);

public static native void cblas_zdotu_sub(int N, @Const Pointer X, int incX,
                       @Const Pointer Y, int incY, Pointer dotu);
public static native void cblas_zdotc_sub(int N, @Const Pointer X, int incX,
                       @Const Pointer Y, int incY, Pointer dotc);


/*
 * Functions having prefixes S D SC DZ
 */
public static native float cblas_snrm2(int N, @Const FloatPointer X, int incX);
public static native float cblas_snrm2(int N, @Const FloatBuffer X, int incX);
public static native float cblas_snrm2(int N, @Const float[] X, int incX);
public static native float cblas_sasum(int N, @Const FloatPointer X, int incX);
public static native float cblas_sasum(int N, @Const FloatBuffer X, int incX);
public static native float cblas_sasum(int N, @Const float[] X, int incX);

public static native double cblas_dnrm2(int N, @Const DoublePointer X, int incX);
public static native double cblas_dnrm2(int N, @Const DoubleBuffer X, int incX);
public static native double cblas_dnrm2(int N, @Const double[] X, int incX);
public static native double cblas_dasum(int N, @Const DoublePointer X, int incX);
public static native double cblas_dasum(int N, @Const DoubleBuffer X, int incX);
public static native double cblas_dasum(int N, @Const double[] X, int incX);

public static native float cblas_scnrm2(int N, @Const Pointer X, int incX);
public static native float cblas_scasum(int N, @Const Pointer X, int incX);

public static native double cblas_dznrm2(int N, @Const Pointer X, int incX);
public static native double cblas_dzasum(int N, @Const Pointer X, int incX);


/*
 * Functions having standard 4 prefixes (S D C Z)
 */
public static native @Cast("size_t") long cblas_isamax(int N, @Const FloatPointer X, int incX);
public static native @Cast("size_t") long cblas_isamax(int N, @Const FloatBuffer X, int incX);
public static native @Cast("size_t") long cblas_isamax(int N, @Const float[] X, int incX);
public static native @Cast("size_t") long cblas_idamax(int N, @Const DoublePointer X, int incX);
public static native @Cast("size_t") long cblas_idamax(int N, @Const DoubleBuffer X, int incX);
public static native @Cast("size_t") long cblas_idamax(int N, @Const double[] X, int incX);
public static native @Cast("size_t") long cblas_icamax(int N, @Const Pointer X, int incX);
public static native @Cast("size_t") long cblas_izamax(int N, @Const Pointer X, int incX);

/*
 * ===========================================================================
 * Prototypes for level 1 BLAS routines
 * ===========================================================================
 */

/* 
 * Routines with standard 4 prefixes (s, d, c, z)
 */
public static native void cblas_sswap(int N, FloatPointer X, int incX, 
                 FloatPointer Y, int incY);
public static native void cblas_sswap(int N, FloatBuffer X, int incX, 
                 FloatBuffer Y, int incY);
public static native void cblas_sswap(int N, float[] X, int incX, 
                 float[] Y, int incY);
public static native void cblas_scopy(int N, @Const FloatPointer X, int incX, 
                 FloatPointer Y, int incY);
public static native void cblas_scopy(int N, @Const FloatBuffer X, int incX, 
                 FloatBuffer Y, int incY);
public static native void cblas_scopy(int N, @Const float[] X, int incX, 
                 float[] Y, int incY);
public static native void cblas_saxpy(int N, float alpha, @Const FloatPointer X,
                 int incX, FloatPointer Y, int incY);
public static native void cblas_saxpy(int N, float alpha, @Const FloatBuffer X,
                 int incX, FloatBuffer Y, int incY);
public static native void cblas_saxpy(int N, float alpha, @Const float[] X,
                 int incX, float[] Y, int incY);

public static native void cblas_dswap(int N, DoublePointer X, int incX, 
                 DoublePointer Y, int incY);
public static native void cblas_dswap(int N, DoubleBuffer X, int incX, 
                 DoubleBuffer Y, int incY);
public static native void cblas_dswap(int N, double[] X, int incX, 
                 double[] Y, int incY);
public static native void cblas_dcopy(int N, @Const DoublePointer X, int incX, 
                 DoublePointer Y, int incY);
public static native void cblas_dcopy(int N, @Const DoubleBuffer X, int incX, 
                 DoubleBuffer Y, int incY);
public static native void cblas_dcopy(int N, @Const double[] X, int incX, 
                 double[] Y, int incY);
public static native void cblas_daxpy(int N, double alpha, @Const DoublePointer X,
                 int incX, DoublePointer Y, int incY);
public static native void cblas_daxpy(int N, double alpha, @Const DoubleBuffer X,
                 int incX, DoubleBuffer Y, int incY);
public static native void cblas_daxpy(int N, double alpha, @Const double[] X,
                 int incX, double[] Y, int incY);

public static native void cblas_cswap(int N, Pointer X, int incX, 
                 Pointer Y, int incY);
public static native void cblas_ccopy(int N, @Const Pointer X, int incX, 
                 Pointer Y, int incY);
public static native void cblas_caxpy(int N, @Const Pointer alpha, @Const Pointer X,
                 int incX, Pointer Y, int incY);

public static native void cblas_zswap(int N, Pointer X, int incX, 
                 Pointer Y, int incY);
public static native void cblas_zcopy(int N, @Const Pointer X, int incX, 
                 Pointer Y, int incY);
public static native void cblas_zaxpy(int N, @Const Pointer alpha, @Const Pointer X,
                 int incX, Pointer Y, int incY);


/* 
 * Routines with S and D prefix only
 */
public static native void cblas_srotg(FloatPointer a, FloatPointer b, FloatPointer c, FloatPointer s);
public static native void cblas_srotg(FloatBuffer a, FloatBuffer b, FloatBuffer c, FloatBuffer s);
public static native void cblas_srotg(float[] a, float[] b, float[] c, float[] s);
public static native void cblas_srotmg(FloatPointer d1, FloatPointer d2, FloatPointer b1, float b2, FloatPointer P);
public static native void cblas_srotmg(FloatBuffer d1, FloatBuffer d2, FloatBuffer b1, float b2, FloatBuffer P);
public static native void cblas_srotmg(float[] d1, float[] d2, float[] b1, float b2, float[] P);
public static native void cblas_srot(int N, FloatPointer X, int incX,
                FloatPointer Y, int incY, float c, float s);
public static native void cblas_srot(int N, FloatBuffer X, int incX,
                FloatBuffer Y, int incY, float c, float s);
public static native void cblas_srot(int N, float[] X, int incX,
                float[] Y, int incY, float c, float s);
public static native void cblas_srotm(int N, FloatPointer X, int incX,
                FloatPointer Y, int incY, @Const FloatPointer P);
public static native void cblas_srotm(int N, FloatBuffer X, int incX,
                FloatBuffer Y, int incY, @Const FloatBuffer P);
public static native void cblas_srotm(int N, float[] X, int incX,
                float[] Y, int incY, @Const float[] P);

public static native void cblas_drotg(DoublePointer a, DoublePointer b, DoublePointer c, DoublePointer s);
public static native void cblas_drotg(DoubleBuffer a, DoubleBuffer b, DoubleBuffer c, DoubleBuffer s);
public static native void cblas_drotg(double[] a, double[] b, double[] c, double[] s);
public static native void cblas_drotmg(DoublePointer d1, DoublePointer d2, DoublePointer b1, double b2, DoublePointer P);
public static native void cblas_drotmg(DoubleBuffer d1, DoubleBuffer d2, DoubleBuffer b1, double b2, DoubleBuffer P);
public static native void cblas_drotmg(double[] d1, double[] d2, double[] b1, double b2, double[] P);
public static native void cblas_drot(int N, DoublePointer X, int incX,
                DoublePointer Y, int incY, double c, double s);
public static native void cblas_drot(int N, DoubleBuffer X, int incX,
                DoubleBuffer Y, int incY, double c, double s);
public static native void cblas_drot(int N, double[] X, int incX,
                double[] Y, int incY, double c, double s);
public static native void cblas_drotm(int N, DoublePointer X, int incX,
                DoublePointer Y, int incY, @Const DoublePointer P);
public static native void cblas_drotm(int N, DoubleBuffer X, int incX,
                DoubleBuffer Y, int incY, @Const DoubleBuffer P);
public static native void cblas_drotm(int N, double[] X, int incX,
                double[] Y, int incY, @Const double[] P);


/* 
 * Routines with S D C Z CS and ZD prefixes
 */
public static native void cblas_sscal(int N, float alpha, FloatPointer X, int incX);
public static native void cblas_sscal(int N, float alpha, FloatBuffer X, int incX);
public static native void cblas_sscal(int N, float alpha, float[] X, int incX);
public static native void cblas_dscal(int N, double alpha, DoublePointer X, int incX);
public static native void cblas_dscal(int N, double alpha, DoubleBuffer X, int incX);
public static native void cblas_dscal(int N, double alpha, double[] X, int incX);
public static native void cblas_cscal(int N, @Const Pointer alpha, Pointer X, int incX);
public static native void cblas_zscal(int N, @Const Pointer alpha, Pointer X, int incX);
public static native void cblas_csscal(int N, float alpha, Pointer X, int incX);
public static native void cblas_zdscal(int N, double alpha, Pointer X, int incX);

/*
 * ===========================================================================
 * Prototypes for level 2 BLAS
 * ===========================================================================
 */

/* 
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
public static native void cblas_sgemv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 float alpha, @Const FloatPointer A, int lda,
                 @Const FloatPointer X, int incX, float beta,
                 FloatPointer Y, int incY);
public static native void cblas_sgemv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 float alpha, @Const FloatBuffer A, int lda,
                 @Const FloatBuffer X, int incX, float beta,
                 FloatBuffer Y, int incY);
public static native void cblas_sgemv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 float alpha, @Const float[] A, int lda,
                 @Const float[] X, int incX, float beta,
                 float[] Y, int incY);
public static native void cblas_sgbmv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 int KL, int KU, float alpha,
                 @Const FloatPointer A, int lda, @Const FloatPointer X,
                 int incX, float beta, FloatPointer Y, int incY);
public static native void cblas_sgbmv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 int KL, int KU, float alpha,
                 @Const FloatBuffer A, int lda, @Const FloatBuffer X,
                 int incX, float beta, FloatBuffer Y, int incY);
public static native void cblas_sgbmv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 int KL, int KU, float alpha,
                 @Const float[] A, int lda, @Const float[] X,
                 int incX, float beta, float[] Y, int incY);
public static native void cblas_strmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const FloatPointer A, int lda, 
                 FloatPointer X, int incX);
public static native void cblas_strmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const FloatBuffer A, int lda, 
                 FloatBuffer X, int incX);
public static native void cblas_strmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const float[] A, int lda, 
                 float[] X, int incX);
public static native void cblas_stbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const FloatPointer A, int lda, 
                 FloatPointer X, int incX);
public static native void cblas_stbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const FloatBuffer A, int lda, 
                 FloatBuffer X, int incX);
public static native void cblas_stbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const float[] A, int lda, 
                 float[] X, int incX);
public static native void cblas_stpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const FloatPointer Ap, FloatPointer X, int incX);
public static native void cblas_stpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const FloatBuffer Ap, FloatBuffer X, int incX);
public static native void cblas_stpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const float[] Ap, float[] X, int incX);
public static native void cblas_strsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const FloatPointer A, int lda, FloatPointer X,
                 int incX);
public static native void cblas_strsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const FloatBuffer A, int lda, FloatBuffer X,
                 int incX);
public static native void cblas_strsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const float[] A, int lda, float[] X,
                 int incX);
public static native void cblas_stbsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const FloatPointer A, int lda,
                 FloatPointer X, int incX);
public static native void cblas_stbsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const FloatBuffer A, int lda,
                 FloatBuffer X, int incX);
public static native void cblas_stbsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const float[] A, int lda,
                 float[] X, int incX);
public static native void cblas_stpsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const FloatPointer Ap, FloatPointer X, int incX);
public static native void cblas_stpsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const FloatBuffer Ap, FloatBuffer X, int incX);
public static native void cblas_stpsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const float[] Ap, float[] X, int incX);

public static native void cblas_dgemv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 double alpha, @Const DoublePointer A, int lda,
                 @Const DoublePointer X, int incX, double beta,
                 DoublePointer Y, int incY);
public static native void cblas_dgemv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 double alpha, @Const DoubleBuffer A, int lda,
                 @Const DoubleBuffer X, int incX, double beta,
                 DoubleBuffer Y, int incY);
public static native void cblas_dgemv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 double alpha, @Const double[] A, int lda,
                 @Const double[] X, int incX, double beta,
                 double[] Y, int incY);
public static native void cblas_dgbmv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 int KL, int KU, double alpha,
                 @Const DoublePointer A, int lda, @Const DoublePointer X,
                 int incX, double beta, DoublePointer Y, int incY);
public static native void cblas_dgbmv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 int KL, int KU, double alpha,
                 @Const DoubleBuffer A, int lda, @Const DoubleBuffer X,
                 int incX, double beta, DoubleBuffer Y, int incY);
public static native void cblas_dgbmv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 int KL, int KU, double alpha,
                 @Const double[] A, int lda, @Const double[] X,
                 int incX, double beta, double[] Y, int incY);
public static native void cblas_dtrmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const DoublePointer A, int lda, 
                 DoublePointer X, int incX);
public static native void cblas_dtrmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const DoubleBuffer A, int lda, 
                 DoubleBuffer X, int incX);
public static native void cblas_dtrmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const double[] A, int lda, 
                 double[] X, int incX);
public static native void cblas_dtbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const DoublePointer A, int lda, 
                 DoublePointer X, int incX);
public static native void cblas_dtbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const DoubleBuffer A, int lda, 
                 DoubleBuffer X, int incX);
public static native void cblas_dtbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const double[] A, int lda, 
                 double[] X, int incX);
public static native void cblas_dtpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const DoublePointer Ap, DoublePointer X, int incX);
public static native void cblas_dtpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const DoubleBuffer Ap, DoubleBuffer X, int incX);
public static native void cblas_dtpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const double[] Ap, double[] X, int incX);
public static native void cblas_dtrsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const DoublePointer A, int lda, DoublePointer X,
                 int incX);
public static native void cblas_dtrsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const DoubleBuffer A, int lda, DoubleBuffer X,
                 int incX);
public static native void cblas_dtrsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const double[] A, int lda, double[] X,
                 int incX);
public static native void cblas_dtbsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const DoublePointer A, int lda,
                 DoublePointer X, int incX);
public static native void cblas_dtbsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const DoubleBuffer A, int lda,
                 DoubleBuffer X, int incX);
public static native void cblas_dtbsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const double[] A, int lda,
                 double[] X, int incX);
public static native void cblas_dtpsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const DoublePointer Ap, DoublePointer X, int incX);
public static native void cblas_dtpsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const DoubleBuffer Ap, DoubleBuffer X, int incX);
public static native void cblas_dtpsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const double[] Ap, double[] X, int incX);

public static native void cblas_cgemv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 @Const Pointer X, int incX, @Const Pointer beta,
                 Pointer Y, int incY);
public static native void cblas_cgbmv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 int KL, int KU, @Const Pointer alpha,
                 @Const Pointer A, int lda, @Const Pointer X,
                 int incX, @Const Pointer beta, Pointer Y, int incY);
public static native void cblas_ctrmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const Pointer A, int lda, 
                 Pointer X, int incX);
public static native void cblas_ctbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const Pointer A, int lda, 
                 Pointer X, int incX);
public static native void cblas_ctpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const Pointer Ap, Pointer X, int incX);
public static native void cblas_ctrsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const Pointer A, int lda, Pointer X,
                 int incX);
public static native void cblas_ctbsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const Pointer A, int lda,
                 Pointer X, int incX);
public static native void cblas_ctpsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const Pointer Ap, Pointer X, int incX);

public static native void cblas_zgemv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 @Const Pointer X, int incX, @Const Pointer beta,
                 Pointer Y, int incY);
public static native void cblas_zgbmv(@Cast("const CBLAS_ORDER") int order,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
                 int KL, int KU, @Const Pointer alpha,
                 @Const Pointer A, int lda, @Const Pointer X,
                 int incX, @Const Pointer beta, Pointer Y, int incY);
public static native void cblas_ztrmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const Pointer A, int lda, 
                 Pointer X, int incX);
public static native void cblas_ztbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const Pointer A, int lda, 
                 Pointer X, int incX);
public static native void cblas_ztpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const Pointer Ap, Pointer X, int incX);
public static native void cblas_ztrsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const Pointer A, int lda, Pointer X,
                 int incX);
public static native void cblas_ztbsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, int K, @Const Pointer A, int lda,
                 Pointer X, int incX);
public static native void cblas_ztpsv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int TransA, @Cast("const CBLAS_DIAG") int Diag,
                 int N, @Const Pointer Ap, Pointer X, int incX);


/* 
 * Routines with S and D prefixes only
 */
public static native void cblas_ssymv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, float alpha, @Const FloatPointer A,
                 int lda, @Const FloatPointer X, int incX,
                 float beta, FloatPointer Y, int incY);
public static native void cblas_ssymv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, float alpha, @Const FloatBuffer A,
                 int lda, @Const FloatBuffer X, int incX,
                 float beta, FloatBuffer Y, int incY);
public static native void cblas_ssymv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, float alpha, @Const float[] A,
                 int lda, @Const float[] X, int incX,
                 float beta, float[] Y, int incY);
public static native void cblas_ssbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, int K, float alpha, @Const FloatPointer A,
                 int lda, @Const FloatPointer X, int incX,
                 float beta, FloatPointer Y, int incY);
public static native void cblas_ssbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, int K, float alpha, @Const FloatBuffer A,
                 int lda, @Const FloatBuffer X, int incX,
                 float beta, FloatBuffer Y, int incY);
public static native void cblas_ssbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, int K, float alpha, @Const float[] A,
                 int lda, @Const float[] X, int incX,
                 float beta, float[] Y, int incY);
public static native void cblas_sspmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, float alpha, @Const FloatPointer Ap,
                 @Const FloatPointer X, int incX,
                 float beta, FloatPointer Y, int incY);
public static native void cblas_sspmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, float alpha, @Const FloatBuffer Ap,
                 @Const FloatBuffer X, int incX,
                 float beta, FloatBuffer Y, int incY);
public static native void cblas_sspmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, float alpha, @Const float[] Ap,
                 @Const float[] X, int incX,
                 float beta, float[] Y, int incY);
public static native void cblas_sger(@Cast("const CBLAS_ORDER") int order, int M, int N,
                float alpha, @Const FloatPointer X, int incX,
                @Const FloatPointer Y, int incY, FloatPointer A, int lda);
public static native void cblas_sger(@Cast("const CBLAS_ORDER") int order, int M, int N,
                float alpha, @Const FloatBuffer X, int incX,
                @Const FloatBuffer Y, int incY, FloatBuffer A, int lda);
public static native void cblas_sger(@Cast("const CBLAS_ORDER") int order, int M, int N,
                float alpha, @Const float[] X, int incX,
                @Const float[] Y, int incY, float[] A, int lda);
public static native void cblas_ssyr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const FloatPointer X,
                int incX, FloatPointer A, int lda);
public static native void cblas_ssyr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const FloatBuffer X,
                int incX, FloatBuffer A, int lda);
public static native void cblas_ssyr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const float[] X,
                int incX, float[] A, int lda);
public static native void cblas_sspr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const FloatPointer X,
                int incX, FloatPointer Ap);
public static native void cblas_sspr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const FloatBuffer X,
                int incX, FloatBuffer Ap);
public static native void cblas_sspr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const float[] X,
                int incX, float[] Ap);
public static native void cblas_ssyr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const FloatPointer X,
                int incX, @Const FloatPointer Y, int incY, FloatPointer A,
                int lda);
public static native void cblas_ssyr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const FloatBuffer X,
                int incX, @Const FloatBuffer Y, int incY, FloatBuffer A,
                int lda);
public static native void cblas_ssyr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const float[] X,
                int incX, @Const float[] Y, int incY, float[] A,
                int lda);
public static native void cblas_sspr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const FloatPointer X,
                int incX, @Const FloatPointer Y, int incY, FloatPointer A);
public static native void cblas_sspr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const FloatBuffer X,
                int incX, @Const FloatBuffer Y, int incY, FloatBuffer A);
public static native void cblas_sspr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const float[] X,
                int incX, @Const float[] Y, int incY, float[] A);

public static native void cblas_dsymv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, double alpha, @Const DoublePointer A,
                 int lda, @Const DoublePointer X, int incX,
                 double beta, DoublePointer Y, int incY);
public static native void cblas_dsymv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, double alpha, @Const DoubleBuffer A,
                 int lda, @Const DoubleBuffer X, int incX,
                 double beta, DoubleBuffer Y, int incY);
public static native void cblas_dsymv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, double alpha, @Const double[] A,
                 int lda, @Const double[] X, int incX,
                 double beta, double[] Y, int incY);
public static native void cblas_dsbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, int K, double alpha, @Const DoublePointer A,
                 int lda, @Const DoublePointer X, int incX,
                 double beta, DoublePointer Y, int incY);
public static native void cblas_dsbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, int K, double alpha, @Const DoubleBuffer A,
                 int lda, @Const DoubleBuffer X, int incX,
                 double beta, DoubleBuffer Y, int incY);
public static native void cblas_dsbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, int K, double alpha, @Const double[] A,
                 int lda, @Const double[] X, int incX,
                 double beta, double[] Y, int incY);
public static native void cblas_dspmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, double alpha, @Const DoublePointer Ap,
                 @Const DoublePointer X, int incX,
                 double beta, DoublePointer Y, int incY);
public static native void cblas_dspmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, double alpha, @Const DoubleBuffer Ap,
                 @Const DoubleBuffer X, int incX,
                 double beta, DoubleBuffer Y, int incY);
public static native void cblas_dspmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, double alpha, @Const double[] Ap,
                 @Const double[] X, int incX,
                 double beta, double[] Y, int incY);
public static native void cblas_dger(@Cast("const CBLAS_ORDER") int order, int M, int N,
                double alpha, @Const DoublePointer X, int incX,
                @Const DoublePointer Y, int incY, DoublePointer A, int lda);
public static native void cblas_dger(@Cast("const CBLAS_ORDER") int order, int M, int N,
                double alpha, @Const DoubleBuffer X, int incX,
                @Const DoubleBuffer Y, int incY, DoubleBuffer A, int lda);
public static native void cblas_dger(@Cast("const CBLAS_ORDER") int order, int M, int N,
                double alpha, @Const double[] X, int incX,
                @Const double[] Y, int incY, double[] A, int lda);
public static native void cblas_dsyr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const DoublePointer X,
                int incX, DoublePointer A, int lda);
public static native void cblas_dsyr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const DoubleBuffer X,
                int incX, DoubleBuffer A, int lda);
public static native void cblas_dsyr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const double[] X,
                int incX, double[] A, int lda);
public static native void cblas_dspr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const DoublePointer X,
                int incX, DoublePointer Ap);
public static native void cblas_dspr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const DoubleBuffer X,
                int incX, DoubleBuffer Ap);
public static native void cblas_dspr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const double[] X,
                int incX, double[] Ap);
public static native void cblas_dsyr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const DoublePointer X,
                int incX, @Const DoublePointer Y, int incY, DoublePointer A,
                int lda);
public static native void cblas_dsyr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const DoubleBuffer X,
                int incX, @Const DoubleBuffer Y, int incY, DoubleBuffer A,
                int lda);
public static native void cblas_dsyr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const double[] X,
                int incX, @Const double[] Y, int incY, double[] A,
                int lda);
public static native void cblas_dspr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const DoublePointer X,
                int incX, @Const DoublePointer Y, int incY, DoublePointer A);
public static native void cblas_dspr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const DoubleBuffer X,
                int incX, @Const DoubleBuffer Y, int incY, DoubleBuffer A);
public static native void cblas_dspr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const double[] X,
                int incX, @Const double[] Y, int incY, double[] A);


/* 
 * Routines with C and Z prefixes only
 */
public static native void cblas_chemv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, @Const Pointer alpha, @Const Pointer A,
                 int lda, @Const Pointer X, int incX,
                 @Const Pointer beta, Pointer Y, int incY);
public static native void cblas_chbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, int K, @Const Pointer alpha, @Const Pointer A,
                 int lda, @Const Pointer X, int incX,
                 @Const Pointer beta, Pointer Y, int incY);
public static native void cblas_chpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, @Const Pointer alpha, @Const Pointer Ap,
                 @Const Pointer X, int incX,
                 @Const Pointer beta, Pointer Y, int incY);
public static native void cblas_cgeru(@Cast("const CBLAS_ORDER") int order, int M, int N,
                 @Const Pointer alpha, @Const Pointer X, int incX,
                 @Const Pointer Y, int incY, Pointer A, int lda);
public static native void cblas_cgerc(@Cast("const CBLAS_ORDER") int order, int M, int N,
                 @Const Pointer alpha, @Const Pointer X, int incX,
                 @Const Pointer Y, int incY, Pointer A, int lda);
public static native void cblas_cher(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const Pointer X, int incX,
                Pointer A, int lda);
public static native void cblas_chpr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, float alpha, @Const Pointer X,
                int incX, Pointer A);
public static native void cblas_cher2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo, int N,
                @Const Pointer alpha, @Const Pointer X, int incX,
                @Const Pointer Y, int incY, Pointer A, int lda);
public static native void cblas_chpr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo, int N,
                @Const Pointer alpha, @Const Pointer X, int incX,
                @Const Pointer Y, int incY, Pointer Ap);

public static native void cblas_zhemv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, @Const Pointer alpha, @Const Pointer A,
                 int lda, @Const Pointer X, int incX,
                 @Const Pointer beta, Pointer Y, int incY);
public static native void cblas_zhbmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, int K, @Const Pointer alpha, @Const Pointer A,
                 int lda, @Const Pointer X, int incX,
                 @Const Pointer beta, Pointer Y, int incY);
public static native void cblas_zhpmv(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                 int N, @Const Pointer alpha, @Const Pointer Ap,
                 @Const Pointer X, int incX,
                 @Const Pointer beta, Pointer Y, int incY);
public static native void cblas_zgeru(@Cast("const CBLAS_ORDER") int order, int M, int N,
                 @Const Pointer alpha, @Const Pointer X, int incX,
                 @Const Pointer Y, int incY, Pointer A, int lda);
public static native void cblas_zgerc(@Cast("const CBLAS_ORDER") int order, int M, int N,
                 @Const Pointer alpha, @Const Pointer X, int incX,
                 @Const Pointer Y, int incY, Pointer A, int lda);
public static native void cblas_zher(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const Pointer X, int incX,
                Pointer A, int lda);
public static native void cblas_zhpr(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo,
                int N, double alpha, @Const Pointer X,
                int incX, Pointer A);
public static native void cblas_zher2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo, int N,
                @Const Pointer alpha, @Const Pointer X, int incX,
                @Const Pointer Y, int incY, Pointer A, int lda);
public static native void cblas_zhpr2(@Cast("const CBLAS_ORDER") int order, @Cast("const CBLAS_UPLO") int Uplo, int N,
                @Const Pointer alpha, @Const Pointer X, int incX,
                @Const Pointer Y, int incY, Pointer Ap);

/*
 * ===========================================================================
 * Prototypes for level 3 BLAS
 * ===========================================================================
 */

/* 
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
public static native void cblas_sgemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N,
                 int K, float alpha, @Const FloatPointer A,
                 int lda, @Const FloatPointer B, int ldb,
                 float beta, FloatPointer C, int ldc);
public static native void cblas_sgemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N,
                 int K, float alpha, @Const FloatBuffer A,
                 int lda, @Const FloatBuffer B, int ldb,
                 float beta, FloatBuffer C, int ldc);
public static native void cblas_sgemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N,
                 int K, float alpha, @Const float[] A,
                 int lda, @Const float[] B, int ldb,
                 float beta, float[] C, int ldc);
public static native void cblas_ssymm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 float alpha, @Const FloatPointer A, int lda,
                 @Const FloatPointer B, int ldb, float beta,
                 FloatPointer C, int ldc);
public static native void cblas_ssymm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 float alpha, @Const FloatBuffer A, int lda,
                 @Const FloatBuffer B, int ldb, float beta,
                 FloatBuffer C, int ldc);
public static native void cblas_ssymm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 float alpha, @Const float[] A, int lda,
                 @Const float[] B, int ldb, float beta,
                 float[] C, int ldc);
public static native void cblas_ssyrk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 float alpha, @Const FloatPointer A, int lda,
                 float beta, FloatPointer C, int ldc);
public static native void cblas_ssyrk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 float alpha, @Const FloatBuffer A, int lda,
                 float beta, FloatBuffer C, int ldc);
public static native void cblas_ssyrk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 float alpha, @Const float[] A, int lda,
                 float beta, float[] C, int ldc);
public static native void cblas_ssyr2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  float alpha, @Const FloatPointer A, int lda,
                  @Const FloatPointer B, int ldb, float beta,
                  FloatPointer C, int ldc);
public static native void cblas_ssyr2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  float alpha, @Const FloatBuffer A, int lda,
                  @Const FloatBuffer B, int ldb, float beta,
                  FloatBuffer C, int ldc);
public static native void cblas_ssyr2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  float alpha, @Const float[] A, int lda,
                  @Const float[] B, int ldb, float beta,
                  float[] C, int ldc);
public static native void cblas_strmm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 float alpha, @Const FloatPointer A, int lda,
                 FloatPointer B, int ldb);
public static native void cblas_strmm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 float alpha, @Const FloatBuffer A, int lda,
                 FloatBuffer B, int ldb);
public static native void cblas_strmm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 float alpha, @Const float[] A, int lda,
                 float[] B, int ldb);
public static native void cblas_strsm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 float alpha, @Const FloatPointer A, int lda,
                 FloatPointer B, int ldb);
public static native void cblas_strsm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 float alpha, @Const FloatBuffer A, int lda,
                 FloatBuffer B, int ldb);
public static native void cblas_strsm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 float alpha, @Const float[] A, int lda,
                 float[] B, int ldb);

public static native void cblas_dgemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N,
                 int K, double alpha, @Const DoublePointer A,
                 int lda, @Const DoublePointer B, int ldb,
                 double beta, DoublePointer C, int ldc);
public static native void cblas_dgemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N,
                 int K, double alpha, @Const DoubleBuffer A,
                 int lda, @Const DoubleBuffer B, int ldb,
                 double beta, DoubleBuffer C, int ldc);
public static native void cblas_dgemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N,
                 int K, double alpha, @Const double[] A,
                 int lda, @Const double[] B, int ldb,
                 double beta, double[] C, int ldc);
public static native void cblas_dsymm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 double alpha, @Const DoublePointer A, int lda,
                 @Const DoublePointer B, int ldb, double beta,
                 DoublePointer C, int ldc);
public static native void cblas_dsymm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 double alpha, @Const DoubleBuffer A, int lda,
                 @Const DoubleBuffer B, int ldb, double beta,
                 DoubleBuffer C, int ldc);
public static native void cblas_dsymm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 double alpha, @Const double[] A, int lda,
                 @Const double[] B, int ldb, double beta,
                 double[] C, int ldc);
public static native void cblas_dsyrk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 double alpha, @Const DoublePointer A, int lda,
                 double beta, DoublePointer C, int ldc);
public static native void cblas_dsyrk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 double alpha, @Const DoubleBuffer A, int lda,
                 double beta, DoubleBuffer C, int ldc);
public static native void cblas_dsyrk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 double alpha, @Const double[] A, int lda,
                 double beta, double[] C, int ldc);
public static native void cblas_dsyr2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  double alpha, @Const DoublePointer A, int lda,
                  @Const DoublePointer B, int ldb, double beta,
                  DoublePointer C, int ldc);
public static native void cblas_dsyr2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  double alpha, @Const DoubleBuffer A, int lda,
                  @Const DoubleBuffer B, int ldb, double beta,
                  DoubleBuffer C, int ldc);
public static native void cblas_dsyr2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  double alpha, @Const double[] A, int lda,
                  @Const double[] B, int ldb, double beta,
                  double[] C, int ldc);
public static native void cblas_dtrmm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 double alpha, @Const DoublePointer A, int lda,
                 DoublePointer B, int ldb);
public static native void cblas_dtrmm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 double alpha, @Const DoubleBuffer A, int lda,
                 DoubleBuffer B, int ldb);
public static native void cblas_dtrmm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 double alpha, @Const double[] A, int lda,
                 double[] B, int ldb);
public static native void cblas_dtrsm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 double alpha, @Const DoublePointer A, int lda,
                 DoublePointer B, int ldb);
public static native void cblas_dtrsm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 double alpha, @Const DoubleBuffer A, int lda,
                 DoubleBuffer B, int ldb);
public static native void cblas_dtrsm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 double alpha, @Const double[] A, int lda,
                 double[] B, int ldb);

public static native void cblas_cgemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N,
                 int K, @Const Pointer alpha, @Const Pointer A,
                 int lda, @Const Pointer B, int ldb,
                 @Const Pointer beta, Pointer C, int ldc);
public static native void cblas_csymm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 @Const Pointer B, int ldb, @Const Pointer beta,
                 Pointer C, int ldc);
public static native void cblas_csyrk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 @Const Pointer beta, Pointer C, int ldc);
public static native void cblas_csyr2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  @Const Pointer alpha, @Const Pointer A, int lda,
                  @Const Pointer B, int ldb, @Const Pointer beta,
                  Pointer C, int ldc);
public static native void cblas_ctrmm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 Pointer B, int ldb);
public static native void cblas_ctrsm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 Pointer B, int ldb);

public static native void cblas_zgemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N,
                 int K, @Const Pointer alpha, @Const Pointer A,
                 int lda, @Const Pointer B, int ldb,
                 @Const Pointer beta, Pointer C, int ldc);
public static native void cblas_zsymm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 @Const Pointer B, int ldb, @Const Pointer beta,
                 Pointer C, int ldc);
public static native void cblas_zsyrk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 @Const Pointer beta, Pointer C, int ldc);
public static native void cblas_zsyr2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  @Const Pointer alpha, @Const Pointer A, int lda,
                  @Const Pointer B, int ldb, @Const Pointer beta,
                  Pointer C, int ldc);
public static native void cblas_ztrmm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 Pointer B, int ldb);
public static native void cblas_ztrsm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, @Cast("const CBLAS_TRANSPOSE") int TransA,
                 @Cast("const CBLAS_DIAG") int Diag, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 Pointer B, int ldb);


/* 
 * Routines with prefixes C and Z only
 */
public static native void cblas_chemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 @Const Pointer B, int ldb, @Const Pointer beta,
                 Pointer C, int ldc);
public static native void cblas_cherk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 float alpha, @Const Pointer A, int lda,
                 float beta, Pointer C, int ldc);
public static native void cblas_cher2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  @Const Pointer alpha, @Const Pointer A, int lda,
                  @Const Pointer B, int ldb, float beta,
                  Pointer C, int ldc);

public static native void cblas_zhemm(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_SIDE") int Side,
                 @Cast("const CBLAS_UPLO") int Uplo, int M, int N,
                 @Const Pointer alpha, @Const Pointer A, int lda,
                 @Const Pointer B, int ldb, @Const Pointer beta,
                 Pointer C, int ldc);
public static native void cblas_zherk(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                 @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                 double alpha, @Const Pointer A, int lda,
                 double beta, Pointer C, int ldc);
public static native void cblas_zher2k(@Cast("const CBLAS_ORDER") int Order, @Cast("const CBLAS_UPLO") int Uplo,
                  @Cast("const CBLAS_TRANSPOSE") int Trans, int N, int K,
                  @Const Pointer alpha, @Const Pointer A, int lda,
                  @Const Pointer B, int ldb, double beta,
                  Pointer C, int ldc);

public static native void cblas_xerbla(int p, @Cast("const char*") BytePointer rout, @Cast("const char*") BytePointer form);
public static native void cblas_xerbla(int p, String rout, String form);

// #endif /* __GSL_CBLAS_H__ */


// Parsed from gsl/gsl_blas_types.h

/* blas/gsl_blas_types.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * Author:  G. Jungman
 */
/* Based on draft BLAST C interface specification  [Jul 7 1998]
 */
// #ifndef __GSL_BLAS_TYPES_H__
// #define __GSL_BLAS_TYPES_H__

// #include <gsl/gsl_cblas.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* typedef  gsl_complex  COMPLEX; */


// #endif /* __GSL_BLAS_TYPES_H__ */


// Parsed from gsl/gsl_blas.h

/* blas/gsl_blas.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * Author:  G. Jungman
 */
// #ifndef __GSL_BLAS_H__
// #define __GSL_BLAS_H__

// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>

// #include <gsl/gsl_blas_types.h>


// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* ========================================================================
 * Level 1
 * ========================================================================
 */

public static native int gsl_blas_sdsdot(float alpha,
                     @Const gsl_vector_float X,
                     @Const gsl_vector_float Y,
                     FloatPointer result
                     );
public static native int gsl_blas_sdsdot(float alpha,
                     @Const gsl_vector_float X,
                     @Const gsl_vector_float Y,
                     FloatBuffer result
                     );
public static native int gsl_blas_sdsdot(float alpha,
                     @Const gsl_vector_float X,
                     @Const gsl_vector_float Y,
                     float[] result
                     );

public static native int gsl_blas_dsdot(@Const gsl_vector_float X,
                    @Const gsl_vector_float Y,
                    DoublePointer result
                    );
public static native int gsl_blas_dsdot(@Const gsl_vector_float X,
                    @Const gsl_vector_float Y,
                    DoubleBuffer result
                    );
public static native int gsl_blas_dsdot(@Const gsl_vector_float X,
                    @Const gsl_vector_float Y,
                    double[] result
                    );

public static native int gsl_blas_sdot(@Const gsl_vector_float X,
                   @Const gsl_vector_float Y,
                   FloatPointer result
                   );
public static native int gsl_blas_sdot(@Const gsl_vector_float X,
                   @Const gsl_vector_float Y,
                   FloatBuffer result
                   );
public static native int gsl_blas_sdot(@Const gsl_vector_float X,
                   @Const gsl_vector_float Y,
                   float[] result
                   );

public static native int gsl_blas_ddot(@Const gsl_vector X,
                   @Const gsl_vector Y,
                   DoublePointer result
                   );
public static native int gsl_blas_ddot(@Const gsl_vector X,
                   @Const gsl_vector Y,
                   DoubleBuffer result
                   );
public static native int gsl_blas_ddot(@Const gsl_vector X,
                   @Const gsl_vector Y,
                   double[] result
                   );


public static native int gsl_blas_cdotu(@Const gsl_vector_complex_float X,
                     @Const gsl_vector_complex_float Y,
                     gsl_complex_float dotu);

public static native int gsl_blas_cdotc(@Const gsl_vector_complex_float X,
                     @Const gsl_vector_complex_float Y,
                     gsl_complex_float dotc);

public static native int gsl_blas_zdotu(@Const gsl_vector_complex X,
                     @Const gsl_vector_complex Y,
                     gsl_complex dotu);

public static native int gsl_blas_zdotc(@Const gsl_vector_complex X,
                     @Const gsl_vector_complex Y,
                     gsl_complex dotc);


public static native float gsl_blas_snrm2(@Const gsl_vector_float X);
public static native float gsl_blas_sasum(@Const gsl_vector_float X);
public static native double gsl_blas_dnrm2(@Const gsl_vector X);
public static native double gsl_blas_dasum(@Const gsl_vector X);
public static native float gsl_blas_scnrm2(@Const gsl_vector_complex_float X);
public static native float gsl_blas_scasum(@Const gsl_vector_complex_float X);
public static native double gsl_blas_dznrm2(@Const gsl_vector_complex X);
public static native double gsl_blas_dzasum(@Const gsl_vector_complex X);


public static native @Cast("CBLAS_INDEX_t") long gsl_blas_isamax(@Const gsl_vector_float X);
public static native @Cast("CBLAS_INDEX_t") long gsl_blas_idamax(@Const gsl_vector X);
public static native @Cast("CBLAS_INDEX_t") long gsl_blas_icamax(@Const gsl_vector_complex_float X);
public static native @Cast("CBLAS_INDEX_t") long gsl_blas_izamax(@Const gsl_vector_complex X);


public static native int gsl_blas_sswap(gsl_vector_float X,
                     gsl_vector_float Y);

public static native int gsl_blas_scopy(@Const gsl_vector_float X,
                     gsl_vector_float Y);

public static native int gsl_blas_saxpy(float alpha,
                     @Const gsl_vector_float X,
                     gsl_vector_float Y);

public static native int gsl_blas_dswap(gsl_vector X,
                     gsl_vector Y);

public static native int gsl_blas_dcopy(@Const gsl_vector X,
                     gsl_vector Y);

public static native int gsl_blas_daxpy(double alpha,
                     @Const gsl_vector X,
                     gsl_vector Y);

public static native int gsl_blas_cswap(gsl_vector_complex_float X,
                     gsl_vector_complex_float Y);

public static native int gsl_blas_ccopy(@Const gsl_vector_complex_float X,
                     gsl_vector_complex_float Y);

public static native int gsl_blas_caxpy(@Const @ByVal gsl_complex_float alpha,
                     @Const gsl_vector_complex_float X,
                     gsl_vector_complex_float Y);

public static native int gsl_blas_zswap(gsl_vector_complex X,
                     gsl_vector_complex Y);

public static native int gsl_blas_zcopy(@Const gsl_vector_complex X,
                     gsl_vector_complex Y);

public static native int gsl_blas_zaxpy(@Const @ByVal gsl_complex alpha,
                     @Const gsl_vector_complex X,
                     gsl_vector_complex Y);


public static native int gsl_blas_srotg(FloatPointer a, FloatPointer b, FloatPointer c, FloatPointer s);
public static native int gsl_blas_srotg(FloatBuffer a, FloatBuffer b, FloatBuffer c, FloatBuffer s);
public static native int gsl_blas_srotg(float[] a, float[] b, float[] c, float[] s);

public static native int gsl_blas_srotmg(FloatPointer d1, FloatPointer d2, FloatPointer b1, float b2, FloatPointer P);
public static native int gsl_blas_srotmg(FloatBuffer d1, FloatBuffer d2, FloatBuffer b1, float b2, FloatBuffer P);
public static native int gsl_blas_srotmg(float[] d1, float[] d2, float[] b1, float b2, float[] P);

public static native int gsl_blas_srot(gsl_vector_float X,
                    gsl_vector_float Y,
                    float c, float s);

public static native int gsl_blas_srotm(gsl_vector_float X,
                     gsl_vector_float Y,
                     @Const FloatPointer P);
public static native int gsl_blas_srotm(gsl_vector_float X,
                     gsl_vector_float Y,
                     @Const FloatBuffer P);
public static native int gsl_blas_srotm(gsl_vector_float X,
                     gsl_vector_float Y,
                     @Const float[] P);

public static native int gsl_blas_drotg(DoublePointer a, DoublePointer b, DoublePointer c, DoublePointer s);
public static native int gsl_blas_drotg(DoubleBuffer a, DoubleBuffer b, DoubleBuffer c, DoubleBuffer s);
public static native int gsl_blas_drotg(double[] a, double[] b, double[] c, double[] s);

public static native int gsl_blas_drotmg(DoublePointer d1, DoublePointer d2, DoublePointer b1,
                      double b2, DoublePointer P);
public static native int gsl_blas_drotmg(DoubleBuffer d1, DoubleBuffer d2, DoubleBuffer b1,
                      double b2, DoubleBuffer P);
public static native int gsl_blas_drotmg(double[] d1, double[] d2, double[] b1,
                      double b2, double[] P);

public static native int gsl_blas_drot(gsl_vector X,
                    gsl_vector Y,
                    double c, double s);

public static native int gsl_blas_drotm(gsl_vector X,
                     gsl_vector Y,
                     @Const DoublePointer P);
public static native int gsl_blas_drotm(gsl_vector X,
                     gsl_vector Y,
                     @Const DoubleBuffer P);
public static native int gsl_blas_drotm(gsl_vector X,
                     gsl_vector Y,
                     @Const double[] P);


public static native void gsl_blas_sscal(float alpha, gsl_vector_float X);
public static native void gsl_blas_dscal(double alpha, gsl_vector X);
public static native void gsl_blas_cscal(@Const @ByVal gsl_complex_float alpha, gsl_vector_complex_float X);
public static native void gsl_blas_zscal(@Const @ByVal gsl_complex alpha, gsl_vector_complex X);
public static native void gsl_blas_csscal(float alpha, gsl_vector_complex_float X);
public static native void gsl_blas_zdscal(double alpha, gsl_vector_complex X);


/* ===========================================================================
 * Level 2
 * ===========================================================================
 */

/*
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
public static native int gsl_blas_sgemv(@Cast("CBLAS_TRANSPOSE_t") int TransA,
                     float alpha,
                     @Const gsl_matrix_float A,
                     @Const gsl_vector_float X,
                     float beta,
                     gsl_vector_float Y);

public static native int gsl_blas_strmv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int TransA, @Cast("CBLAS_DIAG_t") int Diag,
                     @Const gsl_matrix_float A,
                     gsl_vector_float X);

public static native int gsl_blas_strsv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int TransA, @Cast("CBLAS_DIAG_t") int Diag,
                     @Const gsl_matrix_float A,
                     gsl_vector_float X);

public static native int gsl_blas_dgemv(@Cast("CBLAS_TRANSPOSE_t") int TransA,
                     double alpha,
                     @Const gsl_matrix A,
                     @Const gsl_vector X,
                     double beta,
                     gsl_vector Y);

public static native int gsl_blas_dtrmv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int TransA, @Cast("CBLAS_DIAG_t") int Diag,
                     @Const gsl_matrix A,
                     gsl_vector X);

public static native int gsl_blas_dtrsv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int TransA, @Cast("CBLAS_DIAG_t") int Diag,
                     @Const gsl_matrix A,
                     gsl_vector X);

public static native int gsl_blas_cgemv(@Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Const @ByVal gsl_complex_float alpha,
                     @Const gsl_matrix_complex_float A,
                     @Const gsl_vector_complex_float X,
                     @Const @ByVal gsl_complex_float beta,
                     gsl_vector_complex_float Y);

public static native int gsl_blas_ctrmv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int TransA, @Cast("CBLAS_DIAG_t") int Diag,
                     @Const gsl_matrix_complex_float A,
                     gsl_vector_complex_float X);

public static native int gsl_blas_ctrsv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int TransA, @Cast("CBLAS_DIAG_t") int Diag,
                     @Const gsl_matrix_complex_float A,
                     gsl_vector_complex_float X);

public static native int gsl_blas_zgemv(@Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Const @ByVal gsl_complex alpha,
                     @Const gsl_matrix_complex A,
                     @Const gsl_vector_complex X,
                     @Const @ByVal gsl_complex beta,
                     gsl_vector_complex Y);

public static native int gsl_blas_ztrmv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int TransA, @Cast("CBLAS_DIAG_t") int Diag,
                     @Const gsl_matrix_complex A,
                     gsl_vector_complex X);

public static native int gsl_blas_ztrsv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int TransA, @Cast("CBLAS_DIAG_t") int Diag,
                     @Const gsl_matrix_complex A,
                     gsl_vector_complex X);

/*
 * Routines with S and D prefixes only
 */
public static native int gsl_blas_ssymv(@Cast("CBLAS_UPLO_t") int Uplo,
                     float alpha,
                     @Const gsl_matrix_float A,
                     @Const gsl_vector_float X,
                     float beta,
                     gsl_vector_float Y);

public static native int gsl_blas_sger(float alpha,
                    @Const gsl_vector_float X,
                    @Const gsl_vector_float Y,
                    gsl_matrix_float A);

public static native int gsl_blas_ssyr(@Cast("CBLAS_UPLO_t") int Uplo,
                    float alpha,
                    @Const gsl_vector_float X,
                    gsl_matrix_float A);

public static native int gsl_blas_ssyr2(@Cast("CBLAS_UPLO_t") int Uplo,
                     float alpha,
                     @Const gsl_vector_float X,
                     @Const gsl_vector_float Y,
                     gsl_matrix_float A);

public static native int gsl_blas_dsymv(@Cast("CBLAS_UPLO_t") int Uplo,
                     double alpha,
                     @Const gsl_matrix A,
                     @Const gsl_vector X,
                     double beta,
                     gsl_vector Y);
public static native int gsl_blas_dger(double alpha,
                    @Const gsl_vector X,
                    @Const gsl_vector Y,
                    gsl_matrix A);

public static native int gsl_blas_dsyr(@Cast("CBLAS_UPLO_t") int Uplo,
                    double alpha,
                    @Const gsl_vector X,
                    gsl_matrix A);

public static native int gsl_blas_dsyr2(@Cast("CBLAS_UPLO_t") int Uplo,
                     double alpha,
                     @Const gsl_vector X,
                     @Const gsl_vector Y,
                     gsl_matrix A);

/*
 * Routines with C and Z prefixes only
 */

public static native int gsl_blas_chemv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Const @ByVal gsl_complex_float alpha,
                     @Const gsl_matrix_complex_float A,
                     @Const gsl_vector_complex_float X,
                     @Const @ByVal gsl_complex_float beta,
                     gsl_vector_complex_float Y);

public static native int gsl_blas_cgeru(@Const @ByVal gsl_complex_float alpha,
                     @Const gsl_vector_complex_float X,
                     @Const gsl_vector_complex_float Y,
                     gsl_matrix_complex_float A);

public static native int gsl_blas_cgerc(@Const @ByVal gsl_complex_float alpha,
                     @Const gsl_vector_complex_float X,
                     @Const gsl_vector_complex_float Y,
                     gsl_matrix_complex_float A);

public static native int gsl_blas_cher(@Cast("CBLAS_UPLO_t") int Uplo,
                    float alpha,
                    @Const gsl_vector_complex_float X,
                    gsl_matrix_complex_float A);

public static native int gsl_blas_cher2(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Const @ByVal gsl_complex_float alpha,
                     @Const gsl_vector_complex_float X,
                     @Const gsl_vector_complex_float Y,
                     gsl_matrix_complex_float A);

public static native int gsl_blas_zhemv(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Const @ByVal gsl_complex alpha,
                     @Const gsl_matrix_complex A,
                     @Const gsl_vector_complex X,
                     @Const @ByVal gsl_complex beta,
                     gsl_vector_complex Y);

public static native int gsl_blas_zgeru(@Const @ByVal gsl_complex alpha,
                     @Const gsl_vector_complex X,
                     @Const gsl_vector_complex Y,
                     gsl_matrix_complex A);

public static native int gsl_blas_zgerc(@Const @ByVal gsl_complex alpha,
                     @Const gsl_vector_complex X,
                     @Const gsl_vector_complex Y,
                     gsl_matrix_complex A);

public static native int gsl_blas_zher(@Cast("CBLAS_UPLO_t") int Uplo,
                    double alpha,
                    @Const gsl_vector_complex X,
                    gsl_matrix_complex A);

public static native int gsl_blas_zher2(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Const @ByVal gsl_complex alpha,
                     @Const gsl_vector_complex X,
                     @Const gsl_vector_complex Y,
                     gsl_matrix_complex A);

/*
 * ===========================================================================
 * Prototypes for level 3 BLAS
 * ===========================================================================
 */

/*
 * Routines with standard 4 prefixes (S, D, C, Z)
 */
public static native int gsl_blas_sgemm(@Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_TRANSPOSE_t") int TransB,
                     float alpha,
                     @Const gsl_matrix_float A,
                     @Const gsl_matrix_float B,
                     float beta,
                     gsl_matrix_float C);

public static native int gsl_blas_ssymm(@Cast("CBLAS_SIDE_t") int Side, @Cast("CBLAS_UPLO_t") int Uplo,
                     float alpha,
                     @Const gsl_matrix_float A,
                     @Const gsl_matrix_float B,
                     float beta,
                     gsl_matrix_float C);

public static native int gsl_blas_ssyrk(@Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int Trans,
                     float alpha,
                     @Const gsl_matrix_float A,
                     float beta,
                     gsl_matrix_float C);

public static native int gsl_blas_ssyr2k(@Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int Trans,
                      float alpha,
                      @Const gsl_matrix_float A,
                      @Const gsl_matrix_float B,
                      float beta,
                      gsl_matrix_float C);

public static native int gsl_blas_strmm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_DIAG_t") int Diag,
                     float alpha,
                     @Const gsl_matrix_float A,
                     gsl_matrix_float B);

public static native int gsl_blas_strsm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_DIAG_t") int Diag,
                     float alpha,
                     @Const gsl_matrix_float A,
                     gsl_matrix_float B);

public static native int gsl_blas_dgemm(@Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_TRANSPOSE_t") int TransB,
                     double alpha,
                     @Const gsl_matrix A,
                     @Const gsl_matrix B,
                     double beta,
                     gsl_matrix C);

public static native int gsl_blas_dsymm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo,
                     double alpha,
                     @Const gsl_matrix A,
                     @Const gsl_matrix B,
                     double beta,
                     gsl_matrix C);

public static native int gsl_blas_dsyrk(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int Trans,
                     double alpha,
                     @Const gsl_matrix A,
                     double beta,
                     gsl_matrix C);

public static native int gsl_blas_dsyr2k(@Cast("CBLAS_UPLO_t") int Uplo,
                      @Cast("CBLAS_TRANSPOSE_t") int Trans,
                      double alpha,
                      @Const gsl_matrix A,
                      @Const gsl_matrix B,
                      double beta,
                      gsl_matrix C);

public static native int gsl_blas_dtrmm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_DIAG_t") int Diag,
                     double alpha,
                     @Const gsl_matrix A,
                     gsl_matrix B);

public static native int gsl_blas_dtrsm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_DIAG_t") int Diag,
                     double alpha,
                     @Const gsl_matrix A,
                     gsl_matrix B);

public static native int gsl_blas_cgemm(@Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_TRANSPOSE_t") int TransB,
                     @Const @ByVal gsl_complex_float alpha,
                     @Const gsl_matrix_complex_float A,
                     @Const gsl_matrix_complex_float B,
                     @Const @ByVal gsl_complex_float beta,
                     gsl_matrix_complex_float C);

public static native int gsl_blas_csymm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo,
                     @Const @ByVal gsl_complex_float alpha,
                     @Const gsl_matrix_complex_float A,
                     @Const gsl_matrix_complex_float B,
                     @Const @ByVal gsl_complex_float beta,
                     gsl_matrix_complex_float C);

public static native int gsl_blas_csyrk(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int Trans,
                     @Const @ByVal gsl_complex_float alpha,
                     @Const gsl_matrix_complex_float A,
                     @Const @ByVal gsl_complex_float beta,
                     gsl_matrix_complex_float C);

public static native int gsl_blas_csyr2k(@Cast("CBLAS_UPLO_t") int Uplo,
                      @Cast("CBLAS_TRANSPOSE_t") int Trans,
                      @Const @ByVal gsl_complex_float alpha,
                      @Const gsl_matrix_complex_float A,
                      @Const gsl_matrix_complex_float B,
                      @Const @ByVal gsl_complex_float beta,
                      gsl_matrix_complex_float C);

public static native int gsl_blas_ctrmm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_DIAG_t") int Diag,
                     @Const @ByVal gsl_complex_float alpha,
                     @Const gsl_matrix_complex_float A,
                     gsl_matrix_complex_float B);

public static native int gsl_blas_ctrsm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_DIAG_t") int Diag,
                     @Const @ByVal gsl_complex_float alpha,
                     @Const gsl_matrix_complex_float A,
                     gsl_matrix_complex_float B);

public static native int gsl_blas_zgemm(@Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_TRANSPOSE_t") int TransB,
                     @Const @ByVal gsl_complex alpha,
                     @Const gsl_matrix_complex A,
                     @Const gsl_matrix_complex B,
                     @Const @ByVal gsl_complex beta,
                     gsl_matrix_complex C);

public static native int gsl_blas_zsymm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo,
                     @Const @ByVal gsl_complex alpha,
                     @Const gsl_matrix_complex A,
                     @Const gsl_matrix_complex B,
                     @Const @ByVal gsl_complex beta,
                     gsl_matrix_complex C);

public static native int gsl_blas_zsyrk(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int Trans,
                     @Const @ByVal gsl_complex alpha,
                     @Const gsl_matrix_complex A,
                     @Const @ByVal gsl_complex beta,
                     gsl_matrix_complex C);

public static native int gsl_blas_zsyr2k(@Cast("CBLAS_UPLO_t") int Uplo,
                      @Cast("CBLAS_TRANSPOSE_t") int Trans,
                      @Const @ByVal gsl_complex alpha,
                      @Const gsl_matrix_complex A,
                      @Const gsl_matrix_complex B,
                      @Const @ByVal gsl_complex beta,
                      gsl_matrix_complex C);

public static native int gsl_blas_ztrmm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_DIAG_t") int Diag,
                     @Const @ByVal gsl_complex alpha,
                     @Const gsl_matrix_complex A,
                     gsl_matrix_complex B);

public static native int gsl_blas_ztrsm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo, @Cast("CBLAS_TRANSPOSE_t") int TransA,
                     @Cast("CBLAS_DIAG_t") int Diag,
                     @Const @ByVal gsl_complex alpha,
                     @Const gsl_matrix_complex A,
                     gsl_matrix_complex B);

/*
 * Routines with prefixes C and Z only
 */
public static native int gsl_blas_chemm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo,
                     @Const @ByVal gsl_complex_float alpha,
                     @Const gsl_matrix_complex_float A,
                     @Const gsl_matrix_complex_float B,
                     @Const @ByVal gsl_complex_float beta,
                     gsl_matrix_complex_float C);

public static native int gsl_blas_cherk(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int Trans,
                     float alpha,
                     @Const gsl_matrix_complex_float A,
                     float beta,
                     gsl_matrix_complex_float C);

public static native int gsl_blas_cher2k(@Cast("CBLAS_UPLO_t") int Uplo,
                      @Cast("CBLAS_TRANSPOSE_t") int Trans,
                      @Const @ByVal gsl_complex_float alpha,
                      @Const gsl_matrix_complex_float A,
                      @Const gsl_matrix_complex_float B,
                      float beta,
                      gsl_matrix_complex_float C);

public static native int gsl_blas_zhemm(@Cast("CBLAS_SIDE_t") int Side,
                     @Cast("CBLAS_UPLO_t") int Uplo,
                     @Const @ByVal gsl_complex alpha,
                     @Const gsl_matrix_complex A,
                     @Const gsl_matrix_complex B,
                     @Const @ByVal gsl_complex beta,
                     gsl_matrix_complex C);

public static native int gsl_blas_zherk(@Cast("CBLAS_UPLO_t") int Uplo,
                     @Cast("CBLAS_TRANSPOSE_t") int Trans,
                     double alpha,
                     @Const gsl_matrix_complex A,
                     double beta,
                     gsl_matrix_complex C);

public static native int gsl_blas_zher2k(@Cast("CBLAS_UPLO_t") int Uplo,
                      @Cast("CBLAS_TRANSPOSE_t") int Trans,
                      @Const @ByVal gsl_complex alpha,
                      @Const gsl_matrix_complex A,
                      @Const gsl_matrix_complex B,
                      double beta,
                      gsl_matrix_complex C);

// #endif /* __GSL_BLAS_H__ */


// Parsed from gsl/gsl_bspline.h

/* bspline/gsl_bspline.h
 *
 * Copyright (C) 2006 Patrick Alken
 * Copyright (C) 2008 Rhys Ulerich
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_BSPLINE_H__
// #define __GSL_BSPLINE_H__

// #include <stdlib.h>
// #include <gsl/gsl_math.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_bspline_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_bspline_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_bspline_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_bspline_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_bspline_workspace position(long position) {
        return (gsl_bspline_workspace)super.position(position);
    }

    public native @Cast("size_t") long k(); public native gsl_bspline_workspace k(long k);      /* spline order */
    public native @Cast("size_t") long km1(); public native gsl_bspline_workspace km1(long km1);    /* k - 1 (polynomial order) */
    public native @Cast("size_t") long l(); public native gsl_bspline_workspace l(long l);      /* number of polynomial pieces on interval */
    public native @Cast("size_t") long nbreak(); public native gsl_bspline_workspace nbreak(long nbreak); /* number of breakpoints (l + 1) */
    public native @Cast("size_t") long n(); public native gsl_bspline_workspace n(long n);      /* number of bspline basis functions (l + k - 1) */

    public native gsl_vector knots(); public native gsl_bspline_workspace knots(gsl_vector knots);  /* knots vector */
    public native gsl_vector deltal(); public native gsl_bspline_workspace deltal(gsl_vector deltal); /* left delta */
    public native gsl_vector deltar(); public native gsl_bspline_workspace deltar(gsl_vector deltar); /* right delta */
    public native gsl_vector B(); public native gsl_bspline_workspace B(gsl_vector B);      /* temporary spline results */

    /* bspline derivative parameters */
    public native gsl_matrix A(); public native gsl_bspline_workspace A(gsl_matrix A);      /* work matrix */
    public native gsl_matrix dB(); public native gsl_bspline_workspace dB(gsl_matrix dB);     /* temporary derivative results */
}

// #ifndef GSL_DISABLE_DEPRECATED

public static class gsl_bspline_deriv_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_bspline_deriv_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_bspline_deriv_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_bspline_deriv_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_bspline_deriv_workspace position(long position) {
        return (gsl_bspline_deriv_workspace)super.position(position);
    }

    public native @Cast("size_t") long k(); public native gsl_bspline_deriv_workspace k(long k); /* spline order */
    public native gsl_matrix A(); public native gsl_bspline_deriv_workspace A(gsl_matrix A); /* work matrix */
    public native gsl_matrix dB(); public native gsl_bspline_deriv_workspace dB(gsl_matrix dB); /* temporary derivative results */
}




// #endif /* !GSL_DISABLE_DEPRECATED */

public static native gsl_bspline_workspace gsl_bspline_alloc(@Cast("const size_t") long k, @Cast("const size_t") long nbreak);

public static native void gsl_bspline_free(gsl_bspline_workspace w);

public static native @Cast("size_t") long gsl_bspline_ncoeffs(gsl_bspline_workspace w);
public static native @Cast("size_t") long gsl_bspline_order(gsl_bspline_workspace w);
public static native @Cast("size_t") long gsl_bspline_nbreak(gsl_bspline_workspace w);
public static native double gsl_bspline_breakpoint(@Cast("size_t") long i, gsl_bspline_workspace w);
public static native double gsl_bspline_greville_abscissa(@Cast("size_t") long i, gsl_bspline_workspace w);

public static native int gsl_bspline_knots(@Const gsl_vector breakpts, gsl_bspline_workspace w);

public static native int gsl_bspline_knots_uniform(double a, double b,
                              gsl_bspline_workspace w);

public static native int gsl_bspline_knots_greville(@Const gsl_vector abscissae,
                           gsl_bspline_workspace w,
                           DoublePointer abserr);
public static native int gsl_bspline_knots_greville(@Const gsl_vector abscissae,
                           gsl_bspline_workspace w,
                           DoubleBuffer abserr);
public static native int gsl_bspline_knots_greville(@Const gsl_vector abscissae,
                           gsl_bspline_workspace w,
                           double[] abserr);

public static native int gsl_bspline_eval(double x, gsl_vector B, 
                 gsl_bspline_workspace w);

public static native int gsl_bspline_eval_nonzero(double x,
                         gsl_vector Bk,
                         @Cast("size_t*") SizeTPointer istart,
                         @Cast("size_t*") SizeTPointer iend,
                         gsl_bspline_workspace w);

public static native int gsl_bspline_deriv_eval(double x,
                       @Cast("const size_t") long nderiv,
                       gsl_matrix dB,
                       gsl_bspline_workspace w);

public static native int gsl_bspline_deriv_eval_nonzero(double x,
                               @Cast("const size_t") long nderiv,
                               gsl_matrix dB,
                               @Cast("size_t*") SizeTPointer istart,
                               @Cast("size_t*") SizeTPointer iend,
                               gsl_bspline_workspace w);

// #endif /* __GSL_BSPLINE_H__ */


// Parsed from gsl/gsl_cdf.h

/* cdf/gsl_cdf.h
 * 
 * Copyright (C) 2002 Jason H. Stover.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  J. Stover */

// #ifndef __GSL_CDF_H__
// #define __GSL_CDF_H__

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif 

public static native double gsl_cdf_ugaussian_P(double x);
public static native double gsl_cdf_ugaussian_Q(double x);

public static native double gsl_cdf_ugaussian_Pinv(double P);
public static native double gsl_cdf_ugaussian_Qinv(double Q);

public static native double gsl_cdf_gaussian_P(double x, double sigma);
public static native double gsl_cdf_gaussian_Q(double x, double sigma);

public static native double gsl_cdf_gaussian_Pinv(double P, double sigma);
public static native double gsl_cdf_gaussian_Qinv(double Q, double sigma);

public static native double gsl_cdf_gamma_P(double x, double a, double b);
public static native double gsl_cdf_gamma_Q(double x, double a, double b);

public static native double gsl_cdf_gamma_Pinv(double P, double a, double b);
public static native double gsl_cdf_gamma_Qinv(double Q, double a, double b);

public static native double gsl_cdf_cauchy_P(double x, double a);
public static native double gsl_cdf_cauchy_Q(double x, double a);

public static native double gsl_cdf_cauchy_Pinv(double P, double a);
public static native double gsl_cdf_cauchy_Qinv(double Q, double a);

public static native double gsl_cdf_laplace_P(double x, double a);
public static native double gsl_cdf_laplace_Q(double x, double a);

public static native double gsl_cdf_laplace_Pinv(double P, double a);
public static native double gsl_cdf_laplace_Qinv(double Q, double a);

public static native double gsl_cdf_rayleigh_P(double x, double sigma);
public static native double gsl_cdf_rayleigh_Q(double x, double sigma);

public static native double gsl_cdf_rayleigh_Pinv(double P, double sigma);
public static native double gsl_cdf_rayleigh_Qinv(double Q, double sigma);

public static native double gsl_cdf_chisq_P(double x, double nu);
public static native double gsl_cdf_chisq_Q(double x, double nu);

public static native double gsl_cdf_chisq_Pinv(double P, double nu);
public static native double gsl_cdf_chisq_Qinv(double Q, double nu);

public static native double gsl_cdf_exponential_P(double x, double mu);
public static native double gsl_cdf_exponential_Q(double x, double mu);

public static native double gsl_cdf_exponential_Pinv(double P, double mu);
public static native double gsl_cdf_exponential_Qinv(double Q, double mu);

public static native double gsl_cdf_exppow_P(double x, double a, double b);
public static native double gsl_cdf_exppow_Q(double x, double a, double b);

public static native double gsl_cdf_tdist_P(double x, double nu);
public static native double gsl_cdf_tdist_Q(double x, double nu);

public static native double gsl_cdf_tdist_Pinv(double P, double nu);
public static native double gsl_cdf_tdist_Qinv(double Q, double nu);

public static native double gsl_cdf_fdist_P(double x, double nu1, double nu2);
public static native double gsl_cdf_fdist_Q(double x, double nu1, double nu2);

public static native double gsl_cdf_fdist_Pinv(double P, double nu1, double nu2);
public static native double gsl_cdf_fdist_Qinv(double Q, double nu1, double nu2);

public static native double gsl_cdf_beta_P(double x, double a, double b);
public static native double gsl_cdf_beta_Q(double x, double a, double b);

public static native double gsl_cdf_beta_Pinv(double P, double a, double b);
public static native double gsl_cdf_beta_Qinv(double Q, double a, double b);

public static native double gsl_cdf_flat_P(double x, double a, double b);
public static native double gsl_cdf_flat_Q(double x, double a, double b);

public static native double gsl_cdf_flat_Pinv(double P, double a, double b);
public static native double gsl_cdf_flat_Qinv(double Q, double a, double b);

public static native double gsl_cdf_lognormal_P(double x, double zeta, double sigma);
public static native double gsl_cdf_lognormal_Q(double x, double zeta, double sigma);

public static native double gsl_cdf_lognormal_Pinv(double P, double zeta, double sigma);
public static native double gsl_cdf_lognormal_Qinv(double Q, double zeta, double sigma);

public static native double gsl_cdf_gumbel1_P(double x, double a, double b);
public static native double gsl_cdf_gumbel1_Q(double x, double a, double b);

public static native double gsl_cdf_gumbel1_Pinv(double P, double a, double b);
public static native double gsl_cdf_gumbel1_Qinv(double Q, double a, double b);

public static native double gsl_cdf_gumbel2_P(double x, double a, double b);
public static native double gsl_cdf_gumbel2_Q(double x, double a, double b);

public static native double gsl_cdf_gumbel2_Pinv(double P, double a, double b);
public static native double gsl_cdf_gumbel2_Qinv(double Q, double a, double b);

public static native double gsl_cdf_weibull_P(double x, double a, double b);
public static native double gsl_cdf_weibull_Q(double x, double a, double b);

public static native double gsl_cdf_weibull_Pinv(double P, double a, double b);
public static native double gsl_cdf_weibull_Qinv(double Q, double a, double b);

public static native double gsl_cdf_pareto_P(double x, double a, double b);
public static native double gsl_cdf_pareto_Q(double x, double a, double b);

public static native double gsl_cdf_pareto_Pinv(double P, double a, double b);
public static native double gsl_cdf_pareto_Qinv(double Q, double a, double b);

public static native double gsl_cdf_logistic_P(double x, double a);
public static native double gsl_cdf_logistic_Q(double x, double a);

public static native double gsl_cdf_logistic_Pinv(double P, double a);
public static native double gsl_cdf_logistic_Qinv(double Q, double a);

public static native double gsl_cdf_binomial_P(@Cast("const unsigned int") int k, double p, @Cast("const unsigned int") int n);
public static native double gsl_cdf_binomial_Q(@Cast("const unsigned int") int k, double p, @Cast("const unsigned int") int n);

public static native double gsl_cdf_poisson_P(@Cast("const unsigned int") int k, double mu);
public static native double gsl_cdf_poisson_Q(@Cast("const unsigned int") int k, double mu);

public static native double gsl_cdf_geometric_P(@Cast("const unsigned int") int k, double p);
public static native double gsl_cdf_geometric_Q(@Cast("const unsigned int") int k, double p);

public static native double gsl_cdf_negative_binomial_P(@Cast("const unsigned int") int k, double p, double n);
public static native double gsl_cdf_negative_binomial_Q(@Cast("const unsigned int") int k, double p, double n);

public static native double gsl_cdf_pascal_P(@Cast("const unsigned int") int k, double p, @Cast("const unsigned int") int n);
public static native double gsl_cdf_pascal_Q(@Cast("const unsigned int") int k, double p, @Cast("const unsigned int") int n);

public static native double gsl_cdf_hypergeometric_P(@Cast("const unsigned int") int k, @Cast("const unsigned int") int n1,
                                 @Cast("const unsigned int") int n2, @Cast("const unsigned int") int t);
public static native double gsl_cdf_hypergeometric_Q(@Cast("const unsigned int") int k, @Cast("const unsigned int") int n1,
                                 @Cast("const unsigned int") int n2, @Cast("const unsigned int") int t);

// #endif /* __GSL_CDF_H__ */


// Parsed from gsl/gsl_chebyshev.h

/* cheb/gsl_chebyshev.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_CHEBYSHEV_H__
// #define __GSL_CHEBYSHEV_H__

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_mode.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* data for a Chebyshev series over a given interval */

@Name("gsl_cheb_series_struct") public static class gsl_cheb_series extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_cheb_series() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_cheb_series(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_cheb_series(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_cheb_series position(long position) {
        return (gsl_cheb_series)super.position(position);
    }


  public native DoublePointer c(); public native gsl_cheb_series c(DoublePointer c);   /* coefficients                */
  public native @Cast("size_t") long order(); public native gsl_cheb_series order(long order); /* order of expansion          */
  public native double a(); public native gsl_cheb_series a(double a);     /* lower interval point        */
  public native double b(); public native gsl_cheb_series b(double b);     /* upper interval point        */

  /* The following exists (mostly) for the benefit
   * of the implementation. It is an effective single
   * precision order, for use in single precision
   * evaluation. Users can use it if they like, but
   * only they know how to calculate it, since it is
   * specific to the approximated function. By default,
   * order_sp = order.
   * It is used explicitly only by the gsl_cheb_eval_mode
   * functions, which are not meant for casual use.
   */
  public native @Cast("size_t") long order_sp(); public native gsl_cheb_series order_sp(long order_sp);

  /* Additional elements not used by specfunc */

  public native DoublePointer f(); public native gsl_cheb_series f(DoublePointer f);   /* function evaluated at chebyschev points  */
}


/* Calculate a Chebyshev series of specified order over
 * a specified interval, for a given function.
 * Return 0 on failure.
 */
public static native gsl_cheb_series gsl_cheb_alloc(@Cast("const size_t") long order);

/* Free a Chebyshev series previously calculated with gsl_cheb_alloc().
 */
public static native void gsl_cheb_free(gsl_cheb_series cs);

/* Calculate a Chebyshev series using the storage provided.
 * Uses the interval (a,b) and the order with which it
 * was initially created.
 *
 */
public static native int gsl_cheb_init(gsl_cheb_series cs, @Const gsl_function func,
                  double a, double b);

/* Return the order, size of coefficient array and coefficient array ptr */
public static native @Cast("size_t") long gsl_cheb_order(@Const gsl_cheb_series cs);
public static native @Cast("size_t") long gsl_cheb_size(@Const gsl_cheb_series cs);
public static native DoublePointer gsl_cheb_coeffs(@Const gsl_cheb_series cs);

/* Evaluate a Chebyshev series at a given point.
 * No errors can occur for a struct obtained from gsl_cheb_new().
 */
public static native double gsl_cheb_eval(@Const gsl_cheb_series cs, double x);
public static native int gsl_cheb_eval_err(@Const gsl_cheb_series cs, double x, 
                      DoublePointer result, DoublePointer abserr);
public static native int gsl_cheb_eval_err(@Const gsl_cheb_series cs, double x, 
                      DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_cheb_eval_err(@Const gsl_cheb_series cs, double x, 
                      double[] result, double[] abserr);


/* Evaluate a Chebyshev series at a given point, to (at most) the given order.
 * No errors can occur for a struct obtained from gsl_cheb_new().
 */
public static native double gsl_cheb_eval_n(@Const gsl_cheb_series cs, @Cast("const size_t") long order, 
                       double x);
public static native int gsl_cheb_eval_n_err(@Const gsl_cheb_series cs, @Cast("const size_t") long order, 
                        double x, DoublePointer result, DoublePointer abserr);
public static native int gsl_cheb_eval_n_err(@Const gsl_cheb_series cs, @Cast("const size_t") long order, 
                        double x, DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_cheb_eval_n_err(@Const gsl_cheb_series cs, @Cast("const size_t") long order, 
                        double x, double[] result, double[] abserr);


/* Evaluate a Chebyshev series at a given point, using the default
 * order for double precision mode(s) and the single precision
 * order for other modes.
 * No errors can occur for a struct obtained from gsl_cheb_new().
 */
public static native double gsl_cheb_eval_mode(@Const gsl_cheb_series cs, double x, @Cast("gsl_mode_t") int mode);
public static native int gsl_cheb_eval_mode_e(@Const gsl_cheb_series cs, double x, @Cast("gsl_mode_t") int mode, DoublePointer result, DoublePointer abserr);
public static native int gsl_cheb_eval_mode_e(@Const gsl_cheb_series cs, double x, @Cast("gsl_mode_t") int mode, DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_cheb_eval_mode_e(@Const gsl_cheb_series cs, double x, @Cast("gsl_mode_t") int mode, double[] result, double[] abserr);



/* Compute the derivative of a Chebyshev series.
 */
public static native int gsl_cheb_calc_deriv(gsl_cheb_series deriv, @Const gsl_cheb_series cs);

/* Compute the integral of a Chebyshev series. The
 * integral is fixed by the condition that it equals zero at
 * the left end-point, ie it is precisely
 *       Integrate[cs(t; a,b), {t, a, x}]
 */
public static native int gsl_cheb_calc_integ(gsl_cheb_series integ, @Const gsl_cheb_series cs);

// #endif /* __GSL_CHEBYSHEV_H__ */


// Parsed from gsl/gsl_combination.h

/* combination/gsl_combination.h
 * based on permutation/gsl_permutation.h by Brian Gough
 * 
 * Copyright (C) 2001 Szymon Jaroszewicz
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_COMBINATION_H__
// #define __GSL_COMBINATION_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_combination_struct") public static class gsl_combination extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_combination() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_combination(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_combination(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_combination position(long position) {
        return (gsl_combination)super.position(position);
    }

  public native @Cast("size_t") long n(); public native gsl_combination n(long n);
  public native @Cast("size_t") long k(); public native gsl_combination k(long k);
  public native @Cast("size_t*") SizeTPointer data(); public native gsl_combination data(SizeTPointer data);
}

public static native gsl_combination gsl_combination_alloc(@Cast("const size_t") long n, @Cast("const size_t") long k);
public static native gsl_combination gsl_combination_calloc(@Cast("const size_t") long n, @Cast("const size_t") long k);
public static native void gsl_combination_init_first(gsl_combination c);
public static native void gsl_combination_init_last(gsl_combination c);
public static native void gsl_combination_free(gsl_combination c);
public static native int gsl_combination_memcpy(gsl_combination dest, @Const gsl_combination src); 

public static native int gsl_combination_fread(@Cast("FILE*") Pointer stream, gsl_combination c);
public static native int gsl_combination_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_combination c);
public static native int gsl_combination_fscanf(@Cast("FILE*") Pointer stream, gsl_combination c);
public static native int gsl_combination_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_combination c, @Cast("const char*") BytePointer format);
public static native int gsl_combination_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_combination c, String format);

public static native @Cast("size_t") long gsl_combination_n(@Const gsl_combination c);
public static native @Cast("size_t") long gsl_combination_k(@Const gsl_combination c);
public static native @Cast("size_t*") SizeTPointer gsl_combination_data(@Const gsl_combination c);

public static native int gsl_combination_valid(gsl_combination c);
public static native int gsl_combination_next(gsl_combination c);
public static native int gsl_combination_prev(gsl_combination c);

/* */ public static native @Cast("size_t") long gsl_combination_get(@Const gsl_combination c, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE

// #endif /* HAVE_INLINE */

// #endif /* __GSL_COMBINATION_H__ */


// Parsed from gsl/gsl_deriv.h

/* deriv/gsl_deriv.h
 * 
 * Copyright (C) 2000 David Morrison
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_DERIV_H__
// #define __GSL_DERIV_H__
// #include <gsl/gsl_math.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_deriv_central(@Const gsl_function f,
                       double x, double h,
                       DoublePointer result, DoublePointer abserr);
public static native int gsl_deriv_central(@Const gsl_function f,
                       double x, double h,
                       DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_deriv_central(@Const gsl_function f,
                       double x, double h,
                       double[] result, double[] abserr);

public static native int gsl_deriv_backward(@Const gsl_function f,
                        double x, double h,
                        DoublePointer result, DoublePointer abserr);
public static native int gsl_deriv_backward(@Const gsl_function f,
                        double x, double h,
                        DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_deriv_backward(@Const gsl_function f,
                        double x, double h,
                        double[] result, double[] abserr);

public static native int gsl_deriv_forward(@Const gsl_function f,
                       double x, double h,
                       DoublePointer result, DoublePointer abserr);
public static native int gsl_deriv_forward(@Const gsl_function f,
                       double x, double h,
                       DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_deriv_forward(@Const gsl_function f,
                       double x, double h,
                       double[] result, double[] abserr);

// #endif /* __GSL_DERIV_H__ */


// Parsed from gsl/gsl_dht.h

/* dht/gsl_dht.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman
 */
// #ifndef __GSL_DHT_H__
// #define __GSL_DHT_H__

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


@Name("gsl_dht_struct") public static class gsl_dht extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_dht() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_dht(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_dht(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_dht position(long position) {
        return (gsl_dht)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_dht size(long size);  /* size of the sample arrays to be transformed    */
  public native double nu(); public native gsl_dht nu(double nu);    /* Bessel function order                          */
  public native double xmax(); public native gsl_dht xmax(double xmax);  /* the upper limit to the x-sampling domain       */
  public native double kmax(); public native gsl_dht kmax(double kmax);  /* the upper limit to the k-sampling domain       */
  public native DoublePointer j(); public native gsl_dht j(DoublePointer j);     /* array of computed J_nu zeros, j_{nu,s} = j[s]  */
  public native DoublePointer Jjj(); public native gsl_dht Jjj(DoublePointer Jjj);   /* transform numerator, J_nu(j_i j_m / j_N)       */
  public native DoublePointer J2(); public native gsl_dht J2(DoublePointer J2);    /* transform denominator, J_{nu+1}^2(j_m)         */
}


/* Create a new transform object for a given size
 * sampling array on the domain [0, xmax].
 */
public static native gsl_dht gsl_dht_alloc(@Cast("size_t") long size);
public static native gsl_dht gsl_dht_new(@Cast("size_t") long size, double nu, double xmax);

/* Recalculate a transform object for given values of nu, xmax.
 * You cannot change the size of the object since the internal
 * allocation is reused.
 */
public static native int gsl_dht_init(gsl_dht t, double nu, double xmax);

/* The n'th computed x sample point for a given transform.
 * 0 <= n <= size-1
 */
public static native double gsl_dht_x_sample(@Const gsl_dht t, int n);


/* The n'th computed k sample point for a given transform.
 * 0 <= n <= size-1
 */
public static native double gsl_dht_k_sample(@Const gsl_dht t, int n);


/* Free a transform object.
 */
public static native void gsl_dht_free(gsl_dht t);


/* Perform a transform on a sampled array.
 * f_in[0] ... f_in[size-1] and similarly for f_out[]
 */
public static native int gsl_dht_apply(@Const gsl_dht t, DoublePointer f_in, DoublePointer f_out);
public static native int gsl_dht_apply(@Const gsl_dht t, DoubleBuffer f_in, DoubleBuffer f_out);
public static native int gsl_dht_apply(@Const gsl_dht t, double[] f_in, double[] f_out);

// #endif /* __GSL_DHT_H__ */


// Parsed from gsl/gsl_diff.h

/* diff/gsl_diff.h
 * 
 * Copyright (C) 2000 David Morrison
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_DIFF_H__
// #define __GSL_DIFF_H__
// #include <gsl/gsl_math.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

// #ifndef GSL_DISABLE_DEPRECATED
public static native int gsl_diff_central(@Const gsl_function f,
                      double x,
                      DoublePointer result, DoublePointer abserr);
public static native int gsl_diff_central(@Const gsl_function f,
                      double x,
                      DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_diff_central(@Const gsl_function f,
                      double x,
                      double[] result, double[] abserr);

public static native int gsl_diff_backward(@Const gsl_function f,
                       double x,
                       DoublePointer result, DoublePointer abserr);
public static native int gsl_diff_backward(@Const gsl_function f,
                       double x,
                       DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_diff_backward(@Const gsl_function f,
                       double x,
                       double[] result, double[] abserr);

public static native int gsl_diff_forward(@Const gsl_function f,
                      double x,
                      DoublePointer result, DoublePointer abserr);
public static native int gsl_diff_forward(@Const gsl_function f,
                      double x,
                      DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_diff_forward(@Const gsl_function f,
                      double x,
                      double[] result, double[] abserr);
// #endif

// #endif /* __GSL_DIFF_H__ */


// Parsed from gsl/gsl_eigen.h

/* eigen/gsl_eigen.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2006, 2007 Gerard Jungman, Brian Gough, Patrick Alken
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_EIGEN_H__
// #define __GSL_EIGEN_H__

// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_eigen_symm_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_symm_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_symm_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_symm_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_symm_workspace position(long position) {
        return (gsl_eigen_symm_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_symm_workspace size(long size);
  public native DoublePointer d(); public native gsl_eigen_symm_workspace d(DoublePointer d);
  public native DoublePointer sd(); public native gsl_eigen_symm_workspace sd(DoublePointer sd);
}

public static native gsl_eigen_symm_workspace gsl_eigen_symm_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_symm_free(gsl_eigen_symm_workspace w);
public static native int gsl_eigen_symm(gsl_matrix A, gsl_vector eval, gsl_eigen_symm_workspace w);

public static class gsl_eigen_symmv_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_symmv_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_symmv_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_symmv_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_symmv_workspace position(long position) {
        return (gsl_eigen_symmv_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_symmv_workspace size(long size);
  public native DoublePointer d(); public native gsl_eigen_symmv_workspace d(DoublePointer d);
  public native DoublePointer sd(); public native gsl_eigen_symmv_workspace sd(DoublePointer sd);
  public native DoublePointer gc(); public native gsl_eigen_symmv_workspace gc(DoublePointer gc);
  public native DoublePointer gs(); public native gsl_eigen_symmv_workspace gs(DoublePointer gs);
}

public static native gsl_eigen_symmv_workspace gsl_eigen_symmv_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_symmv_free(gsl_eigen_symmv_workspace w);
public static native int gsl_eigen_symmv(gsl_matrix A, gsl_vector eval, gsl_matrix evec, gsl_eigen_symmv_workspace w);

public static class gsl_eigen_herm_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_herm_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_herm_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_herm_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_herm_workspace position(long position) {
        return (gsl_eigen_herm_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_herm_workspace size(long size);
  public native DoublePointer d(); public native gsl_eigen_herm_workspace d(DoublePointer d);
  public native DoublePointer sd(); public native gsl_eigen_herm_workspace sd(DoublePointer sd);
  public native DoublePointer tau(); public native gsl_eigen_herm_workspace tau(DoublePointer tau);
}

public static native gsl_eigen_herm_workspace gsl_eigen_herm_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_herm_free(gsl_eigen_herm_workspace w);
public static native int gsl_eigen_herm(gsl_matrix_complex A, gsl_vector eval,
                         gsl_eigen_herm_workspace w);

public static class gsl_eigen_hermv_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_hermv_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_hermv_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_hermv_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_hermv_workspace position(long position) {
        return (gsl_eigen_hermv_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_hermv_workspace size(long size);
  public native DoublePointer d(); public native gsl_eigen_hermv_workspace d(DoublePointer d);
  public native DoublePointer sd(); public native gsl_eigen_hermv_workspace sd(DoublePointer sd);
  public native DoublePointer tau(); public native gsl_eigen_hermv_workspace tau(DoublePointer tau);
  public native DoublePointer gc(); public native gsl_eigen_hermv_workspace gc(DoublePointer gc);
  public native DoublePointer gs(); public native gsl_eigen_hermv_workspace gs(DoublePointer gs);
}

public static native gsl_eigen_hermv_workspace gsl_eigen_hermv_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_hermv_free(gsl_eigen_hermv_workspace w);
public static native int gsl_eigen_hermv(gsl_matrix_complex A, gsl_vector eval, 
                           gsl_matrix_complex evec,
                           gsl_eigen_hermv_workspace w);

public static class gsl_eigen_francis_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_francis_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_francis_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_francis_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_francis_workspace position(long position) {
        return (gsl_eigen_francis_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_francis_workspace size(long size);           /* matrix size */
  public native @Cast("size_t") long max_iterations(); public native gsl_eigen_francis_workspace max_iterations(long max_iterations); /* max iterations since last eigenvalue found */
  public native @Cast("size_t") long n_iter(); public native gsl_eigen_francis_workspace n_iter(long n_iter);         /* number of iterations since last eigenvalue found */
  public native @Cast("size_t") long n_evals(); public native gsl_eigen_francis_workspace n_evals(long n_evals);        /* number of eigenvalues found so far */

  public native int compute_t(); public native gsl_eigen_francis_workspace compute_t(int compute_t);         /* compute Schur form T = Z^t A Z */

  public native gsl_matrix H(); public native gsl_eigen_francis_workspace H(gsl_matrix H);         /* pointer to Hessenberg matrix */
  public native gsl_matrix Z(); public native gsl_eigen_francis_workspace Z(gsl_matrix Z);         /* pointer to Schur vector matrix */
}

public static native gsl_eigen_francis_workspace gsl_eigen_francis_alloc();
public static native void gsl_eigen_francis_free(gsl_eigen_francis_workspace w);
public static native void gsl_eigen_francis_T(int compute_t,
                          gsl_eigen_francis_workspace w);
public static native int gsl_eigen_francis(gsl_matrix H, gsl_vector_complex eval,
                       gsl_eigen_francis_workspace w);
public static native int gsl_eigen_francis_Z(gsl_matrix H, gsl_vector_complex eval,
                         gsl_matrix Z,
                         gsl_eigen_francis_workspace w);

public static class gsl_eigen_nonsymm_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_nonsymm_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_nonsymm_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_nonsymm_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_nonsymm_workspace position(long position) {
        return (gsl_eigen_nonsymm_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_nonsymm_workspace size(long size);                 /* size of matrices */
  public native gsl_vector diag(); public native gsl_eigen_nonsymm_workspace diag(gsl_vector diag);            /* diagonal matrix elements from balancing */
  public native gsl_vector tau(); public native gsl_eigen_nonsymm_workspace tau(gsl_vector tau);             /* Householder coefficients */
  public native gsl_matrix Z(); public native gsl_eigen_nonsymm_workspace Z(gsl_matrix Z);               /* pointer to Z matrix */
  public native int do_balance(); public native gsl_eigen_nonsymm_workspace do_balance(int do_balance);              /* perform balancing transformation? */
  public native @Cast("size_t") long n_evals(); public native gsl_eigen_nonsymm_workspace n_evals(long n_evals);              /* number of eigenvalues found */

  public native gsl_eigen_francis_workspace francis_workspace_p(); public native gsl_eigen_nonsymm_workspace francis_workspace_p(gsl_eigen_francis_workspace francis_workspace_p);
}

public static native gsl_eigen_nonsymm_workspace gsl_eigen_nonsymm_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_nonsymm_free(gsl_eigen_nonsymm_workspace w);
public static native void gsl_eigen_nonsymm_params(int compute_t, int balance,
                               gsl_eigen_nonsymm_workspace w);
public static native int gsl_eigen_nonsymm(gsl_matrix A, gsl_vector_complex eval,
                       gsl_eigen_nonsymm_workspace w);
public static native int gsl_eigen_nonsymm_Z(gsl_matrix A, gsl_vector_complex eval,
                         gsl_matrix Z, gsl_eigen_nonsymm_workspace w);

public static class gsl_eigen_nonsymmv_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_nonsymmv_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_nonsymmv_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_nonsymmv_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_nonsymmv_workspace position(long position) {
        return (gsl_eigen_nonsymmv_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_nonsymmv_workspace size(long size);                 /* size of matrices */
  public native gsl_vector work(); public native gsl_eigen_nonsymmv_workspace work(gsl_vector work);            /* scratch workspace */
  public native gsl_vector work2(); public native gsl_eigen_nonsymmv_workspace work2(gsl_vector work2);           /* scratch workspace */
  public native gsl_vector work3(); public native gsl_eigen_nonsymmv_workspace work3(gsl_vector work3);           /* scratch workspace */

  public native gsl_matrix Z(); public native gsl_eigen_nonsymmv_workspace Z(gsl_matrix Z);               /* pointer to Schur vectors */

  public native gsl_eigen_nonsymm_workspace nonsymm_workspace_p(); public native gsl_eigen_nonsymmv_workspace nonsymm_workspace_p(gsl_eigen_nonsymm_workspace nonsymm_workspace_p);
}

public static native gsl_eigen_nonsymmv_workspace gsl_eigen_nonsymmv_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_nonsymmv_free(gsl_eigen_nonsymmv_workspace w);
public static native void gsl_eigen_nonsymmv_params(int balance,
                                gsl_eigen_nonsymmv_workspace w);
public static native int gsl_eigen_nonsymmv(gsl_matrix A, gsl_vector_complex eval,
                        gsl_matrix_complex evec,
                        gsl_eigen_nonsymmv_workspace w);
public static native int gsl_eigen_nonsymmv_Z(gsl_matrix A, gsl_vector_complex eval,
                          gsl_matrix_complex evec, gsl_matrix Z,
                          gsl_eigen_nonsymmv_workspace w);

public static class gsl_eigen_gensymm_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_gensymm_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_gensymm_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_gensymm_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_gensymm_workspace position(long position) {
        return (gsl_eigen_gensymm_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_gensymm_workspace size(long size);            /* size of matrices */
  public native gsl_eigen_symm_workspace symm_workspace_p(); public native gsl_eigen_gensymm_workspace symm_workspace_p(gsl_eigen_symm_workspace symm_workspace_p);
}

public static native gsl_eigen_gensymm_workspace gsl_eigen_gensymm_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_gensymm_free(gsl_eigen_gensymm_workspace w);
public static native int gsl_eigen_gensymm(gsl_matrix A, gsl_matrix B,
                       gsl_vector eval, gsl_eigen_gensymm_workspace w);
public static native int gsl_eigen_gensymm_standardize(gsl_matrix A, @Const gsl_matrix B);

public static class gsl_eigen_gensymmv_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_gensymmv_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_gensymmv_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_gensymmv_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_gensymmv_workspace position(long position) {
        return (gsl_eigen_gensymmv_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_gensymmv_workspace size(long size);            /* size of matrices */
  public native gsl_eigen_symmv_workspace symmv_workspace_p(); public native gsl_eigen_gensymmv_workspace symmv_workspace_p(gsl_eigen_symmv_workspace symmv_workspace_p);
}

public static native gsl_eigen_gensymmv_workspace gsl_eigen_gensymmv_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_gensymmv_free(gsl_eigen_gensymmv_workspace w);
public static native int gsl_eigen_gensymmv(gsl_matrix A, gsl_matrix B,
                        gsl_vector eval, gsl_matrix evec,
                        gsl_eigen_gensymmv_workspace w);

public static class gsl_eigen_genherm_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_genherm_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_genherm_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_genherm_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_genherm_workspace position(long position) {
        return (gsl_eigen_genherm_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_genherm_workspace size(long size);            /* size of matrices */
  public native gsl_eigen_herm_workspace herm_workspace_p(); public native gsl_eigen_genherm_workspace herm_workspace_p(gsl_eigen_herm_workspace herm_workspace_p);
}

public static native gsl_eigen_genherm_workspace gsl_eigen_genherm_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_genherm_free(gsl_eigen_genherm_workspace w);
public static native int gsl_eigen_genherm(gsl_matrix_complex A, gsl_matrix_complex B,
                       gsl_vector eval, gsl_eigen_genherm_workspace w);
public static native int gsl_eigen_genherm_standardize(gsl_matrix_complex A,
                                   @Const gsl_matrix_complex B);

public static class gsl_eigen_genhermv_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_genhermv_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_genhermv_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_genhermv_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_genhermv_workspace position(long position) {
        return (gsl_eigen_genhermv_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_genhermv_workspace size(long size);            /* size of matrices */
  public native gsl_eigen_hermv_workspace hermv_workspace_p(); public native gsl_eigen_genhermv_workspace hermv_workspace_p(gsl_eigen_hermv_workspace hermv_workspace_p);
}

public static native gsl_eigen_genhermv_workspace gsl_eigen_genhermv_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_genhermv_free(gsl_eigen_genhermv_workspace w);
public static native int gsl_eigen_genhermv(gsl_matrix_complex A, gsl_matrix_complex B,
                        gsl_vector eval, gsl_matrix_complex evec,
                        gsl_eigen_genhermv_workspace w);

public static class gsl_eigen_gen_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_gen_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_gen_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_gen_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_gen_workspace position(long position) {
        return (gsl_eigen_gen_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_gen_workspace size(long size);            /* size of matrices */
  public native gsl_vector work(); public native gsl_eigen_gen_workspace work(gsl_vector work);       /* scratch workspace */

  public native @Cast("size_t") long n_evals(); public native gsl_eigen_gen_workspace n_evals(long n_evals);         /* number of eigenvalues found */
  public native @Cast("size_t") long max_iterations(); public native gsl_eigen_gen_workspace max_iterations(long max_iterations);  /* maximum QZ iterations allowed */
  public native @Cast("size_t") long n_iter(); public native gsl_eigen_gen_workspace n_iter(long n_iter);          /* number of iterations since last eigenvalue found */
  public native double eshift(); public native gsl_eigen_gen_workspace eshift(double eshift);          /* exceptional shift counter */

  public native int needtop(); public native gsl_eigen_gen_workspace needtop(int needtop);            /* need to compute top index? */

  public native double atol(); public native gsl_eigen_gen_workspace atol(double atol);            /* tolerance for splitting A matrix */
  public native double btol(); public native gsl_eigen_gen_workspace btol(double btol);            /* tolerance for splitting B matrix */

  public native double ascale(); public native gsl_eigen_gen_workspace ascale(double ascale);          /* scaling factor for shifts */
  public native double bscale(); public native gsl_eigen_gen_workspace bscale(double bscale);          /* scaling factor for shifts */

  public native gsl_matrix H(); public native gsl_eigen_gen_workspace H(gsl_matrix H);          /* pointer to hessenberg matrix */
  public native gsl_matrix R(); public native gsl_eigen_gen_workspace R(gsl_matrix R);          /* pointer to upper triangular matrix */

  public native int compute_s(); public native gsl_eigen_gen_workspace compute_s(int compute_s);          /* compute generalized Schur form S */
  public native int compute_t(); public native gsl_eigen_gen_workspace compute_t(int compute_t);          /* compute generalized Schur form T */

  public native gsl_matrix Q(); public native gsl_eigen_gen_workspace Q(gsl_matrix Q);          /* pointer to left Schur vectors */
  public native gsl_matrix Z(); public native gsl_eigen_gen_workspace Z(gsl_matrix Z);          /* pointer to right Schur vectors */
}

public static native gsl_eigen_gen_workspace gsl_eigen_gen_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_gen_free(gsl_eigen_gen_workspace w);
public static native void gsl_eigen_gen_params(int compute_s, int compute_t,
                           int balance, gsl_eigen_gen_workspace w);
public static native int gsl_eigen_gen(gsl_matrix A, gsl_matrix B,
                   gsl_vector_complex alpha, gsl_vector beta,
                   gsl_eigen_gen_workspace w);
public static native int gsl_eigen_gen_QZ(gsl_matrix A, gsl_matrix B,
                      gsl_vector_complex alpha, gsl_vector beta,
                      gsl_matrix Q, gsl_matrix Z,
                      gsl_eigen_gen_workspace w);

public static class gsl_eigen_genv_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_eigen_genv_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_eigen_genv_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_eigen_genv_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_eigen_genv_workspace position(long position) {
        return (gsl_eigen_genv_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_eigen_genv_workspace size(long size);            /* size of matrices */

  public native gsl_vector work1(); public native gsl_eigen_genv_workspace work1(gsl_vector work1);      /* 1-norm of columns of A */
  public native gsl_vector work2(); public native gsl_eigen_genv_workspace work2(gsl_vector work2);      /* 1-norm of columns of B */
  public native gsl_vector work3(); public native gsl_eigen_genv_workspace work3(gsl_vector work3);      /* real part of eigenvector */
  public native gsl_vector work4(); public native gsl_eigen_genv_workspace work4(gsl_vector work4);      /* imag part of eigenvector */
  public native gsl_vector work5(); public native gsl_eigen_genv_workspace work5(gsl_vector work5);      /* real part of back-transformed eigenvector */
  public native gsl_vector work6(); public native gsl_eigen_genv_workspace work6(gsl_vector work6);      /* imag part of back-transformed eigenvector */

  public native gsl_matrix Q(); public native gsl_eigen_genv_workspace Q(gsl_matrix Q);          /* pointer to left Schur vectors */
  public native gsl_matrix Z(); public native gsl_eigen_genv_workspace Z(gsl_matrix Z);          /* pointer to right Schur vectors */

  public native gsl_eigen_gen_workspace gen_workspace_p(); public native gsl_eigen_genv_workspace gen_workspace_p(gsl_eigen_gen_workspace gen_workspace_p);
}

public static native gsl_eigen_genv_workspace gsl_eigen_genv_alloc(@Cast("const size_t") long n);
public static native void gsl_eigen_genv_free(gsl_eigen_genv_workspace w);
public static native int gsl_eigen_genv(gsl_matrix A, gsl_matrix B,
                    gsl_vector_complex alpha, gsl_vector beta,
                    gsl_matrix_complex evec,
                    gsl_eigen_genv_workspace w);
public static native int gsl_eigen_genv_QZ(gsl_matrix A, gsl_matrix B,
                       gsl_vector_complex alpha, gsl_vector beta,
                       gsl_matrix_complex evec,
                       gsl_matrix Q, gsl_matrix Z,
                       gsl_eigen_genv_workspace w);



/** enum gsl_eigen_sort_t */
public static final int
  GSL_EIGEN_SORT_VAL_ASC = 0,
  GSL_EIGEN_SORT_VAL_DESC = 1,
  GSL_EIGEN_SORT_ABS_ASC = 2,
  GSL_EIGEN_SORT_ABS_DESC = 3;

/* Sort eigensystem results based on eigenvalues.
 * Sorts in order of increasing value or increasing
 * absolute value.
 *
 * exceptions: GSL_EBADLEN
 */

public static native int gsl_eigen_symmv_sort(gsl_vector eval, gsl_matrix evec,
                         @Cast("gsl_eigen_sort_t") int sort_type);

public static native int gsl_eigen_hermv_sort(gsl_vector eval, gsl_matrix_complex evec,
                         @Cast("gsl_eigen_sort_t") int sort_type);

public static native int gsl_eigen_nonsymmv_sort(gsl_vector_complex eval,
                            gsl_matrix_complex evec,
                            @Cast("gsl_eigen_sort_t") int sort_type);

public static native int gsl_eigen_gensymmv_sort(gsl_vector eval, gsl_matrix evec, 
                             @Cast("gsl_eigen_sort_t") int sort_type);

public static native int gsl_eigen_genhermv_sort(gsl_vector eval, gsl_matrix_complex evec, 
                             @Cast("gsl_eigen_sort_t") int sort_type);

public static native int gsl_eigen_genv_sort(gsl_vector_complex alpha, gsl_vector beta,
                         gsl_matrix_complex evec,
                         @Cast("gsl_eigen_sort_t") int sort_type);

/* Prototypes for the schur module */

public static native int gsl_schur_gen_eigvals(@Const gsl_matrix A, @Const gsl_matrix B,
                          DoublePointer wr1, DoublePointer wr2, DoublePointer wi,
                          DoublePointer scale1, DoublePointer scale2);
public static native int gsl_schur_gen_eigvals(@Const gsl_matrix A, @Const gsl_matrix B,
                          DoubleBuffer wr1, DoubleBuffer wr2, DoubleBuffer wi,
                          DoubleBuffer scale1, DoubleBuffer scale2);
public static native int gsl_schur_gen_eigvals(@Const gsl_matrix A, @Const gsl_matrix B,
                          double[] wr1, double[] wr2, double[] wi,
                          double[] scale1, double[] scale2);

public static native int gsl_schur_solve_equation(double ca, @Const gsl_matrix A, double z,
                             double d1, double d2, @Const gsl_vector b,
                             gsl_vector x, DoublePointer s, DoublePointer xnorm,
                             double smin);
public static native int gsl_schur_solve_equation(double ca, @Const gsl_matrix A, double z,
                             double d1, double d2, @Const gsl_vector b,
                             gsl_vector x, DoubleBuffer s, DoubleBuffer xnorm,
                             double smin);
public static native int gsl_schur_solve_equation(double ca, @Const gsl_matrix A, double z,
                             double d1, double d2, @Const gsl_vector b,
                             gsl_vector x, double[] s, double[] xnorm,
                             double smin);

public static native int gsl_schur_solve_equation_z(double ca, @Const gsl_matrix A,
                               gsl_complex z, double d1, double d2,
                               @Const gsl_vector_complex b,
                               gsl_vector_complex x, DoublePointer s,
                               DoublePointer xnorm, double smin);
public static native int gsl_schur_solve_equation_z(double ca, @Const gsl_matrix A,
                               gsl_complex z, double d1, double d2,
                               @Const gsl_vector_complex b,
                               gsl_vector_complex x, DoubleBuffer s,
                               DoubleBuffer xnorm, double smin);
public static native int gsl_schur_solve_equation_z(double ca, @Const gsl_matrix A,
                               gsl_complex z, double d1, double d2,
                               @Const gsl_vector_complex b,
                               gsl_vector_complex x, double[] s,
                               double[] xnorm, double smin);


/* The following functions are obsolete: */

/* Eigensolve by Jacobi Method
 *
 * The data in the matrix input is destroyed.
 *
 * exceptions: 
 */
public static native int gsl_eigen_jacobi(gsl_matrix matrix,
                      gsl_vector eval,
                      gsl_matrix evec,
                      @Cast("unsigned int") int max_rot, 
                      @Cast("unsigned int*") IntPointer nrot);
public static native int gsl_eigen_jacobi(gsl_matrix matrix,
                      gsl_vector eval,
                      gsl_matrix evec,
                      @Cast("unsigned int") int max_rot, 
                      @Cast("unsigned int*") IntBuffer nrot);
public static native int gsl_eigen_jacobi(gsl_matrix matrix,
                      gsl_vector eval,
                      gsl_matrix evec,
                      @Cast("unsigned int") int max_rot, 
                      @Cast("unsigned int*") int[] nrot);


/* Invert by Jacobi Method
 *
 * exceptions: 
 */
public static native int gsl_eigen_invert_jacobi(@Const gsl_matrix matrix,
                             gsl_matrix ainv,
                             @Cast("unsigned int") int max_rot);

// #endif /* __GSL_EIGEN_H__ */


// Parsed from gsl/gsl_fit.h

/* fit/gsl_fit.h
 * 
 * Copyright (C) 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_FIT_H__
// #define __GSL_FIT_H__

// #include <stdlib.h>
// #include <gsl/gsl_math.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_fit_linear(@Const DoublePointer x, @Cast("const size_t") long xstride,
                    @Const DoublePointer y, @Cast("const size_t") long ystride,
                    @Cast("const size_t") long n,
                    DoublePointer c0, DoublePointer c1, 
                    DoublePointer cov00, DoublePointer cov01, DoublePointer cov11, 
                    DoublePointer sumsq);
public static native int gsl_fit_linear(@Const DoubleBuffer x, @Cast("const size_t") long xstride,
                    @Const DoubleBuffer y, @Cast("const size_t") long ystride,
                    @Cast("const size_t") long n,
                    DoubleBuffer c0, DoubleBuffer c1, 
                    DoubleBuffer cov00, DoubleBuffer cov01, DoubleBuffer cov11, 
                    DoubleBuffer sumsq);
public static native int gsl_fit_linear(@Const double[] x, @Cast("const size_t") long xstride,
                    @Const double[] y, @Cast("const size_t") long ystride,
                    @Cast("const size_t") long n,
                    double[] c0, double[] c1, 
                    double[] cov00, double[] cov01, double[] cov11, 
                    double[] sumsq);


public static native int gsl_fit_wlinear(@Const DoublePointer x, @Cast("const size_t") long xstride,
                     @Const DoublePointer w, @Cast("const size_t") long wstride,
                     @Const DoublePointer y, @Cast("const size_t") long ystride,
                     @Cast("const size_t") long n,
                     DoublePointer c0, DoublePointer c1, 
                     DoublePointer cov00, DoublePointer cov01, DoublePointer cov11, 
                     DoublePointer chisq);
public static native int gsl_fit_wlinear(@Const DoubleBuffer x, @Cast("const size_t") long xstride,
                     @Const DoubleBuffer w, @Cast("const size_t") long wstride,
                     @Const DoubleBuffer y, @Cast("const size_t") long ystride,
                     @Cast("const size_t") long n,
                     DoubleBuffer c0, DoubleBuffer c1, 
                     DoubleBuffer cov00, DoubleBuffer cov01, DoubleBuffer cov11, 
                     DoubleBuffer chisq);
public static native int gsl_fit_wlinear(@Const double[] x, @Cast("const size_t") long xstride,
                     @Const double[] w, @Cast("const size_t") long wstride,
                     @Const double[] y, @Cast("const size_t") long ystride,
                     @Cast("const size_t") long n,
                     double[] c0, double[] c1, 
                     double[] cov00, double[] cov01, double[] cov11, 
                     double[] chisq);

public static native int gsl_fit_linear_est(double x, 
                    double c0, double c1, 
                    double cov00, double cov01, double cov11,
                    DoublePointer y, DoublePointer y_err);
public static native int gsl_fit_linear_est(double x, 
                    double c0, double c1, 
                    double cov00, double cov01, double cov11,
                    DoubleBuffer y, DoubleBuffer y_err);
public static native int gsl_fit_linear_est(double x, 
                    double c0, double c1, 
                    double cov00, double cov01, double cov11,
                    double[] y, double[] y_err);


public static native int gsl_fit_mul(@Const DoublePointer x, @Cast("const size_t") long xstride,
                 @Const DoublePointer y, @Cast("const size_t") long ystride,
                 @Cast("const size_t") long n,
                 DoublePointer c1, 
                 DoublePointer cov11, 
                 DoublePointer sumsq);
public static native int gsl_fit_mul(@Const DoubleBuffer x, @Cast("const size_t") long xstride,
                 @Const DoubleBuffer y, @Cast("const size_t") long ystride,
                 @Cast("const size_t") long n,
                 DoubleBuffer c1, 
                 DoubleBuffer cov11, 
                 DoubleBuffer sumsq);
public static native int gsl_fit_mul(@Const double[] x, @Cast("const size_t") long xstride,
                 @Const double[] y, @Cast("const size_t") long ystride,
                 @Cast("const size_t") long n,
                 double[] c1, 
                 double[] cov11, 
                 double[] sumsq);

public static native int gsl_fit_wmul(@Const DoublePointer x, @Cast("const size_t") long xstride,
                  @Const DoublePointer w, @Cast("const size_t") long wstride,
                  @Const DoublePointer y, @Cast("const size_t") long ystride,
                  @Cast("const size_t") long n,
                  DoublePointer c1, 
                  DoublePointer cov11, 
                  DoublePointer sumsq);
public static native int gsl_fit_wmul(@Const DoubleBuffer x, @Cast("const size_t") long xstride,
                  @Const DoubleBuffer w, @Cast("const size_t") long wstride,
                  @Const DoubleBuffer y, @Cast("const size_t") long ystride,
                  @Cast("const size_t") long n,
                  DoubleBuffer c1, 
                  DoubleBuffer cov11, 
                  DoubleBuffer sumsq);
public static native int gsl_fit_wmul(@Const double[] x, @Cast("const size_t") long xstride,
                  @Const double[] w, @Cast("const size_t") long wstride,
                  @Const double[] y, @Cast("const size_t") long ystride,
                  @Cast("const size_t") long n,
                  double[] c1, 
                  double[] cov11, 
                  double[] sumsq);


public static native int gsl_fit_mul_est(double x, 
                 double c1, 
                 double cov11,
                 DoublePointer y, DoublePointer y_err);
public static native int gsl_fit_mul_est(double x, 
                 double c1, 
                 double cov11,
                 DoubleBuffer y, DoubleBuffer y_err);
public static native int gsl_fit_mul_est(double x, 
                 double c1, 
                 double cov11,
                 double[] y, double[] y_err);

// #endif /* __GSL_FIT_H__ */


// Parsed from gsl/gsl_permutation.h

/* permutation/gsl_permutation.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTATION_H__
// #define __GSL_PERMUTATION_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_permutation_struct") public static class gsl_permutation extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_permutation() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_permutation(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_permutation(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_permutation position(long position) {
        return (gsl_permutation)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_permutation size(long size);
  public native @Cast("size_t*") SizeTPointer data(); public native gsl_permutation data(SizeTPointer data);
}

public static native gsl_permutation gsl_permutation_alloc(@Cast("const size_t") long n);
public static native gsl_permutation gsl_permutation_calloc(@Cast("const size_t") long n);
public static native void gsl_permutation_init(gsl_permutation p);
public static native void gsl_permutation_free(gsl_permutation p);
public static native int gsl_permutation_memcpy(gsl_permutation dest, @Const gsl_permutation src);

public static native int gsl_permutation_fread(@Cast("FILE*") Pointer stream, gsl_permutation p);
public static native int gsl_permutation_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_permutation p);
public static native int gsl_permutation_fscanf(@Cast("FILE*") Pointer stream, gsl_permutation p);
public static native int gsl_permutation_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_permutation p, @Cast("const char*") BytePointer format);
public static native int gsl_permutation_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_permutation p, String format);

public static native @Cast("size_t") long gsl_permutation_size(@Const gsl_permutation p);
public static native @Cast("size_t*") SizeTPointer gsl_permutation_data(@Const gsl_permutation p);

public static native int gsl_permutation_swap(gsl_permutation p, @Cast("const size_t") long i, @Cast("const size_t") long j);

public static native int gsl_permutation_valid(@Const gsl_permutation p);
public static native void gsl_permutation_reverse(gsl_permutation p);
public static native int gsl_permutation_inverse(gsl_permutation inv, @Const gsl_permutation p);
public static native int gsl_permutation_next(gsl_permutation p);
public static native int gsl_permutation_prev(gsl_permutation p);
public static native int gsl_permutation_mul(gsl_permutation p, @Const gsl_permutation pa, @Const gsl_permutation pb);

public static native int gsl_permutation_linear_to_canonical(gsl_permutation q, @Const gsl_permutation p);
public static native int gsl_permutation_canonical_to_linear(gsl_permutation p, @Const gsl_permutation q);

public static native @Cast("size_t") long gsl_permutation_inversions(@Const gsl_permutation p);
public static native @Cast("size_t") long gsl_permutation_linear_cycles(@Const gsl_permutation p);
public static native @Cast("size_t") long gsl_permutation_canonical_cycles(@Const gsl_permutation q);

/* */ public static native @Cast("size_t") long gsl_permutation_get(@Const gsl_permutation p, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE

// #endif /* HAVE_INLINE */

// #endif /* __GSL_PERMUTATION_H__ */


// Parsed from gsl/gsl_heapsort.h

/* sort/gsl_heapsort.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_HEAPSORT_H__
// #define __GSL_HEAPSORT_H__

// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_comparison_fn_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_comparison_fn_t(Pointer p) { super(p); }
    protected gsl_comparison_fn_t() { allocate(); }
    private native void allocate();
    public native int call(@Const Pointer arg0, @Const Pointer arg1);
}

public static native void gsl_heapsort(Pointer array, @Cast("size_t") long count, @Cast("size_t") long size, gsl_comparison_fn_t compare);
public static native int gsl_heapsort_index(@Cast("size_t*") SizeTPointer p, @Const Pointer array, @Cast("size_t") long count, @Cast("size_t") long size, gsl_comparison_fn_t compare);

// #endif /* __GSL_HEAPSORT_H__ */


// Parsed from gsl/gsl_histogram2d.h

/* histogram/gsl_histogram2d.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_HISTOGRAM2D_H__
// #define __GSL_HISTOGRAM2D_H__

// #include <stdlib.h>
// #include <stdio.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

 public static class gsl_histogram2d extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_histogram2d() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_histogram2d(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_histogram2d(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_histogram2d position(long position) {
        return (gsl_histogram2d)super.position(position);
    }

  public native @Cast("size_t") long nx(); public native gsl_histogram2d nx(long nx);
  public native @Cast("size_t") long ny(); public native gsl_histogram2d ny(long ny);
  public native DoublePointer xrange(); public native gsl_histogram2d xrange(DoublePointer xrange);
  public native DoublePointer yrange(); public native gsl_histogram2d yrange(DoublePointer yrange);
  public native DoublePointer bin(); public native gsl_histogram2d bin(DoublePointer bin);
} 

 public static class gsl_histogram2d_pdf extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_histogram2d_pdf() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_histogram2d_pdf(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_histogram2d_pdf(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_histogram2d_pdf position(long position) {
        return (gsl_histogram2d_pdf)super.position(position);
    }

  public native @Cast("size_t") long nx(); public native gsl_histogram2d_pdf nx(long nx);
  public native @Cast("size_t") long ny(); public native gsl_histogram2d_pdf ny(long ny);
  public native DoublePointer xrange(); public native gsl_histogram2d_pdf xrange(DoublePointer xrange);
  public native DoublePointer yrange(); public native gsl_histogram2d_pdf yrange(DoublePointer yrange);
  public native DoublePointer sum(); public native gsl_histogram2d_pdf sum(DoublePointer sum);
} 

public static native gsl_histogram2d gsl_histogram2d_alloc(@Cast("const size_t") long nx, @Cast("const size_t") long ny);
public static native gsl_histogram2d gsl_histogram2d_calloc(@Cast("const size_t") long nx, @Cast("const size_t") long ny);
public static native gsl_histogram2d gsl_histogram2d_calloc_uniform(@Cast("const size_t") long nx, @Cast("const size_t") long ny,
                                             double xmin, double xmax,
                                             double ymin, double ymax);

public static native void gsl_histogram2d_free(gsl_histogram2d h);

public static native int gsl_histogram2d_increment(gsl_histogram2d h, double x, double y);
public static native int gsl_histogram2d_accumulate(gsl_histogram2d h, 
                                double x, double y, double weight);
public static native int gsl_histogram2d_find(@Const gsl_histogram2d h, 
                          double x, double y, @Cast("size_t*") SizeTPointer i, @Cast("size_t*") SizeTPointer j);

public static native double gsl_histogram2d_get(@Const gsl_histogram2d h, @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_histogram2d_get_xrange(@Const gsl_histogram2d h, @Cast("const size_t") long i,
                                DoublePointer xlower, DoublePointer xupper);
public static native int gsl_histogram2d_get_xrange(@Const gsl_histogram2d h, @Cast("const size_t") long i,
                                DoubleBuffer xlower, DoubleBuffer xupper);
public static native int gsl_histogram2d_get_xrange(@Const gsl_histogram2d h, @Cast("const size_t") long i,
                                double[] xlower, double[] xupper);
public static native int gsl_histogram2d_get_yrange(@Const gsl_histogram2d h, @Cast("const size_t") long j,
                                DoublePointer ylower, DoublePointer yupper);
public static native int gsl_histogram2d_get_yrange(@Const gsl_histogram2d h, @Cast("const size_t") long j,
                                DoubleBuffer ylower, DoubleBuffer yupper);
public static native int gsl_histogram2d_get_yrange(@Const gsl_histogram2d h, @Cast("const size_t") long j,
                                double[] ylower, double[] yupper);

                                     
public static native double gsl_histogram2d_xmax(@Const gsl_histogram2d h);
public static native double gsl_histogram2d_xmin(@Const gsl_histogram2d h);
public static native @Cast("size_t") long gsl_histogram2d_nx(@Const gsl_histogram2d h);

public static native double gsl_histogram2d_ymax(@Const gsl_histogram2d h);
public static native double gsl_histogram2d_ymin(@Const gsl_histogram2d h);
public static native @Cast("size_t") long gsl_histogram2d_ny(@Const gsl_histogram2d h);

public static native void gsl_histogram2d_reset(gsl_histogram2d h);

public static native gsl_histogram2d gsl_histogram2d_calloc_range(@Cast("size_t") long nx, @Cast("size_t") long ny, 
                             DoublePointer xrange, DoublePointer yrange);
public static native gsl_histogram2d gsl_histogram2d_calloc_range(@Cast("size_t") long nx, @Cast("size_t") long ny, 
                             DoubleBuffer xrange, DoubleBuffer yrange);
public static native gsl_histogram2d gsl_histogram2d_calloc_range(@Cast("size_t") long nx, @Cast("size_t") long ny, 
                             double[] xrange, double[] yrange);

public static native int gsl_histogram2d_set_ranges_uniform(gsl_histogram2d h, 
                                    double xmin, double xmax,
                                    double ymin, double ymax);

public static native int gsl_histogram2d_set_ranges(gsl_histogram2d h, 
                            @Const DoublePointer xrange, @Cast("size_t") long xsize,
                            @Const DoublePointer yrange, @Cast("size_t") long ysize);
public static native int gsl_histogram2d_set_ranges(gsl_histogram2d h, 
                            @Const DoubleBuffer xrange, @Cast("size_t") long xsize,
                            @Const DoubleBuffer yrange, @Cast("size_t") long ysize);
public static native int gsl_histogram2d_set_ranges(gsl_histogram2d h, 
                            @Const double[] xrange, @Cast("size_t") long xsize,
                            @Const double[] yrange, @Cast("size_t") long ysize);

public static native int gsl_histogram2d_memcpy(gsl_histogram2d dest, @Const gsl_histogram2d source);

public static native gsl_histogram2d gsl_histogram2d_clone(@Const gsl_histogram2d source);

public static native double gsl_histogram2d_max_val(@Const gsl_histogram2d h);

public static native void gsl_histogram2d_max_bin(@Const gsl_histogram2d h, @Cast("size_t*") SizeTPointer i, @Cast("size_t*") SizeTPointer j);

public static native double gsl_histogram2d_min_val(@Const gsl_histogram2d h);

public static native void gsl_histogram2d_min_bin(@Const gsl_histogram2d h, @Cast("size_t*") SizeTPointer i, @Cast("size_t*") SizeTPointer j);

public static native double gsl_histogram2d_xmean(@Const gsl_histogram2d h);

public static native double gsl_histogram2d_ymean(@Const gsl_histogram2d h);

public static native double gsl_histogram2d_xsigma(@Const gsl_histogram2d h);

public static native double gsl_histogram2d_ysigma(@Const gsl_histogram2d h);

public static native double gsl_histogram2d_cov(@Const gsl_histogram2d h);

public static native double gsl_histogram2d_sum(@Const gsl_histogram2d h);

public static native int gsl_histogram2d_equal_bins_p(@Const gsl_histogram2d h1,
                             @Const gsl_histogram2d h2);

public static native int gsl_histogram2d_add(gsl_histogram2d h1, @Const gsl_histogram2d h2);

public static native int gsl_histogram2d_sub(gsl_histogram2d h1, @Const gsl_histogram2d h2);

public static native int gsl_histogram2d_mul(gsl_histogram2d h1, @Const gsl_histogram2d h2);

public static native int gsl_histogram2d_div(gsl_histogram2d h1, @Const gsl_histogram2d h2);

public static native int gsl_histogram2d_scale(gsl_histogram2d h, double scale);

public static native int gsl_histogram2d_shift(gsl_histogram2d h, double shift);

public static native int gsl_histogram2d_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_histogram2d h);
public static native int gsl_histogram2d_fread(@Cast("FILE*") Pointer stream, gsl_histogram2d h);
public static native int gsl_histogram2d_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_histogram2d h, 
                             @Cast("const char*") BytePointer range_format,
                             @Cast("const char*") BytePointer bin_format);
public static native int gsl_histogram2d_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_histogram2d h, 
                             String range_format,
                             String bin_format);
public static native int gsl_histogram2d_fscanf(@Cast("FILE*") Pointer stream, gsl_histogram2d h);

public static native gsl_histogram2d_pdf gsl_histogram2d_pdf_alloc(@Cast("const size_t") long nx, @Cast("const size_t") long ny);
public static native int gsl_histogram2d_pdf_init(gsl_histogram2d_pdf p, @Const gsl_histogram2d h);
public static native void gsl_histogram2d_pdf_free(gsl_histogram2d_pdf p);
public static native int gsl_histogram2d_pdf_sample(@Const gsl_histogram2d_pdf p, 
                                   double r1, double r2, 
                                   DoublePointer x, DoublePointer y);
public static native int gsl_histogram2d_pdf_sample(@Const gsl_histogram2d_pdf p, 
                                   double r1, double r2, 
                                   DoubleBuffer x, DoubleBuffer y);
public static native int gsl_histogram2d_pdf_sample(@Const gsl_histogram2d_pdf p, 
                                   double r1, double r2, 
                                   double[] x, double[] y);

// #endif /* __GSL_HISTOGRAM2D_H__ */



// Parsed from gsl/gsl_histogram.h

/* histogram/gsl_histogram.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_HISTOGRAM_H__
// #define __GSL_HISTOGRAM_H__

// #include <stdlib.h>
// #include <stdio.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

 public static class gsl_histogram extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_histogram() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_histogram(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_histogram(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_histogram position(long position) {
        return (gsl_histogram)super.position(position);
    }

  public native @Cast("size_t") long n(); public native gsl_histogram n(long n);
  public native DoublePointer range(); public native gsl_histogram range(DoublePointer range);
  public native DoublePointer bin(); public native gsl_histogram bin(DoublePointer bin);
} 

 public static class gsl_histogram_pdf extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_histogram_pdf() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_histogram_pdf(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_histogram_pdf(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_histogram_pdf position(long position) {
        return (gsl_histogram_pdf)super.position(position);
    }

  public native @Cast("size_t") long n(); public native gsl_histogram_pdf n(long n);
  public native DoublePointer range(); public native gsl_histogram_pdf range(DoublePointer range);
  public native DoublePointer sum(); public native gsl_histogram_pdf sum(DoublePointer sum);
} 

public static native gsl_histogram gsl_histogram_alloc(@Cast("size_t") long n);

public static native gsl_histogram gsl_histogram_calloc(@Cast("size_t") long n);
public static native gsl_histogram gsl_histogram_calloc_uniform(@Cast("const size_t") long n, double xmin, double xmax);
public static native void gsl_histogram_free(gsl_histogram h);
public static native int gsl_histogram_increment(gsl_histogram h, double x);
public static native int gsl_histogram_accumulate(gsl_histogram h, double x, double weight);
public static native int gsl_histogram_find(@Const gsl_histogram h, 
                        double x, @Cast("size_t*") SizeTPointer i);

public static native double gsl_histogram_get(@Const gsl_histogram h, @Cast("size_t") long i);
public static native int gsl_histogram_get_range(@Const gsl_histogram h, @Cast("size_t") long i, 
                             DoublePointer lower, DoublePointer upper);
public static native int gsl_histogram_get_range(@Const gsl_histogram h, @Cast("size_t") long i, 
                             DoubleBuffer lower, DoubleBuffer upper);
public static native int gsl_histogram_get_range(@Const gsl_histogram h, @Cast("size_t") long i, 
                             double[] lower, double[] upper);
                                     
public static native double gsl_histogram_max(@Const gsl_histogram h);
public static native double gsl_histogram_min(@Const gsl_histogram h);
public static native @Cast("size_t") long gsl_histogram_bins(@Const gsl_histogram h);

public static native void gsl_histogram_reset(gsl_histogram h);

public static native gsl_histogram gsl_histogram_calloc_range(@Cast("size_t") long n, DoublePointer range);
public static native gsl_histogram gsl_histogram_calloc_range(@Cast("size_t") long n, DoubleBuffer range);
public static native gsl_histogram gsl_histogram_calloc_range(@Cast("size_t") long n, double[] range);

public static native int gsl_histogram_set_ranges(gsl_histogram h, @Const DoublePointer range, @Cast("size_t") long size);
public static native int gsl_histogram_set_ranges(gsl_histogram h, @Const DoubleBuffer range, @Cast("size_t") long size);
public static native int gsl_histogram_set_ranges(gsl_histogram h, @Const double[] range, @Cast("size_t") long size);
public static native int gsl_histogram_set_ranges_uniform(gsl_histogram h, double xmin, double xmax);



public static native int gsl_histogram_memcpy(gsl_histogram dest, @Const gsl_histogram source);

public static native gsl_histogram gsl_histogram_clone(@Const gsl_histogram source);

public static native double gsl_histogram_max_val(@Const gsl_histogram h);

public static native @Cast("size_t") long gsl_histogram_max_bin(@Const gsl_histogram h);

public static native double gsl_histogram_min_val(@Const gsl_histogram h);

public static native @Cast("size_t") long gsl_histogram_min_bin(@Const gsl_histogram h);

public static native int gsl_histogram_equal_bins_p(@Const gsl_histogram h1, @Const gsl_histogram h2);

public static native int gsl_histogram_add(gsl_histogram h1, @Const gsl_histogram h2);

public static native int gsl_histogram_sub(gsl_histogram h1, @Const gsl_histogram h2);

public static native int gsl_histogram_mul(gsl_histogram h1, @Const gsl_histogram h2);
 
public static native int gsl_histogram_div(gsl_histogram h1, @Const gsl_histogram h2);

public static native int gsl_histogram_scale(gsl_histogram h, double scale);

public static native int gsl_histogram_shift(gsl_histogram h, double shift);


public static native double gsl_histogram_sigma(@Const gsl_histogram h);

public static native double gsl_histogram_mean(@Const gsl_histogram h);

public static native double gsl_histogram_sum(@Const gsl_histogram h);

public static native int gsl_histogram_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_histogram h);
public static native int gsl_histogram_fread(@Cast("FILE*") Pointer stream, gsl_histogram h);
public static native int gsl_histogram_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_histogram h, 
                           @Cast("const char*") BytePointer range_format, @Cast("const char*") BytePointer bin_format);
public static native int gsl_histogram_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_histogram h, 
                           String range_format, String bin_format);
public static native int gsl_histogram_fscanf(@Cast("FILE*") Pointer stream, gsl_histogram h);

public static native gsl_histogram_pdf gsl_histogram_pdf_alloc(@Cast("const size_t") long n);
public static native int gsl_histogram_pdf_init(gsl_histogram_pdf p, @Const gsl_histogram h);
public static native void gsl_histogram_pdf_free(gsl_histogram_pdf p);
public static native double gsl_histogram_pdf_sample(@Const gsl_histogram_pdf p, double r);

// #endif /* __GSL_HISTOGRAM_H__ */


// Parsed from gsl/gsl_integration.h

/* integration/gsl_integration.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_INTEGRATION_H__
// #define __GSL_INTEGRATION_H__
// #include <stdlib.h>
// #include <gsl/gsl_math.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* Workspace for adaptive integrators */

public static class gsl_integration_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_integration_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_integration_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_integration_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_integration_workspace position(long position) {
        return (gsl_integration_workspace)super.position(position);
    }

    public native @Cast("size_t") @Name("limit") long _limit(); public native gsl_integration_workspace _limit(long _limit);
    public native @Cast("size_t") long size(); public native gsl_integration_workspace size(long size);
    public native @Cast("size_t") long nrmax(); public native gsl_integration_workspace nrmax(long nrmax);
    public native @Cast("size_t") long i(); public native gsl_integration_workspace i(long i);
    public native @Cast("size_t") long maximum_level(); public native gsl_integration_workspace maximum_level(long maximum_level);
    public native DoublePointer alist(); public native gsl_integration_workspace alist(DoublePointer alist);
    public native DoublePointer blist(); public native gsl_integration_workspace blist(DoublePointer blist);
    public native DoublePointer rlist(); public native gsl_integration_workspace rlist(DoublePointer rlist);
    public native DoublePointer elist(); public native gsl_integration_workspace elist(DoublePointer elist);
    public native @Cast("size_t*") SizeTPointer order(); public native gsl_integration_workspace order(SizeTPointer order);
    public native @Cast("size_t*") SizeTPointer level(); public native gsl_integration_workspace level(SizeTPointer level);
  }

public static native gsl_integration_workspace gsl_integration_workspace_alloc(@Cast("const size_t") long n);

public static native void gsl_integration_workspace_free(gsl_integration_workspace w);


/* Workspace for QAWS integrator */

public static class gsl_integration_qaws_table extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_integration_qaws_table() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_integration_qaws_table(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_integration_qaws_table(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_integration_qaws_table position(long position) {
        return (gsl_integration_qaws_table)super.position(position);
    }

  public native double alpha(); public native gsl_integration_qaws_table alpha(double alpha);
  public native double beta(); public native gsl_integration_qaws_table beta(double beta);
  public native int mu(); public native gsl_integration_qaws_table mu(int mu);
  public native int nu(); public native gsl_integration_qaws_table nu(int nu);
  public native double ri(int i); public native gsl_integration_qaws_table ri(int i, double ri);
  @MemberGetter public native DoublePointer ri();
  public native double rj(int i); public native gsl_integration_qaws_table rj(int i, double rj);
  @MemberGetter public native DoublePointer rj();
  public native double rg(int i); public native gsl_integration_qaws_table rg(int i, double rg);
  @MemberGetter public native DoublePointer rg();
  public native double rh(int i); public native gsl_integration_qaws_table rh(int i, double rh);
  @MemberGetter public native DoublePointer rh();
}

public static native gsl_integration_qaws_table gsl_integration_qaws_table_alloc(double alpha, double beta, int mu, int nu);

public static native int gsl_integration_qaws_table_set(gsl_integration_qaws_table t,
                                double alpha, double beta, int mu, int nu);

public static native void gsl_integration_qaws_table_free(gsl_integration_qaws_table t);

/* Workspace for QAWO integrator */

/** enum gsl_integration_qawo_enum */
public static final int GSL_INTEG_COSINE = 0, GSL_INTEG_SINE = 1;

public static class gsl_integration_qawo_table extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_integration_qawo_table() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_integration_qawo_table(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_integration_qawo_table(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_integration_qawo_table position(long position) {
        return (gsl_integration_qawo_table)super.position(position);
    }

  public native @Cast("size_t") long n(); public native gsl_integration_qawo_table n(long n);
  public native double omega(); public native gsl_integration_qawo_table omega(double omega);
  public native double L(); public native gsl_integration_qawo_table L(double L);
  public native double par(); public native gsl_integration_qawo_table par(double par);
  public native @Cast("gsl_integration_qawo_enum") int sine(); public native gsl_integration_qawo_table sine(int sine);
  public native DoublePointer chebmo(); public native gsl_integration_qawo_table chebmo(DoublePointer chebmo);
}

public static native gsl_integration_qawo_table gsl_integration_qawo_table_alloc(double omega, double L, 
                                  @Cast("gsl_integration_qawo_enum") int sine,
                                  @Cast("size_t") long n);

public static native int gsl_integration_qawo_table_set(gsl_integration_qawo_table t,
                                double omega, double L,
                                @Cast("gsl_integration_qawo_enum") int sine);

public static native int gsl_integration_qawo_table_set_length(gsl_integration_qawo_table t,
                                       double L);

public static native void gsl_integration_qawo_table_free(gsl_integration_qawo_table t);


/* Definition of an integration rule */

public static class gsl_integration_rule extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_integration_rule(Pointer p) { super(p); }
    protected gsl_integration_rule() { allocate(); }
    private native void allocate();
    public native void call(@Const gsl_function f,
                                   double a, double b,
                                   DoublePointer result, DoublePointer abserr,
                                   DoublePointer defabs, DoublePointer resabs);
}

public static native void gsl_integration_qk15(@Const gsl_function f, double a, double b,
                           DoublePointer result, DoublePointer abserr,
                           DoublePointer resabs, DoublePointer resasc);
public static native void gsl_integration_qk15(@Const gsl_function f, double a, double b,
                           DoubleBuffer result, DoubleBuffer abserr,
                           DoubleBuffer resabs, DoubleBuffer resasc);
public static native void gsl_integration_qk15(@Const gsl_function f, double a, double b,
                           double[] result, double[] abserr,
                           double[] resabs, double[] resasc);

public static native void gsl_integration_qk21(@Const gsl_function f, double a, double b,
                           DoublePointer result, DoublePointer abserr,
                           DoublePointer resabs, DoublePointer resasc);
public static native void gsl_integration_qk21(@Const gsl_function f, double a, double b,
                           DoubleBuffer result, DoubleBuffer abserr,
                           DoubleBuffer resabs, DoubleBuffer resasc);
public static native void gsl_integration_qk21(@Const gsl_function f, double a, double b,
                           double[] result, double[] abserr,
                           double[] resabs, double[] resasc);

public static native void gsl_integration_qk31(@Const gsl_function f, double a, double b,
                           DoublePointer result, DoublePointer abserr,
                           DoublePointer resabs, DoublePointer resasc);
public static native void gsl_integration_qk31(@Const gsl_function f, double a, double b,
                           DoubleBuffer result, DoubleBuffer abserr,
                           DoubleBuffer resabs, DoubleBuffer resasc);
public static native void gsl_integration_qk31(@Const gsl_function f, double a, double b,
                           double[] result, double[] abserr,
                           double[] resabs, double[] resasc);

public static native void gsl_integration_qk41(@Const gsl_function f, double a, double b,
                           DoublePointer result, DoublePointer abserr,
                           DoublePointer resabs, DoublePointer resasc);
public static native void gsl_integration_qk41(@Const gsl_function f, double a, double b,
                           DoubleBuffer result, DoubleBuffer abserr,
                           DoubleBuffer resabs, DoubleBuffer resasc);
public static native void gsl_integration_qk41(@Const gsl_function f, double a, double b,
                           double[] result, double[] abserr,
                           double[] resabs, double[] resasc);

public static native void gsl_integration_qk51(@Const gsl_function f, double a, double b,
                           DoublePointer result, DoublePointer abserr,
                           DoublePointer resabs, DoublePointer resasc);
public static native void gsl_integration_qk51(@Const gsl_function f, double a, double b,
                           DoubleBuffer result, DoubleBuffer abserr,
                           DoubleBuffer resabs, DoubleBuffer resasc);
public static native void gsl_integration_qk51(@Const gsl_function f, double a, double b,
                           double[] result, double[] abserr,
                           double[] resabs, double[] resasc);

public static native void gsl_integration_qk61(@Const gsl_function f, double a, double b,
                           DoublePointer result, DoublePointer abserr,
                           DoublePointer resabs, DoublePointer resasc);
public static native void gsl_integration_qk61(@Const gsl_function f, double a, double b,
                           DoubleBuffer result, DoubleBuffer abserr,
                           DoubleBuffer resabs, DoubleBuffer resasc);
public static native void gsl_integration_qk61(@Const gsl_function f, double a, double b,
                           double[] result, double[] abserr,
                           double[] resabs, double[] resasc);

public static native void gsl_integration_qcheb(gsl_function f, double a, double b, 
                            DoublePointer cheb12, DoublePointer cheb24);
public static native void gsl_integration_qcheb(gsl_function f, double a, double b, 
                            DoubleBuffer cheb12, DoubleBuffer cheb24);
public static native void gsl_integration_qcheb(gsl_function f, double a, double b, 
                            double[] cheb12, double[] cheb24);

/* The low-level integration rules in QUADPACK are identified by small
   integers (1-6). We'll use symbolic constants to refer to them.  */

/** enum  */
public static final int
    GSL_INTEG_GAUSS15 = 1,      /* 15 point Gauss-Kronrod rule */
    GSL_INTEG_GAUSS21 = 2,      /* 21 point Gauss-Kronrod rule */
    GSL_INTEG_GAUSS31 = 3,      /* 31 point Gauss-Kronrod rule */
    GSL_INTEG_GAUSS41 = 4,      /* 41 point Gauss-Kronrod rule */
    GSL_INTEG_GAUSS51 = 5,      /* 51 point Gauss-Kronrod rule */
    GSL_INTEG_GAUSS61 = 6;       /* 61 point Gauss-Kronrod rule */

public static native void gsl_integration_qk(int n, @Const DoublePointer xgk, 
                    @Const DoublePointer wg, @Const DoublePointer wgk,
                    DoublePointer fv1, DoublePointer fv2,
                    @Const gsl_function f, double a, double b,
                    DoublePointer result, DoublePointer abserr, 
                    DoublePointer resabs, DoublePointer resasc);
public static native void gsl_integration_qk(int n, @Const DoubleBuffer xgk, 
                    @Const DoubleBuffer wg, @Const DoubleBuffer wgk,
                    DoubleBuffer fv1, DoubleBuffer fv2,
                    @Const gsl_function f, double a, double b,
                    DoubleBuffer result, DoubleBuffer abserr, 
                    DoubleBuffer resabs, DoubleBuffer resasc);
public static native void gsl_integration_qk(int n, @Const double[] xgk, 
                    @Const double[] wg, @Const double[] wgk,
                    double[] fv1, double[] fv2,
                    @Const gsl_function f, double a, double b,
                    double[] result, double[] abserr, 
                    double[] resabs, double[] resasc);


public static native int gsl_integration_qng(@Const gsl_function f,
                         double a, double b,
                         double epsabs, double epsrel,
                         DoublePointer result, DoublePointer abserr,
                         @Cast("size_t*") SizeTPointer neval);
public static native int gsl_integration_qng(@Const gsl_function f,
                         double a, double b,
                         double epsabs, double epsrel,
                         DoubleBuffer result, DoubleBuffer abserr,
                         @Cast("size_t*") SizeTPointer neval);
public static native int gsl_integration_qng(@Const gsl_function f,
                         double a, double b,
                         double epsabs, double epsrel,
                         double[] result, double[] abserr,
                         @Cast("size_t*") SizeTPointer neval);

public static native int gsl_integration_qag(@Const gsl_function f,
                         double a, double b,
                         double epsabs, double epsrel, @Cast("size_t") long limit,
                         int key,
                         gsl_integration_workspace workspace,
                         DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qag(@Const gsl_function f,
                         double a, double b,
                         double epsabs, double epsrel, @Cast("size_t") long limit,
                         int key,
                         gsl_integration_workspace workspace,
                         DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qag(@Const gsl_function f,
                         double a, double b,
                         double epsabs, double epsrel, @Cast("size_t") long limit,
                         int key,
                         gsl_integration_workspace workspace,
                         double[] result, double[] abserr);

public static native int gsl_integration_qagi(gsl_function f,
                          double epsabs, double epsrel, @Cast("size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qagi(gsl_function f,
                          double epsabs, double epsrel, @Cast("size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qagi(gsl_function f,
                          double epsabs, double epsrel, @Cast("size_t") long limit,
                          gsl_integration_workspace workspace,
                          double[] result, double[] abserr);

public static native int gsl_integration_qagiu(gsl_function f,
                           double a,
                           double epsabs, double epsrel, @Cast("size_t") long limit,
                           gsl_integration_workspace workspace,
                           DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qagiu(gsl_function f,
                           double a,
                           double epsabs, double epsrel, @Cast("size_t") long limit,
                           gsl_integration_workspace workspace,
                           DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qagiu(gsl_function f,
                           double a,
                           double epsabs, double epsrel, @Cast("size_t") long limit,
                           gsl_integration_workspace workspace,
                           double[] result, double[] abserr);

public static native int gsl_integration_qagil(gsl_function f,
                           double b,
                           double epsabs, double epsrel, @Cast("size_t") long limit,
                           gsl_integration_workspace workspace,
                           DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qagil(gsl_function f,
                           double b,
                           double epsabs, double epsrel, @Cast("size_t") long limit,
                           gsl_integration_workspace workspace,
                           DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qagil(gsl_function f,
                           double b,
                           double epsabs, double epsrel, @Cast("size_t") long limit,
                           gsl_integration_workspace workspace,
                           double[] result, double[] abserr);


public static native int gsl_integration_qags(@Const gsl_function f,
                          double a, double b,
                          double epsabs, double epsrel, @Cast("size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qags(@Const gsl_function f,
                          double a, double b,
                          double epsabs, double epsrel, @Cast("size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qags(@Const gsl_function f,
                          double a, double b,
                          double epsabs, double epsrel, @Cast("size_t") long limit,
                          gsl_integration_workspace workspace,
                          double[] result, double[] abserr);

public static native int gsl_integration_qagp(@Const gsl_function f,
                          DoublePointer pts, @Cast("size_t") long npts,
                          double epsabs, double epsrel, @Cast("size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qagp(@Const gsl_function f,
                          DoubleBuffer pts, @Cast("size_t") long npts,
                          double epsabs, double epsrel, @Cast("size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qagp(@Const gsl_function f,
                          double[] pts, @Cast("size_t") long npts,
                          double epsabs, double epsrel, @Cast("size_t") long limit,
                          gsl_integration_workspace workspace,
                          double[] result, double[] abserr);

public static native int gsl_integration_qawc(gsl_function f,
                          double a, double b, double c,
                          double epsabs, double epsrel, @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qawc(gsl_function f,
                          double a, double b, double c,
                          double epsabs, double epsrel, @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qawc(gsl_function f,
                          double a, double b, double c,
                          double epsabs, double epsrel, @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          double[] result, double[] abserr);

public static native int gsl_integration_qaws(gsl_function f,
                          double a, double b,
                          gsl_integration_qaws_table t,
                          double epsabs, double epsrel,
                          @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qaws(gsl_function f,
                          double a, double b,
                          gsl_integration_qaws_table t,
                          double epsabs, double epsrel,
                          @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qaws(gsl_function f,
                          double a, double b,
                          gsl_integration_qaws_table t,
                          double epsabs, double epsrel,
                          @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          double[] result, double[] abserr);

public static native int gsl_integration_qawo(gsl_function f,
                          double a,
                          double epsabs, double epsrel,
                          @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          gsl_integration_qawo_table wf,
                          DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qawo(gsl_function f,
                          double a,
                          double epsabs, double epsrel,
                          @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          gsl_integration_qawo_table wf,
                          DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qawo(gsl_function f,
                          double a,
                          double epsabs, double epsrel,
                          @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          gsl_integration_qawo_table wf,
                          double[] result, double[] abserr);

public static native int gsl_integration_qawf(gsl_function f,
                          double a,
                          double epsabs,
                          @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          gsl_integration_workspace cycle_workspace,
                          gsl_integration_qawo_table wf,
                          DoublePointer result, DoublePointer abserr);
public static native int gsl_integration_qawf(gsl_function f,
                          double a,
                          double epsabs,
                          @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          gsl_integration_workspace cycle_workspace,
                          gsl_integration_qawo_table wf,
                          DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_integration_qawf(gsl_function f,
                          double a,
                          double epsabs,
                          @Cast("const size_t") long limit,
                          gsl_integration_workspace workspace,
                          gsl_integration_workspace cycle_workspace,
                          gsl_integration_qawo_table wf,
                          double[] result, double[] abserr);

/* Workspace for fixed-order Gauss-Legendre integration */

public static class gsl_integration_glfixed_table extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_integration_glfixed_table() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_integration_glfixed_table(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_integration_glfixed_table(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_integration_glfixed_table position(long position) {
        return (gsl_integration_glfixed_table)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_integration_glfixed_table n(long n);         /* number of points */
    public native DoublePointer x(); public native gsl_integration_glfixed_table x(DoublePointer x);        /* Gauss abscissae/points */
    public native DoublePointer w(); public native gsl_integration_glfixed_table w(DoublePointer w);        /* Gauss weights for each abscissae */
    public native int precomputed(); public native gsl_integration_glfixed_table precomputed(int precomputed);  /* high precision abscissae/weights precomputed? */
  }


public static native gsl_integration_glfixed_table gsl_integration_glfixed_table_alloc(@Cast("size_t") long n);

public static native void gsl_integration_glfixed_table_free(gsl_integration_glfixed_table t);

/* Routine for fixed-order Gauss-Legendre integration */

public static native double gsl_integration_glfixed(@Const gsl_function f,
                           double a,
                           double b,
                           @Const gsl_integration_glfixed_table t);

/* Routine to retrieve the i-th Gauss-Legendre point and weight from t */

public static native int gsl_integration_glfixed_point(double a,
                                 double b,
                                 @Cast("size_t") long i,
                                 DoublePointer xi,
                                 DoublePointer wi,
                                 @Const gsl_integration_glfixed_table t);
public static native int gsl_integration_glfixed_point(double a,
                                 double b,
                                 @Cast("size_t") long i,
                                 DoubleBuffer xi,
                                 DoubleBuffer wi,
                                 @Const gsl_integration_glfixed_table t);
public static native int gsl_integration_glfixed_point(double a,
                                 double b,
                                 @Cast("size_t") long i,
                                 double[] xi,
                                 double[] wi,
                                 @Const gsl_integration_glfixed_table t);


/* Cquad integration - Pedro Gonnet */

/* Data of a single interval */
public static class gsl_integration_cquad_ival extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_integration_cquad_ival() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_integration_cquad_ival(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_integration_cquad_ival(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_integration_cquad_ival position(long position) {
        return (gsl_integration_cquad_ival)super.position(position);
    }

  public native double a(); public native gsl_integration_cquad_ival a(double a);
  public native double b(); public native gsl_integration_cquad_ival b(double b);
  public native double c(int i); public native gsl_integration_cquad_ival c(int i, double c);
  @MemberGetter public native DoublePointer c();
  public native double fx(int i); public native gsl_integration_cquad_ival fx(int i, double fx);
  @MemberGetter public native DoublePointer fx();
  public native double igral(); public native gsl_integration_cquad_ival igral(double igral);
  public native double err(); public native gsl_integration_cquad_ival err(double err);
  public native int depth(); public native gsl_integration_cquad_ival depth(int depth);
  public native int rdepth(); public native gsl_integration_cquad_ival rdepth(int rdepth);
  public native int ndiv(); public native gsl_integration_cquad_ival ndiv(int ndiv);
}


/* The workspace is just a collection of intervals */
public static class gsl_integration_cquad_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_integration_cquad_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_integration_cquad_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_integration_cquad_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_integration_cquad_workspace position(long position) {
        return (gsl_integration_cquad_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_integration_cquad_workspace size(long size);
  public native gsl_integration_cquad_ival ivals(); public native gsl_integration_cquad_workspace ivals(gsl_integration_cquad_ival ivals);
  public native @Cast("size_t*") SizeTPointer heap(); public native gsl_integration_cquad_workspace heap(SizeTPointer heap);
}

public static native gsl_integration_cquad_workspace gsl_integration_cquad_workspace_alloc(@Cast("const size_t") long n);

public static native void gsl_integration_cquad_workspace_free(gsl_integration_cquad_workspace w);

public static native int gsl_integration_cquad(@Const gsl_function f, double a, double b,
		       double epsabs, double epsrel,
		       gsl_integration_cquad_workspace ws,
		       DoublePointer result, DoublePointer abserr, @Cast("size_t*") SizeTPointer nevals);
public static native int gsl_integration_cquad(@Const gsl_function f, double a, double b,
		       double epsabs, double epsrel,
		       gsl_integration_cquad_workspace ws,
		       DoubleBuffer result, DoubleBuffer abserr, @Cast("size_t*") SizeTPointer nevals);
public static native int gsl_integration_cquad(@Const gsl_function f, double a, double b,
		       double epsabs, double epsrel,
		       gsl_integration_cquad_workspace ws,
		       double[] result, double[] abserr, @Cast("size_t*") SizeTPointer nevals);

// #endif /* __GSL_INTEGRATION_H__ */


// Parsed from gsl/gsl_interp.h

/* interpolation/gsl_interp.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman
 */
// #ifndef __GSL_INTERP_H__
// #define __GSL_INTERP_H__
// #include <stdlib.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* evaluation accelerator */
public static class gsl_interp_accel extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_interp_accel() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_interp_accel(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_interp_accel(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_interp_accel position(long position) {
        return (gsl_interp_accel)super.position(position);
    }

  public native @Cast("size_t") long cache(); public native gsl_interp_accel cache(long cache);        /* cache of index   */
  public native @Cast("size_t") long miss_count(); public native gsl_interp_accel miss_count(long miss_count);   /* keep statistics  */
  public native @Cast("size_t") long hit_count(); public native gsl_interp_accel hit_count(long hit_count);
}


/* interpolation object type */
public static class gsl_interp_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_interp_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_interp_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_interp_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_interp_type position(long position) {
        return (gsl_interp_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public native @Cast("unsigned int") int min_size(); public native gsl_interp_type min_size(int min_size);
  public static class Alloc_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Alloc_long(Pointer p) { super(p); }
      protected Alloc_long() { allocate(); }
      private native void allocate();
      public native Pointer call(@Cast("size_t") long size);
  }
  public native Alloc_long alloc(); public native gsl_interp_type alloc(Alloc_long alloc);
  public static class Init_Pointer_DoublePointer_DoublePointer_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Init_Pointer_DoublePointer_DoublePointer_long(Pointer p) { super(p); }
      protected Init_Pointer_DoublePointer_DoublePointer_long() { allocate(); }
      private native void allocate();
      public native int call(Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Cast("size_t") long size);
  }
  public native Init_Pointer_DoublePointer_DoublePointer_long init(); public native gsl_interp_type init(Init_Pointer_DoublePointer_DoublePointer_long init);
  public static class Eval_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Eval_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer(Pointer p) { super(p); }
      protected Eval_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer() { allocate(); }
      private native void allocate();
      public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Cast("size_t") long size, double x, gsl_interp_accel arg5, DoublePointer y);
  }
  public native Eval_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer eval(); public native gsl_interp_type eval(Eval_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer eval);
  public static class Eval_deriv_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Eval_deriv_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer(Pointer p) { super(p); }
      protected Eval_deriv_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer() { allocate(); }
      private native void allocate();
      public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Cast("size_t") long size, double x, gsl_interp_accel arg5, DoublePointer y_p);
  }
  public native Eval_deriv_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer eval_deriv(); public native gsl_interp_type eval_deriv(Eval_deriv_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer eval_deriv);
  public static class Eval_deriv2_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Eval_deriv2_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer(Pointer p) { super(p); }
      protected Eval_deriv2_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer() { allocate(); }
      private native void allocate();
      public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Cast("size_t") long size, double x, gsl_interp_accel arg5, DoublePointer y_pp);
  }
  public native Eval_deriv2_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer eval_deriv2(); public native gsl_interp_type eval_deriv2(Eval_deriv2_Pointer_DoublePointer_DoublePointer_long_double_gsl_interp_accel_DoublePointer eval_deriv2);
  public static class Eval_integ_Pointer_DoublePointer_DoublePointer_long_gsl_interp_accel_double_double_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Eval_integ_Pointer_DoublePointer_DoublePointer_long_gsl_interp_accel_double_double_DoublePointer(Pointer p) { super(p); }
      protected Eval_integ_Pointer_DoublePointer_DoublePointer_long_gsl_interp_accel_double_double_DoublePointer() { allocate(); }
      private native void allocate();
      public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Cast("size_t") long size, gsl_interp_accel arg4, double a, double b, DoublePointer result);
  }
  public native Eval_integ_Pointer_DoublePointer_DoublePointer_long_gsl_interp_accel_double_double_DoublePointer eval_integ(); public native gsl_interp_type eval_integ(Eval_integ_Pointer_DoublePointer_DoublePointer_long_gsl_interp_accel_double_double_DoublePointer eval_integ);
  public static class Free_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Free_Pointer(Pointer p) { super(p); }
      protected Free_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer arg0);
  }
  public native Free_Pointer free(); public native gsl_interp_type free(Free_Pointer free);

}


/* general interpolation object */
public static class gsl_interp extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_interp() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_interp(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_interp(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_interp position(long position) {
        return (gsl_interp)super.position(position);
    }

  @MemberGetter public native @Const gsl_interp_type type();
  public native double xmin(); public native gsl_interp xmin(double xmin);
  public native double xmax(); public native gsl_interp xmax(double xmax);
  public native @Cast("size_t") long size(); public native gsl_interp size(long size);
  public native Pointer state(); public native gsl_interp state(Pointer state);
}


/* available types */
@MemberGetter public static native @Const gsl_interp_type gsl_interp_linear();
@MemberGetter public static native @Const gsl_interp_type gsl_interp_polynomial();
@MemberGetter public static native @Const gsl_interp_type gsl_interp_cspline();
@MemberGetter public static native @Const gsl_interp_type gsl_interp_cspline_periodic();
@MemberGetter public static native @Const gsl_interp_type gsl_interp_akima();
@MemberGetter public static native @Const gsl_interp_type gsl_interp_akima_periodic();
@MemberGetter public static native @Const gsl_interp_type gsl_interp_steffen();

public static native gsl_interp_accel gsl_interp_accel_alloc();

public static native int gsl_interp_accel_reset(gsl_interp_accel a);

public static native void gsl_interp_accel_free(gsl_interp_accel a);

public static native gsl_interp gsl_interp_alloc(@Const gsl_interp_type T, @Cast("size_t") long n);
     
public static native int gsl_interp_init(gsl_interp obj, @Const DoublePointer xa, @Const DoublePointer ya, @Cast("size_t") long size);
public static native int gsl_interp_init(gsl_interp obj, @Const DoubleBuffer xa, @Const DoubleBuffer ya, @Cast("size_t") long size);
public static native int gsl_interp_init(gsl_interp obj, @Const double[] xa, @Const double[] ya, @Cast("size_t") long size);

public static native @Cast("const char*") BytePointer gsl_interp_name(@Const gsl_interp interp);
public static native @Cast("unsigned int") int gsl_interp_min_size(@Const gsl_interp interp);
public static native @Cast("unsigned int") int gsl_interp_type_min_size(@Const gsl_interp_type T);


public static native int gsl_interp_eval_e(@Const gsl_interp obj,
                  @Const DoublePointer xa, @Const DoublePointer ya, double x,
                  gsl_interp_accel a, DoublePointer y);
public static native int gsl_interp_eval_e(@Const gsl_interp obj,
                  @Const DoubleBuffer xa, @Const DoubleBuffer ya, double x,
                  gsl_interp_accel a, DoubleBuffer y);
public static native int gsl_interp_eval_e(@Const gsl_interp obj,
                  @Const double[] xa, @Const double[] ya, double x,
                  gsl_interp_accel a, double[] y);

public static native double gsl_interp_eval(@Const gsl_interp obj,
                @Const DoublePointer xa, @Const DoublePointer ya, double x,
                gsl_interp_accel a);
public static native double gsl_interp_eval(@Const gsl_interp obj,
                @Const DoubleBuffer xa, @Const DoubleBuffer ya, double x,
                gsl_interp_accel a);
public static native double gsl_interp_eval(@Const gsl_interp obj,
                @Const double[] xa, @Const double[] ya, double x,
                gsl_interp_accel a);

public static native int gsl_interp_eval_deriv_e(@Const gsl_interp obj,
                        @Const DoublePointer xa, @Const DoublePointer ya, double x,
                        gsl_interp_accel a,
                        DoublePointer d);
public static native int gsl_interp_eval_deriv_e(@Const gsl_interp obj,
                        @Const DoubleBuffer xa, @Const DoubleBuffer ya, double x,
                        gsl_interp_accel a,
                        DoubleBuffer d);
public static native int gsl_interp_eval_deriv_e(@Const gsl_interp obj,
                        @Const double[] xa, @Const double[] ya, double x,
                        gsl_interp_accel a,
                        double[] d);

public static native double gsl_interp_eval_deriv(@Const gsl_interp obj,
                      @Const DoublePointer xa, @Const DoublePointer ya, double x,
                      gsl_interp_accel a);
public static native double gsl_interp_eval_deriv(@Const gsl_interp obj,
                      @Const DoubleBuffer xa, @Const DoubleBuffer ya, double x,
                      gsl_interp_accel a);
public static native double gsl_interp_eval_deriv(@Const gsl_interp obj,
                      @Const double[] xa, @Const double[] ya, double x,
                      gsl_interp_accel a);

public static native int gsl_interp_eval_deriv2_e(@Const gsl_interp obj,
                         @Const DoublePointer xa, @Const DoublePointer ya, double x,
                         gsl_interp_accel a,
                         DoublePointer d2);
public static native int gsl_interp_eval_deriv2_e(@Const gsl_interp obj,
                         @Const DoubleBuffer xa, @Const DoubleBuffer ya, double x,
                         gsl_interp_accel a,
                         DoubleBuffer d2);
public static native int gsl_interp_eval_deriv2_e(@Const gsl_interp obj,
                         @Const double[] xa, @Const double[] ya, double x,
                         gsl_interp_accel a,
                         double[] d2);

public static native double gsl_interp_eval_deriv2(@Const gsl_interp obj,
                       @Const DoublePointer xa, @Const DoublePointer ya, double x,
                       gsl_interp_accel a);
public static native double gsl_interp_eval_deriv2(@Const gsl_interp obj,
                       @Const DoubleBuffer xa, @Const DoubleBuffer ya, double x,
                       gsl_interp_accel a);
public static native double gsl_interp_eval_deriv2(@Const gsl_interp obj,
                       @Const double[] xa, @Const double[] ya, double x,
                       gsl_interp_accel a);

public static native int gsl_interp_eval_integ_e(@Const gsl_interp obj,
                        @Const DoublePointer xa, @Const DoublePointer ya,
                        double a, double b,
                        gsl_interp_accel acc,
                        DoublePointer result);
public static native int gsl_interp_eval_integ_e(@Const gsl_interp obj,
                        @Const DoubleBuffer xa, @Const DoubleBuffer ya,
                        double a, double b,
                        gsl_interp_accel acc,
                        DoubleBuffer result);
public static native int gsl_interp_eval_integ_e(@Const gsl_interp obj,
                        @Const double[] xa, @Const double[] ya,
                        double a, double b,
                        gsl_interp_accel acc,
                        double[] result);

public static native double gsl_interp_eval_integ(@Const gsl_interp obj,
                      @Const DoublePointer xa, @Const DoublePointer ya,
                      double a, double b,
                      gsl_interp_accel acc);
public static native double gsl_interp_eval_integ(@Const gsl_interp obj,
                      @Const DoubleBuffer xa, @Const DoubleBuffer ya,
                      double a, double b,
                      gsl_interp_accel acc);
public static native double gsl_interp_eval_integ(@Const gsl_interp obj,
                      @Const double[] xa, @Const double[] ya,
                      double a, double b,
                      gsl_interp_accel acc);

public static native void gsl_interp_free(gsl_interp interp);

/* */ public static native @Cast("size_t") long gsl_interp_bsearch(@Const DoublePointer x_array, double x,
                   @Cast("size_t") long index_lo, @Cast("size_t") long index_hi);
public static native @Cast("size_t") long gsl_interp_bsearch(@Const DoubleBuffer x_array, double x,
                   @Cast("size_t") long index_lo, @Cast("size_t") long index_hi);
public static native @Cast("size_t") long gsl_interp_bsearch(@Const double[] x_array, double x,
                   @Cast("size_t") long index_lo, @Cast("size_t") long index_hi);

// #ifdef HAVE_INLINE

/* Perform a binary search of an array of values.
 * 
 * The parameters index_lo and index_hi provide an initial bracket,
 * and it is assumed that index_lo < index_hi. The resulting index
 * is guaranteed to be strictly less than index_hi and greater than
 * or equal to index_lo, so that the implicit bracket [index, index+1]
 * always corresponds to a region within the implicit value range of
 * the value array.
 *
 * Note that this means the relationship of 'x' to x_array[index]
 * and x_array[index+1] depends on the result region, i.e. the
 * behaviour at the boundaries may not correspond to what you
 * expect. We have the following complete specification of the
 * behaviour.
 * Suppose the input is x_array[] = { x0, x1, ..., xN }
 *    if ( x == x0 )           then  index == 0
 *    if ( x > x0 && x <= x1 ) then  index == 0, and sim. for other interior pts
 *    if ( x == xN )           then  index == N-1
 *    if ( x > xN )            then  index == N-1
 *    if ( x < x0 )            then  index == 0 
 */
// #endif

/* */ public static native @Cast("size_t") long gsl_interp_accel_find(gsl_interp_accel a, @Const DoublePointer x_array, @Cast("size_t") long size, double x);
public static native @Cast("size_t") long gsl_interp_accel_find(gsl_interp_accel a, @Const DoubleBuffer x_array, @Cast("size_t") long size, double x);
public static native @Cast("size_t") long gsl_interp_accel_find(gsl_interp_accel a, @Const double[] x_array, @Cast("size_t") long size, double x);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

// #endif /* __GSL_INTERP_H__ */


// Parsed from gsl/gsl_linalg.h

/* linalg/gsl_linalg.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2006, 2007 Gerard Jungman, Brian Gough, Patrick Alken
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_LINALG_H__
// #define __GSL_LINALG_H__

// #include <stdlib.h>
// #include <gsl/gsl_mode.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>
// #include <gsl/gsl_math.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_blas.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// #define __BEGIN_DECLS extern "C" {
// #define __END_DECLS }
// #else
// #endif

/** enum gsl_linalg_matrix_mod_t */
public static final int
    GSL_LINALG_MOD_NONE = 0,
    GSL_LINALG_MOD_TRANSPOSE = 1,
    GSL_LINALG_MOD_CONJUGATE = 2;


/* Note: You can now use the gsl_blas_dgemm function instead of matmult */

/* Simple implementation of matrix multiply.
 * Calculates C = A.B
 *
 * exceptions: GSL_EBADLEN
 */
public static native int gsl_linalg_matmult(@Const gsl_matrix A,
                        @Const gsl_matrix B,
                        gsl_matrix C);


/* Simple implementation of matrix multiply.
 * Allows transposition of either matrix, so it
 * can compute A.B or Trans(A).B or A.Trans(B) or Trans(A).Trans(B)
 *
 * exceptions: GSL_EBADLEN
 */
public static native int gsl_linalg_matmult_mod(@Const gsl_matrix A,
                            @Cast("gsl_linalg_matrix_mod_t") int modA,
                            @Const gsl_matrix B,
                            @Cast("gsl_linalg_matrix_mod_t") int modB,
                            gsl_matrix C);

/* Calculate the matrix exponential by the scaling and
 * squaring method described in Moler + Van Loan,
 * SIAM Rev 20, 801 (1978). The mode argument allows
 * choosing an optimal strategy, from the table
 * given in the paper, for a given precision.
 *
 * exceptions: GSL_ENOTSQR, GSL_EBADLEN
 */
public static native int gsl_linalg_exponential_ss(
  @Const gsl_matrix A,
  gsl_matrix eA,
  @Cast("gsl_mode_t") int mode
  );


/* Householder Transformations */

public static native double gsl_linalg_householder_transform(gsl_vector v);
public static native @ByVal gsl_complex gsl_linalg_complex_householder_transform(gsl_vector_complex v);

public static native int gsl_linalg_householder_hm(double tau, 
                               @Const gsl_vector v, 
                               gsl_matrix A);

public static native int gsl_linalg_householder_mh(double tau, 
                               @Const gsl_vector v, 
                               gsl_matrix A);

public static native int gsl_linalg_householder_hv(double tau, 
                               @Const gsl_vector v, 
                               gsl_vector w);

public static native int gsl_linalg_householder_hm1(double tau, 
                                gsl_matrix A);

public static native int gsl_linalg_complex_householder_hm(@ByVal gsl_complex tau, 
                                       @Const gsl_vector_complex v, 
                                       gsl_matrix_complex A);

public static native int gsl_linalg_complex_householder_mh(@ByVal gsl_complex tau,
                                       @Const gsl_vector_complex v,
                                       gsl_matrix_complex A);

public static native int gsl_linalg_complex_householder_hv(@ByVal gsl_complex tau, 
                                       @Const gsl_vector_complex v, 
                                       gsl_vector_complex w);

/* Hessenberg reduction */

public static native int gsl_linalg_hessenberg_decomp(gsl_matrix A, gsl_vector tau);
public static native int gsl_linalg_hessenberg_unpack(gsl_matrix H, gsl_vector tau,
                                 gsl_matrix U);
public static native int gsl_linalg_hessenberg_unpack_accum(gsl_matrix H, gsl_vector tau,
                                       gsl_matrix U);
public static native int gsl_linalg_hessenberg_set_zero(gsl_matrix H);
public static native int gsl_linalg_hessenberg_submatrix(gsl_matrix M, gsl_matrix A,
                                    @Cast("size_t") long top, gsl_vector tau);

/* To support gsl-1.9 interface: DEPRECATED */
public static native int gsl_linalg_hessenberg(gsl_matrix A, gsl_vector tau);


/* Hessenberg-Triangular reduction */

public static native int gsl_linalg_hesstri_decomp(gsl_matrix A, gsl_matrix B,
                              gsl_matrix U, gsl_matrix V,
                              gsl_vector work);

/* Singular Value Decomposition

 * exceptions: 
 */

public static native int gsl_linalg_SV_decomp(gsl_matrix A,
                      gsl_matrix V,
                      gsl_vector S,
                      gsl_vector work);

public static native int gsl_linalg_SV_decomp_mod(gsl_matrix A,
                          gsl_matrix X,
                          gsl_matrix V,
                          gsl_vector S,
                          gsl_vector work);

public static native int gsl_linalg_SV_decomp_jacobi(gsl_matrix A,
                                 gsl_matrix Q,
                                 gsl_vector S);

public static native int gsl_linalg_SV_solve(@Const gsl_matrix U,
                     @Const gsl_matrix Q,
                     @Const gsl_vector S,
                     @Const gsl_vector b,
                     gsl_vector x);

public static native int gsl_linalg_SV_leverage(@Const gsl_matrix U, gsl_vector h);


/* LU Decomposition, Gaussian elimination with partial pivoting
 */

public static native int gsl_linalg_LU_decomp(gsl_matrix A, gsl_permutation p, IntPointer signum);
public static native int gsl_linalg_LU_decomp(gsl_matrix A, gsl_permutation p, IntBuffer signum);
public static native int gsl_linalg_LU_decomp(gsl_matrix A, gsl_permutation p, int[] signum);

public static native int gsl_linalg_LU_solve(@Const gsl_matrix LU,
                         @Const gsl_permutation p,
                         @Const gsl_vector b,
                         gsl_vector x);

public static native int gsl_linalg_LU_svx(@Const gsl_matrix LU,
                       @Const gsl_permutation p,
                       gsl_vector x);

public static native int gsl_linalg_LU_refine(@Const gsl_matrix A,
                          @Const gsl_matrix LU,
                          @Const gsl_permutation p,
                          @Const gsl_vector b,
                          gsl_vector x,
                          gsl_vector residual);

public static native int gsl_linalg_LU_invert(@Const gsl_matrix LU,
                          @Const gsl_permutation p,
                          gsl_matrix inverse);

public static native double gsl_linalg_LU_det(gsl_matrix LU, int signum);
public static native double gsl_linalg_LU_lndet(gsl_matrix LU);
public static native int gsl_linalg_LU_sgndet(gsl_matrix lu, int signum);

/* Complex LU Decomposition */

public static native int gsl_linalg_complex_LU_decomp(gsl_matrix_complex A, 
                                  gsl_permutation p, 
                                  IntPointer signum);
public static native int gsl_linalg_complex_LU_decomp(gsl_matrix_complex A, 
                                  gsl_permutation p, 
                                  IntBuffer signum);
public static native int gsl_linalg_complex_LU_decomp(gsl_matrix_complex A, 
                                  gsl_permutation p, 
                                  int[] signum);

public static native int gsl_linalg_complex_LU_solve(@Const gsl_matrix_complex LU,
                                 @Const gsl_permutation p,
                                 @Const gsl_vector_complex b,
                                 gsl_vector_complex x);

public static native int gsl_linalg_complex_LU_svx(@Const gsl_matrix_complex LU,
                               @Const gsl_permutation p,
                               gsl_vector_complex x);

public static native int gsl_linalg_complex_LU_refine(@Const gsl_matrix_complex A,
                                  @Const gsl_matrix_complex LU,
                                  @Const gsl_permutation p,
                                  @Const gsl_vector_complex b,
                                  gsl_vector_complex x,
                                  gsl_vector_complex residual);

public static native int gsl_linalg_complex_LU_invert(@Const gsl_matrix_complex LU,
                                  @Const gsl_permutation p,
                                  gsl_matrix_complex inverse);

public static native @ByVal gsl_complex gsl_linalg_complex_LU_det(gsl_matrix_complex LU,
                                       int signum);

public static native double gsl_linalg_complex_LU_lndet(gsl_matrix_complex LU);

public static native @ByVal gsl_complex gsl_linalg_complex_LU_sgndet(gsl_matrix_complex LU,
                                          int signum);

/* QR decomposition */

public static native int gsl_linalg_QR_decomp(gsl_matrix A,
                          gsl_vector tau);

public static native int gsl_linalg_QR_solve(@Const gsl_matrix QR,
                         @Const gsl_vector tau,
                         @Const gsl_vector b,
                         gsl_vector x);

public static native int gsl_linalg_QR_svx(@Const gsl_matrix QR,
                       @Const gsl_vector tau,
                       gsl_vector x);

public static native int gsl_linalg_QR_lssolve(@Const gsl_matrix QR, 
                           @Const gsl_vector tau, 
                           @Const gsl_vector b, 
                           gsl_vector x, 
                           gsl_vector residual);


public static native int gsl_linalg_QR_QRsolve(gsl_matrix Q,
                           gsl_matrix R,
                           @Const gsl_vector b,
                           gsl_vector x);

public static native int gsl_linalg_QR_Rsolve(@Const gsl_matrix QR,
                          @Const gsl_vector b,
                          gsl_vector x);

public static native int gsl_linalg_QR_Rsvx(@Const gsl_matrix QR,
                        gsl_vector x);

public static native int gsl_linalg_QR_update(gsl_matrix Q,
                          gsl_matrix R,
                          gsl_vector w,
                          @Const gsl_vector v);

public static native int gsl_linalg_QR_QTvec(@Const gsl_matrix QR,
                         @Const gsl_vector tau,
                         gsl_vector v);

public static native int gsl_linalg_QR_Qvec(@Const gsl_matrix QR,
                        @Const gsl_vector tau,
                        gsl_vector v);

public static native int gsl_linalg_QR_QTmat(@Const gsl_matrix QR,
                         @Const gsl_vector tau,
                         gsl_matrix A);

public static native int gsl_linalg_QR_matQ(@Const gsl_matrix QR,
                        @Const gsl_vector tau,
                        gsl_matrix A);

public static native int gsl_linalg_QR_unpack(@Const gsl_matrix QR,
                          @Const gsl_vector tau,
                          gsl_matrix Q,
                          gsl_matrix R);

public static native int gsl_linalg_R_solve(@Const gsl_matrix R,
                        @Const gsl_vector b,
                        gsl_vector x);

public static native int gsl_linalg_R_svx(@Const gsl_matrix R,
                      gsl_vector x);


/* Q R P^T decomposition */

public static native int gsl_linalg_QRPT_decomp(gsl_matrix A,
                            gsl_vector tau,
                            gsl_permutation p,
                            IntPointer signum,
                            gsl_vector norm);
public static native int gsl_linalg_QRPT_decomp(gsl_matrix A,
                            gsl_vector tau,
                            gsl_permutation p,
                            IntBuffer signum,
                            gsl_vector norm);
public static native int gsl_linalg_QRPT_decomp(gsl_matrix A,
                            gsl_vector tau,
                            gsl_permutation p,
                            int[] signum,
                            gsl_vector norm);

public static native int gsl_linalg_QRPT_decomp2(@Const gsl_matrix A, 
                             gsl_matrix q, gsl_matrix r, 
                             gsl_vector tau, 
                             gsl_permutation p, 
                             IntPointer signum,
                             gsl_vector norm);
public static native int gsl_linalg_QRPT_decomp2(@Const gsl_matrix A, 
                             gsl_matrix q, gsl_matrix r, 
                             gsl_vector tau, 
                             gsl_permutation p, 
                             IntBuffer signum,
                             gsl_vector norm);
public static native int gsl_linalg_QRPT_decomp2(@Const gsl_matrix A, 
                             gsl_matrix q, gsl_matrix r, 
                             gsl_vector tau, 
                             gsl_permutation p, 
                             int[] signum,
                             gsl_vector norm);

public static native int gsl_linalg_QRPT_solve(@Const gsl_matrix QR,
                           @Const gsl_vector tau,
                           @Const gsl_permutation p,
                           @Const gsl_vector b,
                           gsl_vector x);

public static native int gsl_linalg_QRPT_lssolve(@Const gsl_matrix QR,
                             @Const gsl_vector tau,
                             @Const gsl_permutation p,
                             @Const gsl_vector b,
                             gsl_vector x,
                             gsl_vector residual);

public static native int gsl_linalg_QRPT_lssolve2(@Const gsl_matrix QR,
                              @Const gsl_vector tau,
                              @Const gsl_permutation p,
                              @Const gsl_vector b,
                              @Cast("const size_t") long rank,
                              gsl_vector x,
                              gsl_vector residual);

public static native int gsl_linalg_QRPT_svx(@Const gsl_matrix QR,
                         @Const gsl_vector tau,
                         @Const gsl_permutation p,
                         gsl_vector x);

public static native int gsl_linalg_QRPT_QRsolve(@Const gsl_matrix Q,
                             @Const gsl_matrix R,
                             @Const gsl_permutation p,
                             @Const gsl_vector b,
                             gsl_vector x);

public static native int gsl_linalg_QRPT_Rsolve(@Const gsl_matrix QR,
                             @Const gsl_permutation p,
                             @Const gsl_vector b,
                             gsl_vector x);

public static native int gsl_linalg_QRPT_Rsvx(@Const gsl_matrix QR,
                           @Const gsl_permutation p,
                           gsl_vector x);

public static native int gsl_linalg_QRPT_update(gsl_matrix Q,
                            gsl_matrix R,
                            @Const gsl_permutation p,
                            gsl_vector u,
                            @Const gsl_vector v);

public static native @Cast("size_t") long gsl_linalg_QRPT_rank(@Const gsl_matrix QR, double tol);

public static native int gsl_linalg_QRPT_rcond(@Const gsl_matrix QR, DoublePointer rcond, gsl_vector work);
public static native int gsl_linalg_QRPT_rcond(@Const gsl_matrix QR, DoubleBuffer rcond, gsl_vector work);
public static native int gsl_linalg_QRPT_rcond(@Const gsl_matrix QR, double[] rcond, gsl_vector work);

/* COD decomposition */

public static native int gsl_linalg_COD_decomp(gsl_matrix A, gsl_vector tau_Q, gsl_vector tau_Z,
                          gsl_permutation p, @Cast("size_t*") SizeTPointer rank, gsl_vector work);

public static native int gsl_linalg_COD_decomp_e(gsl_matrix A, gsl_vector tau_Q, gsl_vector tau_Z,
                            gsl_permutation p, double tol, @Cast("size_t*") SizeTPointer rank, gsl_vector work);

public static native int gsl_linalg_COD_lssolve(@Const gsl_matrix QRZ, @Const gsl_vector tau_Q, @Const gsl_vector tau_Z,
                            @Const gsl_permutation perm, @Cast("const size_t") long rank, @Const gsl_vector b,
                            gsl_vector x, gsl_vector residual);

public static native int gsl_linalg_COD_unpack(@Const gsl_matrix QRZ, @Const gsl_vector tau_Q,
                          @Const gsl_vector tau_Z, @Cast("const size_t") long rank, gsl_matrix Q,
                          gsl_matrix R, gsl_matrix Z);

public static native int gsl_linalg_COD_matZ(@Const gsl_matrix QRZ, @Const gsl_vector tau_Z, @Cast("const size_t") long rank,
                        gsl_matrix A, gsl_vector work);

/* LQ decomposition */

public static native int gsl_linalg_LQ_decomp(gsl_matrix A, gsl_vector tau);

public static native int gsl_linalg_LQ_solve_T(@Const gsl_matrix LQ, @Const gsl_vector tau, 
			 @Const gsl_vector b, gsl_vector x);

public static native int gsl_linalg_LQ_svx_T(@Const gsl_matrix LQ, @Const gsl_vector tau, 
                         gsl_vector x);

public static native int gsl_linalg_LQ_lssolve_T(@Const gsl_matrix LQ, @Const gsl_vector tau, 
			   @Const gsl_vector b, gsl_vector x, 
			   gsl_vector residual);

public static native int gsl_linalg_LQ_Lsolve_T(@Const gsl_matrix LQ, @Const gsl_vector b, 
			  gsl_vector x);

public static native int gsl_linalg_LQ_Lsvx_T(@Const gsl_matrix LQ, gsl_vector x);

public static native int gsl_linalg_L_solve_T(@Const gsl_matrix L, @Const gsl_vector b, 
			gsl_vector x);

public static native int gsl_linalg_LQ_vecQ(@Const gsl_matrix LQ, @Const gsl_vector tau, 
			gsl_vector v);

public static native int gsl_linalg_LQ_vecQT(@Const gsl_matrix LQ, @Const gsl_vector tau, 
			 gsl_vector v);

public static native int gsl_linalg_LQ_unpack(@Const gsl_matrix LQ, @Const gsl_vector tau, 
			  gsl_matrix Q, gsl_matrix L);

public static native int gsl_linalg_LQ_update(gsl_matrix Q, gsl_matrix R,
			  @Const gsl_vector v, gsl_vector w);
public static native int gsl_linalg_LQ_LQsolve(gsl_matrix Q, gsl_matrix L, 
			   @Const gsl_vector b, gsl_vector x);

/* P^T L Q decomposition */

public static native int gsl_linalg_PTLQ_decomp(gsl_matrix A, gsl_vector tau, 
			    gsl_permutation p, IntPointer signum, 
			    gsl_vector norm);
public static native int gsl_linalg_PTLQ_decomp(gsl_matrix A, gsl_vector tau, 
			    gsl_permutation p, IntBuffer signum, 
			    gsl_vector norm);
public static native int gsl_linalg_PTLQ_decomp(gsl_matrix A, gsl_vector tau, 
			    gsl_permutation p, int[] signum, 
			    gsl_vector norm);

public static native int gsl_linalg_PTLQ_decomp2(@Const gsl_matrix A, gsl_matrix q, 
			     gsl_matrix r, gsl_vector tau, 
			     gsl_permutation p, IntPointer signum, 
			     gsl_vector norm);
public static native int gsl_linalg_PTLQ_decomp2(@Const gsl_matrix A, gsl_matrix q, 
			     gsl_matrix r, gsl_vector tau, 
			     gsl_permutation p, IntBuffer signum, 
			     gsl_vector norm);
public static native int gsl_linalg_PTLQ_decomp2(@Const gsl_matrix A, gsl_matrix q, 
			     gsl_matrix r, gsl_vector tau, 
			     gsl_permutation p, int[] signum, 
			     gsl_vector norm);

public static native int gsl_linalg_PTLQ_solve_T(@Const gsl_matrix QR,
			   @Const gsl_vector tau,
			   @Const gsl_permutation p,
			   @Const gsl_vector b,
			   gsl_vector x);

public static native int gsl_linalg_PTLQ_svx_T(@Const gsl_matrix LQ,
                           @Const gsl_vector tau,
                           @Const gsl_permutation p,
                           gsl_vector x);

public static native int gsl_linalg_PTLQ_LQsolve_T(@Const gsl_matrix Q, @Const gsl_matrix L,
			     @Const gsl_permutation p,
			     @Const gsl_vector b,
			     gsl_vector x);

public static native int gsl_linalg_PTLQ_Lsolve_T(@Const gsl_matrix LQ,
			    @Const gsl_permutation p,
			    @Const gsl_vector b,
			    gsl_vector x);

public static native int gsl_linalg_PTLQ_Lsvx_T(@Const gsl_matrix LQ,
			  @Const gsl_permutation p,
			  gsl_vector x);

public static native int gsl_linalg_PTLQ_update(gsl_matrix Q, gsl_matrix L,
			    @Const gsl_permutation p,
			    @Const gsl_vector v, gsl_vector w);

/* Cholesky Decomposition */

public static native int gsl_linalg_cholesky_decomp(gsl_matrix A);
public static native int gsl_linalg_cholesky_decomp1(gsl_matrix A);

public static native int gsl_linalg_cholesky_solve(@Const gsl_matrix cholesky,
                               @Const gsl_vector b,
                               gsl_vector x);

public static native int gsl_linalg_cholesky_svx(@Const gsl_matrix cholesky,
                             gsl_vector x);

public static native int gsl_linalg_cholesky_invert(gsl_matrix cholesky);

/* Cholesky decomposition with unit-diagonal triangular parts.
 *   A = L D L^T, where diag(L) = (1,1,...,1).
 *   Upon exit, A contains L and L^T as for Cholesky, and
 *   the diagonal of A is (1,1,...,1). The vector Dis set
 *   to the diagonal elements of the diagonal matrix D.
 */
public static native int gsl_linalg_cholesky_decomp_unit(gsl_matrix A, gsl_vector D);

public static native int gsl_linalg_cholesky_scale(@Const gsl_matrix A, gsl_vector S);

public static native int gsl_linalg_cholesky_scale_apply(gsl_matrix A, @Const gsl_vector S);

public static native int gsl_linalg_cholesky_decomp2(gsl_matrix A, gsl_vector S);

public static native int gsl_linalg_cholesky_svx2(@Const gsl_matrix LLT,
                              @Const gsl_vector S,
                              gsl_vector x);

public static native int gsl_linalg_cholesky_solve2(@Const gsl_matrix LLT,
                                @Const gsl_vector S,
                                @Const gsl_vector b,
                                gsl_vector x);

public static native int gsl_linalg_cholesky_rcond(@Const gsl_matrix LLT, DoublePointer rcond,
                               gsl_vector work);
public static native int gsl_linalg_cholesky_rcond(@Const gsl_matrix LLT, DoubleBuffer rcond,
                               gsl_vector work);
public static native int gsl_linalg_cholesky_rcond(@Const gsl_matrix LLT, double[] rcond,
                               gsl_vector work);

/* Complex Cholesky Decomposition */

public static native int gsl_linalg_complex_cholesky_decomp(gsl_matrix_complex A);

public static native int gsl_linalg_complex_cholesky_solve(@Const gsl_matrix_complex cholesky,
                                       @Const gsl_vector_complex b,
                                       gsl_vector_complex x);

public static native int gsl_linalg_complex_cholesky_svx(@Const gsl_matrix_complex cholesky,
                                     gsl_vector_complex x);

public static native int gsl_linalg_complex_cholesky_invert(gsl_matrix_complex cholesky);

/* Pivoted Cholesky LDLT decomposition */

public static native int gsl_linalg_pcholesky_decomp(gsl_matrix A, gsl_permutation p);

public static native int gsl_linalg_pcholesky_solve(@Const gsl_matrix LDLT,
                               @Const gsl_permutation p,
                               @Const gsl_vector b,
                               gsl_vector x);

public static native int gsl_linalg_pcholesky_svx(@Const gsl_matrix LDLT,
                             @Const gsl_permutation p,
                             gsl_vector x);

public static native int gsl_linalg_pcholesky_decomp2(gsl_matrix A, gsl_permutation p,
                                 gsl_vector S);

public static native int gsl_linalg_pcholesky_solve2(@Const gsl_matrix LDLT,
                                @Const gsl_permutation p,
                                @Const gsl_vector S,
                                @Const gsl_vector b,
                                gsl_vector x);

public static native int gsl_linalg_pcholesky_svx2(@Const gsl_matrix LDLT,
                              @Const gsl_permutation p,
                              @Const gsl_vector S,
                              gsl_vector x);

public static native int gsl_linalg_pcholesky_invert(@Const gsl_matrix LDLT, @Const gsl_permutation p,
                                gsl_matrix Ainv);

public static native int gsl_linalg_pcholesky_rcond(@Const gsl_matrix LDLT, @Const gsl_permutation p,
                                DoublePointer rcond, gsl_vector work);
public static native int gsl_linalg_pcholesky_rcond(@Const gsl_matrix LDLT, @Const gsl_permutation p,
                                DoubleBuffer rcond, gsl_vector work);
public static native int gsl_linalg_pcholesky_rcond(@Const gsl_matrix LDLT, @Const gsl_permutation p,
                                double[] rcond, gsl_vector work);

/* Modified Cholesky decomposition */

public static native int gsl_linalg_mcholesky_decomp(gsl_matrix A, gsl_permutation p,
                                 gsl_vector E);

public static native int gsl_linalg_mcholesky_solve(@Const gsl_matrix LDLT,
                               @Const gsl_permutation p,
                               @Const gsl_vector b,
                               gsl_vector x);

public static native int gsl_linalg_mcholesky_svx(@Const gsl_matrix LDLT,
                             @Const gsl_permutation p,
                             gsl_vector x);

public static native int gsl_linalg_mcholesky_rcond(@Const gsl_matrix LDLT, @Const gsl_permutation p,
                                DoublePointer rcond, gsl_vector work);
public static native int gsl_linalg_mcholesky_rcond(@Const gsl_matrix LDLT, @Const gsl_permutation p,
                                DoubleBuffer rcond, gsl_vector work);
public static native int gsl_linalg_mcholesky_rcond(@Const gsl_matrix LDLT, @Const gsl_permutation p,
                                double[] rcond, gsl_vector work);

public static native int gsl_linalg_mcholesky_invert(@Const gsl_matrix LDLT, @Const gsl_permutation p,
                                gsl_matrix Ainv);

/* Symmetric to symmetric tridiagonal decomposition */

public static native int gsl_linalg_symmtd_decomp(gsl_matrix A, 
                              gsl_vector tau);

public static native int gsl_linalg_symmtd_unpack(@Const gsl_matrix A, 
                              @Const gsl_vector tau,
                              gsl_matrix Q, 
                              gsl_vector diag, 
                              gsl_vector subdiag);

public static native int gsl_linalg_symmtd_unpack_T(@Const gsl_matrix A,
                                gsl_vector diag, 
                                gsl_vector subdiag);

/* Hermitian to symmetric tridiagonal decomposition */

public static native int gsl_linalg_hermtd_decomp(gsl_matrix_complex A, 
                              gsl_vector_complex tau);

public static native int gsl_linalg_hermtd_unpack(@Const gsl_matrix_complex A, 
                              @Const gsl_vector_complex tau,
                              gsl_matrix_complex U, 
                              gsl_vector diag, 
                              gsl_vector sudiag);

public static native int gsl_linalg_hermtd_unpack_T(@Const gsl_matrix_complex A, 
                                gsl_vector diag, 
                                gsl_vector subdiag);

/* Linear Solve Using Householder Transformations

 * exceptions: 
 */

public static native int gsl_linalg_HH_solve(gsl_matrix A, @Const gsl_vector b, gsl_vector x);
public static native int gsl_linalg_HH_svx(gsl_matrix A, gsl_vector x);

/* Linear solve for a symmetric tridiagonal system.

 * The input vectors represent the NxN matrix as follows:
 *
 *     diag[0]  offdiag[0]             0    ...
 *  offdiag[0]     diag[1]    offdiag[1]    ...
 *           0  offdiag[1]       diag[2]    ...
 *           0           0    offdiag[2]    ...
 *         ...         ...           ...    ...
 */
public static native int gsl_linalg_solve_symm_tridiag(@Const gsl_vector diag,
                                   @Const gsl_vector offdiag,
                                   @Const gsl_vector b,
                                   gsl_vector x);

/* Linear solve for a nonsymmetric tridiagonal system.

 * The input vectors represent the NxN matrix as follows:
 *
 *       diag[0]  abovediag[0]              0    ...
 *  belowdiag[0]       diag[1]   abovediag[1]    ...
 *             0  belowdiag[1]        diag[2]    ...
 *             0             0   belowdiag[2]    ...
 *           ...           ...            ...    ...
 */
public static native int gsl_linalg_solve_tridiag(@Const gsl_vector diag,
                                   @Const gsl_vector abovediag,
                                   @Const gsl_vector belowdiag,
                                   @Const gsl_vector b,
                                   gsl_vector x);


/* Linear solve for a symmetric cyclic tridiagonal system.

 * The input vectors represent the NxN matrix as follows:
 *
 *      diag[0]  offdiag[0]             0   .....  offdiag[N-1]
 *   offdiag[0]     diag[1]    offdiag[1]   .....
 *            0  offdiag[1]       diag[2]   .....
 *            0           0    offdiag[2]   .....
 *          ...         ...
 * offdiag[N-1]         ...
 */
public static native int gsl_linalg_solve_symm_cyc_tridiag(@Const gsl_vector diag,
                                       @Const gsl_vector offdiag,
                                       @Const gsl_vector b,
                                       gsl_vector x);

/* Linear solve for a nonsymmetric cyclic tridiagonal system.

 * The input vectors represent the NxN matrix as follows:
 *
 *        diag[0]  abovediag[0]             0   .....  belowdiag[N-1]
 *   belowdiag[0]       diag[1]  abovediag[1]   .....
 *              0  belowdiag[1]       diag[2]
 *              0             0  belowdiag[2]   .....
 *            ...           ...
 * abovediag[N-1]           ...
 */
public static native int gsl_linalg_solve_cyc_tridiag(@Const gsl_vector diag,
                                  @Const gsl_vector abovediag,
                                  @Const gsl_vector belowdiag,
                                  @Const gsl_vector b,
                                  gsl_vector x);


/* Bidiagonal decomposition */

public static native int gsl_linalg_bidiag_decomp(gsl_matrix A, 
                              gsl_vector tau_U, 
                              gsl_vector tau_V);

public static native int gsl_linalg_bidiag_unpack(@Const gsl_matrix A, 
                              @Const gsl_vector tau_U, 
                              gsl_matrix U, 
                              @Const gsl_vector tau_V,
                              gsl_matrix V,
                              gsl_vector diag, 
                              gsl_vector superdiag);

public static native int gsl_linalg_bidiag_unpack2(gsl_matrix A, 
                               gsl_vector tau_U, 
                               gsl_vector tau_V,
                               gsl_matrix V);

public static native int gsl_linalg_bidiag_unpack_B(@Const gsl_matrix A, 
                                gsl_vector diag, 
                                gsl_vector superdiag);

/* Balancing */

public static native int gsl_linalg_balance_matrix(gsl_matrix A, gsl_vector D);
public static native int gsl_linalg_balance_accum(gsl_matrix A, gsl_vector D);
public static native int gsl_linalg_balance_columns(gsl_matrix A, gsl_vector D);

/* condition estimation */

public static native int gsl_linalg_tri_upper_rcond(@Const gsl_matrix A, DoublePointer rcond, gsl_vector work);
public static native int gsl_linalg_tri_upper_rcond(@Const gsl_matrix A, DoubleBuffer rcond, gsl_vector work);
public static native int gsl_linalg_tri_upper_rcond(@Const gsl_matrix A, double[] rcond, gsl_vector work);
public static native int gsl_linalg_tri_lower_rcond(@Const gsl_matrix A, DoublePointer rcond, gsl_vector work);
public static native int gsl_linalg_tri_lower_rcond(@Const gsl_matrix A, DoubleBuffer rcond, gsl_vector work);
public static native int gsl_linalg_tri_lower_rcond(@Const gsl_matrix A, double[] rcond, gsl_vector work);
public static class Ainvx_int_gsl_vector_Pointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Ainvx_int_gsl_vector_Pointer(Pointer p) { super(p); }
    protected Ainvx_int_gsl_vector_Pointer() { allocate(); }
    private native void allocate();
    public native int call(@Cast("CBLAS_TRANSPOSE_t") int TransA, gsl_vector x, Pointer params);
}
public static native int gsl_linalg_invnorm1(@Cast("const size_t") long N,
                        Ainvx_int_gsl_vector_Pointer Ainvx,
                        Pointer params, DoublePointer Ainvnorm, gsl_vector work);
public static native int gsl_linalg_invnorm1(@Cast("const size_t") long N,
                        Ainvx_int_gsl_vector_Pointer Ainvx,
                        Pointer params, DoubleBuffer Ainvnorm, gsl_vector work);
public static native int gsl_linalg_invnorm1(@Cast("const size_t") long N,
                        Ainvx_int_gsl_vector_Pointer Ainvx,
                        Pointer params, double[] Ainvnorm, gsl_vector work);

/* triangular matrices */

public static native int gsl_linalg_tri_upper_invert(gsl_matrix T);
public static native int gsl_linalg_tri_lower_invert(gsl_matrix T);
public static native int gsl_linalg_tri_upper_unit_invert(gsl_matrix T);
public static native int gsl_linalg_tri_lower_unit_invert(gsl_matrix T);

/* */ public static native void gsl_linalg_givens(double a, double b,
                                    DoublePointer c, DoublePointer s);
public static native void gsl_linalg_givens(double a, double b,
                                    DoubleBuffer c, DoubleBuffer s);
public static native void gsl_linalg_givens(double a, double b,
                                    double[] c, double[] s);
/* */ public static native void gsl_linalg_givens_gv(gsl_vector v, @Cast("const size_t") long i,
                                       @Cast("const size_t") long j, double c,
                                       double s);

// #ifdef HAVE_INLINE

/* Generate a Givens rotation (cos,sin) which takes v=(x,y) to (|v|,0) 
   From Golub and Van Loan, "Matrix Computations", Section 5.1.8 */ /* gsl_linalg_givens() */

// #endif /* HAVE_INLINE */

// #endif /* __GSL_LINALG_H__ */


// Parsed from gsl/gsl_poly.h

/* poly/gsl_poly.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_POLY_H__
// #define __GSL_POLY_H__

// #include <stdlib.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_complex.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Evaluate polynomial
 *
 * c[0] + c[1] x + c[2] x^2 + ... + c[len-1] x^(len-1)
 *
 * exceptions: none
 */

/* real polynomial, real x */
/* */ public static native double gsl_poly_eval(@Const DoublePointer c, int len, double x);
public static native double gsl_poly_eval(@Const DoubleBuffer c, int len, double x);
public static native double gsl_poly_eval(@Const double[] c, int len, double x);

/* real polynomial, complex x */
/* */ public static native @ByVal gsl_complex gsl_poly_complex_eval(@Const DoublePointer c, int len, @Const @ByVal gsl_complex z);
public static native @ByVal gsl_complex gsl_poly_complex_eval(@Const DoubleBuffer c, int len, @Const @ByVal gsl_complex z);
public static native @ByVal gsl_complex gsl_poly_complex_eval(@Const double[] c, int len, @Const @ByVal gsl_complex z);

/* complex polynomial, complex x */
/* */ public static native @ByVal gsl_complex gsl_complex_poly_complex_eval(@Const gsl_complex c, int len, @Const @ByVal gsl_complex z);

public static native int gsl_poly_eval_derivs(@Const DoublePointer c, @Cast("const size_t") long lenc, double x, DoublePointer res, @Cast("const size_t") long lenres);
public static native int gsl_poly_eval_derivs(@Const DoubleBuffer c, @Cast("const size_t") long lenc, double x, DoubleBuffer res, @Cast("const size_t") long lenres);
public static native int gsl_poly_eval_derivs(@Const double[] c, @Cast("const size_t") long lenc, double x, double[] res, @Cast("const size_t") long lenres);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */

/* Work with divided-difference polynomials, Abramowitz & Stegun 25.2.26 */

public static native int gsl_poly_dd_init(DoublePointer dd, @Const DoublePointer x, @Const DoublePointer y,
                  @Cast("size_t") long size);
public static native int gsl_poly_dd_init(DoubleBuffer dd, @Const DoubleBuffer x, @Const DoubleBuffer y,
                  @Cast("size_t") long size);
public static native int gsl_poly_dd_init(double[] dd, @Const double[] x, @Const double[] y,
                  @Cast("size_t") long size);

/* */ public static native double gsl_poly_dd_eval(@Const DoublePointer dd, @Const DoublePointer xa, @Cast("const size_t") long size, double x);
public static native double gsl_poly_dd_eval(@Const DoubleBuffer dd, @Const DoubleBuffer xa, @Cast("const size_t") long size, double x);
public static native double gsl_poly_dd_eval(@Const double[] dd, @Const double[] xa, @Cast("const size_t") long size, double x);

// #ifdef HAVE_INLINE
// #endif /* HAVE_INLINE */


public static native int gsl_poly_dd_taylor(DoublePointer c, double xp,
                    @Const DoublePointer dd, @Const DoublePointer x, @Cast("size_t") long size,
                    DoublePointer w);
public static native int gsl_poly_dd_taylor(DoubleBuffer c, double xp,
                    @Const DoubleBuffer dd, @Const DoubleBuffer x, @Cast("size_t") long size,
                    DoubleBuffer w);
public static native int gsl_poly_dd_taylor(double[] c, double xp,
                    @Const double[] dd, @Const double[] x, @Cast("size_t") long size,
                    double[] w);

public static native int gsl_poly_dd_hermite_init(DoublePointer dd, DoublePointer z, @Const DoublePointer xa, @Const DoublePointer ya,
                          @Const DoublePointer dya, @Cast("const size_t") long size);
public static native int gsl_poly_dd_hermite_init(DoubleBuffer dd, DoubleBuffer z, @Const DoubleBuffer xa, @Const DoubleBuffer ya,
                          @Const DoubleBuffer dya, @Cast("const size_t") long size);
public static native int gsl_poly_dd_hermite_init(double[] dd, double[] z, @Const double[] xa, @Const double[] ya,
                          @Const double[] dya, @Cast("const size_t") long size);

/* Solve for real or complex roots of the standard quadratic equation,
 * returning the number of real roots.
 *
 * Roots are returned ordered.
 */
public static native int gsl_poly_solve_quadratic(double a, double b, double c, 
                              DoublePointer x0, DoublePointer x1);
public static native int gsl_poly_solve_quadratic(double a, double b, double c, 
                              DoubleBuffer x0, DoubleBuffer x1);
public static native int gsl_poly_solve_quadratic(double a, double b, double c, 
                              double[] x0, double[] x1);

public static native int gsl_poly_complex_solve_quadratic(double a, double b, double c, 
                                  gsl_complex z0, gsl_complex z1);


/* Solve for real roots of the cubic equation
 * x^3 + a x^2 + b x + c = 0, returning the
 * number of real roots.
 *
 * Roots are returned ordered.
 */
public static native int gsl_poly_solve_cubic(double a, double b, double c, 
                          DoublePointer x0, DoublePointer x1, DoublePointer x2);
public static native int gsl_poly_solve_cubic(double a, double b, double c, 
                          DoubleBuffer x0, DoubleBuffer x1, DoubleBuffer x2);
public static native int gsl_poly_solve_cubic(double a, double b, double c, 
                          double[] x0, double[] x1, double[] x2);

public static native int gsl_poly_complex_solve_cubic(double a, double b, double c, 
                              gsl_complex z0, gsl_complex z1, 
                              gsl_complex z2);


/* Solve for the complex roots of a general real polynomial */

 public static class gsl_poly_complex_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_poly_complex_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_poly_complex_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_poly_complex_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_poly_complex_workspace position(long position) {
        return (gsl_poly_complex_workspace)super.position(position);
    }
 
  public native @Cast("size_t") long nc(); public native gsl_poly_complex_workspace nc(long nc);
  public native DoublePointer matrix(); public native gsl_poly_complex_workspace matrix(DoublePointer matrix); 
} 

public static native gsl_poly_complex_workspace gsl_poly_complex_workspace_alloc(@Cast("size_t") long n);
public static native void gsl_poly_complex_workspace_free(gsl_poly_complex_workspace w);

public static native int gsl_poly_complex_solve(@Const DoublePointer a, @Cast("size_t") long n, 
                        gsl_poly_complex_workspace w,
                        @Cast("gsl_complex_packed_ptr") DoublePointer z);
public static native int gsl_poly_complex_solve(@Const DoubleBuffer a, @Cast("size_t") long n, 
                        gsl_poly_complex_workspace w,
                        @Cast("gsl_complex_packed_ptr") DoubleBuffer z);
public static native int gsl_poly_complex_solve(@Const double[] a, @Cast("size_t") long n, 
                        gsl_poly_complex_workspace w,
                        @Cast("gsl_complex_packed_ptr") double[] z);

// #endif /* __GSL_POLY_H__ */


// Parsed from gsl/gsl_rng.h

/* rng/gsl_rng.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007 James Theiler, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_RNG_H__
// #define __GSL_RNG_H__
// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_rng_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_rng_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_rng_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_rng_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_rng_type position(long position) {
        return (gsl_rng_type)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native @Cast("unsigned long int") long max(); public native gsl_rng_type max(long max);
    public native @Cast("unsigned long int") long min(); public native gsl_rng_type min(long min);
    public native @Cast("size_t") long size(); public native gsl_rng_type size(long size);
    public static class Set_Pointer_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Set_Pointer_long(Pointer p) { super(p); }
        protected Set_Pointer_long() { allocate(); }
        private native void allocate();
        public native void call(Pointer state, @Cast("unsigned long int") long seed);
    }
    public native Set_Pointer_long set(); public native gsl_rng_type set(Set_Pointer_long set);
    public static class Get_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Get_Pointer(Pointer p) { super(p); }
        protected Get_Pointer() { allocate(); }
        private native void allocate();
        public native @Cast("unsigned long int") long call(Pointer state);
    }
    public native Get_Pointer get(); public native gsl_rng_type get(Get_Pointer get);
    public static class Get_double_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Get_double_Pointer(Pointer p) { super(p); }
        protected Get_double_Pointer() { allocate(); }
        private native void allocate();
        public native double call(Pointer state);
    }
    public native Get_double_Pointer get_double(); public native gsl_rng_type get_double(Get_double_Pointer get_double);
  }

public static class gsl_rng extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_rng() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_rng(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_rng(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_rng position(long position) {
        return (gsl_rng)super.position(position);
    }

    @MemberGetter public native @Const gsl_rng_type type();
    public native Pointer state(); public native gsl_rng state(Pointer state);
  }


/* These structs also need to appear in default.c so you can select
   them via the environment variable GSL_RNG_TYPE */

@MemberGetter public static native @Const gsl_rng_type gsl_rng_borosh13();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_coveyou();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_cmrg();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_fishman18();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_fishman20();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_fishman2x();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_gfsr4();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_knuthran();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_knuthran2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_knuthran2002();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_lecuyer21();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_minstd();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_mrg();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_mt19937();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_mt19937_1999();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_mt19937_1998();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_r250();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ran0();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ran1();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ran2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ran3();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_rand();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_rand48();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random128_bsd();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random128_glibc2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random128_libc5();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random256_bsd();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random256_glibc2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random256_libc5();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random32_bsd();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random32_glibc2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random32_libc5();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random64_bsd();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random64_glibc2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random64_libc5();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random8_bsd();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random8_glibc2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random8_libc5();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random_bsd();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random_glibc2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_random_libc5();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_randu();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ranf();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ranlux();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ranlux389();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ranlxd1();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ranlxd2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ranlxs0();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ranlxs1();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ranlxs2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_ranmar();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_slatec();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_taus();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_taus2();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_taus113();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_transputer();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_tt800();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_uni();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_uni32();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_vax();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_waterman14();
@MemberGetter public static native @Const gsl_rng_type gsl_rng_zuf();

public static native @Cast("const gsl_rng_type**") PointerPointer gsl_rng_types_setup();

@MemberGetter public static native @Const gsl_rng_type gsl_rng_default();
public static native @Cast("unsigned long int") long gsl_rng_default_seed(); public static native void gsl_rng_default_seed(long gsl_rng_default_seed);

public static native gsl_rng gsl_rng_alloc(@Const gsl_rng_type T);
public static native int gsl_rng_memcpy(gsl_rng dest, @Const gsl_rng src);
public static native gsl_rng gsl_rng_clone(@Const gsl_rng r);

public static native void gsl_rng_free(gsl_rng r);

public static native void gsl_rng_set(@Const gsl_rng r, @Cast("unsigned long int") long seed);
public static native @Cast("unsigned long int") long gsl_rng_max(@Const gsl_rng r);
public static native @Cast("unsigned long int") long gsl_rng_min(@Const gsl_rng r);
public static native @Cast("const char*") BytePointer gsl_rng_name(@Const gsl_rng r);

public static native int gsl_rng_fread(@Cast("FILE*") Pointer stream, gsl_rng r);
public static native int gsl_rng_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_rng r);

public static native @Cast("size_t") long gsl_rng_size(@Const gsl_rng r);
public static native Pointer gsl_rng_state(@Const gsl_rng r);

public static native void gsl_rng_print_state(@Const gsl_rng r);

public static native @Const gsl_rng_type gsl_rng_env_setup();

/* */ public static native @Cast("unsigned long int") long gsl_rng_get(@Const gsl_rng r);
/* */ public static native double gsl_rng_uniform(@Const gsl_rng r);
/* */ public static native double gsl_rng_uniform_pos(@Const gsl_rng r);
/* */ public static native @Cast("unsigned long int") long gsl_rng_uniform_int(@Const gsl_rng r, @Cast("unsigned long int") long n);

// #ifdef HAVE_INLINE

/* Note: to avoid integer overflow in (range+1) we work with scale =
   range/n = (max-min)/n rather than scale=(max-min+1)/n, this reduces
   efficiency slightly but avoids having to check for the out of range
   value.  Note that range is typically O(2^32) so the addition of 1
   is negligible in most usage. */
// #endif /* HAVE_INLINE */

// #endif /* __GSL_RNG_H__ */


// Parsed from gsl/gsl_qrng.h

/* Author: G. Jungman + modifications from O. Teytaud
 */
// #ifndef __GSL_QRNG_H__
// #define __GSL_QRNG_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_inline.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Once again, more inane C-style OOP... kill me now. */

/* Structure describing a type of generator.
 */
public static class gsl_qrng_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_qrng_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_qrng_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_qrng_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_qrng_type position(long position) {
        return (gsl_qrng_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public native @Cast("unsigned int") int max_dimension(); public native gsl_qrng_type max_dimension(int max_dimension);
  public static class State_size_int extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    State_size_int(Pointer p) { super(p); }
      protected State_size_int() { allocate(); }
      private native void allocate();
      public native @Cast("size_t") long call(@Cast("unsigned int") int dimension);
  }
  public native State_size_int state_size(); public native gsl_qrng_type state_size(State_size_int state_size);
  public static class Init_state_Pointer_int extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Init_state_Pointer_int(Pointer p) { super(p); }
      protected Init_state_Pointer_int() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("unsigned int") int dimension);
  }
  public native Init_state_Pointer_int init_state(); public native gsl_qrng_type init_state(Init_state_Pointer_int init_state);
  public static class Get_Pointer_int_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Get_Pointer_int_DoublePointer(Pointer p) { super(p); }
      protected Get_Pointer_int_DoublePointer() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("unsigned int") int dimension, DoublePointer x);
  }
  public native Get_Pointer_int_DoublePointer get(); public native gsl_qrng_type get(Get_Pointer_int_DoublePointer get);
}

/* Structure describing a generator instance of a
 * specified type, with generator-specific state info
 * and dimension-specific info.
 */
public static class gsl_qrng extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_qrng() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_qrng(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_qrng(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_qrng position(long position) {
        return (gsl_qrng)super.position(position);
    }

  @MemberGetter public native @Const gsl_qrng_type type();
  public native @Cast("unsigned int") int dimension(); public native gsl_qrng dimension(int dimension);
  public native @Cast("size_t") long state_size(); public native gsl_qrng state_size(long state_size);
  public native Pointer state(); public native gsl_qrng state(Pointer state);
}


/* Supported generator types.
 */
@MemberGetter public static native @Const gsl_qrng_type gsl_qrng_niederreiter_2();
@MemberGetter public static native @Const gsl_qrng_type gsl_qrng_sobol();
@MemberGetter public static native @Const gsl_qrng_type gsl_qrng_halton();
@MemberGetter public static native @Const gsl_qrng_type gsl_qrng_reversehalton();


/* Allocate and initialize a generator
 * of the specified type, in the given
 * space dimension.
 */
public static native gsl_qrng gsl_qrng_alloc(@Const gsl_qrng_type T, @Cast("unsigned int") int dimension);


/* Copy a generator. */
public static native int gsl_qrng_memcpy(gsl_qrng dest, @Const gsl_qrng src);


/* Clone a generator. */
public static native gsl_qrng gsl_qrng_clone(@Const gsl_qrng q);


/* Free a generator. */
public static native void gsl_qrng_free(gsl_qrng q);


/* Intialize a generator. */
public static native void gsl_qrng_init(gsl_qrng q);


/* Get the standardized name of the generator. */
public static native @Cast("const char*") BytePointer gsl_qrng_name(@Const gsl_qrng q);


/* ISN'T THIS CONFUSING FOR PEOPLE?
  WHAT IF SOMEBODY TRIES TO COPY WITH THIS ???
  */
public static native @Cast("size_t") long gsl_qrng_size(@Const gsl_qrng q);


public static native Pointer gsl_qrng_state(@Const gsl_qrng q);


/* Retrieve next vector in sequence. */
/* */ public static native int gsl_qrng_get(@Const gsl_qrng q, DoublePointer x);
public static native int gsl_qrng_get(@Const gsl_qrng q, DoubleBuffer x);
public static native int gsl_qrng_get(@Const gsl_qrng q, double[] x);

// #ifdef HAVE_INLINE

// #endif /* HAVE_INLINE */


// #endif /* !__GSL_QRNG_H__ */


// Parsed from gsl/gsl_randist.h

/* randist/gsl_randist.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 James Theiler, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_RANDIST_H__
// #define __GSL_RANDIST_H__
// #include <gsl/gsl_rng.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native @Cast("unsigned int") int gsl_ran_bernoulli(@Const gsl_rng r, double p);
public static native double gsl_ran_bernoulli_pdf(@Cast("const unsigned int") int k, double p);

public static native double gsl_ran_beta(@Const gsl_rng r, double a, double b);
public static native double gsl_ran_beta_pdf(double x, double a, double b);

public static native @Cast("unsigned int") int gsl_ran_binomial(@Const gsl_rng r, double p, @Cast("unsigned int") int n);
public static native @Cast("unsigned int") int gsl_ran_binomial_knuth(@Const gsl_rng r, double p, @Cast("unsigned int") int n);
public static native @Cast("unsigned int") int gsl_ran_binomial_tpe(@Const gsl_rng r, double p, @Cast("unsigned int") int n);
public static native double gsl_ran_binomial_pdf(@Cast("const unsigned int") int k, double p, @Cast("const unsigned int") int n);

public static native double gsl_ran_exponential(@Const gsl_rng r, double mu);
public static native double gsl_ran_exponential_pdf(double x, double mu);

public static native double gsl_ran_exppow(@Const gsl_rng r, double a, double b);
public static native double gsl_ran_exppow_pdf(double x, double a, double b);

public static native double gsl_ran_cauchy(@Const gsl_rng r, double a);
public static native double gsl_ran_cauchy_pdf(double x, double a);

public static native double gsl_ran_chisq(@Const gsl_rng r, double nu);
public static native double gsl_ran_chisq_pdf(double x, double nu);

public static native void gsl_ran_dirichlet(@Const gsl_rng r, @Cast("const size_t") long K, @Const DoublePointer alpha, DoublePointer theta);
public static native void gsl_ran_dirichlet(@Const gsl_rng r, @Cast("const size_t") long K, @Const DoubleBuffer alpha, DoubleBuffer theta);
public static native void gsl_ran_dirichlet(@Const gsl_rng r, @Cast("const size_t") long K, @Const double[] alpha, double[] theta);
public static native double gsl_ran_dirichlet_pdf(@Cast("const size_t") long K, @Const DoublePointer alpha, @Const DoublePointer theta);
public static native double gsl_ran_dirichlet_pdf(@Cast("const size_t") long K, @Const DoubleBuffer alpha, @Const DoubleBuffer theta);
public static native double gsl_ran_dirichlet_pdf(@Cast("const size_t") long K, @Const double[] alpha, @Const double[] theta);
public static native double gsl_ran_dirichlet_lnpdf(@Cast("const size_t") long K, @Const DoublePointer alpha, @Const DoublePointer theta);
public static native double gsl_ran_dirichlet_lnpdf(@Cast("const size_t") long K, @Const DoubleBuffer alpha, @Const DoubleBuffer theta);
public static native double gsl_ran_dirichlet_lnpdf(@Cast("const size_t") long K, @Const double[] alpha, @Const double[] theta);

public static native double gsl_ran_erlang(@Const gsl_rng r, double a, double n);
public static native double gsl_ran_erlang_pdf(double x, double a, double n);

public static native double gsl_ran_fdist(@Const gsl_rng r, double nu1, double nu2);
public static native double gsl_ran_fdist_pdf(double x, double nu1, double nu2);

public static native double gsl_ran_flat(@Const gsl_rng r, double a, double b);
public static native double gsl_ran_flat_pdf(double x, double a, double b);

public static native double gsl_ran_gamma(@Const gsl_rng r, double a, double b);
public static native double gsl_ran_gamma_int(@Const gsl_rng r, @Cast("const unsigned int") int a);
public static native double gsl_ran_gamma_pdf(double x, double a, double b);
public static native double gsl_ran_gamma_mt(@Const gsl_rng r, double a, double b);
public static native double gsl_ran_gamma_knuth(@Const gsl_rng r, double a, double b);

public static native double gsl_ran_gaussian(@Const gsl_rng r, double sigma);
public static native double gsl_ran_gaussian_ratio_method(@Const gsl_rng r, double sigma);
public static native double gsl_ran_gaussian_ziggurat(@Const gsl_rng r, double sigma);
public static native double gsl_ran_gaussian_pdf(double x, double sigma);

public static native double gsl_ran_ugaussian(@Const gsl_rng r);
public static native double gsl_ran_ugaussian_ratio_method(@Const gsl_rng r);
public static native double gsl_ran_ugaussian_pdf(double x);

public static native double gsl_ran_gaussian_tail(@Const gsl_rng r, double a, double sigma);
public static native double gsl_ran_gaussian_tail_pdf(double x, double a, double sigma);

public static native double gsl_ran_ugaussian_tail(@Const gsl_rng r, double a);
public static native double gsl_ran_ugaussian_tail_pdf(double x, double a);

public static native void gsl_ran_bivariate_gaussian(@Const gsl_rng r, double sigma_x, double sigma_y, double rho, DoublePointer x, DoublePointer y);
public static native void gsl_ran_bivariate_gaussian(@Const gsl_rng r, double sigma_x, double sigma_y, double rho, DoubleBuffer x, DoubleBuffer y);
public static native void gsl_ran_bivariate_gaussian(@Const gsl_rng r, double sigma_x, double sigma_y, double rho, double[] x, double[] y);
public static native double gsl_ran_bivariate_gaussian_pdf(double x, double y, double sigma_x, double sigma_y, double rho);

public static native int gsl_ran_multivariate_gaussian(@Const gsl_rng r, @Const gsl_vector mu, @Const gsl_matrix L, gsl_vector result);
public static native int gsl_ran_multivariate_gaussian_log_pdf(@Const gsl_vector x,
                                           @Const gsl_vector mu,
                                           @Const gsl_matrix L,
                                           DoublePointer result,
                                           gsl_vector work);
public static native int gsl_ran_multivariate_gaussian_log_pdf(@Const gsl_vector x,
                                           @Const gsl_vector mu,
                                           @Const gsl_matrix L,
                                           DoubleBuffer result,
                                           gsl_vector work);
public static native int gsl_ran_multivariate_gaussian_log_pdf(@Const gsl_vector x,
                                           @Const gsl_vector mu,
                                           @Const gsl_matrix L,
                                           double[] result,
                                           gsl_vector work);
public static native int gsl_ran_multivariate_gaussian_pdf(@Const gsl_vector x,
                                       @Const gsl_vector mu,
                                       @Const gsl_matrix L,
                                       DoublePointer result,
                                       gsl_vector work);
public static native int gsl_ran_multivariate_gaussian_pdf(@Const gsl_vector x,
                                       @Const gsl_vector mu,
                                       @Const gsl_matrix L,
                                       DoubleBuffer result,
                                       gsl_vector work);
public static native int gsl_ran_multivariate_gaussian_pdf(@Const gsl_vector x,
                                       @Const gsl_vector mu,
                                       @Const gsl_matrix L,
                                       double[] result,
                                       gsl_vector work);
public static native int gsl_ran_multivariate_gaussian_mean(@Const gsl_matrix X, gsl_vector mu_hat);
public static native int gsl_ran_multivariate_gaussian_vcov(@Const gsl_matrix X, gsl_matrix sigma_hat);

public static native double gsl_ran_landau(@Const gsl_rng r);
public static native double gsl_ran_landau_pdf(double x);

public static native @Cast("unsigned int") int gsl_ran_geometric(@Const gsl_rng r, double p);
public static native double gsl_ran_geometric_pdf(@Cast("const unsigned int") int k, double p);

public static native @Cast("unsigned int") int gsl_ran_hypergeometric(@Const gsl_rng r, @Cast("unsigned int") int n1, @Cast("unsigned int") int n2, @Cast("unsigned int") int t);
public static native double gsl_ran_hypergeometric_pdf(@Cast("const unsigned int") int k, @Cast("const unsigned int") int n1, @Cast("const unsigned int") int n2, @Cast("unsigned int") int t);

public static native double gsl_ran_gumbel1(@Const gsl_rng r, double a, double b);
public static native double gsl_ran_gumbel1_pdf(double x, double a, double b);

public static native double gsl_ran_gumbel2(@Const gsl_rng r, double a, double b);
public static native double gsl_ran_gumbel2_pdf(double x, double a, double b);

public static native double gsl_ran_logistic(@Const gsl_rng r, double a);
public static native double gsl_ran_logistic_pdf(double x, double a);

public static native double gsl_ran_lognormal(@Const gsl_rng r, double zeta, double sigma);
public static native double gsl_ran_lognormal_pdf(double x, double zeta, double sigma);

public static native @Cast("unsigned int") int gsl_ran_logarithmic(@Const gsl_rng r, double p);
public static native double gsl_ran_logarithmic_pdf(@Cast("const unsigned int") int k, double p);

public static native void gsl_ran_multinomial(@Const gsl_rng r, @Cast("const size_t") long K,
                          @Cast("const unsigned int") int N, @Const DoublePointer p,
                          @Cast("unsigned int*") IntPointer n );
public static native void gsl_ran_multinomial(@Const gsl_rng r, @Cast("const size_t") long K,
                          @Cast("const unsigned int") int N, @Const DoubleBuffer p,
                          @Cast("unsigned int*") IntBuffer n );
public static native void gsl_ran_multinomial(@Const gsl_rng r, @Cast("const size_t") long K,
                          @Cast("const unsigned int") int N, @Const double[] p,
                          @Cast("unsigned int*") int[] n );
public static native double gsl_ran_multinomial_pdf(@Cast("const size_t") long K,
                                @Const DoublePointer p, @Cast("const unsigned int*") IntPointer n );
public static native double gsl_ran_multinomial_pdf(@Cast("const size_t") long K,
                                @Const DoubleBuffer p, @Cast("const unsigned int*") IntBuffer n );
public static native double gsl_ran_multinomial_pdf(@Cast("const size_t") long K,
                                @Const double[] p, @Cast("const unsigned int*") int[] n );
public static native double gsl_ran_multinomial_lnpdf(@Cast("const size_t") long K,
                           @Const DoublePointer p, @Cast("const unsigned int*") IntPointer n );
public static native double gsl_ran_multinomial_lnpdf(@Cast("const size_t") long K,
                           @Const DoubleBuffer p, @Cast("const unsigned int*") IntBuffer n );
public static native double gsl_ran_multinomial_lnpdf(@Cast("const size_t") long K,
                           @Const double[] p, @Cast("const unsigned int*") int[] n );


public static native @Cast("unsigned int") int gsl_ran_negative_binomial(@Const gsl_rng r, double p, double n);
public static native double gsl_ran_negative_binomial_pdf(@Cast("const unsigned int") int k, double p, double n);

public static native @Cast("unsigned int") int gsl_ran_pascal(@Const gsl_rng r, double p, @Cast("unsigned int") int n);
public static native double gsl_ran_pascal_pdf(@Cast("const unsigned int") int k, double p, @Cast("unsigned int") int n);

public static native double gsl_ran_pareto(@Const gsl_rng r, double a, double b);
public static native double gsl_ran_pareto_pdf(double x, double a, double b);

public static native @Cast("unsigned int") int gsl_ran_poisson(@Const gsl_rng r, double mu);
public static native void gsl_ran_poisson_array(@Const gsl_rng r, @Cast("size_t") long n, @Cast("unsigned int*") IntPointer array,
                            double mu);
public static native void gsl_ran_poisson_array(@Const gsl_rng r, @Cast("size_t") long n, @Cast("unsigned int*") IntBuffer array,
                            double mu);
public static native void gsl_ran_poisson_array(@Const gsl_rng r, @Cast("size_t") long n, @Cast("unsigned int*") int[] array,
                            double mu);
public static native double gsl_ran_poisson_pdf(@Cast("const unsigned int") int k, double mu);

public static native double gsl_ran_rayleigh(@Const gsl_rng r, double sigma);
public static native double gsl_ran_rayleigh_pdf(double x, double sigma);

public static native double gsl_ran_rayleigh_tail(@Const gsl_rng r, double a, double sigma);
public static native double gsl_ran_rayleigh_tail_pdf(double x, double a, double sigma);

public static native double gsl_ran_tdist(@Const gsl_rng r, double nu);
public static native double gsl_ran_tdist_pdf(double x, double nu);

public static native double gsl_ran_laplace(@Const gsl_rng r, double a);
public static native double gsl_ran_laplace_pdf(double x, double a);

public static native double gsl_ran_levy(@Const gsl_rng r, double c, double alpha);
public static native double gsl_ran_levy_skew(@Const gsl_rng r, double c, double alpha, double beta);

public static native double gsl_ran_weibull(@Const gsl_rng r, double a, double b);
public static native double gsl_ran_weibull_pdf(double x, double a, double b);

public static native void gsl_ran_dir_2d(@Const gsl_rng r, DoublePointer x, DoublePointer y);
public static native void gsl_ran_dir_2d(@Const gsl_rng r, DoubleBuffer x, DoubleBuffer y);
public static native void gsl_ran_dir_2d(@Const gsl_rng r, double[] x, double[] y);
public static native void gsl_ran_dir_2d_trig_method(@Const gsl_rng r, DoublePointer x, DoublePointer y);
public static native void gsl_ran_dir_2d_trig_method(@Const gsl_rng r, DoubleBuffer x, DoubleBuffer y);
public static native void gsl_ran_dir_2d_trig_method(@Const gsl_rng r, double[] x, double[] y);
public static native void gsl_ran_dir_3d(@Const gsl_rng r, DoublePointer x, DoublePointer y, DoublePointer z);
public static native void gsl_ran_dir_3d(@Const gsl_rng r, DoubleBuffer x, DoubleBuffer y, DoubleBuffer z);
public static native void gsl_ran_dir_3d(@Const gsl_rng r, double[] x, double[] y, double[] z);
public static native void gsl_ran_dir_nd(@Const gsl_rng r, @Cast("size_t") long n, DoublePointer x);
public static native void gsl_ran_dir_nd(@Const gsl_rng r, @Cast("size_t") long n, DoubleBuffer x);
public static native void gsl_ran_dir_nd(@Const gsl_rng r, @Cast("size_t") long n, double[] x);

public static native void gsl_ran_shuffle(@Const gsl_rng r, Pointer base, @Cast("size_t") long nmembm, @Cast("size_t") long size);
public static native int gsl_ran_choose(@Const gsl_rng r, Pointer dest, @Cast("size_t") long k, Pointer src, @Cast("size_t") long n, @Cast("size_t") long size);
public static native void gsl_ran_sample(@Const gsl_rng r, Pointer dest, @Cast("size_t") long k, Pointer src, @Cast("size_t") long n, @Cast("size_t") long size);


public static class gsl_ran_discrete_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_ran_discrete_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_ran_discrete_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_ran_discrete_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_ran_discrete_t position(long position) {
        return (gsl_ran_discrete_t)super.position(position);
    }
                /* struct for Walker algorithm */
    public native @Cast("size_t") long K(); public native gsl_ran_discrete_t K(long K);
    public native @Cast("size_t*") SizeTPointer A(); public native gsl_ran_discrete_t A(SizeTPointer A);
    public native DoublePointer F(); public native gsl_ran_discrete_t F(DoublePointer F);
}

public static native gsl_ran_discrete_t gsl_ran_discrete_preproc(@Cast("size_t") long K, @Const DoublePointer P);
public static native gsl_ran_discrete_t gsl_ran_discrete_preproc(@Cast("size_t") long K, @Const DoubleBuffer P);
public static native gsl_ran_discrete_t gsl_ran_discrete_preproc(@Cast("size_t") long K, @Const double[] P);
public static native void gsl_ran_discrete_free(gsl_ran_discrete_t g);
public static native @Cast("size_t") long gsl_ran_discrete(@Const gsl_rng r, @Const gsl_ran_discrete_t g);
public static native double gsl_ran_discrete_pdf(@Cast("size_t") long k, @Const gsl_ran_discrete_t g);

// #endif /* __GSL_RANDIST_H__ */


// Parsed from gsl/gsl_roots.h

/* roots/gsl_roots.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Reid Priedhorsky, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_ROOTS_H__
// #define __GSL_ROOTS_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_math.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_root_fsolver_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_root_fsolver_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_root_fsolver_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_root_fsolver_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_root_fsolver_type position(long position) {
        return (gsl_root_fsolver_type)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native @Cast("size_t") long size(); public native gsl_root_fsolver_type size(long size);
    public static class Set_Pointer_gsl_function_DoublePointer_double_double extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Set_Pointer_gsl_function_DoublePointer_double_double(Pointer p) { super(p); }
        protected Set_Pointer_gsl_function_DoublePointer_double_double() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_function f, DoublePointer root, double x_lower, double x_upper);
    }
    public native Set_Pointer_gsl_function_DoublePointer_double_double set(); public native gsl_root_fsolver_type set(Set_Pointer_gsl_function_DoublePointer_double_double set);
    public static class Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer(Pointer p) { super(p); }
        protected Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_function f, DoublePointer root, DoublePointer x_lower, DoublePointer x_upper);
    }
    public native Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer iterate(); public native gsl_root_fsolver_type iterate(Iterate_Pointer_gsl_function_DoublePointer_DoublePointer_DoublePointer iterate);
  }

public static class gsl_root_fsolver extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_root_fsolver() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_root_fsolver(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_root_fsolver(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_root_fsolver position(long position) {
        return (gsl_root_fsolver)super.position(position);
    }

    @MemberGetter public native @Const gsl_root_fsolver_type type();
    public native gsl_function function(); public native gsl_root_fsolver function(gsl_function function);
    public native double root(); public native gsl_root_fsolver root(double root);
    public native double x_lower(); public native gsl_root_fsolver x_lower(double x_lower);
    public native double x_upper(); public native gsl_root_fsolver x_upper(double x_upper);
    public native Pointer state(); public native gsl_root_fsolver state(Pointer state);
  }

public static class gsl_root_fdfsolver_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_root_fdfsolver_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_root_fdfsolver_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_root_fdfsolver_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_root_fdfsolver_type position(long position) {
        return (gsl_root_fdfsolver_type)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native @Cast("size_t") long size(); public native gsl_root_fdfsolver_type size(long size);
    public static class Set_Pointer_gsl_function_fdf_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Set_Pointer_gsl_function_fdf_DoublePointer(Pointer p) { super(p); }
        protected Set_Pointer_gsl_function_fdf_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_function_fdf f, DoublePointer root);
    }
    public native Set_Pointer_gsl_function_fdf_DoublePointer set(); public native gsl_root_fdfsolver_type set(Set_Pointer_gsl_function_fdf_DoublePointer set);
    public static class Iterate_Pointer_gsl_function_fdf_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Iterate_Pointer_gsl_function_fdf_DoublePointer(Pointer p) { super(p); }
        protected Iterate_Pointer_gsl_function_fdf_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_function_fdf f, DoublePointer root);
    }
    public native Iterate_Pointer_gsl_function_fdf_DoublePointer iterate(); public native gsl_root_fdfsolver_type iterate(Iterate_Pointer_gsl_function_fdf_DoublePointer iterate);
  }

public static class gsl_root_fdfsolver extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_root_fdfsolver() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_root_fdfsolver(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_root_fdfsolver(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_root_fdfsolver position(long position) {
        return (gsl_root_fdfsolver)super.position(position);
    }

    @MemberGetter public native @Const gsl_root_fdfsolver_type type();
    public native gsl_function_fdf fdf(); public native gsl_root_fdfsolver fdf(gsl_function_fdf fdf);
    public native double root(); public native gsl_root_fdfsolver root(double root);
    public native Pointer state(); public native gsl_root_fdfsolver state(Pointer state);
  }

public static native gsl_root_fsolver gsl_root_fsolver_alloc(@Const gsl_root_fsolver_type T);
public static native void gsl_root_fsolver_free(gsl_root_fsolver s);

public static native int gsl_root_fsolver_set(gsl_root_fsolver s,
                          gsl_function f, 
                          double x_lower, double x_upper);

public static native int gsl_root_fsolver_iterate(gsl_root_fsolver s);

public static native @Cast("const char*") BytePointer gsl_root_fsolver_name(@Const gsl_root_fsolver s);
public static native double gsl_root_fsolver_root(@Const gsl_root_fsolver s);
public static native double gsl_root_fsolver_x_lower(@Const gsl_root_fsolver s);
public static native double gsl_root_fsolver_x_upper(@Const gsl_root_fsolver s);


public static native gsl_root_fdfsolver gsl_root_fdfsolver_alloc(@Const gsl_root_fdfsolver_type T);

public static native int gsl_root_fdfsolver_set(gsl_root_fdfsolver s, 
                         gsl_function_fdf fdf, double root);

public static native int gsl_root_fdfsolver_iterate(gsl_root_fdfsolver s);

public static native void gsl_root_fdfsolver_free(gsl_root_fdfsolver s);

public static native @Cast("const char*") BytePointer gsl_root_fdfsolver_name(@Const gsl_root_fdfsolver s);
public static native double gsl_root_fdfsolver_root(@Const gsl_root_fdfsolver s);

public static native int gsl_root_test_interval(double x_lower, double x_upper, double epsabs, double epsrel);

public static native int gsl_root_test_residual(double f, double epsabs);

public static native int gsl_root_test_delta(double x1, double x0, double epsabs, double epsrel);

@MemberGetter public static native @Const gsl_root_fsolver_type gsl_root_fsolver_bisection();
@MemberGetter public static native @Const gsl_root_fsolver_type gsl_root_fsolver_brent();
@MemberGetter public static native @Const gsl_root_fsolver_type gsl_root_fsolver_falsepos();
@MemberGetter public static native @Const gsl_root_fdfsolver_type gsl_root_fdfsolver_newton();
@MemberGetter public static native @Const gsl_root_fdfsolver_type gsl_root_fdfsolver_secant();
@MemberGetter public static native @Const gsl_root_fdfsolver_type gsl_root_fdfsolver_steffenson();

// #endif /* __GSL_ROOTS_H__ */


// Parsed from gsl/gsl_siman.h

/* siman/gsl_siman.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Mark Galassi
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SIMAN_H__
// #define __GSL_SIMAN_H__
// #include <stdlib.h>
// #include <gsl/gsl_rng.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* types for the function pointers passed to gsl_siman_solve */

public static class gsl_siman_Efunc_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_siman_Efunc_t(Pointer p) { super(p); }
    protected gsl_siman_Efunc_t() { allocate(); }
    private native void allocate();
    public native double call(Pointer xp);
}
public static class gsl_siman_step_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_siman_step_t(Pointer p) { super(p); }
    protected gsl_siman_step_t() { allocate(); }
    private native void allocate();
    public native void call(@Const gsl_rng r, Pointer xp, double step_size);
}
public static class gsl_siman_metric_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_siman_metric_t(Pointer p) { super(p); }
    protected gsl_siman_metric_t() { allocate(); }
    private native void allocate();
    public native double call(Pointer xp, Pointer yp);
}
public static class gsl_siman_print_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_siman_print_t(Pointer p) { super(p); }
    protected gsl_siman_print_t() { allocate(); }
    private native void allocate();
    public native void call(Pointer xp);
}
public static class gsl_siman_copy_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_siman_copy_t(Pointer p) { super(p); }
    protected gsl_siman_copy_t() { allocate(); }
    private native void allocate();
    public native void call(Pointer source, Pointer dest);
}
public static class gsl_siman_copy_construct_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_siman_copy_construct_t(Pointer p) { super(p); }
    protected gsl_siman_copy_construct_t() { allocate(); }
    private native void allocate();
    public native Pointer call(Pointer xp);
}
public static class gsl_siman_destroy_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    gsl_siman_destroy_t(Pointer p) { super(p); }
    protected gsl_siman_destroy_t() { allocate(); }
    private native void allocate();
    public native void call(Pointer xp);
}

/* this structure contains all the information needed to structure the
   search, beyond the energy function, the step function and the
   initial guess. */

public static class gsl_siman_params_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_siman_params_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_siman_params_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_siman_params_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_siman_params_t position(long position) {
        return (gsl_siman_params_t)super.position(position);
    }

  public native int n_tries(); public native gsl_siman_params_t n_tries(int n_tries);          /* how many points to try for each step */
  public native int iters_fixed_T(); public native gsl_siman_params_t iters_fixed_T(int iters_fixed_T);    /* how many iterations at each temperature? */
  public native double step_size(); public native gsl_siman_params_t step_size(double step_size);     /* max step size in the random walk */
  /* the following parameters are for the Boltzmann distribution */
  public native double k(); public native gsl_siman_params_t k(double k);
  public native double t_initial(); public native gsl_siman_params_t t_initial(double t_initial);
  public native double mu_t(); public native gsl_siman_params_t mu_t(double mu_t);
  public native double t_min(); public native gsl_siman_params_t t_min(double t_min);
}

/* prototype for the workhorse function */

public static native void gsl_siman_solve(@Const gsl_rng r, 
                     Pointer x0_p, gsl_siman_Efunc_t Ef,
                     gsl_siman_step_t take_step,
                     gsl_siman_metric_t distance,
                     gsl_siman_print_t print_position,
                     gsl_siman_copy_t copyfunc,
                     gsl_siman_copy_construct_t copy_constructor,
                     gsl_siman_destroy_t destructor,
                     @Cast("size_t") long element_size,
                     @ByVal gsl_siman_params_t params);

public static native void gsl_siman_solve_many(@Const gsl_rng r, Pointer x0_p, gsl_siman_Efunc_t Ef,
                      gsl_siman_step_t take_step,
                      gsl_siman_metric_t distance,
                      gsl_siman_print_t print_position,
                      @Cast("size_t") long element_size,
                      @ByVal gsl_siman_params_t params);

// #endif /* __GSL_SIMAN_H__ */


// Parsed from gsl/gsl_spline.h

/* interpolation/gsl_spline.h
 * 
 * Copyright (C) 2001, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SPLINE_H__
// #define __GSL_SPLINE_H__
// #include <stdlib.h>
// #include <gsl/gsl_interp.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* general interpolation object */
public static class gsl_spline extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_spline() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_spline(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_spline(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_spline position(long position) {
        return (gsl_spline)super.position(position);
    }

  public native gsl_interp interp(); public native gsl_spline interp(gsl_interp interp);
  public native DoublePointer x(); public native gsl_spline x(DoublePointer x);
  public native DoublePointer y(); public native gsl_spline y(DoublePointer y);
  public native @Cast("size_t") long size(); public native gsl_spline size(long size);
}

public static native gsl_spline gsl_spline_alloc(@Const gsl_interp_type T, @Cast("size_t") long size);
     
public static native int gsl_spline_init(gsl_spline spline, @Const DoublePointer xa, @Const DoublePointer ya, @Cast("size_t") long size);
public static native int gsl_spline_init(gsl_spline spline, @Const DoubleBuffer xa, @Const DoubleBuffer ya, @Cast("size_t") long size);
public static native int gsl_spline_init(gsl_spline spline, @Const double[] xa, @Const double[] ya, @Cast("size_t") long size);

public static native @Cast("const char*") BytePointer gsl_spline_name(@Const gsl_spline spline);
public static native @Cast("unsigned int") int gsl_spline_min_size(@Const gsl_spline spline);


public static native int gsl_spline_eval_e(@Const gsl_spline spline, double x,
                  gsl_interp_accel a, DoublePointer y);
public static native int gsl_spline_eval_e(@Const gsl_spline spline, double x,
                  gsl_interp_accel a, DoubleBuffer y);
public static native int gsl_spline_eval_e(@Const gsl_spline spline, double x,
                  gsl_interp_accel a, double[] y);

public static native double gsl_spline_eval(@Const gsl_spline spline, double x, gsl_interp_accel a);

public static native int gsl_spline_eval_deriv_e(@Const gsl_spline spline,
                        double x,
                        gsl_interp_accel a,
                        DoublePointer y);
public static native int gsl_spline_eval_deriv_e(@Const gsl_spline spline,
                        double x,
                        gsl_interp_accel a,
                        DoubleBuffer y);
public static native int gsl_spline_eval_deriv_e(@Const gsl_spline spline,
                        double x,
                        gsl_interp_accel a,
                        double[] y);

public static native double gsl_spline_eval_deriv(@Const gsl_spline spline,
                      double x,
                      gsl_interp_accel a);

public static native int gsl_spline_eval_deriv2_e(@Const gsl_spline spline,
                         double x,
                         gsl_interp_accel a,
                         DoublePointer y);
public static native int gsl_spline_eval_deriv2_e(@Const gsl_spline spline,
                         double x,
                         gsl_interp_accel a,
                         DoubleBuffer y);
public static native int gsl_spline_eval_deriv2_e(@Const gsl_spline spline,
                         double x,
                         gsl_interp_accel a,
                         double[] y);

public static native double gsl_spline_eval_deriv2(@Const gsl_spline spline,
                       double x,
                       gsl_interp_accel a);

public static native int gsl_spline_eval_integ_e(@Const gsl_spline spline,
                        double a, double b,
                        gsl_interp_accel acc,
                        DoublePointer y);
public static native int gsl_spline_eval_integ_e(@Const gsl_spline spline,
                        double a, double b,
                        gsl_interp_accel acc,
                        DoubleBuffer y);
public static native int gsl_spline_eval_integ_e(@Const gsl_spline spline,
                        double a, double b,
                        gsl_interp_accel acc,
                        double[] y);

public static native double gsl_spline_eval_integ(@Const gsl_spline spline,
                      double a, double b,
                      gsl_interp_accel acc);

public static native void gsl_spline_free(gsl_spline spline);

// #endif /* __GSL_INTERP_H__ */


// Parsed from gsl/gsl_sum.h

/* sum/gsl_sum.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */


// #ifndef __GSL_SUM_H__
// #define __GSL_SUM_H__

// #include <stdlib.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/*  Workspace for Levin U Transform with error estimation,
 *   
 *   size        = number of terms the workspace can handle
 *   sum_plain   = simple sum of series
 *   q_num       = backward diagonal of numerator; length = size
 *   q_den       = backward diagonal of denominator; length = size
 *   dq_num      = table of numerator derivatives; length = size**2
 *   dq_den      = table of denominator derivatives; length = size**2
 *   dsum        = derivative of sum wrt term i; length = size
 */

public static class gsl_sum_levin_u_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_sum_levin_u_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_sum_levin_u_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_sum_levin_u_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_sum_levin_u_workspace position(long position) {
        return (gsl_sum_levin_u_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_sum_levin_u_workspace size(long size);
  public native @Cast("size_t") long i(); public native gsl_sum_levin_u_workspace i(long i);                     /* position in array */
  public native @Cast("size_t") long terms_used(); public native gsl_sum_levin_u_workspace terms_used(long terms_used);            /* number of calls */
  public native double sum_plain(); public native gsl_sum_levin_u_workspace sum_plain(double sum_plain);
  public native DoublePointer q_num(); public native gsl_sum_levin_u_workspace q_num(DoublePointer q_num);
  public native DoublePointer q_den(); public native gsl_sum_levin_u_workspace q_den(DoublePointer q_den);
  public native DoublePointer dq_num(); public native gsl_sum_levin_u_workspace dq_num(DoublePointer dq_num);
  public native DoublePointer dq_den(); public native gsl_sum_levin_u_workspace dq_den(DoublePointer dq_den);
  public native DoublePointer dsum(); public native gsl_sum_levin_u_workspace dsum(DoublePointer dsum);
}

public static native gsl_sum_levin_u_workspace gsl_sum_levin_u_alloc(@Cast("size_t") long n);
public static native void gsl_sum_levin_u_free(gsl_sum_levin_u_workspace w);

/* Basic Levin-u acceleration method.
 *
 *   array       = array of series elements
 *   n           = size of array
 *   sum_accel   = result of summation acceleration
 *   err         = estimated error   
 *
 * See [Fessler et al., ACM TOMS 9, 346 (1983) and TOMS-602]
 */

public static native int gsl_sum_levin_u_accel(@Const DoublePointer array,
                           @Cast("const size_t") long n,
                           gsl_sum_levin_u_workspace w,
                           DoublePointer sum_accel, DoublePointer abserr);
public static native int gsl_sum_levin_u_accel(@Const DoubleBuffer array,
                           @Cast("const size_t") long n,
                           gsl_sum_levin_u_workspace w,
                           DoubleBuffer sum_accel, DoubleBuffer abserr);
public static native int gsl_sum_levin_u_accel(@Const double[] array,
                           @Cast("const size_t") long n,
                           gsl_sum_levin_u_workspace w,
                           double[] sum_accel, double[] abserr);

/* Basic Levin-u acceleration method with constraints on the terms
 * used,
 *
 *   array       = array of series elements
 *   n           = size of array
 *   min_terms   = minimum number of terms to sum
 *   max_terms   = maximum number of terms to sum
 *   sum_accel   = result of summation acceleration
 *   err         = estimated error   
 *
 * See [Fessler et al., ACM TOMS 9, 346 (1983) and TOMS-602] 
 */

public static native int gsl_sum_levin_u_minmax(@Const DoublePointer array,
                            @Cast("const size_t") long n,
                            @Cast("const size_t") long min_terms,
                            @Cast("const size_t") long max_terms,
                            gsl_sum_levin_u_workspace w,
                            DoublePointer sum_accel, DoublePointer abserr);
public static native int gsl_sum_levin_u_minmax(@Const DoubleBuffer array,
                            @Cast("const size_t") long n,
                            @Cast("const size_t") long min_terms,
                            @Cast("const size_t") long max_terms,
                            gsl_sum_levin_u_workspace w,
                            DoubleBuffer sum_accel, DoubleBuffer abserr);
public static native int gsl_sum_levin_u_minmax(@Const double[] array,
                            @Cast("const size_t") long n,
                            @Cast("const size_t") long min_terms,
                            @Cast("const size_t") long max_terms,
                            gsl_sum_levin_u_workspace w,
                            double[] sum_accel, double[] abserr);

/* Basic Levin-u step w/o reference to the array of terms.
 * We only need to specify the value of the current term
 * to execute the step. See TOMS-745.
 *
 * sum = t0 + ... + t_{n-1} + term;  term = t_{n}
 *
 *   term   = value of the series term to be added
 *   n      = position of term in series (starting from 0)
 *   sum_accel = result of summation acceleration
 *   sum_plain = simple sum of series
 */

public static native int gsl_sum_levin_u_step(double term,
                      @Cast("const size_t") long n,
                      @Cast("const size_t") long nmax,
                      gsl_sum_levin_u_workspace w, 
                      DoublePointer sum_accel);
public static native int gsl_sum_levin_u_step(double term,
                      @Cast("const size_t") long n,
                      @Cast("const size_t") long nmax,
                      gsl_sum_levin_u_workspace w, 
                      DoubleBuffer sum_accel);
public static native int gsl_sum_levin_u_step(double term,
                      @Cast("const size_t") long n,
                      @Cast("const size_t") long nmax,
                      gsl_sum_levin_u_workspace w, 
                      double[] sum_accel);

/* The following functions perform the same calculation without
   estimating the errors. They require O(N) storage instead of O(N^2).
   This may be useful for summing many similar series where the size
   of the error has already been estimated reliably and is not
   expected to change.  */

public static class gsl_sum_levin_utrunc_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_sum_levin_utrunc_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_sum_levin_utrunc_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_sum_levin_utrunc_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_sum_levin_utrunc_workspace position(long position) {
        return (gsl_sum_levin_utrunc_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_sum_levin_utrunc_workspace size(long size);
  public native @Cast("size_t") long i(); public native gsl_sum_levin_utrunc_workspace i(long i);                     /* position in array */
  public native @Cast("size_t") long terms_used(); public native gsl_sum_levin_utrunc_workspace terms_used(long terms_used);            /* number of calls */
  public native double sum_plain(); public native gsl_sum_levin_utrunc_workspace sum_plain(double sum_plain);
  public native DoublePointer q_num(); public native gsl_sum_levin_utrunc_workspace q_num(DoublePointer q_num);
  public native DoublePointer q_den(); public native gsl_sum_levin_utrunc_workspace q_den(DoublePointer q_den);
  public native DoublePointer dsum(); public native gsl_sum_levin_utrunc_workspace dsum(DoublePointer dsum);
}

public static native gsl_sum_levin_utrunc_workspace gsl_sum_levin_utrunc_alloc(@Cast("size_t") long n);
public static native void gsl_sum_levin_utrunc_free(gsl_sum_levin_utrunc_workspace w);

public static native int gsl_sum_levin_utrunc_accel(@Const DoublePointer array,
                                @Cast("const size_t") long n,
                                gsl_sum_levin_utrunc_workspace w,
                                DoublePointer sum_accel, DoublePointer abserr_trunc);
public static native int gsl_sum_levin_utrunc_accel(@Const DoubleBuffer array,
                                @Cast("const size_t") long n,
                                gsl_sum_levin_utrunc_workspace w,
                                DoubleBuffer sum_accel, DoubleBuffer abserr_trunc);
public static native int gsl_sum_levin_utrunc_accel(@Const double[] array,
                                @Cast("const size_t") long n,
                                gsl_sum_levin_utrunc_workspace w,
                                double[] sum_accel, double[] abserr_trunc);

public static native int gsl_sum_levin_utrunc_minmax(@Const DoublePointer array,
                                 @Cast("const size_t") long n,
                                 @Cast("const size_t") long min_terms,
                                 @Cast("const size_t") long max_terms,
                                 gsl_sum_levin_utrunc_workspace w,
                                 DoublePointer sum_accel, DoublePointer abserr_trunc);
public static native int gsl_sum_levin_utrunc_minmax(@Const DoubleBuffer array,
                                 @Cast("const size_t") long n,
                                 @Cast("const size_t") long min_terms,
                                 @Cast("const size_t") long max_terms,
                                 gsl_sum_levin_utrunc_workspace w,
                                 DoubleBuffer sum_accel, DoubleBuffer abserr_trunc);
public static native int gsl_sum_levin_utrunc_minmax(@Const double[] array,
                                 @Cast("const size_t") long n,
                                 @Cast("const size_t") long min_terms,
                                 @Cast("const size_t") long max_terms,
                                 gsl_sum_levin_utrunc_workspace w,
                                 double[] sum_accel, double[] abserr_trunc);

public static native int gsl_sum_levin_utrunc_step(double term,
                               @Cast("const size_t") long n,
                               gsl_sum_levin_utrunc_workspace w, 
                               DoublePointer sum_accel);
public static native int gsl_sum_levin_utrunc_step(double term,
                               @Cast("const size_t") long n,
                               gsl_sum_levin_utrunc_workspace w, 
                               DoubleBuffer sum_accel);
public static native int gsl_sum_levin_utrunc_step(double term,
                               @Cast("const size_t") long n,
                               gsl_sum_levin_utrunc_workspace w, 
                               double[] sum_accel);

// #endif /* __GSL_SUM_H__ */


// Parsed from gsl/gsl_wavelet.h

/* wavelet/gsl_wavelet.h
 * 
 * Copyright (C) 2004 Ivo Alxneit
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_WAVELET_H__
// #define __GSL_WAVELET_H__
// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_errno.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/** enum gsl_wavelet_direction */
public static final int
  gsl_wavelet_forward = 1, gsl_wavelet_backward = -1;

public static class gsl_wavelet_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_wavelet_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_wavelet_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_wavelet_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_wavelet_type position(long position) {
        return (gsl_wavelet_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public static class Init_PointerPointer_PointerPointer_PointerPointer_PointerPointer_SizeTPointer_SizeTPointer_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Init_PointerPointer_PointerPointer_PointerPointer_PointerPointer_SizeTPointer_SizeTPointer_long(Pointer p) { super(p); }
      protected Init_PointerPointer_PointerPointer_PointerPointer_PointerPointer_SizeTPointer_SizeTPointer_long() { allocate(); }
      private native void allocate();
      public native int call(@Cast("const double**") PointerPointer h1, @Cast("const double**") PointerPointer g1,
                 @Cast("const double**") PointerPointer h2, @Cast("const double**") PointerPointer g2, @Cast("size_t*") SizeTPointer nc,
                 @Cast("size_t*") SizeTPointer offset, @Cast("size_t") long member);
  }
  public native Init_PointerPointer_PointerPointer_PointerPointer_PointerPointer_SizeTPointer_SizeTPointer_long init(); public native gsl_wavelet_type init(Init_PointerPointer_PointerPointer_PointerPointer_PointerPointer_SizeTPointer_SizeTPointer_long init);
}

public static class gsl_wavelet extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_wavelet() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_wavelet(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_wavelet(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_wavelet position(long position) {
        return (gsl_wavelet)super.position(position);
    }

  @MemberGetter public native @Const gsl_wavelet_type type();
  @MemberGetter public native @Const DoublePointer h1();
  @MemberGetter public native @Const DoublePointer g1();
  @MemberGetter public native @Const DoublePointer h2();
  @MemberGetter public native @Const DoublePointer g2();
  public native @Cast("size_t") long nc(); public native gsl_wavelet nc(long nc);
  public native @Cast("size_t") long offset(); public native gsl_wavelet offset(long offset);
}

public static class gsl_wavelet_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_wavelet_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_wavelet_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_wavelet_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_wavelet_workspace position(long position) {
        return (gsl_wavelet_workspace)super.position(position);
    }

  public native DoublePointer scratch(); public native gsl_wavelet_workspace scratch(DoublePointer scratch);
  public native @Cast("size_t") long n(); public native gsl_wavelet_workspace n(long n);
}

@MemberGetter public static native @Const gsl_wavelet_type gsl_wavelet_daubechies();
@MemberGetter public static native @Const gsl_wavelet_type gsl_wavelet_daubechies_centered();
@MemberGetter public static native @Const gsl_wavelet_type gsl_wavelet_haar();
@MemberGetter public static native @Const gsl_wavelet_type gsl_wavelet_haar_centered();
@MemberGetter public static native @Const gsl_wavelet_type gsl_wavelet_bspline();
@MemberGetter public static native @Const gsl_wavelet_type gsl_wavelet_bspline_centered();

public static native gsl_wavelet gsl_wavelet_alloc(@Const gsl_wavelet_type T, @Cast("size_t") long k);
public static native void gsl_wavelet_free(gsl_wavelet w);
public static native @Cast("const char*") BytePointer gsl_wavelet_name(@Const gsl_wavelet w);

public static native gsl_wavelet_workspace gsl_wavelet_workspace_alloc(@Cast("size_t") long n);
public static native void gsl_wavelet_workspace_free(gsl_wavelet_workspace work);

public static native int gsl_wavelet_transform(@Const gsl_wavelet w, 
                           DoublePointer data, @Cast("size_t") long stride, @Cast("size_t") long n,
                           @Cast("gsl_wavelet_direction") int dir, 
                           gsl_wavelet_workspace work);
public static native int gsl_wavelet_transform(@Const gsl_wavelet w, 
                           DoubleBuffer data, @Cast("size_t") long stride, @Cast("size_t") long n,
                           @Cast("gsl_wavelet_direction") int dir, 
                           gsl_wavelet_workspace work);
public static native int gsl_wavelet_transform(@Const gsl_wavelet w, 
                           double[] data, @Cast("size_t") long stride, @Cast("size_t") long n,
                           @Cast("gsl_wavelet_direction") int dir, 
                           gsl_wavelet_workspace work);

public static native int gsl_wavelet_transform_forward(@Const gsl_wavelet w, 
                                   DoublePointer data, @Cast("size_t") long stride, @Cast("size_t") long n, 
                                   gsl_wavelet_workspace work);
public static native int gsl_wavelet_transform_forward(@Const gsl_wavelet w, 
                                   DoubleBuffer data, @Cast("size_t") long stride, @Cast("size_t") long n, 
                                   gsl_wavelet_workspace work);
public static native int gsl_wavelet_transform_forward(@Const gsl_wavelet w, 
                                   double[] data, @Cast("size_t") long stride, @Cast("size_t") long n, 
                                   gsl_wavelet_workspace work);

public static native int gsl_wavelet_transform_inverse(@Const gsl_wavelet w, 
                                    DoublePointer data, @Cast("size_t") long stride, @Cast("size_t") long n, 
                                    gsl_wavelet_workspace work);
public static native int gsl_wavelet_transform_inverse(@Const gsl_wavelet w, 
                                    DoubleBuffer data, @Cast("size_t") long stride, @Cast("size_t") long n, 
                                    gsl_wavelet_workspace work);
public static native int gsl_wavelet_transform_inverse(@Const gsl_wavelet w, 
                                    double[] data, @Cast("size_t") long stride, @Cast("size_t") long n, 
                                    gsl_wavelet_workspace work);

// #endif /* __GSL_WAVELET_H__ */


// Parsed from gsl/gsl_wavelet2d.h

/* wavelet/gsl_wavelet.h
 * 
 * Copyright (C) 2004 Ivo Alxneit
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_WAVELET2D_H__
// #define __GSL_WAVELET2D_H__
// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_vector_double.h>
// #include <gsl/gsl_matrix_double.h>
// #include <gsl/gsl_wavelet.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_wavelet2d_transform(@Const gsl_wavelet w, 
                             DoublePointer data, 
                             @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2,
                             @Cast("gsl_wavelet_direction") int dir, 
                             gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_transform(@Const gsl_wavelet w, 
                             DoubleBuffer data, 
                             @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2,
                             @Cast("gsl_wavelet_direction") int dir, 
                             gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_transform(@Const gsl_wavelet w, 
                             double[] data, 
                             @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2,
                             @Cast("gsl_wavelet_direction") int dir, 
                             gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_transform_forward(@Const gsl_wavelet w, 
                                     DoublePointer data,
                                     @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                                     gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_transform_forward(@Const gsl_wavelet w, 
                                     DoubleBuffer data,
                                     @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                                     gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_transform_forward(@Const gsl_wavelet w, 
                                     double[] data,
                                     @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                                     gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_transform_inverse(@Const gsl_wavelet w, 
                                     DoublePointer data, 
                                     @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                                     gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_transform_inverse(@Const gsl_wavelet w, 
                                     DoubleBuffer data, 
                                     @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                                     gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_transform_inverse(@Const gsl_wavelet w, 
                                     double[] data, 
                                     @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                                     gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_nstransform(@Const gsl_wavelet w, 
                               DoublePointer data, 
                               @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                               @Cast("gsl_wavelet_direction") int dir,
                               gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_nstransform(@Const gsl_wavelet w, 
                               DoubleBuffer data, 
                               @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                               @Cast("gsl_wavelet_direction") int dir,
                               gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_nstransform(@Const gsl_wavelet w, 
                               double[] data, 
                               @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                               @Cast("gsl_wavelet_direction") int dir,
                               gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_nstransform_forward(@Const gsl_wavelet w, 
                                       DoublePointer data, 
                                       @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2,
                                       gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_nstransform_forward(@Const gsl_wavelet w, 
                                       DoubleBuffer data, 
                                       @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2,
                                       gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_nstransform_forward(@Const gsl_wavelet w, 
                                       double[] data, 
                                       @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2,
                                       gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_nstransform_inverse(@Const gsl_wavelet w, 
                                       DoublePointer data, 
                                       @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                                       gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_nstransform_inverse(@Const gsl_wavelet w, 
                                       DoubleBuffer data, 
                                       @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                                       gsl_wavelet_workspace work);
public static native int gsl_wavelet2d_nstransform_inverse(@Const gsl_wavelet w, 
                                       double[] data, 
                                       @Cast("size_t") long tda, @Cast("size_t") long size1, @Cast("size_t") long size2, 
                                       gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_transform_matrix(@Const gsl_wavelet w, 
                                gsl_matrix a, 
                                @Cast("gsl_wavelet_direction") int dir, 
                                gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_transform_matrix_forward(@Const gsl_wavelet w, 
                                        gsl_matrix a, 
                                        gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_transform_matrix_inverse(@Const gsl_wavelet w, 
                                        gsl_matrix a, 
                                        gsl_wavelet_workspace work);


public static native int gsl_wavelet2d_nstransform_matrix(@Const gsl_wavelet w, 
                                  gsl_matrix a, 
                                  @Cast("gsl_wavelet_direction") int dir, 
                                  gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_nstransform_matrix_forward(@Const gsl_wavelet w, 
                                          gsl_matrix a, 
                                          gsl_wavelet_workspace work);

public static native int gsl_wavelet2d_nstransform_matrix_inverse(@Const gsl_wavelet w, 
                                          gsl_matrix a, 
                                          gsl_wavelet_workspace work);

// #endif /* __GSL_WAVELET2D_H__ */


// Parsed from gsl/gsl_multilarge.h

/* gsl_multilarge.h
 * 
 * Copyright (C) 2015 Patrick Alken
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MULTILARGE_H__
// #define __GSL_MULTILARGE_H__

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* iteration solver type */
public static class gsl_multilarge_linear_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multilarge_linear_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multilarge_linear_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multilarge_linear_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multilarge_linear_type position(long position) {
        return (gsl_multilarge_linear_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public static class Alloc_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Alloc_long(Pointer p) { super(p); }
      protected Alloc_long() { allocate(); }
      private native void allocate();
      public native Pointer call(@Cast("const size_t") long p);
  }
  public native Alloc_long alloc(); public native gsl_multilarge_linear_type alloc(Alloc_long alloc);
  public static class Reset_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Reset_Pointer(Pointer p) { super(p); }
      protected Reset_Pointer() { allocate(); }
      private native void allocate();
      public native int call(Pointer arg0);
  }
  public native Reset_Pointer reset(); public native gsl_multilarge_linear_type reset(Reset_Pointer reset);
  public static class Accumulate_gsl_matrix_gsl_vector_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Accumulate_gsl_matrix_gsl_vector_Pointer(Pointer p) { super(p); }
      protected Accumulate_gsl_matrix_gsl_vector_Pointer() { allocate(); }
      private native void allocate();
      public native int call(gsl_matrix X, gsl_vector y,
                       Pointer arg2);
  }
  public native Accumulate_gsl_matrix_gsl_vector_Pointer accumulate(); public native gsl_multilarge_linear_type accumulate(Accumulate_gsl_matrix_gsl_vector_Pointer accumulate);
  public static class Solve_double_gsl_vector_DoublePointer_DoublePointer_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Solve_double_gsl_vector_DoublePointer_DoublePointer_Pointer(Pointer p) { super(p); }
      protected Solve_double_gsl_vector_DoublePointer_DoublePointer_Pointer() { allocate(); }
      private native void allocate();
      public native int call(double lambda, gsl_vector c,
                  DoublePointer rnorm, DoublePointer snorm, Pointer arg4);
  }
  public native Solve_double_gsl_vector_DoublePointer_DoublePointer_Pointer solve(); public native gsl_multilarge_linear_type solve(Solve_double_gsl_vector_DoublePointer_DoublePointer_Pointer solve);
  public static class Rcond_DoublePointer_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Rcond_DoublePointer_Pointer(Pointer p) { super(p); }
      protected Rcond_DoublePointer_Pointer() { allocate(); }
      private native void allocate();
      public native int call(DoublePointer rcond, Pointer arg1);
  }
  public native Rcond_DoublePointer_Pointer rcond(); public native gsl_multilarge_linear_type rcond(Rcond_DoublePointer_Pointer rcond);
  public static class Lcurve_gsl_vector_gsl_vector_gsl_vector_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Lcurve_gsl_vector_gsl_vector_gsl_vector_Pointer(Pointer p) { super(p); }
      protected Lcurve_gsl_vector_gsl_vector_gsl_vector_Pointer() { allocate(); }
      private native void allocate();
      public native int call(gsl_vector reg_param, gsl_vector rho,
                   gsl_vector eta, Pointer arg3);
  }
  public native Lcurve_gsl_vector_gsl_vector_gsl_vector_Pointer lcurve(); public native gsl_multilarge_linear_type lcurve(Lcurve_gsl_vector_gsl_vector_gsl_vector_Pointer lcurve);
  public static class Free_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Free_Pointer(Pointer p) { super(p); }
      protected Free_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer arg0);
  }
  public native Free_Pointer free(); public native gsl_multilarge_linear_type free(Free_Pointer free);
}

public static class gsl_multilarge_linear_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multilarge_linear_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multilarge_linear_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multilarge_linear_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multilarge_linear_workspace position(long position) {
        return (gsl_multilarge_linear_workspace)super.position(position);
    }

  @MemberGetter public native @Const gsl_multilarge_linear_type type();
  public native Pointer state(); public native gsl_multilarge_linear_workspace state(Pointer state);
  public native @Cast("size_t") long p(); public native gsl_multilarge_linear_workspace p(long p);
}

/* available types */
@MemberGetter public static native @Const gsl_multilarge_linear_type gsl_multilarge_linear_normal();
@MemberGetter public static native @Const gsl_multilarge_linear_type gsl_multilarge_linear_tsqr();

/*
 * Prototypes
 */
public static native gsl_multilarge_linear_workspace gsl_multilarge_linear_alloc(@Const gsl_multilarge_linear_type T,
                            @Cast("const size_t") long p);

public static native void gsl_multilarge_linear_free(gsl_multilarge_linear_workspace w);

public static native @Cast("const char*") BytePointer gsl_multilarge_linear_name(@Const gsl_multilarge_linear_workspace w);

public static native int gsl_multilarge_linear_reset(gsl_multilarge_linear_workspace w);

public static native int gsl_multilarge_linear_accumulate(gsl_matrix X,
                                     gsl_vector y,
                                     gsl_multilarge_linear_workspace w);

public static native int gsl_multilarge_linear_solve(double lambda, gsl_vector c,
                                DoublePointer rnorm, DoublePointer snorm,
                                gsl_multilarge_linear_workspace w);
public static native int gsl_multilarge_linear_solve(double lambda, gsl_vector c,
                                DoubleBuffer rnorm, DoubleBuffer snorm,
                                gsl_multilarge_linear_workspace w);
public static native int gsl_multilarge_linear_solve(double lambda, gsl_vector c,
                                double[] rnorm, double[] snorm,
                                gsl_multilarge_linear_workspace w);

public static native int gsl_multilarge_linear_rcond(DoublePointer rcond, gsl_multilarge_linear_workspace w);
public static native int gsl_multilarge_linear_rcond(DoubleBuffer rcond, gsl_multilarge_linear_workspace w);
public static native int gsl_multilarge_linear_rcond(double[] rcond, gsl_multilarge_linear_workspace w);

public static native int gsl_multilarge_linear_lcurve(gsl_vector reg_param, gsl_vector rho,
                                 gsl_vector eta,
                                 gsl_multilarge_linear_workspace w);

public static native int gsl_multilarge_linear_wstdform1(@Const gsl_vector L,
                                     @Const gsl_matrix X,
                                     @Const gsl_vector w,
                                     @Const gsl_vector y,
                                     gsl_matrix Xs,
                                     gsl_vector ys,
                                     gsl_multilarge_linear_workspace work);

public static native int gsl_multilarge_linear_stdform1(@Const gsl_vector L,
                                    @Const gsl_matrix X,
                                    @Const gsl_vector y,
                                    gsl_matrix Xs,
                                    gsl_vector ys,
                                    gsl_multilarge_linear_workspace work);

public static native int gsl_multilarge_linear_L_decomp(gsl_matrix L, gsl_vector tau);

public static native int gsl_multilarge_linear_wstdform2(@Const gsl_matrix LQR,
                                     @Const gsl_vector Ltau,
                                     @Const gsl_matrix X,
                                     @Const gsl_vector w,
                                     @Const gsl_vector y,
                                     gsl_matrix Xs,
                                     gsl_vector ys,
                                     gsl_multilarge_linear_workspace work);

public static native int gsl_multilarge_linear_stdform2(@Const gsl_matrix LQR,
                                    @Const gsl_vector Ltau,
                                    @Const gsl_matrix X,
                                    @Const gsl_vector y,
                                    gsl_matrix Xs,
                                    gsl_vector ys,
                                    gsl_multilarge_linear_workspace work);

public static native int gsl_multilarge_linear_genform1(@Const gsl_vector L,
                                    @Const gsl_vector cs,
                                    gsl_vector c,
                                    gsl_multilarge_linear_workspace work);

public static native int gsl_multilarge_linear_genform2(@Const gsl_matrix LQR,
                                    @Const gsl_vector Ltau,
                                    @Const gsl_vector cs,
                                    gsl_vector c,
                                    gsl_multilarge_linear_workspace work);

// #endif /* __GSL_MULTILARGE_H__ */


// Parsed from gsl/gsl_rstat.h

/* rstat/gsl_rstat.h
 * 
 * Copyright (C) 2015 Patrick Alken
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_RSTAT_H__
// #define __GSL_RSTAT_H__

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_rstat_quantile_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_rstat_quantile_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_rstat_quantile_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_rstat_quantile_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_rstat_quantile_workspace position(long position) {
        return (gsl_rstat_quantile_workspace)super.position(position);
    }

  public native double p(); public native gsl_rstat_quantile_workspace p(double p);        /* p-quantile */
  public native double q(int i); public native gsl_rstat_quantile_workspace q(int i, double q);
  @MemberGetter public native DoublePointer q();     /* heights q_i */
  public native int npos(int i); public native gsl_rstat_quantile_workspace npos(int i, int npos);
  @MemberGetter public native IntPointer npos();     /* positions n_i */
  public native double np(int i); public native gsl_rstat_quantile_workspace np(int i, double np);
  @MemberGetter public native DoublePointer np();    /* desired positions n_i' */
  public native double dnp(int i); public native gsl_rstat_quantile_workspace dnp(int i, double dnp);
  @MemberGetter public native DoublePointer dnp();   /* increments dn_i' */
  public native @Cast("size_t") long n(); public native gsl_rstat_quantile_workspace n(long n);        /* number of data added */
}

public static native gsl_rstat_quantile_workspace gsl_rstat_quantile_alloc(double p);
public static native void gsl_rstat_quantile_free(gsl_rstat_quantile_workspace w);
public static native int gsl_rstat_quantile_reset(gsl_rstat_quantile_workspace w);
public static native int gsl_rstat_quantile_add(double x, gsl_rstat_quantile_workspace w);
public static native double gsl_rstat_quantile_get(gsl_rstat_quantile_workspace w);

public static class gsl_rstat_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_rstat_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_rstat_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_rstat_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_rstat_workspace position(long position) {
        return (gsl_rstat_workspace)super.position(position);
    }

  public native double min(); public native gsl_rstat_workspace min(double min);      /* minimum value added */
  public native double max(); public native gsl_rstat_workspace max(double max);      /* maximum value added */
  public native double mean(); public native gsl_rstat_workspace mean(double mean);     /* current mean */
  public native double M2(); public native gsl_rstat_workspace M2(double M2);       /* M_k = sum_{i=1..n} [ x_i - mean_n ]^k */
  public native double M3(); public native gsl_rstat_workspace M3(double M3);
  public native double M4(); public native gsl_rstat_workspace M4(double M4);
  public native @Cast("size_t") long n(); public native gsl_rstat_workspace n(long n);        /* number of data points added */
  public native gsl_rstat_quantile_workspace median_workspace_p(); public native gsl_rstat_workspace median_workspace_p(gsl_rstat_quantile_workspace median_workspace_p); /* median workspace */
}

public static native gsl_rstat_workspace gsl_rstat_alloc();
public static native void gsl_rstat_free(gsl_rstat_workspace w);
public static native @Cast("size_t") long gsl_rstat_n(gsl_rstat_workspace w);
public static native int gsl_rstat_add(double x, gsl_rstat_workspace w);
public static native double gsl_rstat_min(gsl_rstat_workspace w);
public static native double gsl_rstat_max(gsl_rstat_workspace w);
public static native double gsl_rstat_mean(gsl_rstat_workspace w);
public static native double gsl_rstat_variance(gsl_rstat_workspace w);
public static native double gsl_rstat_sd(gsl_rstat_workspace w);
public static native double gsl_rstat_rms(gsl_rstat_workspace w);
public static native double gsl_rstat_sd_mean(gsl_rstat_workspace w);
public static native double gsl_rstat_median(gsl_rstat_workspace w);
public static native double gsl_rstat_skew(gsl_rstat_workspace w);
public static native double gsl_rstat_kurtosis(gsl_rstat_workspace w);
public static native int gsl_rstat_reset(gsl_rstat_workspace w);

// #endif /* __GSL_RSTAT_H__ */


// Parsed from gsl/gsl_spmatrix.h

/* gsl_spmatrix.h
 * 
 * Copyright (C) 2012-2014 Patrick Alken
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SPMATRIX_H__
// #define __GSL_SPMATRIX_H__

// #include <stdlib.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/*
 * Binary tree data structure for storing sparse matrix elements
 * in triplet format. This is used for efficiently detecting
 * duplicates and element retrieval via gsl_spmatrix_get
 */
public static class gsl_spmatrix_tree extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_spmatrix_tree() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_spmatrix_tree(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_spmatrix_tree(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_spmatrix_tree position(long position) {
        return (gsl_spmatrix_tree)super.position(position);
    }

  public native Pointer tree(); public native gsl_spmatrix_tree tree(Pointer tree);       /* tree structure */
  public native Pointer node_array(); public native gsl_spmatrix_tree node_array(Pointer node_array); /* preallocated array of tree nodes */
  public native @Cast("size_t") long n(); public native gsl_spmatrix_tree n(long n);         /* number of tree nodes in use (<= nzmax) */
}

/*
 * Triplet format:
 *
 * If data[n] = A_{ij}, then:
 *   i = A->i[n]
 *   j = A->p[n]
 *
 * Compressed column format (CCS):
 *
 * If data[n] = A_{ij}, then:
 *   i = A->i[n]
 *   A->p[j] <= n < A->p[j+1]
 * so that column j is stored in
 * [ data[p[j]], data[p[j] + 1], ..., data[p[j+1] - 1] ]
 *
 * Compressed row format (CRS):
 *
 * If data[n] = A_{ij}, then:
 *   j = A->i[n]
 *   A->p[i] <= n < A->p[i+1]
 * so that row i is stored in
 * [ data[p[i]], data[p[i] + 1], ..., data[p[i+1] - 1] ]
 */

public static class gsl_spmatrix extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_spmatrix() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_spmatrix(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_spmatrix(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_spmatrix position(long position) {
        return (gsl_spmatrix)super.position(position);
    }

  public native @Cast("size_t") long size1(); public native gsl_spmatrix size1(long size1);  /* number of rows */
  public native @Cast("size_t") long size2(); public native gsl_spmatrix size2(long size2);  /* number of columns */

  /* i (size nzmax) contains:
   *
   * Triplet/CCS: row indices
   * CRS: column indices
   */
  public native @Cast("size_t*") SizeTPointer i(); public native gsl_spmatrix i(SizeTPointer i);

  public native DoublePointer data(); public native gsl_spmatrix data(DoublePointer data);  /* matrix elements of size nzmax */

  /*
   * p contains the column indices (triplet) or column pointers (compcol)
   *
   * triplet: p[n] = column number of element data[n]
   * CCS:     p[j] = index in data of first non-zero element in column j
   * CRS:     p[i] = index in data of first non-zero element in row i
   */
  public native @Cast("size_t*") SizeTPointer p(); public native gsl_spmatrix p(SizeTPointer p);

  public native @Cast("size_t") long nzmax(); public native gsl_spmatrix nzmax(long nzmax);  /* maximum number of matrix elements */
  public native @Cast("size_t") long nz(); public native gsl_spmatrix nz(long nz);     /* number of non-zero values in matrix */

  public native gsl_spmatrix_tree tree_data(); public native gsl_spmatrix tree_data(gsl_spmatrix_tree tree_data); /* binary tree for sorting triplet data */

  /*
   * workspace of size MAX(size1,size2)*MAX(sizeof(double),sizeof(size_t))
   * used in various routines
   */
  public native Pointer work(); public native gsl_spmatrix work(Pointer work);

  public native @Cast("size_t") long sptype(); public native gsl_spmatrix sptype(long sptype); /* sparse storage type */
}

public static final int GSL_SPMATRIX_TRIPLET =      (0);
public static final int GSL_SPMATRIX_CCS =          (1);
public static final int GSL_SPMATRIX_CRS =          (2);

// #define GSL_SPMATRIX_ISTRIPLET(m) ((m)->sptype == GSL_SPMATRIX_TRIPLET)
// #define GSL_SPMATRIX_ISCCS(m)     ((m)->sptype == GSL_SPMATRIX_CCS)
// #define GSL_SPMATRIX_ISCRS(m)     ((m)->sptype == GSL_SPMATRIX_CRS)

/*
 * Prototypes
 */

public static native gsl_spmatrix gsl_spmatrix_alloc(@Cast("const size_t") long n1, @Cast("const size_t") long n2);
public static native gsl_spmatrix gsl_spmatrix_alloc_nzmax(@Cast("const size_t") long n1, @Cast("const size_t") long n2,
                                       @Cast("const size_t") long nzmax, @Cast("const size_t") long flags);
public static native void gsl_spmatrix_free(gsl_spmatrix m);
public static native int gsl_spmatrix_realloc(@Cast("const size_t") long nzmax, gsl_spmatrix m);
public static native int gsl_spmatrix_set_zero(gsl_spmatrix m);
public static native @Cast("size_t") long gsl_spmatrix_nnz(@Const gsl_spmatrix m);
public static native int gsl_spmatrix_compare_idx(@Cast("const size_t") long ia, @Cast("const size_t") long ja,
                             @Cast("const size_t") long ib, @Cast("const size_t") long jb);
public static native int gsl_spmatrix_tree_rebuild(gsl_spmatrix m);

/* spcopy.c */
public static native int gsl_spmatrix_memcpy(gsl_spmatrix dest, @Const gsl_spmatrix src);

/* spgetset.c */
public static native double gsl_spmatrix_get(@Const gsl_spmatrix m, @Cast("const size_t") long i,
                        @Cast("const size_t") long j);
public static native int gsl_spmatrix_set(gsl_spmatrix m, @Cast("const size_t") long i, @Cast("const size_t") long j,
                     double x);
public static native DoublePointer gsl_spmatrix_ptr(gsl_spmatrix m, @Cast("const size_t") long i, @Cast("const size_t") long j);

/* spcompress.c */
public static native gsl_spmatrix gsl_spmatrix_compcol(@Const gsl_spmatrix T);
public static native gsl_spmatrix gsl_spmatrix_ccs(@Const gsl_spmatrix T);
public static native gsl_spmatrix gsl_spmatrix_crs(@Const gsl_spmatrix T);
public static native void gsl_spmatrix_cumsum(@Cast("const size_t") long n, @Cast("size_t*") SizeTPointer c);

/* spio.c */
public static native int gsl_spmatrix_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_spmatrix m,
                         @Cast("const char*") BytePointer format);
public static native int gsl_spmatrix_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_spmatrix m,
                         String format);
public static native gsl_spmatrix gsl_spmatrix_fscanf(@Cast("FILE*") Pointer stream);
public static native int gsl_spmatrix_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_spmatrix m);
public static native int gsl_spmatrix_fread(@Cast("FILE*") Pointer stream, gsl_spmatrix m);

/* spoper.c */
public static native int gsl_spmatrix_scale(gsl_spmatrix m, double x);
public static native int gsl_spmatrix_minmax(@Const gsl_spmatrix m, DoublePointer min_out,
                        DoublePointer max_out);
public static native int gsl_spmatrix_minmax(@Const gsl_spmatrix m, DoubleBuffer min_out,
                        DoubleBuffer max_out);
public static native int gsl_spmatrix_minmax(@Const gsl_spmatrix m, double[] min_out,
                        double[] max_out);
public static native int gsl_spmatrix_add(gsl_spmatrix c, @Const gsl_spmatrix a,
                     @Const gsl_spmatrix b);
public static native int gsl_spmatrix_d2sp(gsl_spmatrix S, @Const gsl_matrix A);
public static native int gsl_spmatrix_sp2d(gsl_matrix A, @Const gsl_spmatrix S);

/* spprop.c */
public static native int gsl_spmatrix_equal(@Const gsl_spmatrix a, @Const gsl_spmatrix b);

/* spswap.c */
public static native int gsl_spmatrix_transpose(gsl_spmatrix m);
public static native int gsl_spmatrix_transpose2(gsl_spmatrix m);
public static native int gsl_spmatrix_transpose_memcpy(gsl_spmatrix dest, @Const gsl_spmatrix src);

// #endif /* __GSL_SPMATRIX_H__ */


// Parsed from gsl/gsl_spblas.h

/* gsl_spblas.h
 * 
 * Copyright (C) 2012-2014 Patrick Alken
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SPBLAS_H__
// #define __GSL_SPBLAS_H__

// #include <stdlib.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>
// #include <gsl/gsl_spmatrix.h>
// #include <gsl/gsl_blas.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/*
 * Prototypes
 */

public static native int gsl_spblas_dgemv(@Cast("const CBLAS_TRANSPOSE_t") int TransA, double alpha,
                     @Const gsl_spmatrix A, @Const gsl_vector x,
                     double beta, gsl_vector y);
public static native int gsl_spblas_dgemm(double alpha, @Const gsl_spmatrix A,
                     @Const gsl_spmatrix B, gsl_spmatrix C);
public static native @Cast("size_t") long gsl_spblas_scatter(@Const gsl_spmatrix A, @Cast("const size_t") long j,
                          double alpha, @Cast("size_t*") SizeTPointer w, DoublePointer x,
                          @Cast("const size_t") long mark, gsl_spmatrix C, @Cast("size_t") long nz);
public static native @Cast("size_t") long gsl_spblas_scatter(@Const gsl_spmatrix A, @Cast("const size_t") long j,
                          double alpha, @Cast("size_t*") SizeTPointer w, DoubleBuffer x,
                          @Cast("const size_t") long mark, gsl_spmatrix C, @Cast("size_t") long nz);
public static native @Cast("size_t") long gsl_spblas_scatter(@Const gsl_spmatrix A, @Cast("const size_t") long j,
                          double alpha, @Cast("size_t*") SizeTPointer w, double[] x,
                          @Cast("const size_t") long mark, gsl_spmatrix C, @Cast("size_t") long nz);

// #endif /* __GSL_SPBLAS_H__ */


// Parsed from gsl/gsl_splinalg.h

/* gsl_splinalg.h
 * 
 * Copyright (C) 2012-2014 Patrick Alken
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SPLINALG_H__
// #define __GSL_SPLINALG_H__

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>
// #include <gsl/gsl_spmatrix.h>
// #include <gsl/gsl_linalg.h>
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* iteration solver type */
public static class gsl_splinalg_itersolve_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_splinalg_itersolve_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_splinalg_itersolve_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_splinalg_itersolve_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_splinalg_itersolve_type position(long position) {
        return (gsl_splinalg_itersolve_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public static class Alloc_long_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Alloc_long_long(Pointer p) { super(p); }
      protected Alloc_long_long() { allocate(); }
      private native void allocate();
      public native Pointer call(@Cast("const size_t") long n, @Cast("const size_t") long m);
  }
  public native Alloc_long_long alloc(); public native gsl_splinalg_itersolve_type alloc(Alloc_long_long alloc);
  public static class Iterate_gsl_spmatrix_gsl_vector_double_gsl_vector_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Iterate_gsl_spmatrix_gsl_vector_double_gsl_vector_Pointer(Pointer p) { super(p); }
      protected Iterate_gsl_spmatrix_gsl_vector_double_gsl_vector_Pointer() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_spmatrix A, @Const gsl_vector b,
                    double tol, gsl_vector x, Pointer arg4);
  }
  public native Iterate_gsl_spmatrix_gsl_vector_double_gsl_vector_Pointer iterate(); public native gsl_splinalg_itersolve_type iterate(Iterate_gsl_spmatrix_gsl_vector_double_gsl_vector_Pointer iterate);
  public static class Normr_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Normr_Pointer(Pointer p) { super(p); }
      protected Normr_Pointer() { allocate(); }
      private native void allocate();
      public native double call(@Const Pointer arg0);
  }
  public native Normr_Pointer normr(); public native gsl_splinalg_itersolve_type normr(Normr_Pointer normr);
  public static class Free_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Free_Pointer(Pointer p) { super(p); }
      protected Free_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer arg0);
  }
  public native Free_Pointer free(); public native gsl_splinalg_itersolve_type free(Free_Pointer free);
}

public static class gsl_splinalg_itersolve extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_splinalg_itersolve() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_splinalg_itersolve(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_splinalg_itersolve(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_splinalg_itersolve position(long position) {
        return (gsl_splinalg_itersolve)super.position(position);
    }

  @MemberGetter public native @Const gsl_splinalg_itersolve_type type();
  public native double normr(); public native gsl_splinalg_itersolve normr(double normr); /* current residual norm || b - A x || */
  public native Pointer state(); public native gsl_splinalg_itersolve state(Pointer state);
}

/* available types */
@MemberGetter public static native @Const gsl_splinalg_itersolve_type gsl_splinalg_itersolve_gmres();

/*
 * Prototypes
 */
public static native gsl_splinalg_itersolve gsl_splinalg_itersolve_alloc(@Const gsl_splinalg_itersolve_type T,
                             @Cast("const size_t") long n, @Cast("const size_t") long m);
public static native void gsl_splinalg_itersolve_free(gsl_splinalg_itersolve w);
public static native @Cast("const char*") BytePointer gsl_splinalg_itersolve_name(@Const gsl_splinalg_itersolve w);
public static native int gsl_splinalg_itersolve_iterate(@Const gsl_spmatrix A,
                                   @Const gsl_vector b,
                                   double tol, gsl_vector x,
                                   gsl_splinalg_itersolve w);
public static native double gsl_splinalg_itersolve_normr(@Const gsl_splinalg_itersolve w);

// #endif /* __GSL_SPLINALG_H__ */


// Parsed from gsl/gsl_interp2d.h

/* interpolation/gsl_interp2d.h
 * 
 * Copyright 2012 David Zaslavsky
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_INTERP2D_H__
// #define __GSL_INTERP2D_H__

// #include <gsl/gsl_interp.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_interp2d_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_interp2d_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_interp2d_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_interp2d_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_interp2d_type position(long position) {
        return (gsl_interp2d_type)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native @Cast("unsigned int") int min_size(); public native gsl_interp2d_type min_size(int min_size);
    public static class Alloc_long_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Alloc_long_long(Pointer p) { super(p); }
        protected Alloc_long_long() { allocate(); }
        private native void allocate();
        public native Pointer call(@Cast("size_t") long xsize, @Cast("size_t") long ysize);
    }
    public native Alloc_long_long alloc(); public native gsl_interp2d_type alloc(Alloc_long_long alloc);
    public static class Init_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Init_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long(Pointer p) { super(p); }
        protected Init_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long() { allocate(); }
        private native void allocate();
        public native int call(Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Const DoublePointer za, @Cast("size_t") long xsize, @Cast("size_t") long ysize);
    }
    public native Init_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long init(); public native gsl_interp2d_type init(Init_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long init);
    public static class Eval_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Eval_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer(Pointer p) { super(p); }
        protected Eval_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Const DoublePointer za, @Cast("size_t") long xsize, @Cast("size_t") long ysize, double x, double y, gsl_interp_accel arg8, gsl_interp_accel arg9, DoublePointer z);
    }
    public native Eval_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval(); public native gsl_interp2d_type eval(Eval_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval);
    public static class Eval_deriv_x_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Eval_deriv_x_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer(Pointer p) { super(p); }
        protected Eval_deriv_x_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Const DoublePointer za, @Cast("size_t") long xsize, @Cast("size_t") long ysize, double x, double y, gsl_interp_accel arg8, gsl_interp_accel arg9, DoublePointer z_p);
    }
    public native Eval_deriv_x_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_x(); public native gsl_interp2d_type eval_deriv_x(Eval_deriv_x_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_x);
    public static class Eval_deriv_y_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Eval_deriv_y_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer(Pointer p) { super(p); }
        protected Eval_deriv_y_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Const DoublePointer za, @Cast("size_t") long xsize, @Cast("size_t") long ysize, double x, double y, gsl_interp_accel arg8, gsl_interp_accel arg9, DoublePointer z_p);
    }
    public native Eval_deriv_y_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_y(); public native gsl_interp2d_type eval_deriv_y(Eval_deriv_y_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_y);
    public static class Eval_deriv_xx_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Eval_deriv_xx_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer(Pointer p) { super(p); }
        protected Eval_deriv_xx_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Const DoublePointer za, @Cast("size_t") long xsize, @Cast("size_t") long ysize, double x, double y, gsl_interp_accel arg8, gsl_interp_accel arg9, DoublePointer z_pp);
    }
    public native Eval_deriv_xx_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_xx(); public native gsl_interp2d_type eval_deriv_xx(Eval_deriv_xx_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_xx);
    public static class Eval_deriv_xy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Eval_deriv_xy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer(Pointer p) { super(p); }
        protected Eval_deriv_xy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Const DoublePointer za, @Cast("size_t") long xsize, @Cast("size_t") long ysize, double x, double y, gsl_interp_accel arg8, gsl_interp_accel arg9, DoublePointer z_pp);
    }
    public native Eval_deriv_xy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_xy(); public native gsl_interp2d_type eval_deriv_xy(Eval_deriv_xy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_xy);
    public static class Eval_deriv_yy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Eval_deriv_yy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer(Pointer p) { super(p); }
        protected Eval_deriv_yy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer() { allocate(); }
        private native void allocate();
        public native int call(@Const Pointer arg0, @Const DoublePointer xa, @Const DoublePointer ya, @Const DoublePointer za, @Cast("size_t") long xsize, @Cast("size_t") long ysize, double x, double y, gsl_interp_accel arg8, gsl_interp_accel arg9, DoublePointer z_pp);
    }
    public native Eval_deriv_yy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_yy(); public native gsl_interp2d_type eval_deriv_yy(Eval_deriv_yy_Pointer_DoublePointer_DoublePointer_DoublePointer_long_long_double_double_gsl_interp_accel_gsl_interp_accel_DoublePointer eval_deriv_yy);
    public static class Free_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Free_Pointer(Pointer p) { super(p); }
        protected Free_Pointer() { allocate(); }
        private native void allocate();
        public native void call(Pointer arg0);
    }
    public native Free_Pointer free(); public native gsl_interp2d_type free(Free_Pointer free);
}

public static class gsl_interp2d extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_interp2d() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_interp2d(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_interp2d(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_interp2d position(long position) {
        return (gsl_interp2d)super.position(position);
    }

    @MemberGetter public native @Const gsl_interp2d_type type(); /* interpolation type */
    public native double xmin(); public native gsl_interp2d xmin(double xmin);                    /* minimum value of x for which data have been provided */
    public native double xmax(); public native gsl_interp2d xmax(double xmax);                    /* maximum value of x for which data have been provided */
    public native double ymin(); public native gsl_interp2d ymin(double ymin);                    /* minimum value of y for which data have been provided */
    public native double ymax(); public native gsl_interp2d ymax(double ymax);                    /* maximum value of y for which data have been provided */
    public native @Cast("size_t") long xsize(); public native gsl_interp2d xsize(long xsize);                   /* number of x values provided */
    public native @Cast("size_t") long ysize(); public native gsl_interp2d ysize(long ysize);                   /* number of y values provided */
    public native Pointer state(); public native gsl_interp2d state(Pointer state);                   /* internal state object specific to the interpolation type */
}

/* available types */
@MemberGetter public static native @Const gsl_interp2d_type gsl_interp2d_bilinear();
@MemberGetter public static native @Const gsl_interp2d_type gsl_interp2d_bicubic();

public static native gsl_interp2d gsl_interp2d_alloc(@Const gsl_interp2d_type T, @Cast("const size_t") long xsize,
                                  @Cast("const size_t") long ysize);

public static native @Cast("const char*") BytePointer gsl_interp2d_name(@Const gsl_interp2d interp);
public static native @Cast("size_t") long gsl_interp2d_min_size(@Const gsl_interp2d interp);
public static native @Cast("size_t") long gsl_interp2d_type_min_size(@Const gsl_interp2d_type T);
public static native int gsl_interp2d_set(@Const gsl_interp2d interp, DoublePointer zarr,
                     @Cast("const size_t") long i, @Cast("const size_t") long j, double z);
public static native int gsl_interp2d_set(@Const gsl_interp2d interp, DoubleBuffer zarr,
                     @Cast("const size_t") long i, @Cast("const size_t") long j, double z);
public static native int gsl_interp2d_set(@Const gsl_interp2d interp, double[] zarr,
                     @Cast("const size_t") long i, @Cast("const size_t") long j, double z);
public static native double gsl_interp2d_get(@Const gsl_interp2d interp, @Const DoublePointer zarr,
                        @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native double gsl_interp2d_get(@Const gsl_interp2d interp, @Const DoubleBuffer zarr,
                        @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native double gsl_interp2d_get(@Const gsl_interp2d interp, @Const double[] zarr,
                        @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native @Cast("size_t") long gsl_interp2d_idx(@Const gsl_interp2d interp,
                        @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native int gsl_interp2d_init(gsl_interp2d interp, @Const DoublePointer xa, @Const DoublePointer ya,
                      @Const DoublePointer za, @Cast("const size_t") long xsize, @Cast("const size_t") long ysize);
public static native int gsl_interp2d_init(gsl_interp2d interp, @Const DoubleBuffer xa, @Const DoubleBuffer ya,
                      @Const DoubleBuffer za, @Cast("const size_t") long xsize, @Cast("const size_t") long ysize);
public static native int gsl_interp2d_init(gsl_interp2d interp, @Const double[] xa, @Const double[] ya,
                      @Const double[] za, @Cast("const size_t") long xsize, @Cast("const size_t") long ysize);
public static native void gsl_interp2d_free(gsl_interp2d interp);

public static native double gsl_interp2d_eval(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                         @Const DoublePointer yarr, @Const DoublePointer zarr, double x,
                         double y, gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                         @Const DoubleBuffer yarr, @Const DoubleBuffer zarr, double x,
                         double y, gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval(@Const gsl_interp2d interp, @Const double[] xarr,
                         @Const double[] yarr, @Const double[] zarr, double x,
                         double y, gsl_interp_accel xa, gsl_interp_accel ya);

public static native double gsl_interp2d_eval_extrap(@Const gsl_interp2d interp,
                                @Const DoublePointer xarr, @Const DoublePointer yarr,
                                @Const DoublePointer zarr, double x,
                                double y, gsl_interp_accel xa,
                                gsl_interp_accel ya);
public static native double gsl_interp2d_eval_extrap(@Const gsl_interp2d interp,
                                @Const DoubleBuffer xarr, @Const DoubleBuffer yarr,
                                @Const DoubleBuffer zarr, double x,
                                double y, gsl_interp_accel xa,
                                gsl_interp_accel ya);
public static native double gsl_interp2d_eval_extrap(@Const gsl_interp2d interp,
                                @Const double[] xarr, @Const double[] yarr,
                                @Const double[] zarr, double x,
                                double y, gsl_interp_accel xa,
                                gsl_interp_accel ya);

public static native int gsl_interp2d_eval_e(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                        @Const DoublePointer yarr, @Const DoublePointer zarr,
                        double x, double y, gsl_interp_accel xa,
                        gsl_interp_accel ya, DoublePointer z);
public static native int gsl_interp2d_eval_e(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                        @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                        double x, double y, gsl_interp_accel xa,
                        gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_interp2d_eval_e(@Const gsl_interp2d interp, @Const double[] xarr,
                        @Const double[] yarr, @Const double[] zarr,
                        double x, double y, gsl_interp_accel xa,
                        gsl_interp_accel ya, double[] z);

public static native int gsl_interp2d_eval_e_extrap(@Const gsl_interp2d interp,
                               @Const DoublePointer xarr,
                               @Const DoublePointer yarr,
                               @Const DoublePointer zarr,
                               double x,
                               double y,
                               gsl_interp_accel xa,
                               gsl_interp_accel ya,
                               DoublePointer z);
public static native int gsl_interp2d_eval_e_extrap(@Const gsl_interp2d interp,
                               @Const DoubleBuffer xarr,
                               @Const DoubleBuffer yarr,
                               @Const DoubleBuffer zarr,
                               double x,
                               double y,
                               gsl_interp_accel xa,
                               gsl_interp_accel ya,
                               DoubleBuffer z);
public static native int gsl_interp2d_eval_e_extrap(@Const gsl_interp2d interp,
                               @Const double[] xarr,
                               @Const double[] yarr,
                               @Const double[] zarr,
                               double x,
                               double y,
                               gsl_interp_accel xa,
                               gsl_interp_accel ya,
                               double[] z);

public static native double gsl_interp2d_eval_deriv_x(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                 @Const DoublePointer yarr, @Const DoublePointer zarr,
                                 double x, double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_x(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                 @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                 double x, double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_x(@Const gsl_interp2d interp, @Const double[] xarr,
                                 @Const double[] yarr, @Const double[] zarr,
                                 double x, double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya);

public static native int gsl_interp2d_eval_deriv_x_e(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                @Const DoublePointer yarr, @Const DoublePointer zarr,
                                double x, double y,
                                gsl_interp_accel xa, gsl_interp_accel ya, DoublePointer z);
public static native int gsl_interp2d_eval_deriv_x_e(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                double x, double y,
                                gsl_interp_accel xa, gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_interp2d_eval_deriv_x_e(@Const gsl_interp2d interp, @Const double[] xarr,
                                @Const double[] yarr, @Const double[] zarr,
                                double x, double y,
                                gsl_interp_accel xa, gsl_interp_accel ya, double[] z);

public static native double gsl_interp2d_eval_deriv_y(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                 @Const DoublePointer yarr, @Const DoublePointer zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_y(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                 @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_y(@Const gsl_interp2d interp, @Const double[] xarr,
                                 @Const double[] yarr, @Const double[] zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya);

public static native int gsl_interp2d_eval_deriv_y_e(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                @Const DoublePointer yarr, @Const DoublePointer zarr,
                                double x, double y,
                                gsl_interp_accel xa, gsl_interp_accel ya, DoublePointer z);
public static native int gsl_interp2d_eval_deriv_y_e(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                double x, double y,
                                gsl_interp_accel xa, gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_interp2d_eval_deriv_y_e(@Const gsl_interp2d interp, @Const double[] xarr,
                                @Const double[] yarr, @Const double[] zarr,
                                double x, double y,
                                gsl_interp_accel xa, gsl_interp_accel ya, double[] z);

public static native double gsl_interp2d_eval_deriv_xx(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                  @Const DoublePointer yarr, @Const DoublePointer zarr,
                                  double x, double y,
                                  gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_xx(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                  @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                  double x, double y,
                                  gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_xx(@Const gsl_interp2d interp, @Const double[] xarr,
                                  @Const double[] yarr, @Const double[] zarr,
                                  double x, double y,
                                  gsl_interp_accel xa, gsl_interp_accel ya);

public static native int gsl_interp2d_eval_deriv_xx_e(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                 @Const DoublePointer yarr, @Const DoublePointer zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya, DoublePointer z);
public static native int gsl_interp2d_eval_deriv_xx_e(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                 @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_interp2d_eval_deriv_xx_e(@Const gsl_interp2d interp, @Const double[] xarr,
                                 @Const double[] yarr, @Const double[] zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya, double[] z);

public static native double gsl_interp2d_eval_deriv_yy(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                  @Const DoublePointer yarr, @Const DoublePointer zarr,
                                  double x, double y,
                                  gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_yy(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                  @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                  double x, double y,
                                  gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_yy(@Const gsl_interp2d interp, @Const double[] xarr,
                                  @Const double[] yarr, @Const double[] zarr,
                                  double x, double y,
                                  gsl_interp_accel xa, gsl_interp_accel ya);

public static native int gsl_interp2d_eval_deriv_yy_e(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                 @Const DoublePointer yarr, @Const DoublePointer zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya, DoublePointer z);
public static native int gsl_interp2d_eval_deriv_yy_e(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                 @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_interp2d_eval_deriv_yy_e(@Const gsl_interp2d interp, @Const double[] xarr,
                                 @Const double[] yarr, @Const double[] zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya, double[] z);

public static native double gsl_interp2d_eval_deriv_xy(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                  @Const DoublePointer yarr, @Const DoublePointer zarr,
                                  double x, double y,
                                  gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_xy(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                  @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                  double x, double y,
                                  gsl_interp_accel xa, gsl_interp_accel ya);
public static native double gsl_interp2d_eval_deriv_xy(@Const gsl_interp2d interp, @Const double[] xarr,
                                  @Const double[] yarr, @Const double[] zarr,
                                  double x, double y,
                                  gsl_interp_accel xa, gsl_interp_accel ya);

public static native int gsl_interp2d_eval_deriv_xy_e(@Const gsl_interp2d interp, @Const DoublePointer xarr,
                                 @Const DoublePointer yarr, @Const DoublePointer zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya, DoublePointer z);
public static native int gsl_interp2d_eval_deriv_xy_e(@Const gsl_interp2d interp, @Const DoubleBuffer xarr,
                                 @Const DoubleBuffer yarr, @Const DoubleBuffer zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_interp2d_eval_deriv_xy_e(@Const gsl_interp2d interp, @Const double[] xarr,
                                 @Const double[] yarr, @Const double[] zarr,
                                 double x, double y,
                                 gsl_interp_accel xa, gsl_interp_accel ya, double[] z);

// #endif /* __GSL_INTERP2D_H__ */


// Parsed from gsl/gsl_spline2d.h

/* interpolation/gsl_spline2d.h
 * 
 * Copyright 2012 David Zaslavsky
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SPLINE2D_H__
// #define __GSL_SPLINE2D_H__

// #include <gsl/gsl_interp.h>
// #include <gsl/gsl_interp2d.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/*
 * A 2D interpolation object which stores the arrays defining the function.
 * In all other respects, this is just like a gsl_interp2d object.
 */
public static class gsl_spline2d extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_spline2d() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_spline2d(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_spline2d(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_spline2d position(long position) {
        return (gsl_spline2d)super.position(position);
    }

  public native @ByRef gsl_interp2d interp_object(); public native gsl_spline2d interp_object(gsl_interp2d interp_object); /* low-level interpolation object */
  public native DoublePointer xarr(); public native gsl_spline2d xarr(DoublePointer xarr);              /* x data array */
  public native DoublePointer yarr(); public native gsl_spline2d yarr(DoublePointer yarr);              /* y data array */
  public native DoublePointer zarr(); public native gsl_spline2d zarr(DoublePointer zarr);              /* z data array */
}

public static native gsl_spline2d gsl_spline2d_alloc(@Const gsl_interp2d_type T, @Cast("size_t") long xsize, @Cast("size_t") long ysize);

public static native int gsl_spline2d_init(gsl_spline2d interp, @Const DoublePointer xa,
                      @Const DoublePointer ya, @Const DoublePointer za,
                      @Cast("size_t") long xsize, @Cast("size_t") long ysize);
public static native int gsl_spline2d_init(gsl_spline2d interp, @Const DoubleBuffer xa,
                      @Const DoubleBuffer ya, @Const DoubleBuffer za,
                      @Cast("size_t") long xsize, @Cast("size_t") long ysize);
public static native int gsl_spline2d_init(gsl_spline2d interp, @Const double[] xa,
                      @Const double[] ya, @Const double[] za,
                      @Cast("size_t") long xsize, @Cast("size_t") long ysize);

public static native void gsl_spline2d_free(gsl_spline2d interp);

public static native double gsl_spline2d_eval(@Const gsl_spline2d interp, double x,
                         double y, gsl_interp_accel xa, gsl_interp_accel ya);

public static native int gsl_spline2d_eval_e(@Const gsl_spline2d interp, double x,
                        double y, gsl_interp_accel xa, gsl_interp_accel ya,
                        DoublePointer z);
public static native int gsl_spline2d_eval_e(@Const gsl_spline2d interp, double x,
                        double y, gsl_interp_accel xa, gsl_interp_accel ya,
                        DoubleBuffer z);
public static native int gsl_spline2d_eval_e(@Const gsl_spline2d interp, double x,
                        double y, gsl_interp_accel xa, gsl_interp_accel ya,
                        double[] z);

public static native double gsl_spline2d_eval_deriv_x(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa, gsl_interp_accel ya);

public static native int gsl_spline2d_eval_deriv_x_e(@Const gsl_spline2d interp, double x,
                                double y, gsl_interp_accel xa,
                                gsl_interp_accel ya, DoublePointer z);
public static native int gsl_spline2d_eval_deriv_x_e(@Const gsl_spline2d interp, double x,
                                double y, gsl_interp_accel xa,
                                gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_spline2d_eval_deriv_x_e(@Const gsl_spline2d interp, double x,
                                double y, gsl_interp_accel xa,
                                gsl_interp_accel ya, double[] z);

public static native double gsl_spline2d_eval_deriv_y(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya);

public static native int gsl_spline2d_eval_deriv_y_e(@Const gsl_spline2d interp, double x,
                                double y, gsl_interp_accel xa,
                                gsl_interp_accel ya, DoublePointer z);
public static native int gsl_spline2d_eval_deriv_y_e(@Const gsl_spline2d interp, double x,
                                double y, gsl_interp_accel xa,
                                gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_spline2d_eval_deriv_y_e(@Const gsl_spline2d interp, double x,
                                double y, gsl_interp_accel xa,
                                gsl_interp_accel ya, double[] z);

public static native double gsl_spline2d_eval_deriv_xx(@Const gsl_spline2d interp, double x,
                                  double y, gsl_interp_accel xa, gsl_interp_accel ya);

public static native int gsl_spline2d_eval_deriv_xx_e(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya, DoublePointer z);
public static native int gsl_spline2d_eval_deriv_xx_e(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_spline2d_eval_deriv_xx_e(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya, double[] z);

public static native double gsl_spline2d_eval_deriv_yy(@Const gsl_spline2d interp, double x,
                                  double y, gsl_interp_accel xa, gsl_interp_accel ya);

public static native int gsl_spline2d_eval_deriv_yy_e(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya, DoublePointer z);
public static native int gsl_spline2d_eval_deriv_yy_e(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_spline2d_eval_deriv_yy_e(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya, double[] z);

public static native double gsl_spline2d_eval_deriv_xy(@Const gsl_spline2d interp, double x,
                                  double y, gsl_interp_accel xa, gsl_interp_accel ya);

public static native int gsl_spline2d_eval_deriv_xy_e(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya, DoublePointer z);
public static native int gsl_spline2d_eval_deriv_xy_e(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya, DoubleBuffer z);
public static native int gsl_spline2d_eval_deriv_xy_e(@Const gsl_spline2d interp, double x,
                                 double y, gsl_interp_accel xa,
                                 gsl_interp_accel ya, double[] z);

public static native @Cast("size_t") long gsl_spline2d_min_size(@Const gsl_spline2d interp);

public static native @Cast("const char*") BytePointer gsl_spline2d_name(@Const gsl_spline2d interp);

public static native int gsl_spline2d_set(@Const gsl_spline2d interp, DoublePointer zarr,
                     @Cast("const size_t") long i, @Cast("const size_t") long j, double z);
public static native int gsl_spline2d_set(@Const gsl_spline2d interp, DoubleBuffer zarr,
                     @Cast("const size_t") long i, @Cast("const size_t") long j, double z);
public static native int gsl_spline2d_set(@Const gsl_spline2d interp, double[] zarr,
                     @Cast("const size_t") long i, @Cast("const size_t") long j, double z);
public static native double gsl_spline2d_get(@Const gsl_spline2d interp, @Const DoublePointer zarr,
                        @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native double gsl_spline2d_get(@Const gsl_spline2d interp, @Const DoubleBuffer zarr,
                        @Cast("const size_t") long i, @Cast("const size_t") long j);
public static native double gsl_spline2d_get(@Const gsl_spline2d interp, @Const double[] zarr,
                        @Cast("const size_t") long i, @Cast("const size_t") long j);

// #endif /* __GSL_SPLINE2D_H__ */


// Parsed from gsl/gsl_const.h

/* const/gsl_const.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_CONST__
// #define __GSL_CONST__

// #include <gsl/gsl_const_num.h>

// #include <gsl/gsl_const_cgs.h>
// #include <gsl/gsl_const_mks.h>

// #include <gsl/gsl_const_cgsm.h>
// #include <gsl/gsl_const_mksa.h>

// #endif /* __GSL_CONST__ */


// Parsed from gsl/gsl_const_num.h

/* const/gsl_const_num.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
 * 2006, 2007, 2008, 2009 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_CONST_NUM__
// #define __GSL_CONST_NUM__

public static final double GSL_CONST_NUM_FINE_STRUCTURE = (7.297352533e-3); /* 1 */
public static final double GSL_CONST_NUM_AVOGADRO = (6.02214199e23); /* 1 / mol */
public static final double GSL_CONST_NUM_YOTTA = (1e24); /* 1 */
public static final double GSL_CONST_NUM_ZETTA = (1e21); /* 1 */
public static final double GSL_CONST_NUM_EXA = (1e18); /* 1 */
public static final double GSL_CONST_NUM_PETA = (1e15); /* 1 */
public static final double GSL_CONST_NUM_TERA = (1e12); /* 1 */
public static final double GSL_CONST_NUM_GIGA = (1e9); /* 1 */
public static final double GSL_CONST_NUM_MEGA = (1e6); /* 1 */
public static final double GSL_CONST_NUM_KILO = (1e3); /* 1 */
public static final double GSL_CONST_NUM_MILLI = (1e-3); /* 1 */
public static final double GSL_CONST_NUM_MICRO = (1e-6); /* 1 */
public static final double GSL_CONST_NUM_NANO = (1e-9); /* 1 */
public static final double GSL_CONST_NUM_PICO = (1e-12); /* 1 */
public static final double GSL_CONST_NUM_FEMTO = (1e-15); /* 1 */
public static final double GSL_CONST_NUM_ATTO = (1e-18); /* 1 */
public static final double GSL_CONST_NUM_ZEPTO = (1e-21); /* 1 */
public static final double GSL_CONST_NUM_YOCTO = (1e-24); /* 1 */

// #endif /* __GSL_CONST_NUM__ */


// Parsed from gsl/gsl_const_cgs.h

/* const/gsl_const_cgs.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
 * 2006, 2007, 2008, 2009 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_CONST_CGS__
// #define __GSL_CONST_CGS__

public static final double GSL_CONST_CGS_SPEED_OF_LIGHT = (2.99792458e10); /* cm / s */
public static final double GSL_CONST_CGS_GRAVITATIONAL_CONSTANT = (6.673e-8); /* cm^3 / g s^2 */
public static final double GSL_CONST_CGS_PLANCKS_CONSTANT_H = (6.62606896e-27); /* g cm^2 / s */
public static final double GSL_CONST_CGS_PLANCKS_CONSTANT_HBAR = (1.05457162825e-27); /* g cm^2 / s */
public static final double GSL_CONST_CGS_ASTRONOMICAL_UNIT = (1.49597870691e13); /* cm */
public static final double GSL_CONST_CGS_LIGHT_YEAR = (9.46053620707e17); /* cm */
public static final double GSL_CONST_CGS_PARSEC = (3.08567758135e18); /* cm */
public static final double GSL_CONST_CGS_GRAV_ACCEL = (9.80665e2); /* cm / s^2 */
public static final double GSL_CONST_CGS_ELECTRON_VOLT = (1.602176487e-12); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGS_MASS_ELECTRON = (9.10938188e-28); /* g */
public static final double GSL_CONST_CGS_MASS_MUON = (1.88353109e-25); /* g */
public static final double GSL_CONST_CGS_MASS_PROTON = (1.67262158e-24); /* g */
public static final double GSL_CONST_CGS_MASS_NEUTRON = (1.67492716e-24); /* g */
public static final double GSL_CONST_CGS_RYDBERG = (2.17987196968e-11); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGS_BOLTZMANN = (1.3806504e-16); /* g cm^2 / K s^2 */
public static final double GSL_CONST_CGS_MOLAR_GAS = (8.314472e7); /* g cm^2 / K mol s^2 */
public static final double GSL_CONST_CGS_STANDARD_GAS_VOLUME = (2.2710981e4); /* cm^3 / mol */
public static final double GSL_CONST_CGS_MINUTE = (6e1); /* s */
public static final double GSL_CONST_CGS_HOUR = (3.6e3); /* s */
public static final double GSL_CONST_CGS_DAY = (8.64e4); /* s */
public static final double GSL_CONST_CGS_WEEK = (6.048e5); /* s */
public static final double GSL_CONST_CGS_INCH = (2.54e0); /* cm */
public static final double GSL_CONST_CGS_FOOT = (3.048e1); /* cm */
public static final double GSL_CONST_CGS_YARD = (9.144e1); /* cm */
public static final double GSL_CONST_CGS_MILE = (1.609344e5); /* cm */
public static final double GSL_CONST_CGS_NAUTICAL_MILE = (1.852e5); /* cm */
public static final double GSL_CONST_CGS_FATHOM = (1.8288e2); /* cm */
public static final double GSL_CONST_CGS_MIL = (2.54e-3); /* cm */
public static final double GSL_CONST_CGS_POINT = (3.52777777778e-2); /* cm */
public static final double GSL_CONST_CGS_TEXPOINT = (3.51459803515e-2); /* cm */
public static final double GSL_CONST_CGS_MICRON = (1e-4); /* cm */
public static final double GSL_CONST_CGS_ANGSTROM = (1e-8); /* cm */
public static final double GSL_CONST_CGS_HECTARE = (1e8); /* cm^2 */
public static final double GSL_CONST_CGS_ACRE = (4.04685642241e7); /* cm^2 */
public static final double GSL_CONST_CGS_BARN = (1e-24); /* cm^2 */
public static final double GSL_CONST_CGS_LITER = (1e3); /* cm^3 */
public static final double GSL_CONST_CGS_US_GALLON = (3.78541178402e3); /* cm^3 */
public static final double GSL_CONST_CGS_QUART = (9.46352946004e2); /* cm^3 */
public static final double GSL_CONST_CGS_PINT = (4.73176473002e2); /* cm^3 */
public static final double GSL_CONST_CGS_CUP = (2.36588236501e2); /* cm^3 */
public static final double GSL_CONST_CGS_FLUID_OUNCE = (2.95735295626e1); /* cm^3 */
public static final double GSL_CONST_CGS_TABLESPOON = (1.47867647813e1); /* cm^3 */
public static final double GSL_CONST_CGS_TEASPOON = (4.92892159375e0); /* cm^3 */
public static final double GSL_CONST_CGS_CANADIAN_GALLON = (4.54609e3); /* cm^3 */
public static final double GSL_CONST_CGS_UK_GALLON = (4.546092e3); /* cm^3 */
public static final double GSL_CONST_CGS_MILES_PER_HOUR = (4.4704e1); /* cm / s */
public static final double GSL_CONST_CGS_KILOMETERS_PER_HOUR = (2.77777777778e1); /* cm / s */
public static final double GSL_CONST_CGS_KNOT = (5.14444444444e1); /* cm / s */
public static final double GSL_CONST_CGS_POUND_MASS = (4.5359237e2); /* g */
public static final double GSL_CONST_CGS_OUNCE_MASS = (2.8349523125e1); /* g */
public static final double GSL_CONST_CGS_TON = (9.0718474e5); /* g */
public static final double GSL_CONST_CGS_METRIC_TON = (1e6); /* g */
public static final double GSL_CONST_CGS_UK_TON = (1.0160469088e6); /* g */
public static final double GSL_CONST_CGS_TROY_OUNCE = (3.1103475e1); /* g */
public static final double GSL_CONST_CGS_CARAT = (2e-1); /* g */
public static final double GSL_CONST_CGS_UNIFIED_ATOMIC_MASS = (1.660538782e-24); /* g */
public static final double GSL_CONST_CGS_GRAM_FORCE = (9.80665e2); /* cm g / s^2 */
public static final double GSL_CONST_CGS_POUND_FORCE = (4.44822161526e5); /* cm g / s^2 */
public static final double GSL_CONST_CGS_KILOPOUND_FORCE = (4.44822161526e8); /* cm g / s^2 */
public static final double GSL_CONST_CGS_POUNDAL = (1.38255e4); /* cm g / s^2 */
public static final double GSL_CONST_CGS_CALORIE = (4.1868e7); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGS_BTU = (1.05505585262e10); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGS_THERM = (1.05506e15); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGS_HORSEPOWER = (7.457e9); /* g cm^2 / s^3 */
public static final double GSL_CONST_CGS_BAR = (1e6); /* g / cm s^2 */
public static final double GSL_CONST_CGS_STD_ATMOSPHERE = (1.01325e6); /* g / cm s^2 */
public static final double GSL_CONST_CGS_TORR = (1.33322368421e3); /* g / cm s^2 */
public static final double GSL_CONST_CGS_METER_OF_MERCURY = (1.33322368421e6); /* g / cm s^2 */
public static final double GSL_CONST_CGS_INCH_OF_MERCURY = (3.38638815789e4); /* g / cm s^2 */
public static final double GSL_CONST_CGS_INCH_OF_WATER = (2.490889e3); /* g / cm s^2 */
public static final double GSL_CONST_CGS_PSI = (6.89475729317e4); /* g / cm s^2 */
public static final double GSL_CONST_CGS_POISE = (1e0); /* g / cm s */
public static final double GSL_CONST_CGS_STOKES = (1e0); /* cm^2 / s */
public static final double GSL_CONST_CGS_STILB = (1e0); /* cd / cm^2 */
public static final double GSL_CONST_CGS_LUMEN = (1e0); /* cd sr */
public static final double GSL_CONST_CGS_LUX = (1e-4); /* cd sr / cm^2 */
public static final double GSL_CONST_CGS_PHOT = (1e0); /* cd sr / cm^2 */
public static final double GSL_CONST_CGS_FOOTCANDLE = (1.076e-3); /* cd sr / cm^2 */
public static final double GSL_CONST_CGS_LAMBERT = (1e0); /* cd sr / cm^2 */
public static final double GSL_CONST_CGS_FOOTLAMBERT = (1.07639104e-3); /* cd sr / cm^2 */
public static final double GSL_CONST_CGS_CURIE = (3.7e10); /* 1 / s */
public static final double GSL_CONST_CGS_ROENTGEN = (2.58e-7); /* A s / g */
public static final double GSL_CONST_CGS_RAD = (1e2); /* cm^2 / s^2 */
public static final double GSL_CONST_CGS_SOLAR_MASS = (1.98892e33); /* g */
public static final double GSL_CONST_CGS_BOHR_RADIUS = (5.291772083e-9); /* cm */
public static final double GSL_CONST_CGS_NEWTON = (1e5); /* cm g / s^2 */
public static final double GSL_CONST_CGS_DYNE = (1e0); /* cm g / s^2 */
public static final double GSL_CONST_CGS_JOULE = (1e7); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGS_ERG = (1e0); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGS_STEFAN_BOLTZMANN_CONSTANT = (5.67040047374e-5); /* g / K^4 s^3 */
public static final double GSL_CONST_CGS_THOMSON_CROSS_SECTION = (6.65245893699e-25); /* cm^2 */

// #endif /* __GSL_CONST_CGS__ */


// Parsed from gsl/gsl_const_mks.h

/* const/gsl_const_mks.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
 * 2006, 2007, 2008, 2009 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_CONST_MKS__
// #define __GSL_CONST_MKS__

public static final double GSL_CONST_MKS_SPEED_OF_LIGHT = (2.99792458e8); /* m / s */
public static final double GSL_CONST_MKS_GRAVITATIONAL_CONSTANT = (6.673e-11); /* m^3 / kg s^2 */
public static final double GSL_CONST_MKS_PLANCKS_CONSTANT_H = (6.62606896e-34); /* kg m^2 / s */
public static final double GSL_CONST_MKS_PLANCKS_CONSTANT_HBAR = (1.05457162825e-34); /* kg m^2 / s */
public static final double GSL_CONST_MKS_ASTRONOMICAL_UNIT = (1.49597870691e11); /* m */
public static final double GSL_CONST_MKS_LIGHT_YEAR = (9.46053620707e15); /* m */
public static final double GSL_CONST_MKS_PARSEC = (3.08567758135e16); /* m */
public static final double GSL_CONST_MKS_GRAV_ACCEL = (9.80665e0); /* m / s^2 */
public static final double GSL_CONST_MKS_ELECTRON_VOLT = (1.602176487e-19); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKS_MASS_ELECTRON = (9.10938188e-31); /* kg */
public static final double GSL_CONST_MKS_MASS_MUON = (1.88353109e-28); /* kg */
public static final double GSL_CONST_MKS_MASS_PROTON = (1.67262158e-27); /* kg */
public static final double GSL_CONST_MKS_MASS_NEUTRON = (1.67492716e-27); /* kg */
public static final double GSL_CONST_MKS_RYDBERG = (2.17987196968e-18); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKS_BOLTZMANN = (1.3806504e-23); /* kg m^2 / K s^2 */
public static final double GSL_CONST_MKS_MOLAR_GAS = (8.314472e0); /* kg m^2 / K mol s^2 */
public static final double GSL_CONST_MKS_STANDARD_GAS_VOLUME = (2.2710981e-2); /* m^3 / mol */
public static final double GSL_CONST_MKS_MINUTE = (6e1); /* s */
public static final double GSL_CONST_MKS_HOUR = (3.6e3); /* s */
public static final double GSL_CONST_MKS_DAY = (8.64e4); /* s */
public static final double GSL_CONST_MKS_WEEK = (6.048e5); /* s */
public static final double GSL_CONST_MKS_INCH = (2.54e-2); /* m */
public static final double GSL_CONST_MKS_FOOT = (3.048e-1); /* m */
public static final double GSL_CONST_MKS_YARD = (9.144e-1); /* m */
public static final double GSL_CONST_MKS_MILE = (1.609344e3); /* m */
public static final double GSL_CONST_MKS_NAUTICAL_MILE = (1.852e3); /* m */
public static final double GSL_CONST_MKS_FATHOM = (1.8288e0); /* m */
public static final double GSL_CONST_MKS_MIL = (2.54e-5); /* m */
public static final double GSL_CONST_MKS_POINT = (3.52777777778e-4); /* m */
public static final double GSL_CONST_MKS_TEXPOINT = (3.51459803515e-4); /* m */
public static final double GSL_CONST_MKS_MICRON = (1e-6); /* m */
public static final double GSL_CONST_MKS_ANGSTROM = (1e-10); /* m */
public static final double GSL_CONST_MKS_HECTARE = (1e4); /* m^2 */
public static final double GSL_CONST_MKS_ACRE = (4.04685642241e3); /* m^2 */
public static final double GSL_CONST_MKS_BARN = (1e-28); /* m^2 */
public static final double GSL_CONST_MKS_LITER = (1e-3); /* m^3 */
public static final double GSL_CONST_MKS_US_GALLON = (3.78541178402e-3); /* m^3 */
public static final double GSL_CONST_MKS_QUART = (9.46352946004e-4); /* m^3 */
public static final double GSL_CONST_MKS_PINT = (4.73176473002e-4); /* m^3 */
public static final double GSL_CONST_MKS_CUP = (2.36588236501e-4); /* m^3 */
public static final double GSL_CONST_MKS_FLUID_OUNCE = (2.95735295626e-5); /* m^3 */
public static final double GSL_CONST_MKS_TABLESPOON = (1.47867647813e-5); /* m^3 */
public static final double GSL_CONST_MKS_TEASPOON = (4.92892159375e-6); /* m^3 */
public static final double GSL_CONST_MKS_CANADIAN_GALLON = (4.54609e-3); /* m^3 */
public static final double GSL_CONST_MKS_UK_GALLON = (4.546092e-3); /* m^3 */
public static final double GSL_CONST_MKS_MILES_PER_HOUR = (4.4704e-1); /* m / s */
public static final double GSL_CONST_MKS_KILOMETERS_PER_HOUR = (2.77777777778e-1); /* m / s */
public static final double GSL_CONST_MKS_KNOT = (5.14444444444e-1); /* m / s */
public static final double GSL_CONST_MKS_POUND_MASS = (4.5359237e-1); /* kg */
public static final double GSL_CONST_MKS_OUNCE_MASS = (2.8349523125e-2); /* kg */
public static final double GSL_CONST_MKS_TON = (9.0718474e2); /* kg */
public static final double GSL_CONST_MKS_METRIC_TON = (1e3); /* kg */
public static final double GSL_CONST_MKS_UK_TON = (1.0160469088e3); /* kg */
public static final double GSL_CONST_MKS_TROY_OUNCE = (3.1103475e-2); /* kg */
public static final double GSL_CONST_MKS_CARAT = (2e-4); /* kg */
public static final double GSL_CONST_MKS_UNIFIED_ATOMIC_MASS = (1.660538782e-27); /* kg */
public static final double GSL_CONST_MKS_GRAM_FORCE = (9.80665e-3); /* kg m / s^2 */
public static final double GSL_CONST_MKS_POUND_FORCE = (4.44822161526e0); /* kg m / s^2 */
public static final double GSL_CONST_MKS_KILOPOUND_FORCE = (4.44822161526e3); /* kg m / s^2 */
public static final double GSL_CONST_MKS_POUNDAL = (1.38255e-1); /* kg m / s^2 */
public static final double GSL_CONST_MKS_CALORIE = (4.1868e0); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKS_BTU = (1.05505585262e3); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKS_THERM = (1.05506e8); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKS_HORSEPOWER = (7.457e2); /* kg m^2 / s^3 */
public static final double GSL_CONST_MKS_BAR = (1e5); /* kg / m s^2 */
public static final double GSL_CONST_MKS_STD_ATMOSPHERE = (1.01325e5); /* kg / m s^2 */
public static final double GSL_CONST_MKS_TORR = (1.33322368421e2); /* kg / m s^2 */
public static final double GSL_CONST_MKS_METER_OF_MERCURY = (1.33322368421e5); /* kg / m s^2 */
public static final double GSL_CONST_MKS_INCH_OF_MERCURY = (3.38638815789e3); /* kg / m s^2 */
public static final double GSL_CONST_MKS_INCH_OF_WATER = (2.490889e2); /* kg / m s^2 */
public static final double GSL_CONST_MKS_PSI = (6.89475729317e3); /* kg / m s^2 */
public static final double GSL_CONST_MKS_POISE = (1e-1); /* kg m^-1 s^-1 */
public static final double GSL_CONST_MKS_STOKES = (1e-4); /* m^2 / s */
public static final double GSL_CONST_MKS_STILB = (1e4); /* cd / m^2 */
public static final double GSL_CONST_MKS_LUMEN = (1e0); /* cd sr */
public static final double GSL_CONST_MKS_LUX = (1e0); /* cd sr / m^2 */
public static final double GSL_CONST_MKS_PHOT = (1e4); /* cd sr / m^2 */
public static final double GSL_CONST_MKS_FOOTCANDLE = (1.076e1); /* cd sr / m^2 */
public static final double GSL_CONST_MKS_LAMBERT = (1e4); /* cd sr / m^2 */
public static final double GSL_CONST_MKS_FOOTLAMBERT = (1.07639104e1); /* cd sr / m^2 */
public static final double GSL_CONST_MKS_CURIE = (3.7e10); /* 1 / s */
public static final double GSL_CONST_MKS_ROENTGEN = (2.58e-4); /* A s / kg */
public static final double GSL_CONST_MKS_RAD = (1e-2); /* m^2 / s^2 */
public static final double GSL_CONST_MKS_SOLAR_MASS = (1.98892e30); /* kg */
public static final double GSL_CONST_MKS_BOHR_RADIUS = (5.291772083e-11); /* m */
public static final double GSL_CONST_MKS_NEWTON = (1e0); /* kg m / s^2 */
public static final double GSL_CONST_MKS_DYNE = (1e-5); /* kg m / s^2 */
public static final double GSL_CONST_MKS_JOULE = (1e0); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKS_ERG = (1e-7); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKS_STEFAN_BOLTZMANN_CONSTANT = (5.67040047374e-8); /* kg / K^4 s^3 */
public static final double GSL_CONST_MKS_THOMSON_CROSS_SECTION = (6.65245893699e-29); /* m^2 */
public static final double GSL_CONST_MKS_BOHR_MAGNETON = (9.27400899e-24); /* A m^2 */
public static final double GSL_CONST_MKS_NUCLEAR_MAGNETON = (5.05078317e-27); /* A m^2 */
public static final double GSL_CONST_MKS_ELECTRON_MAGNETIC_MOMENT = (9.28476362e-24); /* A m^2 */
public static final double GSL_CONST_MKS_PROTON_MAGNETIC_MOMENT = (1.410606633e-26); /* A m^2 */
public static final double GSL_CONST_MKS_FARADAY = (9.64853429775e4); /* A s / mol */
public static final double GSL_CONST_MKS_ELECTRON_CHARGE = (1.602176487e-19); /* A s */
public static final double GSL_CONST_MKS_VACUUM_PERMITTIVITY = (8.854187817e-12); /* A^2 s^4 / kg m^3 */
public static final double GSL_CONST_MKS_VACUUM_PERMEABILITY = (1.25663706144e-6); /* kg m / A^2 s^2 */
public static final double GSL_CONST_MKS_DEBYE = (3.33564095198e-30); /* A s^2 / m^2 */
public static final double GSL_CONST_MKS_GAUSS = (1e-4); /* kg / A s^2 */

// #endif /* __GSL_CONST_MKS__ */


// Parsed from gsl/gsl_const_cgsm.h

/* const/gsl_const_cgsm.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
 * 2006, 2007, 2008, 2009 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_CONST_CGSM__
// #define __GSL_CONST_CGSM__

public static final double GSL_CONST_CGSM_SPEED_OF_LIGHT = (2.99792458e10); /* cm / s */
public static final double GSL_CONST_CGSM_GRAVITATIONAL_CONSTANT = (6.673e-8); /* cm^3 / g s^2 */
public static final double GSL_CONST_CGSM_PLANCKS_CONSTANT_H = (6.62606896e-27); /* g cm^2 / s */
public static final double GSL_CONST_CGSM_PLANCKS_CONSTANT_HBAR = (1.05457162825e-27); /* g cm^2 / s */
public static final double GSL_CONST_CGSM_ASTRONOMICAL_UNIT = (1.49597870691e13); /* cm */
public static final double GSL_CONST_CGSM_LIGHT_YEAR = (9.46053620707e17); /* cm */
public static final double GSL_CONST_CGSM_PARSEC = (3.08567758135e18); /* cm */
public static final double GSL_CONST_CGSM_GRAV_ACCEL = (9.80665e2); /* cm / s^2 */
public static final double GSL_CONST_CGSM_ELECTRON_VOLT = (1.602176487e-12); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGSM_MASS_ELECTRON = (9.10938188e-28); /* g */
public static final double GSL_CONST_CGSM_MASS_MUON = (1.88353109e-25); /* g */
public static final double GSL_CONST_CGSM_MASS_PROTON = (1.67262158e-24); /* g */
public static final double GSL_CONST_CGSM_MASS_NEUTRON = (1.67492716e-24); /* g */
public static final double GSL_CONST_CGSM_RYDBERG = (2.17987196968e-11); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGSM_BOLTZMANN = (1.3806504e-16); /* g cm^2 / K s^2 */
public static final double GSL_CONST_CGSM_MOLAR_GAS = (8.314472e7); /* g cm^2 / K mol s^2 */
public static final double GSL_CONST_CGSM_STANDARD_GAS_VOLUME = (2.2710981e4); /* cm^3 / mol */
public static final double GSL_CONST_CGSM_MINUTE = (6e1); /* s */
public static final double GSL_CONST_CGSM_HOUR = (3.6e3); /* s */
public static final double GSL_CONST_CGSM_DAY = (8.64e4); /* s */
public static final double GSL_CONST_CGSM_WEEK = (6.048e5); /* s */
public static final double GSL_CONST_CGSM_INCH = (2.54e0); /* cm */
public static final double GSL_CONST_CGSM_FOOT = (3.048e1); /* cm */
public static final double GSL_CONST_CGSM_YARD = (9.144e1); /* cm */
public static final double GSL_CONST_CGSM_MILE = (1.609344e5); /* cm */
public static final double GSL_CONST_CGSM_NAUTICAL_MILE = (1.852e5); /* cm */
public static final double GSL_CONST_CGSM_FATHOM = (1.8288e2); /* cm */
public static final double GSL_CONST_CGSM_MIL = (2.54e-3); /* cm */
public static final double GSL_CONST_CGSM_POINT = (3.52777777778e-2); /* cm */
public static final double GSL_CONST_CGSM_TEXPOINT = (3.51459803515e-2); /* cm */
public static final double GSL_CONST_CGSM_MICRON = (1e-4); /* cm */
public static final double GSL_CONST_CGSM_ANGSTROM = (1e-8); /* cm */
public static final double GSL_CONST_CGSM_HECTARE = (1e8); /* cm^2 */
public static final double GSL_CONST_CGSM_ACRE = (4.04685642241e7); /* cm^2 */
public static final double GSL_CONST_CGSM_BARN = (1e-24); /* cm^2 */
public static final double GSL_CONST_CGSM_LITER = (1e3); /* cm^3 */
public static final double GSL_CONST_CGSM_US_GALLON = (3.78541178402e3); /* cm^3 */
public static final double GSL_CONST_CGSM_QUART = (9.46352946004e2); /* cm^3 */
public static final double GSL_CONST_CGSM_PINT = (4.73176473002e2); /* cm^3 */
public static final double GSL_CONST_CGSM_CUP = (2.36588236501e2); /* cm^3 */
public static final double GSL_CONST_CGSM_FLUID_OUNCE = (2.95735295626e1); /* cm^3 */
public static final double GSL_CONST_CGSM_TABLESPOON = (1.47867647813e1); /* cm^3 */
public static final double GSL_CONST_CGSM_TEASPOON = (4.92892159375e0); /* cm^3 */
public static final double GSL_CONST_CGSM_CANADIAN_GALLON = (4.54609e3); /* cm^3 */
public static final double GSL_CONST_CGSM_UK_GALLON = (4.546092e3); /* cm^3 */
public static final double GSL_CONST_CGSM_MILES_PER_HOUR = (4.4704e1); /* cm / s */
public static final double GSL_CONST_CGSM_KILOMETERS_PER_HOUR = (2.77777777778e1); /* cm / s */
public static final double GSL_CONST_CGSM_KNOT = (5.14444444444e1); /* cm / s */
public static final double GSL_CONST_CGSM_POUND_MASS = (4.5359237e2); /* g */
public static final double GSL_CONST_CGSM_OUNCE_MASS = (2.8349523125e1); /* g */
public static final double GSL_CONST_CGSM_TON = (9.0718474e5); /* g */
public static final double GSL_CONST_CGSM_METRIC_TON = (1e6); /* g */
public static final double GSL_CONST_CGSM_UK_TON = (1.0160469088e6); /* g */
public static final double GSL_CONST_CGSM_TROY_OUNCE = (3.1103475e1); /* g */
public static final double GSL_CONST_CGSM_CARAT = (2e-1); /* g */
public static final double GSL_CONST_CGSM_UNIFIED_ATOMIC_MASS = (1.660538782e-24); /* g */
public static final double GSL_CONST_CGSM_GRAM_FORCE = (9.80665e2); /* cm g / s^2 */
public static final double GSL_CONST_CGSM_POUND_FORCE = (4.44822161526e5); /* cm g / s^2 */
public static final double GSL_CONST_CGSM_KILOPOUND_FORCE = (4.44822161526e8); /* cm g / s^2 */
public static final double GSL_CONST_CGSM_POUNDAL = (1.38255e4); /* cm g / s^2 */
public static final double GSL_CONST_CGSM_CALORIE = (4.1868e7); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGSM_BTU = (1.05505585262e10); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGSM_THERM = (1.05506e15); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGSM_HORSEPOWER = (7.457e9); /* g cm^2 / s^3 */
public static final double GSL_CONST_CGSM_BAR = (1e6); /* g / cm s^2 */
public static final double GSL_CONST_CGSM_STD_ATMOSPHERE = (1.01325e6); /* g / cm s^2 */
public static final double GSL_CONST_CGSM_TORR = (1.33322368421e3); /* g / cm s^2 */
public static final double GSL_CONST_CGSM_METER_OF_MERCURY = (1.33322368421e6); /* g / cm s^2 */
public static final double GSL_CONST_CGSM_INCH_OF_MERCURY = (3.38638815789e4); /* g / cm s^2 */
public static final double GSL_CONST_CGSM_INCH_OF_WATER = (2.490889e3); /* g / cm s^2 */
public static final double GSL_CONST_CGSM_PSI = (6.89475729317e4); /* g / cm s^2 */
public static final double GSL_CONST_CGSM_POISE = (1e0); /* g / cm s */
public static final double GSL_CONST_CGSM_STOKES = (1e0); /* cm^2 / s */
public static final double GSL_CONST_CGSM_STILB = (1e0); /* cd / cm^2 */
public static final double GSL_CONST_CGSM_LUMEN = (1e0); /* cd sr */
public static final double GSL_CONST_CGSM_LUX = (1e-4); /* cd sr / cm^2 */
public static final double GSL_CONST_CGSM_PHOT = (1e0); /* cd sr / cm^2 */
public static final double GSL_CONST_CGSM_FOOTCANDLE = (1.076e-3); /* cd sr / cm^2 */
public static final double GSL_CONST_CGSM_LAMBERT = (1e0); /* cd sr / cm^2 */
public static final double GSL_CONST_CGSM_FOOTLAMBERT = (1.07639104e-3); /* cd sr / cm^2 */
public static final double GSL_CONST_CGSM_CURIE = (3.7e10); /* 1 / s */
public static final double GSL_CONST_CGSM_ROENTGEN = (2.58e-8); /* abamp s / g */
public static final double GSL_CONST_CGSM_RAD = (1e2); /* cm^2 / s^2 */
public static final double GSL_CONST_CGSM_SOLAR_MASS = (1.98892e33); /* g */
public static final double GSL_CONST_CGSM_BOHR_RADIUS = (5.291772083e-9); /* cm */
public static final double GSL_CONST_CGSM_NEWTON = (1e5); /* cm g / s^2 */
public static final double GSL_CONST_CGSM_DYNE = (1e0); /* cm g / s^2 */
public static final double GSL_CONST_CGSM_JOULE = (1e7); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGSM_ERG = (1e0); /* g cm^2 / s^2 */
public static final double GSL_CONST_CGSM_STEFAN_BOLTZMANN_CONSTANT = (5.67040047374e-5); /* g / K^4 s^3 */
public static final double GSL_CONST_CGSM_THOMSON_CROSS_SECTION = (6.65245893699e-25); /* cm^2 */
public static final double GSL_CONST_CGSM_BOHR_MAGNETON = (9.27400899e-21); /* abamp cm^2 */
public static final double GSL_CONST_CGSM_NUCLEAR_MAGNETON = (5.05078317e-24); /* abamp cm^2 */
public static final double GSL_CONST_CGSM_ELECTRON_MAGNETIC_MOMENT = (9.28476362e-21); /* abamp cm^2 */
public static final double GSL_CONST_CGSM_PROTON_MAGNETIC_MOMENT = (1.410606633e-23); /* abamp cm^2 */
public static final double GSL_CONST_CGSM_FARADAY = (9.64853429775e3); /* abamp s / mol */
public static final double GSL_CONST_CGSM_ELECTRON_CHARGE = (1.602176487e-20); /* abamp s */

// #endif /* __GSL_CONST_CGSM__ */


// Parsed from gsl/gsl_const_mksa.h

/* const/gsl_const_mksa.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
 * 2006, 2007, 2008, 2009 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_CONST_MKSA__
// #define __GSL_CONST_MKSA__

public static final double GSL_CONST_MKSA_SPEED_OF_LIGHT = (2.99792458e8); /* m / s */
public static final double GSL_CONST_MKSA_GRAVITATIONAL_CONSTANT = (6.673e-11); /* m^3 / kg s^2 */
public static final double GSL_CONST_MKSA_PLANCKS_CONSTANT_H = (6.62606896e-34); /* kg m^2 / s */
public static final double GSL_CONST_MKSA_PLANCKS_CONSTANT_HBAR = (1.05457162825e-34); /* kg m^2 / s */
public static final double GSL_CONST_MKSA_ASTRONOMICAL_UNIT = (1.49597870691e11); /* m */
public static final double GSL_CONST_MKSA_LIGHT_YEAR = (9.46053620707e15); /* m */
public static final double GSL_CONST_MKSA_PARSEC = (3.08567758135e16); /* m */
public static final double GSL_CONST_MKSA_GRAV_ACCEL = (9.80665e0); /* m / s^2 */
public static final double GSL_CONST_MKSA_ELECTRON_VOLT = (1.602176487e-19); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKSA_MASS_ELECTRON = (9.10938188e-31); /* kg */
public static final double GSL_CONST_MKSA_MASS_MUON = (1.88353109e-28); /* kg */
public static final double GSL_CONST_MKSA_MASS_PROTON = (1.67262158e-27); /* kg */
public static final double GSL_CONST_MKSA_MASS_NEUTRON = (1.67492716e-27); /* kg */
public static final double GSL_CONST_MKSA_RYDBERG = (2.17987196968e-18); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKSA_BOLTZMANN = (1.3806504e-23); /* kg m^2 / K s^2 */
public static final double GSL_CONST_MKSA_MOLAR_GAS = (8.314472e0); /* kg m^2 / K mol s^2 */
public static final double GSL_CONST_MKSA_STANDARD_GAS_VOLUME = (2.2710981e-2); /* m^3 / mol */
public static final double GSL_CONST_MKSA_MINUTE = (6e1); /* s */
public static final double GSL_CONST_MKSA_HOUR = (3.6e3); /* s */
public static final double GSL_CONST_MKSA_DAY = (8.64e4); /* s */
public static final double GSL_CONST_MKSA_WEEK = (6.048e5); /* s */
public static final double GSL_CONST_MKSA_INCH = (2.54e-2); /* m */
public static final double GSL_CONST_MKSA_FOOT = (3.048e-1); /* m */
public static final double GSL_CONST_MKSA_YARD = (9.144e-1); /* m */
public static final double GSL_CONST_MKSA_MILE = (1.609344e3); /* m */
public static final double GSL_CONST_MKSA_NAUTICAL_MILE = (1.852e3); /* m */
public static final double GSL_CONST_MKSA_FATHOM = (1.8288e0); /* m */
public static final double GSL_CONST_MKSA_MIL = (2.54e-5); /* m */
public static final double GSL_CONST_MKSA_POINT = (3.52777777778e-4); /* m */
public static final double GSL_CONST_MKSA_TEXPOINT = (3.51459803515e-4); /* m */
public static final double GSL_CONST_MKSA_MICRON = (1e-6); /* m */
public static final double GSL_CONST_MKSA_ANGSTROM = (1e-10); /* m */
public static final double GSL_CONST_MKSA_HECTARE = (1e4); /* m^2 */
public static final double GSL_CONST_MKSA_ACRE = (4.04685642241e3); /* m^2 */
public static final double GSL_CONST_MKSA_BARN = (1e-28); /* m^2 */
public static final double GSL_CONST_MKSA_LITER = (1e-3); /* m^3 */
public static final double GSL_CONST_MKSA_US_GALLON = (3.78541178402e-3); /* m^3 */
public static final double GSL_CONST_MKSA_QUART = (9.46352946004e-4); /* m^3 */
public static final double GSL_CONST_MKSA_PINT = (4.73176473002e-4); /* m^3 */
public static final double GSL_CONST_MKSA_CUP = (2.36588236501e-4); /* m^3 */
public static final double GSL_CONST_MKSA_FLUID_OUNCE = (2.95735295626e-5); /* m^3 */
public static final double GSL_CONST_MKSA_TABLESPOON = (1.47867647813e-5); /* m^3 */
public static final double GSL_CONST_MKSA_TEASPOON = (4.92892159375e-6); /* m^3 */
public static final double GSL_CONST_MKSA_CANADIAN_GALLON = (4.54609e-3); /* m^3 */
public static final double GSL_CONST_MKSA_UK_GALLON = (4.546092e-3); /* m^3 */
public static final double GSL_CONST_MKSA_MILES_PER_HOUR = (4.4704e-1); /* m / s */
public static final double GSL_CONST_MKSA_KILOMETERS_PER_HOUR = (2.77777777778e-1); /* m / s */
public static final double GSL_CONST_MKSA_KNOT = (5.14444444444e-1); /* m / s */
public static final double GSL_CONST_MKSA_POUND_MASS = (4.5359237e-1); /* kg */
public static final double GSL_CONST_MKSA_OUNCE_MASS = (2.8349523125e-2); /* kg */
public static final double GSL_CONST_MKSA_TON = (9.0718474e2); /* kg */
public static final double GSL_CONST_MKSA_METRIC_TON = (1e3); /* kg */
public static final double GSL_CONST_MKSA_UK_TON = (1.0160469088e3); /* kg */
public static final double GSL_CONST_MKSA_TROY_OUNCE = (3.1103475e-2); /* kg */
public static final double GSL_CONST_MKSA_CARAT = (2e-4); /* kg */
public static final double GSL_CONST_MKSA_UNIFIED_ATOMIC_MASS = (1.660538782e-27); /* kg */
public static final double GSL_CONST_MKSA_GRAM_FORCE = (9.80665e-3); /* kg m / s^2 */
public static final double GSL_CONST_MKSA_POUND_FORCE = (4.44822161526e0); /* kg m / s^2 */
public static final double GSL_CONST_MKSA_KILOPOUND_FORCE = (4.44822161526e3); /* kg m / s^2 */
public static final double GSL_CONST_MKSA_POUNDAL = (1.38255e-1); /* kg m / s^2 */
public static final double GSL_CONST_MKSA_CALORIE = (4.1868e0); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKSA_BTU = (1.05505585262e3); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKSA_THERM = (1.05506e8); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKSA_HORSEPOWER = (7.457e2); /* kg m^2 / s^3 */
public static final double GSL_CONST_MKSA_BAR = (1e5); /* kg / m s^2 */
public static final double GSL_CONST_MKSA_STD_ATMOSPHERE = (1.01325e5); /* kg / m s^2 */
public static final double GSL_CONST_MKSA_TORR = (1.33322368421e2); /* kg / m s^2 */
public static final double GSL_CONST_MKSA_METER_OF_MERCURY = (1.33322368421e5); /* kg / m s^2 */
public static final double GSL_CONST_MKSA_INCH_OF_MERCURY = (3.38638815789e3); /* kg / m s^2 */
public static final double GSL_CONST_MKSA_INCH_OF_WATER = (2.490889e2); /* kg / m s^2 */
public static final double GSL_CONST_MKSA_PSI = (6.89475729317e3); /* kg / m s^2 */
public static final double GSL_CONST_MKSA_POISE = (1e-1); /* kg m^-1 s^-1 */
public static final double GSL_CONST_MKSA_STOKES = (1e-4); /* m^2 / s */
public static final double GSL_CONST_MKSA_STILB = (1e4); /* cd / m^2 */
public static final double GSL_CONST_MKSA_LUMEN = (1e0); /* cd sr */
public static final double GSL_CONST_MKSA_LUX = (1e0); /* cd sr / m^2 */
public static final double GSL_CONST_MKSA_PHOT = (1e4); /* cd sr / m^2 */
public static final double GSL_CONST_MKSA_FOOTCANDLE = (1.076e1); /* cd sr / m^2 */
public static final double GSL_CONST_MKSA_LAMBERT = (1e4); /* cd sr / m^2 */
public static final double GSL_CONST_MKSA_FOOTLAMBERT = (1.07639104e1); /* cd sr / m^2 */
public static final double GSL_CONST_MKSA_CURIE = (3.7e10); /* 1 / s */
public static final double GSL_CONST_MKSA_ROENTGEN = (2.58e-4); /* A s / kg */
public static final double GSL_CONST_MKSA_RAD = (1e-2); /* m^2 / s^2 */
public static final double GSL_CONST_MKSA_SOLAR_MASS = (1.98892e30); /* kg */
public static final double GSL_CONST_MKSA_BOHR_RADIUS = (5.291772083e-11); /* m */
public static final double GSL_CONST_MKSA_NEWTON = (1e0); /* kg m / s^2 */
public static final double GSL_CONST_MKSA_DYNE = (1e-5); /* kg m / s^2 */
public static final double GSL_CONST_MKSA_JOULE = (1e0); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKSA_ERG = (1e-7); /* kg m^2 / s^2 */
public static final double GSL_CONST_MKSA_STEFAN_BOLTZMANN_CONSTANT = (5.67040047374e-8); /* kg / K^4 s^3 */
public static final double GSL_CONST_MKSA_THOMSON_CROSS_SECTION = (6.65245893699e-29); /* m^2 */
public static final double GSL_CONST_MKSA_BOHR_MAGNETON = (9.27400899e-24); /* A m^2 */
public static final double GSL_CONST_MKSA_NUCLEAR_MAGNETON = (5.05078317e-27); /* A m^2 */
public static final double GSL_CONST_MKSA_ELECTRON_MAGNETIC_MOMENT = (9.28476362e-24); /* A m^2 */
public static final double GSL_CONST_MKSA_PROTON_MAGNETIC_MOMENT = (1.410606633e-26); /* A m^2 */
public static final double GSL_CONST_MKSA_FARADAY = (9.64853429775e4); /* A s / mol */
public static final double GSL_CONST_MKSA_ELECTRON_CHARGE = (1.602176487e-19); /* A s */
public static final double GSL_CONST_MKSA_VACUUM_PERMITTIVITY = (8.854187817e-12); /* A^2 s^4 / kg m^3 */
public static final double GSL_CONST_MKSA_VACUUM_PERMEABILITY = (1.25663706144e-6); /* kg m / A^2 s^2 */
public static final double GSL_CONST_MKSA_DEBYE = (3.33564095198e-30); /* A s^2 / m^2 */
public static final double GSL_CONST_MKSA_GAUSS = (1e-4); /* kg / A s^2 */

// #endif /* __GSL_CONST_MKSA__ */


// Parsed from gsl/gsl_fft.h

/* fft/gsl_fft.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_FFT_H__
// #define __GSL_FFT_H__

// #include <gsl/gsl_complex.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/** enum gsl_fft_direction */
public static final int
    gsl_fft_forward = -1, gsl_fft_backward = 1;

/* this gives the sign in the formula

   h(f) = \sum x(t) exp(+/- 2 pi i f t) 
       
   where - is the forward transform direction and + the inverse direction */

// #endif /* __GSL_FFT_H__ */


// Parsed from gsl/gsl_fft_complex_float.h

/* fft/gsl_fft_complex_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_FFT_COMPLEX_FLOAT_H__
// #define __GSL_FFT_COMPLEX_FLOAT_H__

// #include <stddef.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_fft.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/*  Power of 2 routines  */


public static native int gsl_fft_complex_float_radix2_forward(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                          @Cast("const size_t") long stride,
                                          @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_forward(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                          @Cast("const size_t") long stride,
                                          @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_forward(@Cast("gsl_complex_packed_array_float") float[] data,
                                          @Cast("const size_t") long stride,
                                          @Cast("const size_t") long n);

public static native int gsl_fft_complex_float_radix2_backward(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                           @Cast("const size_t") long stride,
                                           @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_backward(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                           @Cast("const size_t") long stride,
                                           @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_backward(@Cast("gsl_complex_packed_array_float") float[] data,
                                           @Cast("const size_t") long stride,
                                           @Cast("const size_t") long n);

public static native int gsl_fft_complex_float_radix2_inverse(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                          @Cast("const size_t") long stride,
                                          @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_inverse(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                          @Cast("const size_t") long stride,
                                          @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_inverse(@Cast("gsl_complex_packed_array_float") float[] data,
                                          @Cast("const size_t") long stride,
                                          @Cast("const size_t") long n);

public static native int gsl_fft_complex_float_radix2_transform(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                            @Cast("const size_t") long stride,
                                            @Cast("const size_t") long n,
                                            @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_float_radix2_transform(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                            @Cast("const size_t") long stride,
                                            @Cast("const size_t") long n,
                                            @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_float_radix2_transform(@Cast("gsl_complex_packed_array_float") float[] data,
                                            @Cast("const size_t") long stride,
                                            @Cast("const size_t") long n,
                                            @Cast("const gsl_fft_direction") int sign);

public static native int gsl_fft_complex_float_radix2_dif_forward(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                              @Cast("const size_t") long stride,
                                              @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_dif_forward(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                              @Cast("const size_t") long stride,
                                              @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_dif_forward(@Cast("gsl_complex_packed_array_float") float[] data,
                                              @Cast("const size_t") long stride,
                                              @Cast("const size_t") long n);

public static native int gsl_fft_complex_float_radix2_dif_backward(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                               @Cast("const size_t") long stride,
                                               @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_dif_backward(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                               @Cast("const size_t") long stride,
                                               @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_dif_backward(@Cast("gsl_complex_packed_array_float") float[] data,
                                               @Cast("const size_t") long stride,
                                               @Cast("const size_t") long n);

public static native int gsl_fft_complex_float_radix2_dif_inverse(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                              @Cast("const size_t") long stride,
                                              @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_dif_inverse(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                              @Cast("const size_t") long stride,
                                              @Cast("const size_t") long n);
public static native int gsl_fft_complex_float_radix2_dif_inverse(@Cast("gsl_complex_packed_array_float") float[] data,
                                              @Cast("const size_t") long stride,
                                              @Cast("const size_t") long n);

public static native int gsl_fft_complex_float_radix2_dif_transform(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                                @Cast("const size_t") long stride,
                                                @Cast("const size_t") long n,
                                                @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_float_radix2_dif_transform(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                                @Cast("const size_t") long stride,
                                                @Cast("const size_t") long n,
                                                @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_float_radix2_dif_transform(@Cast("gsl_complex_packed_array_float") float[] data,
                                                @Cast("const size_t") long stride,
                                                @Cast("const size_t") long n,
                                                @Cast("const gsl_fft_direction") int sign);

/*  Mixed Radix general-N routines  */

public static class gsl_fft_complex_wavetable_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_complex_wavetable_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_complex_wavetable_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_complex_wavetable_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_complex_wavetable_float position(long position) {
        return (gsl_fft_complex_wavetable_float)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_fft_complex_wavetable_float n(long n);
    public native @Cast("size_t") long nf(); public native gsl_fft_complex_wavetable_float nf(long nf);
    public native @Cast("size_t") long factor(int i); public native gsl_fft_complex_wavetable_float factor(int i, long factor);
    @MemberGetter public native @Cast("size_t*") SizeTPointer factor();
    public native gsl_complex_float twiddle(int i); public native gsl_fft_complex_wavetable_float twiddle(int i, gsl_complex_float twiddle);
    @MemberGetter public native @Cast("gsl_complex_float**") PointerPointer twiddle();
    public native gsl_complex_float trig(); public native gsl_fft_complex_wavetable_float trig(gsl_complex_float trig);
  }

public static class gsl_fft_complex_workspace_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_complex_workspace_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_complex_workspace_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_complex_workspace_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_complex_workspace_float position(long position) {
        return (gsl_fft_complex_workspace_float)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_fft_complex_workspace_float n(long n);
    public native FloatPointer scratch(); public native gsl_fft_complex_workspace_float scratch(FloatPointer scratch);
}


public static native gsl_fft_complex_wavetable_float gsl_fft_complex_wavetable_float_alloc(@Cast("size_t") long n);

public static native void gsl_fft_complex_wavetable_float_free(gsl_fft_complex_wavetable_float wavetable);

public static native gsl_fft_complex_workspace_float gsl_fft_complex_workspace_float_alloc(@Cast("size_t") long n);

public static native void gsl_fft_complex_workspace_float_free(gsl_fft_complex_workspace_float workspace);


public static native int gsl_fft_complex_float_memcpy(gsl_fft_complex_wavetable_float dest,
                               gsl_fft_complex_wavetable_float src);


public static native int gsl_fft_complex_float_forward(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                   @Cast("const size_t") long stride,
                                   @Cast("const size_t") long n,
                                   @Const gsl_fft_complex_wavetable_float wavetable,
                                   gsl_fft_complex_workspace_float work);
public static native int gsl_fft_complex_float_forward(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                   @Cast("const size_t") long stride,
                                   @Cast("const size_t") long n,
                                   @Const gsl_fft_complex_wavetable_float wavetable,
                                   gsl_fft_complex_workspace_float work);
public static native int gsl_fft_complex_float_forward(@Cast("gsl_complex_packed_array_float") float[] data,
                                   @Cast("const size_t") long stride,
                                   @Cast("const size_t") long n,
                                   @Const gsl_fft_complex_wavetable_float wavetable,
                                   gsl_fft_complex_workspace_float work);

public static native int gsl_fft_complex_float_backward(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                    @Cast("const size_t") long stride,
                                    @Cast("const size_t") long n,
                                    @Const gsl_fft_complex_wavetable_float wavetable,
                                    gsl_fft_complex_workspace_float work);
public static native int gsl_fft_complex_float_backward(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                    @Cast("const size_t") long stride,
                                    @Cast("const size_t") long n,
                                    @Const gsl_fft_complex_wavetable_float wavetable,
                                    gsl_fft_complex_workspace_float work);
public static native int gsl_fft_complex_float_backward(@Cast("gsl_complex_packed_array_float") float[] data,
                                    @Cast("const size_t") long stride,
                                    @Cast("const size_t") long n,
                                    @Const gsl_fft_complex_wavetable_float wavetable,
                                    gsl_fft_complex_workspace_float work);

public static native int gsl_fft_complex_float_inverse(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                   @Cast("const size_t") long stride,
                                   @Cast("const size_t") long n,
                                   @Const gsl_fft_complex_wavetable_float wavetable,
                                   gsl_fft_complex_workspace_float work);
public static native int gsl_fft_complex_float_inverse(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                   @Cast("const size_t") long stride,
                                   @Cast("const size_t") long n,
                                   @Const gsl_fft_complex_wavetable_float wavetable,
                                   gsl_fft_complex_workspace_float work);
public static native int gsl_fft_complex_float_inverse(@Cast("gsl_complex_packed_array_float") float[] data,
                                   @Cast("const size_t") long stride,
                                   @Cast("const size_t") long n,
                                   @Const gsl_fft_complex_wavetable_float wavetable,
                                   gsl_fft_complex_workspace_float work);

public static native int gsl_fft_complex_float_transform(@Cast("gsl_complex_packed_array_float") FloatPointer data,
                                     @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                     @Const gsl_fft_complex_wavetable_float wavetable,
                                     gsl_fft_complex_workspace_float work,
                                     @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_float_transform(@Cast("gsl_complex_packed_array_float") FloatBuffer data,
                                     @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                     @Const gsl_fft_complex_wavetable_float wavetable,
                                     gsl_fft_complex_workspace_float work,
                                     @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_float_transform(@Cast("gsl_complex_packed_array_float") float[] data,
                                     @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                     @Const gsl_fft_complex_wavetable_float wavetable,
                                     gsl_fft_complex_workspace_float work,
                                     @Cast("const gsl_fft_direction") int sign);

// #endif /* __GSL_FFT_COMPLEX_FLOAT_H__ */




// Parsed from gsl/gsl_fft_complex.h

/* fft/gsl_fft_complex.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_FFT_COMPLEX_H__
// #define __GSL_FFT_COMPLEX_H__

// #include <stddef.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_fft.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/*  Power of 2 routines  */


public static native int gsl_fft_complex_radix2_forward(@Cast("gsl_complex_packed_array") DoublePointer data,
                                    @Cast("const size_t") long stride,
                                    @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_forward(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                                    @Cast("const size_t") long stride,
                                    @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_forward(@Cast("gsl_complex_packed_array") double[] data,
                                    @Cast("const size_t") long stride,
                                    @Cast("const size_t") long n);

public static native int gsl_fft_complex_radix2_backward(@Cast("gsl_complex_packed_array") DoublePointer data,
                                     @Cast("const size_t") long stride,
                                     @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_backward(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                                     @Cast("const size_t") long stride,
                                     @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_backward(@Cast("gsl_complex_packed_array") double[] data,
                                     @Cast("const size_t") long stride,
                                     @Cast("const size_t") long n);

public static native int gsl_fft_complex_radix2_inverse(@Cast("gsl_complex_packed_array") DoublePointer data,
                                    @Cast("const size_t") long stride,
                                    @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_inverse(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                                    @Cast("const size_t") long stride,
                                    @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_inverse(@Cast("gsl_complex_packed_array") double[] data,
                                    @Cast("const size_t") long stride,
                                    @Cast("const size_t") long n);

public static native int gsl_fft_complex_radix2_transform(@Cast("gsl_complex_packed_array") DoublePointer data,
                                      @Cast("const size_t") long stride,
                                      @Cast("const size_t") long n,
                                      @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_radix2_transform(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                                      @Cast("const size_t") long stride,
                                      @Cast("const size_t") long n,
                                      @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_radix2_transform(@Cast("gsl_complex_packed_array") double[] data,
                                      @Cast("const size_t") long stride,
                                      @Cast("const size_t") long n,
                                      @Cast("const gsl_fft_direction") int sign);

public static native int gsl_fft_complex_radix2_dif_forward(@Cast("gsl_complex_packed_array") DoublePointer data,
                                        @Cast("const size_t") long stride,
                                        @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_dif_forward(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                                        @Cast("const size_t") long stride,
                                        @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_dif_forward(@Cast("gsl_complex_packed_array") double[] data,
                                        @Cast("const size_t") long stride,
                                        @Cast("const size_t") long n);

public static native int gsl_fft_complex_radix2_dif_backward(@Cast("gsl_complex_packed_array") DoublePointer data,
                                         @Cast("const size_t") long stride,
                                         @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_dif_backward(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                                         @Cast("const size_t") long stride,
                                         @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_dif_backward(@Cast("gsl_complex_packed_array") double[] data,
                                         @Cast("const size_t") long stride,
                                         @Cast("const size_t") long n);

public static native int gsl_fft_complex_radix2_dif_inverse(@Cast("gsl_complex_packed_array") DoublePointer data,
                                        @Cast("const size_t") long stride,
                                        @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_dif_inverse(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                                        @Cast("const size_t") long stride,
                                        @Cast("const size_t") long n);
public static native int gsl_fft_complex_radix2_dif_inverse(@Cast("gsl_complex_packed_array") double[] data,
                                        @Cast("const size_t") long stride,
                                        @Cast("const size_t") long n);

public static native int gsl_fft_complex_radix2_dif_transform(@Cast("gsl_complex_packed_array") DoublePointer data,
                                          @Cast("const size_t") long stride,
                                          @Cast("const size_t") long n,
                                          @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_radix2_dif_transform(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                                          @Cast("const size_t") long stride,
                                          @Cast("const size_t") long n,
                                          @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_radix2_dif_transform(@Cast("gsl_complex_packed_array") double[] data,
                                          @Cast("const size_t") long stride,
                                          @Cast("const size_t") long n,
                                          @Cast("const gsl_fft_direction") int sign);

/*  Mixed Radix general-N routines  */

public static class gsl_fft_complex_wavetable extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_complex_wavetable() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_complex_wavetable(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_complex_wavetable(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_complex_wavetable position(long position) {
        return (gsl_fft_complex_wavetable)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_fft_complex_wavetable n(long n);
    public native @Cast("size_t") long nf(); public native gsl_fft_complex_wavetable nf(long nf);
    public native @Cast("size_t") long factor(int i); public native gsl_fft_complex_wavetable factor(int i, long factor);
    @MemberGetter public native @Cast("size_t*") SizeTPointer factor();
    public native gsl_complex twiddle(int i); public native gsl_fft_complex_wavetable twiddle(int i, gsl_complex twiddle);
    @MemberGetter public native @Cast("gsl_complex**") PointerPointer twiddle();
    public native gsl_complex trig(); public native gsl_fft_complex_wavetable trig(gsl_complex trig);
  }

public static class gsl_fft_complex_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_complex_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_complex_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_complex_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_complex_workspace position(long position) {
        return (gsl_fft_complex_workspace)super.position(position);
    }

  public native @Cast("size_t") long n(); public native gsl_fft_complex_workspace n(long n);
  public native DoublePointer scratch(); public native gsl_fft_complex_workspace scratch(DoublePointer scratch);
}


public static native gsl_fft_complex_wavetable gsl_fft_complex_wavetable_alloc(@Cast("size_t") long n);

public static native void gsl_fft_complex_wavetable_free(gsl_fft_complex_wavetable wavetable);

public static native gsl_fft_complex_workspace gsl_fft_complex_workspace_alloc(@Cast("size_t") long n);

public static native void gsl_fft_complex_workspace_free(gsl_fft_complex_workspace workspace);

public static native int gsl_fft_complex_memcpy(gsl_fft_complex_wavetable dest,
                            gsl_fft_complex_wavetable src);


public static native int gsl_fft_complex_forward(@Cast("gsl_complex_packed_array") DoublePointer data,
                             @Cast("const size_t") long stride,
                             @Cast("const size_t") long n,
                             @Const gsl_fft_complex_wavetable wavetable,
                             gsl_fft_complex_workspace work);
public static native int gsl_fft_complex_forward(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                             @Cast("const size_t") long stride,
                             @Cast("const size_t") long n,
                             @Const gsl_fft_complex_wavetable wavetable,
                             gsl_fft_complex_workspace work);
public static native int gsl_fft_complex_forward(@Cast("gsl_complex_packed_array") double[] data,
                             @Cast("const size_t") long stride,
                             @Cast("const size_t") long n,
                             @Const gsl_fft_complex_wavetable wavetable,
                             gsl_fft_complex_workspace work);

public static native int gsl_fft_complex_backward(@Cast("gsl_complex_packed_array") DoublePointer data,
                              @Cast("const size_t") long stride,
                              @Cast("const size_t") long n,
                              @Const gsl_fft_complex_wavetable wavetable,
                              gsl_fft_complex_workspace work);
public static native int gsl_fft_complex_backward(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                              @Cast("const size_t") long stride,
                              @Cast("const size_t") long n,
                              @Const gsl_fft_complex_wavetable wavetable,
                              gsl_fft_complex_workspace work);
public static native int gsl_fft_complex_backward(@Cast("gsl_complex_packed_array") double[] data,
                              @Cast("const size_t") long stride,
                              @Cast("const size_t") long n,
                              @Const gsl_fft_complex_wavetable wavetable,
                              gsl_fft_complex_workspace work);

public static native int gsl_fft_complex_inverse(@Cast("gsl_complex_packed_array") DoublePointer data,
                             @Cast("const size_t") long stride,
                             @Cast("const size_t") long n,
                             @Const gsl_fft_complex_wavetable wavetable,
                             gsl_fft_complex_workspace work);
public static native int gsl_fft_complex_inverse(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                             @Cast("const size_t") long stride,
                             @Cast("const size_t") long n,
                             @Const gsl_fft_complex_wavetable wavetable,
                             gsl_fft_complex_workspace work);
public static native int gsl_fft_complex_inverse(@Cast("gsl_complex_packed_array") double[] data,
                             @Cast("const size_t") long stride,
                             @Cast("const size_t") long n,
                             @Const gsl_fft_complex_wavetable wavetable,
                             gsl_fft_complex_workspace work);

public static native int gsl_fft_complex_transform(@Cast("gsl_complex_packed_array") DoublePointer data,
                               @Cast("const size_t") long stride, @Cast("const size_t") long n,
                               @Const gsl_fft_complex_wavetable wavetable,
                               gsl_fft_complex_workspace work,
                               @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_transform(@Cast("gsl_complex_packed_array") DoubleBuffer data,
                               @Cast("const size_t") long stride, @Cast("const size_t") long n,
                               @Const gsl_fft_complex_wavetable wavetable,
                               gsl_fft_complex_workspace work,
                               @Cast("const gsl_fft_direction") int sign);
public static native int gsl_fft_complex_transform(@Cast("gsl_complex_packed_array") double[] data,
                               @Cast("const size_t") long stride, @Cast("const size_t") long n,
                               @Const gsl_fft_complex_wavetable wavetable,
                               gsl_fft_complex_workspace work,
                               @Cast("const gsl_fft_direction") int sign);

// #endif /* __GSL_FFT_COMPLEX_H__ */


// Parsed from gsl/gsl_fft_halfcomplex_float.h

/* fft/gsl_fft_halfcomplex_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_FFT_HALFCOMPLEX_FLOAT_H__
// #define __GSL_FFT_HALFCOMPLEX_FLOAT_H__

// #include <stddef.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_fft.h>
// #include <gsl/gsl_fft_real_float.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_fft_halfcomplex_float_radix2_backward(FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_backward(FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_backward(float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_inverse(FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_inverse(FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_inverse(float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_transform(FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_transform(FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_transform(float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static class gsl_fft_halfcomplex_wavetable_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_halfcomplex_wavetable_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_halfcomplex_wavetable_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_halfcomplex_wavetable_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_halfcomplex_wavetable_float position(long position) {
        return (gsl_fft_halfcomplex_wavetable_float)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_fft_halfcomplex_wavetable_float n(long n);
    public native @Cast("size_t") long nf(); public native gsl_fft_halfcomplex_wavetable_float nf(long nf);
    public native @Cast("size_t") long factor(int i); public native gsl_fft_halfcomplex_wavetable_float factor(int i, long factor);
    @MemberGetter public native @Cast("size_t*") SizeTPointer factor();
    public native gsl_complex_float twiddle(int i); public native gsl_fft_halfcomplex_wavetable_float twiddle(int i, gsl_complex_float twiddle);
    @MemberGetter public native @Cast("gsl_complex_float**") PointerPointer twiddle();
    public native gsl_complex_float trig(); public native gsl_fft_halfcomplex_wavetable_float trig(gsl_complex_float trig);
  }


public static native gsl_fft_halfcomplex_wavetable_float gsl_fft_halfcomplex_wavetable_float_alloc(@Cast("size_t") long n);

public static native void gsl_fft_halfcomplex_wavetable_float_free(gsl_fft_halfcomplex_wavetable_float wavetable);

public static native int gsl_fft_halfcomplex_float_backward(FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                        @Const gsl_fft_halfcomplex_wavetable_float wavetable,
                                        gsl_fft_real_workspace_float work);
public static native int gsl_fft_halfcomplex_float_backward(FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                        @Const gsl_fft_halfcomplex_wavetable_float wavetable,
                                        gsl_fft_real_workspace_float work);
public static native int gsl_fft_halfcomplex_float_backward(float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                        @Const gsl_fft_halfcomplex_wavetable_float wavetable,
                                        gsl_fft_real_workspace_float work);

public static native int gsl_fft_halfcomplex_float_inverse(FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                       @Const gsl_fft_halfcomplex_wavetable_float wavetable,
                                       gsl_fft_real_workspace_float work);
public static native int gsl_fft_halfcomplex_float_inverse(FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                       @Const gsl_fft_halfcomplex_wavetable_float wavetable,
                                       gsl_fft_real_workspace_float work);
public static native int gsl_fft_halfcomplex_float_inverse(float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                       @Const gsl_fft_halfcomplex_wavetable_float wavetable,
                                       gsl_fft_real_workspace_float work);

public static native int gsl_fft_halfcomplex_float_transform(FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                         @Const gsl_fft_halfcomplex_wavetable_float wavetable,
                                         gsl_fft_real_workspace_float work);
public static native int gsl_fft_halfcomplex_float_transform(FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                         @Const gsl_fft_halfcomplex_wavetable_float wavetable,
                                         gsl_fft_real_workspace_float work);
public static native int gsl_fft_halfcomplex_float_transform(float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                         @Const gsl_fft_halfcomplex_wavetable_float wavetable,
                                         gsl_fft_real_workspace_float work);

public static native int gsl_fft_halfcomplex_float_unpack(@Const FloatPointer halfcomplex_coefficient,
                                  FloatPointer complex_coefficient,
                                  @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_unpack(@Const FloatBuffer halfcomplex_coefficient,
                                  FloatBuffer complex_coefficient,
                                  @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_unpack(@Const float[] halfcomplex_coefficient,
                                  float[] complex_coefficient,
                                  @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_fft_halfcomplex_float_radix2_unpack(@Const FloatPointer halfcomplex_coefficient,
                                         FloatPointer complex_coefficient,
                                         @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_unpack(@Const FloatBuffer halfcomplex_coefficient,
                                         FloatBuffer complex_coefficient,
                                         @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_float_radix2_unpack(@Const float[] halfcomplex_coefficient,
                                         float[] complex_coefficient,
                                         @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_FFT_HALFCOMPLEX_FLOAT_H__ */


// Parsed from gsl/gsl_fft_halfcomplex.h

/* fft/gsl_fft_halfcomplex.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_FFT_HALFCOMPLEX_H__
// #define __GSL_FFT_HALFCOMPLEX_H__

// #include <stddef.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_fft.h>
// #include <gsl/gsl_fft_real.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_fft_halfcomplex_radix2_backward(DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_backward(DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_backward(double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_inverse(DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_inverse(DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_inverse(double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_transform(DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_transform(DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_transform(double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static class gsl_fft_halfcomplex_wavetable extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_halfcomplex_wavetable() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_halfcomplex_wavetable(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_halfcomplex_wavetable(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_halfcomplex_wavetable position(long position) {
        return (gsl_fft_halfcomplex_wavetable)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_fft_halfcomplex_wavetable n(long n);
    public native @Cast("size_t") long nf(); public native gsl_fft_halfcomplex_wavetable nf(long nf);
    public native @Cast("size_t") long factor(int i); public native gsl_fft_halfcomplex_wavetable factor(int i, long factor);
    @MemberGetter public native @Cast("size_t*") SizeTPointer factor();
    public native gsl_complex twiddle(int i); public native gsl_fft_halfcomplex_wavetable twiddle(int i, gsl_complex twiddle);
    @MemberGetter public native @Cast("gsl_complex**") PointerPointer twiddle();
    public native gsl_complex trig(); public native gsl_fft_halfcomplex_wavetable trig(gsl_complex trig);
  }

public static native gsl_fft_halfcomplex_wavetable gsl_fft_halfcomplex_wavetable_alloc(@Cast("size_t") long n);

public static native void gsl_fft_halfcomplex_wavetable_free(gsl_fft_halfcomplex_wavetable wavetable);


public static native int gsl_fft_halfcomplex_backward(DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                  @Const gsl_fft_halfcomplex_wavetable wavetable,
                                  gsl_fft_real_workspace work);
public static native int gsl_fft_halfcomplex_backward(DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                  @Const gsl_fft_halfcomplex_wavetable wavetable,
                                  gsl_fft_real_workspace work);
public static native int gsl_fft_halfcomplex_backward(double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                  @Const gsl_fft_halfcomplex_wavetable wavetable,
                                  gsl_fft_real_workspace work);

public static native int gsl_fft_halfcomplex_inverse(DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                 @Const gsl_fft_halfcomplex_wavetable wavetable,
                                 gsl_fft_real_workspace work);
public static native int gsl_fft_halfcomplex_inverse(DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                 @Const gsl_fft_halfcomplex_wavetable wavetable,
                                 gsl_fft_real_workspace work);
public static native int gsl_fft_halfcomplex_inverse(double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                 @Const gsl_fft_halfcomplex_wavetable wavetable,
                                 gsl_fft_real_workspace work);

public static native int gsl_fft_halfcomplex_transform(DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                   @Const gsl_fft_halfcomplex_wavetable wavetable,
                                   gsl_fft_real_workspace work);
public static native int gsl_fft_halfcomplex_transform(DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                   @Const gsl_fft_halfcomplex_wavetable wavetable,
                                   gsl_fft_real_workspace work);
public static native int gsl_fft_halfcomplex_transform(double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                   @Const gsl_fft_halfcomplex_wavetable wavetable,
                                   gsl_fft_real_workspace work);

public static native int gsl_fft_halfcomplex_unpack(@Const DoublePointer halfcomplex_coefficient,
                            DoublePointer complex_coefficient,
                            @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_unpack(@Const DoubleBuffer halfcomplex_coefficient,
                            DoubleBuffer complex_coefficient,
                            @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_unpack(@Const double[] halfcomplex_coefficient,
                            double[] complex_coefficient,
                            @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_fft_halfcomplex_radix2_unpack(@Const DoublePointer halfcomplex_coefficient,
                                   DoublePointer complex_coefficient,
                                   @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_unpack(@Const DoubleBuffer halfcomplex_coefficient,
                                   DoubleBuffer complex_coefficient,
                                   @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_halfcomplex_radix2_unpack(@Const double[] halfcomplex_coefficient,
                                   double[] complex_coefficient,
                                   @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_FFT_HALFCOMPLEX_H__ */


// Parsed from gsl/gsl_fft_real_float.h

/* fft/gsl_fft_real_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_FFT_REAL_FLOAT_H__
// #define __GSL_FFT_REAL_FLOAT_H__

// #include <stddef.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_fft.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_fft_real_float_radix2_transform(FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_real_float_radix2_transform(FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_real_float_radix2_transform(float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static class gsl_fft_real_wavetable_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_real_wavetable_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_real_wavetable_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_real_wavetable_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_real_wavetable_float position(long position) {
        return (gsl_fft_real_wavetable_float)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_fft_real_wavetable_float n(long n);
    public native @Cast("size_t") long nf(); public native gsl_fft_real_wavetable_float nf(long nf);
    public native @Cast("size_t") long factor(int i); public native gsl_fft_real_wavetable_float factor(int i, long factor);
    @MemberGetter public native @Cast("size_t*") SizeTPointer factor();
    public native gsl_complex_float twiddle(int i); public native gsl_fft_real_wavetable_float twiddle(int i, gsl_complex_float twiddle);
    @MemberGetter public native @Cast("gsl_complex_float**") PointerPointer twiddle();
    public native gsl_complex_float trig(); public native gsl_fft_real_wavetable_float trig(gsl_complex_float trig);
  }

public static class gsl_fft_real_workspace_float extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_real_workspace_float() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_real_workspace_float(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_real_workspace_float(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_real_workspace_float position(long position) {
        return (gsl_fft_real_workspace_float)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_fft_real_workspace_float n(long n);
    public native FloatPointer scratch(); public native gsl_fft_real_workspace_float scratch(FloatPointer scratch);
  }

public static native gsl_fft_real_wavetable_float gsl_fft_real_wavetable_float_alloc(@Cast("size_t") long n);

public static native void gsl_fft_real_wavetable_float_free(gsl_fft_real_wavetable_float wavetable);

public static native gsl_fft_real_workspace_float gsl_fft_real_workspace_float_alloc(@Cast("size_t") long n);

public static native void gsl_fft_real_workspace_float_free(gsl_fft_real_workspace_float workspace);

public static native int gsl_fft_real_float_transform(FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                  @Const gsl_fft_real_wavetable_float wavetable,
                                  gsl_fft_real_workspace_float work);
public static native int gsl_fft_real_float_transform(FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                  @Const gsl_fft_real_wavetable_float wavetable,
                                  gsl_fft_real_workspace_float work);
public static native int gsl_fft_real_float_transform(float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                                  @Const gsl_fft_real_wavetable_float wavetable,
                                  gsl_fft_real_workspace_float work);


public static native int gsl_fft_real_float_unpack(@Const FloatPointer real_float_coefficient,
                               FloatPointer complex_coefficient,
                               @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_real_float_unpack(@Const FloatBuffer real_float_coefficient,
                               FloatBuffer complex_coefficient,
                               @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_real_float_unpack(@Const float[] real_float_coefficient,
                               float[] complex_coefficient,
                               @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_FFT_REAL_FLOAT_H__ */


// Parsed from gsl/gsl_fft_real.h

/* fft/gsl_fft_real.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_FFT_REAL_H__
// #define __GSL_FFT_REAL_H__

// #include <stddef.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_fft.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_fft_real_radix2_transform(DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_real_radix2_transform(DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_real_radix2_transform(double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static class gsl_fft_real_wavetable extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_real_wavetable() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_real_wavetable(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_real_wavetable(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_real_wavetable position(long position) {
        return (gsl_fft_real_wavetable)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_fft_real_wavetable n(long n);
    public native @Cast("size_t") long nf(); public native gsl_fft_real_wavetable nf(long nf);
    public native @Cast("size_t") long factor(int i); public native gsl_fft_real_wavetable factor(int i, long factor);
    @MemberGetter public native @Cast("size_t*") SizeTPointer factor();
    public native gsl_complex twiddle(int i); public native gsl_fft_real_wavetable twiddle(int i, gsl_complex twiddle);
    @MemberGetter public native @Cast("gsl_complex**") PointerPointer twiddle();
    public native gsl_complex trig(); public native gsl_fft_real_wavetable trig(gsl_complex trig);
  }

public static class gsl_fft_real_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_fft_real_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_fft_real_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_fft_real_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_fft_real_workspace position(long position) {
        return (gsl_fft_real_workspace)super.position(position);
    }

    public native @Cast("size_t") long n(); public native gsl_fft_real_workspace n(long n);
    public native DoublePointer scratch(); public native gsl_fft_real_workspace scratch(DoublePointer scratch);
  }

public static native gsl_fft_real_wavetable gsl_fft_real_wavetable_alloc(@Cast("size_t") long n);

public static native void gsl_fft_real_wavetable_free(gsl_fft_real_wavetable wavetable);

public static native gsl_fft_real_workspace gsl_fft_real_workspace_alloc(@Cast("size_t") long n);

public static native void gsl_fft_real_workspace_free(gsl_fft_real_workspace workspace);


public static native int gsl_fft_real_transform(DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                            @Const gsl_fft_real_wavetable wavetable,
                            gsl_fft_real_workspace work);
public static native int gsl_fft_real_transform(DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                            @Const gsl_fft_real_wavetable wavetable,
                            gsl_fft_real_workspace work);
public static native int gsl_fft_real_transform(double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                            @Const gsl_fft_real_wavetable wavetable,
                            gsl_fft_real_workspace work);


public static native int gsl_fft_real_unpack(@Const DoublePointer real_coefficient,
                         DoublePointer complex_coefficient,
                         @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_real_unpack(@Const DoubleBuffer real_coefficient,
                         DoubleBuffer complex_coefficient,
                         @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_fft_real_unpack(@Const double[] real_coefficient,
                         double[] complex_coefficient,
                         @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_FFT_REAL_H__ */


// Parsed from gsl/gsl_dft_complex_float.h

/* fft/gsl_dft_complex_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_DFT_COMPLEX_FLOAT_H__
// #define __GSL_DFT_COMPLEX_FLOAT_H__

// #include <stddef.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_fft.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_dft_complex_float_forward(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             FloatPointer result);
public static native int gsl_dft_complex_float_forward(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             FloatBuffer result);
public static native int gsl_dft_complex_float_forward(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             float[] result);

public static native int gsl_dft_complex_float_backward(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                              FloatPointer result);
public static native int gsl_dft_complex_float_backward(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                              FloatBuffer result);
public static native int gsl_dft_complex_float_backward(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                              float[] result);

public static native int gsl_dft_complex_float_inverse(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             FloatPointer result);
public static native int gsl_dft_complex_float_inverse(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             FloatBuffer result);
public static native int gsl_dft_complex_float_inverse(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             float[] result);

public static native int gsl_dft_complex_float_transform(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                     FloatPointer result, @Cast("const gsl_fft_direction") int sign);
public static native int gsl_dft_complex_float_transform(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                     FloatBuffer result, @Cast("const gsl_fft_direction") int sign);
public static native int gsl_dft_complex_float_transform(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                     float[] result, @Cast("const gsl_fft_direction") int sign);

// #endif /* __GSL_DFT_COMPLEX_FLOAT_H__ */


// Parsed from gsl/gsl_dft_complex.h

/* fft/gsl_dft_complex.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_DFT_COMPLEX_H__
// #define __GSL_DFT_COMPLEX_H__

// #include <stddef.h>

// #include <gsl/gsl_math.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_fft.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_dft_complex_forward(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             DoublePointer result);
public static native int gsl_dft_complex_forward(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             DoubleBuffer result);
public static native int gsl_dft_complex_forward(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             double[] result);

public static native int gsl_dft_complex_backward(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                              DoublePointer result);
public static native int gsl_dft_complex_backward(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                              DoubleBuffer result);
public static native int gsl_dft_complex_backward(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                              double[] result);

public static native int gsl_dft_complex_inverse(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             DoublePointer result);
public static native int gsl_dft_complex_inverse(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             DoubleBuffer result);
public static native int gsl_dft_complex_inverse(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                             double[] result);

public static native int gsl_dft_complex_transform(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                     DoublePointer result, @Cast("const gsl_fft_direction") int sign);
public static native int gsl_dft_complex_transform(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                     DoubleBuffer result, @Cast("const gsl_fft_direction") int sign);
public static native int gsl_dft_complex_transform(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n,
                     double[] result, @Cast("const gsl_fft_direction") int sign);

// #endif /* __GSL_DFT_COMPLEX_H__ */


// Parsed from gsl/gsl_monte.h

/* monte/gsl_monte.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Michael Booth
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Some things common to all the Monte-Carlo implementations */
/* Author: MJB */

// #ifndef __GSL_MONTE_H__
// #define __GSL_MONTE_H__

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* Hide the function type in a typedef so that we can use it in all our
   integration functions, and make it easy to change things.
*/

@Name("gsl_monte_function_struct") public static class gsl_monte_function extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_monte_function() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_monte_function(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_monte_function(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_monte_function position(long position) {
        return (gsl_monte_function)super.position(position);
    }

  public static class F_DoublePointer_long_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    F_DoublePointer_long_Pointer(Pointer p) { super(p); }
      protected F_DoublePointer_long_Pointer() { allocate(); }
      private native void allocate();
      public native double call(DoublePointer x_array, @Cast("size_t") long dim, Pointer params);
  }
  public native F_DoublePointer_long_Pointer f(); public native gsl_monte_function f(F_DoublePointer_long_Pointer f);
  public native @Cast("size_t") long dim(); public native gsl_monte_function dim(long dim);
  public native Pointer params(); public native gsl_monte_function params(Pointer params);
}

// #define GSL_MONTE_FN_EVAL(F,x) (*((F)->f))(x,(F)->dim,(F)->params)

// #endif /* __GSL_MONTE_H__ */


// Parsed from gsl/gsl_monte_plain.h

/* monte/gsl_monte_plain.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Michael Booth
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Plain Monte-Carlo. */

/* Author: MJB */

// #ifndef __GSL_MONTE_PLAIN_H__
// #define __GSL_MONTE_PLAIN_H__

// #include <stdio.h>
// #include <gsl/gsl_monte.h>
// #include <gsl/gsl_rng.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_monte_plain_state extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_monte_plain_state() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_monte_plain_state(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_monte_plain_state(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_monte_plain_state position(long position) {
        return (gsl_monte_plain_state)super.position(position);
    }

  public native @Cast("size_t") long dim(); public native gsl_monte_plain_state dim(long dim);
  public native DoublePointer x(); public native gsl_monte_plain_state x(DoublePointer x);
}

public static native int gsl_monte_plain_integrate(@Const gsl_monte_function f,
                           @Const DoublePointer xl, @Const DoublePointer xu,
                           @Cast("const size_t") long dim,
                           @Cast("const size_t") long calls, 
                           gsl_rng r,
                           gsl_monte_plain_state state,
                           DoublePointer result, DoublePointer abserr);
public static native int gsl_monte_plain_integrate(@Const gsl_monte_function f,
                           @Const DoubleBuffer xl, @Const DoubleBuffer xu,
                           @Cast("const size_t") long dim,
                           @Cast("const size_t") long calls, 
                           gsl_rng r,
                           gsl_monte_plain_state state,
                           DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_monte_plain_integrate(@Const gsl_monte_function f,
                           @Const double[] xl, @Const double[] xu,
                           @Cast("const size_t") long dim,
                           @Cast("const size_t") long calls, 
                           gsl_rng r,
                           gsl_monte_plain_state state,
                           double[] result, double[] abserr);

public static native gsl_monte_plain_state gsl_monte_plain_alloc(@Cast("size_t") long dim);

public static native int gsl_monte_plain_init(gsl_monte_plain_state state);

public static native void gsl_monte_plain_free(gsl_monte_plain_state state);

// #endif /* __GSL_MONTE_PLAIN_H__ */


// Parsed from gsl/gsl_monte_miser.h

/* monte/gsl_monte_miser.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Michael Booth
 * Copyright (C) 2009 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author: MJB */

// #ifndef __GSL_MONTE_MISER_H__
// #define __GSL_MONTE_MISER_H__

// #include <gsl/gsl_rng.h>
// #include <gsl/gsl_monte.h>
// #include <gsl/gsl_monte_plain.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_monte_miser_state extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_monte_miser_state() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_monte_miser_state(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_monte_miser_state(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_monte_miser_state position(long position) {
        return (gsl_monte_miser_state)super.position(position);
    }

  public native @Cast("size_t") long min_calls(); public native gsl_monte_miser_state min_calls(long min_calls);
  public native @Cast("size_t") long min_calls_per_bisection(); public native gsl_monte_miser_state min_calls_per_bisection(long min_calls_per_bisection);
  public native double dither(); public native gsl_monte_miser_state dither(double dither);
  public native double estimate_frac(); public native gsl_monte_miser_state estimate_frac(double estimate_frac);
  public native double alpha(); public native gsl_monte_miser_state alpha(double alpha);
  public native @Cast("size_t") long dim(); public native gsl_monte_miser_state dim(long dim);
  public native int estimate_style(); public native gsl_monte_miser_state estimate_style(int estimate_style);
  public native int depth(); public native gsl_monte_miser_state depth(int depth);
  public native int verbose(); public native gsl_monte_miser_state verbose(int verbose);
  public native DoublePointer x(); public native gsl_monte_miser_state x(DoublePointer x);
  public native DoublePointer xmid(); public native gsl_monte_miser_state xmid(DoublePointer xmid);
  public native DoublePointer sigma_l(); public native gsl_monte_miser_state sigma_l(DoublePointer sigma_l);
  public native DoublePointer sigma_r(); public native gsl_monte_miser_state sigma_r(DoublePointer sigma_r);
  public native DoublePointer fmax_l(); public native gsl_monte_miser_state fmax_l(DoublePointer fmax_l);
  public native DoublePointer fmax_r(); public native gsl_monte_miser_state fmax_r(DoublePointer fmax_r);
  public native DoublePointer fmin_l(); public native gsl_monte_miser_state fmin_l(DoublePointer fmin_l);
  public native DoublePointer fmin_r(); public native gsl_monte_miser_state fmin_r(DoublePointer fmin_r);
  public native DoublePointer fsum_l(); public native gsl_monte_miser_state fsum_l(DoublePointer fsum_l);
  public native DoublePointer fsum_r(); public native gsl_monte_miser_state fsum_r(DoublePointer fsum_r);
  public native DoublePointer fsum2_l(); public native gsl_monte_miser_state fsum2_l(DoublePointer fsum2_l);
  public native DoublePointer fsum2_r(); public native gsl_monte_miser_state fsum2_r(DoublePointer fsum2_r);
  public native @Cast("size_t*") SizeTPointer hits_l(); public native gsl_monte_miser_state hits_l(SizeTPointer hits_l);
  public native @Cast("size_t*") SizeTPointer hits_r(); public native gsl_monte_miser_state hits_r(SizeTPointer hits_r);
} 

public static native int gsl_monte_miser_integrate(gsl_monte_function f, 
                              @Const DoublePointer xl, @Const DoublePointer xh, 
                              @Cast("size_t") long dim, @Cast("size_t") long calls, 
                              gsl_rng r, 
                              gsl_monte_miser_state state,
                              DoublePointer result, DoublePointer abserr);
public static native int gsl_monte_miser_integrate(gsl_monte_function f, 
                              @Const DoubleBuffer xl, @Const DoubleBuffer xh, 
                              @Cast("size_t") long dim, @Cast("size_t") long calls, 
                              gsl_rng r, 
                              gsl_monte_miser_state state,
                              DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_monte_miser_integrate(gsl_monte_function f, 
                              @Const double[] xl, @Const double[] xh, 
                              @Cast("size_t") long dim, @Cast("size_t") long calls, 
                              gsl_rng r, 
                              gsl_monte_miser_state state,
                              double[] result, double[] abserr);

public static native gsl_monte_miser_state gsl_monte_miser_alloc(@Cast("size_t") long dim);

public static native int gsl_monte_miser_init(gsl_monte_miser_state state);

public static native void gsl_monte_miser_free(gsl_monte_miser_state state);

public static class gsl_monte_miser_params extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_monte_miser_params() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_monte_miser_params(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_monte_miser_params(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_monte_miser_params position(long position) {
        return (gsl_monte_miser_params)super.position(position);
    }

  public native double estimate_frac(); public native gsl_monte_miser_params estimate_frac(double estimate_frac);
  public native @Cast("size_t") long min_calls(); public native gsl_monte_miser_params min_calls(long min_calls);
  public native @Cast("size_t") long min_calls_per_bisection(); public native gsl_monte_miser_params min_calls_per_bisection(long min_calls_per_bisection);
  public native double alpha(); public native gsl_monte_miser_params alpha(double alpha);
  public native double dither(); public native gsl_monte_miser_params dither(double dither);
}

public static native void gsl_monte_miser_params_get(@Const gsl_monte_miser_state state,
				 gsl_monte_miser_params params);

public static native void gsl_monte_miser_params_set(gsl_monte_miser_state state,
				 @Const gsl_monte_miser_params params);

// #endif /* __GSL_MONTE_MISER_H__ */


// Parsed from gsl/gsl_monte_vegas.h

/* monte/gsl_monte_vegas.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Michael Booth
 * Copyright (C) 2009 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* header for the gsl "vegas" routines.  Mike Booth, May 1998 */

// #ifndef __GSL_MONTE_VEGAS_H__
// #define __GSL_MONTE_VEGAS_H__

// #include <stdlib.h>
// #include <gsl/gsl_rng.h>
// #include <gsl/gsl_monte.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/** enum  */
public static final int GSL_VEGAS_MODE_IMPORTANCE = 1, 
      GSL_VEGAS_MODE_IMPORTANCE_ONLY = 0, 
      GSL_VEGAS_MODE_STRATIFIED = -1;

public static class gsl_monte_vegas_state extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_monte_vegas_state() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_monte_vegas_state(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_monte_vegas_state(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_monte_vegas_state position(long position) {
        return (gsl_monte_vegas_state)super.position(position);
    }

  /* grid */
  public native @Cast("size_t") long dim(); public native gsl_monte_vegas_state dim(long dim);
  public native @Cast("size_t") long bins_max(); public native gsl_monte_vegas_state bins_max(long bins_max);
  public native @Cast("unsigned int") int bins(); public native gsl_monte_vegas_state bins(int bins);
  public native @Cast("unsigned int") int boxes(); public native gsl_monte_vegas_state boxes(int boxes); /* these are both counted along the axes */
  public native DoublePointer xi(); public native gsl_monte_vegas_state xi(DoublePointer xi);
  public native DoublePointer xin(); public native gsl_monte_vegas_state xin(DoublePointer xin);
  public native DoublePointer delx(); public native gsl_monte_vegas_state delx(DoublePointer delx);
  public native DoublePointer weight(); public native gsl_monte_vegas_state weight(DoublePointer weight);
  public native double vol(); public native gsl_monte_vegas_state vol(double vol);

  public native DoublePointer x(); public native gsl_monte_vegas_state x(DoublePointer x);
  public native IntPointer bin(); public native gsl_monte_vegas_state bin(IntPointer bin);
  public native IntPointer box(); public native gsl_monte_vegas_state box(IntPointer box);
  
  /* distribution */
  public native DoublePointer d(); public native gsl_monte_vegas_state d(DoublePointer d);

  /* control variables */
  public native double alpha(); public native gsl_monte_vegas_state alpha(double alpha);
  public native int mode(); public native gsl_monte_vegas_state mode(int mode);
  public native int verbose(); public native gsl_monte_vegas_state verbose(int verbose);
  public native @Cast("unsigned int") int iterations(); public native gsl_monte_vegas_state iterations(int iterations);
  public native int stage(); public native gsl_monte_vegas_state stage(int stage);

  /* scratch variables preserved between calls to vegas1/2/3  */
  public native double jac(); public native gsl_monte_vegas_state jac(double jac);
  public native double wtd_int_sum(); public native gsl_monte_vegas_state wtd_int_sum(double wtd_int_sum); 
  public native double sum_wgts(); public native gsl_monte_vegas_state sum_wgts(double sum_wgts);
  public native double chi_sum(); public native gsl_monte_vegas_state chi_sum(double chi_sum);
  public native double chisq(); public native gsl_monte_vegas_state chisq(double chisq);

  public native double result(); public native gsl_monte_vegas_state result(double result);
  public native double sigma(); public native gsl_monte_vegas_state sigma(double sigma);

  public native @Cast("unsigned int") int it_start(); public native gsl_monte_vegas_state it_start(int it_start);
  public native @Cast("unsigned int") int it_num(); public native gsl_monte_vegas_state it_num(int it_num);
  public native @Cast("unsigned int") int samples(); public native gsl_monte_vegas_state samples(int samples);
  public native @Cast("unsigned int") int calls_per_box(); public native gsl_monte_vegas_state calls_per_box(int calls_per_box);

  public native @Cast("FILE*") Pointer ostream(); public native gsl_monte_vegas_state ostream(Pointer ostream);

}

public static native int gsl_monte_vegas_integrate(gsl_monte_function f, 
                              DoublePointer xl, DoublePointer xu, 
                              @Cast("size_t") long dim, @Cast("size_t") long calls,
                              gsl_rng r,
                              gsl_monte_vegas_state state,
                              DoublePointer result, DoublePointer abserr);
public static native int gsl_monte_vegas_integrate(gsl_monte_function f, 
                              DoubleBuffer xl, DoubleBuffer xu, 
                              @Cast("size_t") long dim, @Cast("size_t") long calls,
                              gsl_rng r,
                              gsl_monte_vegas_state state,
                              DoubleBuffer result, DoubleBuffer abserr);
public static native int gsl_monte_vegas_integrate(gsl_monte_function f, 
                              double[] xl, double[] xu, 
                              @Cast("size_t") long dim, @Cast("size_t") long calls,
                              gsl_rng r,
                              gsl_monte_vegas_state state,
                              double[] result, double[] abserr);

public static native gsl_monte_vegas_state gsl_monte_vegas_alloc(@Cast("size_t") long dim);

public static native int gsl_monte_vegas_init(gsl_monte_vegas_state state);

public static native void gsl_monte_vegas_free(gsl_monte_vegas_state state);

public static native double gsl_monte_vegas_chisq(@Const gsl_monte_vegas_state state);
public static native void gsl_monte_vegas_runval(@Const gsl_monte_vegas_state state, DoublePointer result, DoublePointer sigma);
public static native void gsl_monte_vegas_runval(@Const gsl_monte_vegas_state state, DoubleBuffer result, DoubleBuffer sigma);
public static native void gsl_monte_vegas_runval(@Const gsl_monte_vegas_state state, double[] result, double[] sigma);

public static class gsl_monte_vegas_params extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_monte_vegas_params() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_monte_vegas_params(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_monte_vegas_params(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_monte_vegas_params position(long position) {
        return (gsl_monte_vegas_params)super.position(position);
    }

  public native double alpha(); public native gsl_monte_vegas_params alpha(double alpha);
  public native @Cast("size_t") long iterations(); public native gsl_monte_vegas_params iterations(long iterations);
  public native int stage(); public native gsl_monte_vegas_params stage(int stage);
  public native int mode(); public native gsl_monte_vegas_params mode(int mode);
  public native int verbose(); public native gsl_monte_vegas_params verbose(int verbose);
  public native @Cast("FILE*") Pointer ostream(); public native gsl_monte_vegas_params ostream(Pointer ostream);
}

public static native void gsl_monte_vegas_params_get(@Const gsl_monte_vegas_state state,
				 gsl_monte_vegas_params params);

public static native void gsl_monte_vegas_params_set(gsl_monte_vegas_state state,
				 @Const gsl_monte_vegas_params params);

// #endif /* __GSL_MONTE_VEGAS_H__ */



// Parsed from gsl/gsl_multifit.h

/* multifit/gsl_multifit.h
 * 
 * Copyright (C) 2000, 2007, 2010 Brian Gough
 * Copyright (C) 2013, Patrick Alken
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MULTIFIT_H__
// #define __GSL_MULTIFIT_H__

// #include <stdlib.h>
// #include <gsl/gsl_math.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_multifit_linear_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_linear_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_linear_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_linear_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_linear_workspace position(long position) {
        return (gsl_multifit_linear_workspace)super.position(position);
    }

  public native @Cast("size_t") long nmax(); public native gsl_multifit_linear_workspace nmax(long nmax);         /* maximum number of observations */
  public native @Cast("size_t") long pmax(); public native gsl_multifit_linear_workspace pmax(long pmax);         /* maximum number of parameters */
  public native @Cast("size_t") long n(); public native gsl_multifit_linear_workspace n(long n);            /* number of observations in current SVD decomposition */
  public native @Cast("size_t") long p(); public native gsl_multifit_linear_workspace p(long p);            /* number of parameters in current SVD decomposition */
  public native gsl_matrix A(); public native gsl_multifit_linear_workspace A(gsl_matrix A);      /* least squares matrix for SVD, n-by-p */
  public native gsl_matrix Q(); public native gsl_multifit_linear_workspace Q(gsl_matrix Q);
  public native gsl_matrix QSI(); public native gsl_multifit_linear_workspace QSI(gsl_matrix QSI);
  public native gsl_vector S(); public native gsl_multifit_linear_workspace S(gsl_vector S);
  public native gsl_vector t(); public native gsl_multifit_linear_workspace t(gsl_vector t);
  public native gsl_vector xt(); public native gsl_multifit_linear_workspace xt(gsl_vector xt);
  public native gsl_vector D(); public native gsl_multifit_linear_workspace D(gsl_vector D);
  public native double rcond(); public native gsl_multifit_linear_workspace rcond(double rcond);        /* reciprocal condition number */
}

public static native gsl_multifit_linear_workspace gsl_multifit_linear_alloc(@Cast("const size_t") long n, @Cast("const size_t") long p);

public static native void gsl_multifit_linear_free(gsl_multifit_linear_workspace w);

public static native int gsl_multifit_linear(@Const gsl_matrix X,
                     @Const gsl_vector y,
                     gsl_vector c,
                     gsl_matrix cov,
                     DoublePointer chisq,
                     gsl_multifit_linear_workspace work);
public static native int gsl_multifit_linear(@Const gsl_matrix X,
                     @Const gsl_vector y,
                     gsl_vector c,
                     gsl_matrix cov,
                     DoubleBuffer chisq,
                     gsl_multifit_linear_workspace work);
public static native int gsl_multifit_linear(@Const gsl_matrix X,
                     @Const gsl_vector y,
                     gsl_vector c,
                     gsl_matrix cov,
                     double[] chisq,
                     gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_svd(@Const gsl_matrix X,
                         gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_bsvd(@Const gsl_matrix X,
                          gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_solve(double lambda,
                           @Const gsl_matrix X,
                           @Const gsl_vector y,
                           gsl_vector c,
                           DoublePointer rnorm,
                           DoublePointer snorm,
                           gsl_multifit_linear_workspace work);
public static native int gsl_multifit_linear_solve(double lambda,
                           @Const gsl_matrix X,
                           @Const gsl_vector y,
                           gsl_vector c,
                           DoubleBuffer rnorm,
                           DoubleBuffer snorm,
                           gsl_multifit_linear_workspace work);
public static native int gsl_multifit_linear_solve(double lambda,
                           @Const gsl_matrix X,
                           @Const gsl_vector y,
                           gsl_vector c,
                           double[] rnorm,
                           double[] snorm,
                           gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_applyW(@Const gsl_matrix X,
                           @Const gsl_vector w,
                           @Const gsl_vector y,
                           gsl_matrix WX,
                           gsl_vector Wy);

public static native int gsl_multifit_linear_stdform1(@Const gsl_vector L,
                              @Const gsl_matrix X,
                              @Const gsl_vector y,
                              gsl_matrix Xs,
                              gsl_vector ys,
                              gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_wstdform1(@Const gsl_vector L,
                               @Const gsl_matrix X,
                               @Const gsl_vector w,
                               @Const gsl_vector y,
                               gsl_matrix Xs,
                               gsl_vector ys,
                               gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_L_decomp(gsl_matrix L, gsl_vector tau);

public static native int gsl_multifit_linear_stdform2(@Const gsl_matrix LQR,
                              @Const gsl_vector Ltau,
                              @Const gsl_matrix X,
                              @Const gsl_vector y,
                              gsl_matrix Xs,
                              gsl_vector ys,
                              gsl_matrix M,
                              gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_wstdform2(@Const gsl_matrix LQR,
                               @Const gsl_vector Ltau,
                               @Const gsl_matrix X,
                               @Const gsl_vector w,
                               @Const gsl_vector y,
                               gsl_matrix Xs,
                               gsl_vector ys,
                               gsl_matrix M,
                               gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_genform1(@Const gsl_vector L,
                              @Const gsl_vector cs,
                              gsl_vector c,
                              gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_genform2(@Const gsl_matrix LQR,
                              @Const gsl_vector Ltau,
                              @Const gsl_matrix X,
                              @Const gsl_vector y,
                              @Const gsl_vector cs,
                              @Const gsl_matrix M,
                              gsl_vector c,
                              gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_wgenform2(@Const gsl_matrix LQR,
                               @Const gsl_vector Ltau,
                               @Const gsl_matrix X,
                               @Const gsl_vector w,
                               @Const gsl_vector y,
                               @Const gsl_vector cs,
                               @Const gsl_matrix M,
                               gsl_vector c,
                               gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_lreg(double smin, double smax,
                          gsl_vector reg_param);

public static native int gsl_multifit_linear_lcurve(@Const gsl_vector y,
                            gsl_vector reg_param,
                            gsl_vector rho, gsl_vector eta,
                            gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_lcorner(@Const gsl_vector rho,
                            @Const gsl_vector eta,
                            @Cast("size_t*") SizeTPointer idx);

public static native int gsl_multifit_linear_lcorner2(@Const gsl_vector reg_param,
                             @Const gsl_vector eta,
                             @Cast("size_t*") SizeTPointer idx);

public static native int gsl_multifit_linear_Lk(@Cast("const size_t") long p, @Cast("const size_t") long k, gsl_matrix L);

public static native int gsl_multifit_linear_Lsobolev(@Cast("const size_t") long p, @Cast("const size_t") long kmax,
                             @Const gsl_vector alpha, gsl_matrix L,
                             gsl_multifit_linear_workspace work);

public static native int gsl_multifit_wlinear(@Const gsl_matrix X,
                      @Const gsl_vector w,
                      @Const gsl_vector y,
                      gsl_vector c,
                      gsl_matrix cov,
                      DoublePointer chisq,
                      gsl_multifit_linear_workspace work);
public static native int gsl_multifit_wlinear(@Const gsl_matrix X,
                      @Const gsl_vector w,
                      @Const gsl_vector y,
                      gsl_vector c,
                      gsl_matrix cov,
                      DoubleBuffer chisq,
                      gsl_multifit_linear_workspace work);
public static native int gsl_multifit_wlinear(@Const gsl_matrix X,
                      @Const gsl_vector w,
                      @Const gsl_vector y,
                      gsl_vector c,
                      gsl_matrix cov,
                      double[] chisq,
                      gsl_multifit_linear_workspace work);

public static native int gsl_multifit_wlinear_svd(@Const gsl_matrix X,
                          @Const gsl_vector w,
                          @Const gsl_vector y,
                          double tol,
                          @Cast("size_t*") SizeTPointer rank,
                          gsl_vector c,
                          gsl_matrix cov,
                          DoublePointer chisq, 
                          gsl_multifit_linear_workspace work);
public static native int gsl_multifit_wlinear_svd(@Const gsl_matrix X,
                          @Const gsl_vector w,
                          @Const gsl_vector y,
                          double tol,
                          @Cast("size_t*") SizeTPointer rank,
                          gsl_vector c,
                          gsl_matrix cov,
                          DoubleBuffer chisq, 
                          gsl_multifit_linear_workspace work);
public static native int gsl_multifit_wlinear_svd(@Const gsl_matrix X,
                          @Const gsl_vector w,
                          @Const gsl_vector y,
                          double tol,
                          @Cast("size_t*") SizeTPointer rank,
                          gsl_vector c,
                          gsl_matrix cov,
                          double[] chisq, 
                          gsl_multifit_linear_workspace work);

public static native int gsl_multifit_wlinear_usvd(@Const gsl_matrix X,
                           @Const gsl_vector w,
                           @Const gsl_vector y,
                           double tol,
                           @Cast("size_t*") SizeTPointer rank,
                           gsl_vector c,
                           gsl_matrix cov,
                           DoublePointer chisq, 
                           gsl_multifit_linear_workspace work);
public static native int gsl_multifit_wlinear_usvd(@Const gsl_matrix X,
                           @Const gsl_vector w,
                           @Const gsl_vector y,
                           double tol,
                           @Cast("size_t*") SizeTPointer rank,
                           gsl_vector c,
                           gsl_matrix cov,
                           DoubleBuffer chisq, 
                           gsl_multifit_linear_workspace work);
public static native int gsl_multifit_wlinear_usvd(@Const gsl_matrix X,
                           @Const gsl_vector w,
                           @Const gsl_vector y,
                           double tol,
                           @Cast("size_t*") SizeTPointer rank,
                           gsl_vector c,
                           gsl_matrix cov,
                           double[] chisq, 
                           gsl_multifit_linear_workspace work);

public static native int gsl_multifit_linear_est(@Const gsl_vector x,
                         @Const gsl_vector c,
                         @Const gsl_matrix cov, DoublePointer y, DoublePointer y_err);
public static native int gsl_multifit_linear_est(@Const gsl_vector x,
                         @Const gsl_vector c,
                         @Const gsl_matrix cov, DoubleBuffer y, DoubleBuffer y_err);
public static native int gsl_multifit_linear_est(@Const gsl_vector x,
                         @Const gsl_vector c,
                         @Const gsl_matrix cov, double[] y, double[] y_err);

public static native double gsl_multifit_linear_rcond(@Const gsl_multifit_linear_workspace w);

public static native int gsl_multifit_linear_residuals(@Const gsl_matrix X, @Const gsl_vector y,
                               @Const gsl_vector c, gsl_vector r);

public static class gsl_multifit_robust_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_robust_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_robust_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_robust_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_robust_type position(long position) {
        return (gsl_multifit_robust_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();     /* method name */
  public static class Wfun_gsl_vector_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Wfun_gsl_vector_gsl_vector(Pointer p) { super(p); }
      protected Wfun_gsl_vector_gsl_vector() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector r, gsl_vector w);
  }
  public native Wfun_gsl_vector_gsl_vector wfun(); public native gsl_multifit_robust_type wfun(Wfun_gsl_vector_gsl_vector wfun);
  public static class Psi_deriv_gsl_vector_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Psi_deriv_gsl_vector_gsl_vector(Pointer p) { super(p); }
      protected Psi_deriv_gsl_vector_gsl_vector() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector r, gsl_vector dpsi);
  }
  public native Psi_deriv_gsl_vector_gsl_vector psi_deriv(); public native gsl_multifit_robust_type psi_deriv(Psi_deriv_gsl_vector_gsl_vector psi_deriv);
  public native double tuning_default(); public native gsl_multifit_robust_type tuning_default(double tuning_default); /* default tuning constant */
}

public static class gsl_multifit_robust_stats extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_robust_stats() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_robust_stats(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_robust_stats(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_robust_stats position(long position) {
        return (gsl_multifit_robust_stats)super.position(position);
    }

  public native double sigma_ols(); public native gsl_multifit_robust_stats sigma_ols(double sigma_ols);    /* OLS estimate of sigma */
  public native double sigma_mad(); public native gsl_multifit_robust_stats sigma_mad(double sigma_mad);    /* MAD estimate of sigma */
  public native double sigma_rob(); public native gsl_multifit_robust_stats sigma_rob(double sigma_rob);    /* robust estimate of sigma */
  public native double sigma(); public native gsl_multifit_robust_stats sigma(double sigma);        /* final estimate of sigma */
  public native double Rsq(); public native gsl_multifit_robust_stats Rsq(double Rsq);          /* R^2 coefficient of determination */
  public native double adj_Rsq(); public native gsl_multifit_robust_stats adj_Rsq(double adj_Rsq);      /* degree of freedom adjusted R^2 */
  public native double rmse(); public native gsl_multifit_robust_stats rmse(double rmse);         /* root mean squared error */
  public native double sse(); public native gsl_multifit_robust_stats sse(double sse);          /* residual sum of squares */
  public native @Cast("size_t") long dof(); public native gsl_multifit_robust_stats dof(long dof);          /* degrees of freedom */
  public native @Cast("size_t") long numit(); public native gsl_multifit_robust_stats numit(long numit);        /* number of iterations */
  public native gsl_vector weights(); public native gsl_multifit_robust_stats weights(gsl_vector weights); /* final weights */
  public native gsl_vector r(); public native gsl_multifit_robust_stats r(gsl_vector r);       /* final residuals y - X c */
}

public static class gsl_multifit_robust_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_robust_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_robust_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_robust_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_robust_workspace position(long position) {
        return (gsl_multifit_robust_workspace)super.position(position);
    }

  public native @Cast("size_t") long n(); public native gsl_multifit_robust_workspace n(long n);            /* number of observations */
  public native @Cast("size_t") long p(); public native gsl_multifit_robust_workspace p(long p);            /* number of parameters */
  public native @Cast("size_t") long numit(); public native gsl_multifit_robust_workspace numit(long numit);        /* number of iterations */
  public native @Cast("size_t") long maxiter(); public native gsl_multifit_robust_workspace maxiter(long maxiter);      /* maximum iterations */
  @MemberGetter public native @Const gsl_multifit_robust_type type();
  public native double tune(); public native gsl_multifit_robust_workspace tune(double tune);         /* tuning parameter */

  public native gsl_vector r(); public native gsl_multifit_robust_workspace r(gsl_vector r);       /* residuals at current iteration */
  public native gsl_vector weights(); public native gsl_multifit_robust_workspace weights(gsl_vector weights); /* weights at current iteration */
  public native gsl_vector c_prev(); public native gsl_multifit_robust_workspace c_prev(gsl_vector c_prev);  /* coefficients from previous iteration */
  public native gsl_vector resfac(); public native gsl_multifit_robust_workspace resfac(gsl_vector resfac);  /* multiplicative factors for residuals */

  public native gsl_vector psi(); public native gsl_multifit_robust_workspace psi(gsl_vector psi);     /* psi(r) */
  public native gsl_vector dpsi(); public native gsl_multifit_robust_workspace dpsi(gsl_vector dpsi);    /* psi'(r) */

  public native gsl_matrix QSI(); public native gsl_multifit_robust_workspace QSI(gsl_matrix QSI);     /* Q S^{-1} of original matrix X */
  public native gsl_vector D(); public native gsl_multifit_robust_workspace D(gsl_vector D);       /* balancing parameters of original matrix X */

  public native gsl_vector workn(); public native gsl_multifit_robust_workspace workn(gsl_vector workn);   /* workspace of length n */

  public native @ByRef gsl_multifit_robust_stats stats(); public native gsl_multifit_robust_workspace stats(gsl_multifit_robust_stats stats); /* various statistics */

  public native gsl_multifit_linear_workspace multifit_p(); public native gsl_multifit_robust_workspace multifit_p(gsl_multifit_linear_workspace multifit_p);
}

/* available types */
@MemberGetter public static native @Const gsl_multifit_robust_type gsl_multifit_robust_default();
@MemberGetter public static native @Const gsl_multifit_robust_type gsl_multifit_robust_bisquare();
@MemberGetter public static native @Const gsl_multifit_robust_type gsl_multifit_robust_cauchy();
@MemberGetter public static native @Const gsl_multifit_robust_type gsl_multifit_robust_fair();
@MemberGetter public static native @Const gsl_multifit_robust_type gsl_multifit_robust_huber();
@MemberGetter public static native @Const gsl_multifit_robust_type gsl_multifit_robust_ols();
@MemberGetter public static native @Const gsl_multifit_robust_type gsl_multifit_robust_welsch();

public static native gsl_multifit_robust_workspace gsl_multifit_robust_alloc(@Const gsl_multifit_robust_type T,
                                                         @Cast("const size_t") long n, @Cast("const size_t") long p);
public static native void gsl_multifit_robust_free(gsl_multifit_robust_workspace w);
public static native int gsl_multifit_robust_tune(double tune,
                             gsl_multifit_robust_workspace w);
public static native int gsl_multifit_robust_maxiter(@Cast("const size_t") long maxiter,
                                gsl_multifit_robust_workspace w);
public static native @Cast("const char*") BytePointer gsl_multifit_robust_name(@Const gsl_multifit_robust_workspace w);
public static native @ByVal gsl_multifit_robust_stats gsl_multifit_robust_statistics(@Const gsl_multifit_robust_workspace w);
public static native int gsl_multifit_robust_weights(@Const gsl_vector r, gsl_vector wts,
                                gsl_multifit_robust_workspace w);
public static native int gsl_multifit_robust(@Const gsl_matrix X, @Const gsl_vector y,
                        gsl_vector c, gsl_matrix cov,
                        gsl_multifit_robust_workspace w);
public static native int gsl_multifit_robust_est(@Const gsl_vector x, @Const gsl_vector c,
                            @Const gsl_matrix cov, DoublePointer y, DoublePointer y_err);
public static native int gsl_multifit_robust_est(@Const gsl_vector x, @Const gsl_vector c,
                            @Const gsl_matrix cov, DoubleBuffer y, DoubleBuffer y_err);
public static native int gsl_multifit_robust_est(@Const gsl_vector x, @Const gsl_vector c,
                            @Const gsl_matrix cov, double[] y, double[] y_err);
public static native int gsl_multifit_robust_residuals(@Const gsl_matrix X,
                                  @Const gsl_vector y,
                                  @Const gsl_vector c, gsl_vector r,
                                  gsl_multifit_robust_workspace w);

// #endif /* __GSL_MULTIFIT_H__ */


// Parsed from gsl/gsl_multifit_nlin.h

/* multifit_nlin/gsl_multifit_nlin.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MULTIFIT_NLIN_H__
// #define __GSL_MULTIFIT_NLIN_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_math.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_multifit_gradient(@Const gsl_matrix J, @Const gsl_vector f,
                           gsl_vector g);

public static native int gsl_multifit_covar(@Const gsl_matrix J, double epsrel, gsl_matrix covar);
public static native int gsl_multifit_covar_QRPT(gsl_matrix r, gsl_permutation perm,
                             double epsrel, gsl_matrix covar);


/* Definition of vector-valued functions with parameters based on gsl_vector */

@Name("gsl_multifit_function_struct") public static class gsl_multifit_function extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_function() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_function(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_function(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_function position(long position) {
        return (gsl_multifit_function)super.position(position);
    }

  public static class F_gsl_vector_Pointer_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    F_gsl_vector_Pointer_gsl_vector(Pointer p) { super(p); }
      protected F_gsl_vector_Pointer_gsl_vector() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector x, Pointer params, gsl_vector f);
  }
  public native F_gsl_vector_Pointer_gsl_vector f(); public native gsl_multifit_function f(F_gsl_vector_Pointer_gsl_vector f);
  public native @Cast("size_t") long n(); public native gsl_multifit_function n(long n);   /* number of functions */
  public native @Cast("size_t") long p(); public native gsl_multifit_function p(long p);   /* number of independent variables */
  public native Pointer params(); public native gsl_multifit_function params(Pointer params);
}

// #define GSL_MULTIFIT_FN_EVAL(F,x,y) (*((F)->f))(x,(F)->params,(y))

public static class gsl_multifit_fsolver_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_fsolver_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_fsolver_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_fsolver_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_fsolver_type position(long position) {
        return (gsl_multifit_fsolver_type)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native @Cast("size_t") long size(); public native gsl_multifit_fsolver_type size(long size);
    public static class Alloc_Pointer_long_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Alloc_Pointer_long_long(Pointer p) { super(p); }
        protected Alloc_Pointer_long_long() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, @Cast("size_t") long n, @Cast("size_t") long p);
    }
    public native Alloc_Pointer_long_long alloc(); public native gsl_multifit_fsolver_type alloc(Alloc_Pointer_long_long alloc);
    public static class Set_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Set_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector(Pointer p) { super(p); }
        protected Set_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_multifit_function function, gsl_vector x, gsl_vector f, gsl_vector dx);
    }
    public native Set_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector set(); public native gsl_multifit_fsolver_type set(Set_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector set);
    public static class Iterate_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Iterate_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector(Pointer p) { super(p); }
        protected Iterate_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_multifit_function function, gsl_vector x, gsl_vector f, gsl_vector dx);
    }
    public native Iterate_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector iterate(); public native gsl_multifit_fsolver_type iterate(Iterate_Pointer_gsl_multifit_function_gsl_vector_gsl_vector_gsl_vector iterate);
    public static class Free_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Free_Pointer(Pointer p) { super(p); }
        protected Free_Pointer() { allocate(); }
        private native void allocate();
        public native void call(Pointer state);
    }
    public native Free_Pointer free(); public native gsl_multifit_fsolver_type free(Free_Pointer free);
  }

public static class gsl_multifit_fsolver extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_fsolver() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_fsolver(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_fsolver(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_fsolver position(long position) {
        return (gsl_multifit_fsolver)super.position(position);
    }

    @MemberGetter public native @Const gsl_multifit_fsolver_type type();
    public native gsl_multifit_function function(); public native gsl_multifit_fsolver function(gsl_multifit_function function);
    public native gsl_vector x(); public native gsl_multifit_fsolver x(gsl_vector x);
    public native gsl_vector f(); public native gsl_multifit_fsolver f(gsl_vector f);
    public native gsl_vector dx(); public native gsl_multifit_fsolver dx(gsl_vector dx);
    public native Pointer state(); public native gsl_multifit_fsolver state(Pointer state);
  }

public static native gsl_multifit_fsolver gsl_multifit_fsolver_alloc(@Const gsl_multifit_fsolver_type T, 
                            @Cast("size_t") long n, @Cast("size_t") long p);

public static native void gsl_multifit_fsolver_free(gsl_multifit_fsolver s);

public static native int gsl_multifit_fsolver_set(gsl_multifit_fsolver s, 
                              gsl_multifit_function f, 
                              @Const gsl_vector x);

public static native int gsl_multifit_fsolver_iterate(gsl_multifit_fsolver s);

public static native int gsl_multifit_fsolver_driver(gsl_multifit_fsolver s,
                                 @Cast("const size_t") long maxiter,
                                 double epsabs, double epsrel);

public static native @Cast("const char*") BytePointer gsl_multifit_fsolver_name(@Const gsl_multifit_fsolver s);
public static native gsl_vector gsl_multifit_fsolver_position(@Const gsl_multifit_fsolver s);

/* Definition of vector-valued functions and gradient with parameters
   based on gsl_vector */

@Name("gsl_multifit_function_fdf_struct") public static class gsl_multifit_function_fdf extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_function_fdf() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_function_fdf(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_function_fdf(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_function_fdf position(long position) {
        return (gsl_multifit_function_fdf)super.position(position);
    }

  public static class F_gsl_vector_Pointer_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    F_gsl_vector_Pointer_gsl_vector(Pointer p) { super(p); }
      protected F_gsl_vector_Pointer_gsl_vector() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector x, Pointer params, gsl_vector f);
  }
  public native F_gsl_vector_Pointer_gsl_vector f(); public native gsl_multifit_function_fdf f(F_gsl_vector_Pointer_gsl_vector f);
  public static class Df_gsl_vector_Pointer_gsl_matrix extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Df_gsl_vector_Pointer_gsl_matrix(Pointer p) { super(p); }
      protected Df_gsl_vector_Pointer_gsl_matrix() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector x, Pointer params, gsl_matrix df);
  }
  public native Df_gsl_vector_Pointer_gsl_matrix df(); public native gsl_multifit_function_fdf df(Df_gsl_vector_Pointer_gsl_matrix df);
  public static class Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix(Pointer p) { super(p); }
      protected Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector x, Pointer params, gsl_vector f, gsl_matrix df);
  }
  public native Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix fdf(); public native gsl_multifit_function_fdf fdf(Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix fdf);
  public native @Cast("size_t") long n(); public native gsl_multifit_function_fdf n(long n);       /* number of functions */
  public native @Cast("size_t") long p(); public native gsl_multifit_function_fdf p(long p);       /* number of independent variables */
  public native Pointer params(); public native gsl_multifit_function_fdf params(Pointer params);  /* user parameters */
  public native @Cast("size_t") long nevalf(); public native gsl_multifit_function_fdf nevalf(long nevalf);  /* number of function evaluations */
  public native @Cast("size_t") long nevaldf(); public native gsl_multifit_function_fdf nevaldf(long nevaldf); /* number of Jacobian evaluations */
}

public static class gsl_multifit_fdfsolver_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_fdfsolver_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_fdfsolver_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_fdfsolver_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_fdfsolver_type position(long position) {
        return (gsl_multifit_fdfsolver_type)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native @Cast("size_t") long size(); public native gsl_multifit_fdfsolver_type size(long size);
    public static class Alloc_Pointer_long_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Alloc_Pointer_long_long(Pointer p) { super(p); }
        protected Alloc_Pointer_long_long() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, @Cast("size_t") long n, @Cast("size_t") long p);
    }
    public native Alloc_Pointer_long_long alloc(); public native gsl_multifit_fdfsolver_type alloc(Alloc_Pointer_long_long alloc);
    public static class Set_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Set_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector(Pointer p) { super(p); }
        protected Set_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, @Const gsl_vector wts,
                    gsl_multifit_function_fdf fdf, gsl_vector x,
                    gsl_vector f, gsl_vector dx);
    }
    public native Set_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector set(); public native gsl_multifit_fdfsolver_type set(Set_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector set);
    public static class Iterate_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Iterate_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector(Pointer p) { super(p); }
        protected Iterate_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, @Const gsl_vector wts,
                        gsl_multifit_function_fdf fdf, gsl_vector x,
                        gsl_vector f, gsl_vector dx);
    }
    public native Iterate_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector iterate(); public native gsl_multifit_fdfsolver_type iterate(Iterate_Pointer_gsl_vector_gsl_multifit_function_fdf_gsl_vector_gsl_vector_gsl_vector iterate);
    public static class Gradient_Pointer_gsl_vector extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Gradient_Pointer_gsl_vector(Pointer p) { super(p); }
        protected Gradient_Pointer_gsl_vector() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_vector g);
    }
    public native Gradient_Pointer_gsl_vector gradient(); public native gsl_multifit_fdfsolver_type gradient(Gradient_Pointer_gsl_vector gradient);
    public static class Jac_Pointer_gsl_matrix extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Jac_Pointer_gsl_matrix(Pointer p) { super(p); }
        protected Jac_Pointer_gsl_matrix() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_matrix J);
    }
    public native Jac_Pointer_gsl_matrix jac(); public native gsl_multifit_fdfsolver_type jac(Jac_Pointer_gsl_matrix jac);
    public static class Free_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Free_Pointer(Pointer p) { super(p); }
        protected Free_Pointer() { allocate(); }
        private native void allocate();
        public native void call(Pointer state);
    }
    public native Free_Pointer free(); public native gsl_multifit_fdfsolver_type free(Free_Pointer free);
  }

public static class gsl_multifit_fdfsolver extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_fdfsolver() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_fdfsolver(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_fdfsolver(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_fdfsolver position(long position) {
        return (gsl_multifit_fdfsolver)super.position(position);
    }

    @MemberGetter public native @Const gsl_multifit_fdfsolver_type type();
    public native gsl_multifit_function_fdf fdf(); public native gsl_multifit_fdfsolver fdf(gsl_multifit_function_fdf fdf);
    public native gsl_vector x(); public native gsl_multifit_fdfsolver x(gsl_vector x);        /* parameter values x */
    public native gsl_vector f(); public native gsl_multifit_fdfsolver f(gsl_vector f);        /* residual vector f(x) */
    public native gsl_vector dx(); public native gsl_multifit_fdfsolver dx(gsl_vector dx);       /* step dx */
    public native gsl_vector g(); public native gsl_multifit_fdfsolver g(gsl_vector g);        /* gradient J^T f */
    public native gsl_vector sqrt_wts(); public native gsl_multifit_fdfsolver sqrt_wts(gsl_vector sqrt_wts); /* sqrt(wts) */
    public native @Cast("size_t") long niter(); public native gsl_multifit_fdfsolver niter(long niter);          /* number of iterations performed */
    public native Pointer state(); public native gsl_multifit_fdfsolver state(Pointer state);
  }


public static native gsl_multifit_fdfsolver gsl_multifit_fdfsolver_alloc(@Const gsl_multifit_fdfsolver_type T, 
                              @Cast("size_t") long n, @Cast("size_t") long p);

public static native int gsl_multifit_fdfsolver_set(gsl_multifit_fdfsolver s, 
                            gsl_multifit_function_fdf fdf,
                            @Const gsl_vector x);
public static native int gsl_multifit_fdfsolver_wset(gsl_multifit_fdfsolver s, 
                                 gsl_multifit_function_fdf f, 
                                 @Const gsl_vector x,
                                 @Const gsl_vector wts);

public static native int gsl_multifit_fdfsolver_iterate(gsl_multifit_fdfsolver s);

public static native int gsl_multifit_fdfsolver_driver(gsl_multifit_fdfsolver s,
                                   @Cast("const size_t") long maxiter,
                                   double xtol,
                                   double gtol,
                                   double ftol,
                                   IntPointer info);
public static native int gsl_multifit_fdfsolver_driver(gsl_multifit_fdfsolver s,
                                   @Cast("const size_t") long maxiter,
                                   double xtol,
                                   double gtol,
                                   double ftol,
                                   IntBuffer info);
public static native int gsl_multifit_fdfsolver_driver(gsl_multifit_fdfsolver s,
                                   @Cast("const size_t") long maxiter,
                                   double xtol,
                                   double gtol,
                                   double ftol,
                                   int[] info);

public static native int gsl_multifit_fdfsolver_jac(gsl_multifit_fdfsolver s,
                                gsl_matrix J);

public static native void gsl_multifit_fdfsolver_free(gsl_multifit_fdfsolver s);

public static native @Cast("const char*") BytePointer gsl_multifit_fdfsolver_name(@Const gsl_multifit_fdfsolver s);
public static native gsl_vector gsl_multifit_fdfsolver_position(@Const gsl_multifit_fdfsolver s);
public static native gsl_vector gsl_multifit_fdfsolver_residual(@Const gsl_multifit_fdfsolver s);
public static native @Cast("size_t") long gsl_multifit_fdfsolver_niter(@Const gsl_multifit_fdfsolver s);
public static native int gsl_multifit_eval_wf(gsl_multifit_function_fdf fdf,
                         @Const gsl_vector x, @Const gsl_vector wts,
                         gsl_vector y);
public static native int gsl_multifit_eval_wdf(gsl_multifit_function_fdf fdf,
                          @Const gsl_vector x, @Const gsl_vector wts,
                          gsl_matrix dy);

public static native int gsl_multifit_fdfsolver_test(@Const gsl_multifit_fdfsolver s,
                                 double xtol,
                                 double gtol,
                                 double ftol, IntPointer info);
public static native int gsl_multifit_fdfsolver_test(@Const gsl_multifit_fdfsolver s,
                                 double xtol,
                                 double gtol,
                                 double ftol, IntBuffer info);
public static native int gsl_multifit_fdfsolver_test(@Const gsl_multifit_fdfsolver s,
                                 double xtol,
                                 double gtol,
                                 double ftol, int[] info);
public static native int gsl_multifit_test_delta(@Const gsl_vector dx, @Const gsl_vector x, 
                             double epsabs, double epsrel);

public static native int gsl_multifit_test_gradient(@Const gsl_vector g, double epsabs);

public static native int gsl_multifit_fdfsolver_dif_df(@Const gsl_vector x,
                                  @Const gsl_vector wts,
                                  gsl_multifit_function_fdf fdf,
                                  @Const gsl_vector f, gsl_matrix J);


public static class gsl_multifit_fdfridge extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multifit_fdfridge() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multifit_fdfridge(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multifit_fdfridge(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multifit_fdfridge position(long position) {
        return (gsl_multifit_fdfridge)super.position(position);
    }

  public native @Cast("size_t") long n(); public native gsl_multifit_fdfridge n(long n);                         /* number of (original) residuals */
  public native @Cast("size_t") long p(); public native gsl_multifit_fdfridge p(long p);                         /* number of model parameters */
  public native double lambda(); public native gsl_multifit_fdfridge lambda(double lambda);                    /* damping parameter */
  @MemberGetter public native @Const gsl_vector L_diag();         /* diagonal damping matrix or NULL */
  @MemberGetter public native @Const gsl_matrix L();              /* general damping matrix or NULL */
  public native gsl_vector f(); public native gsl_multifit_fdfridge f(gsl_vector f);                    /* function values for finite diff J */
  public native gsl_vector wts(); public native gsl_multifit_fdfridge wts(gsl_vector wts);                  /* weight vector for augmented system */
  public native gsl_multifit_fdfsolver s(); public native gsl_multifit_fdfridge s(gsl_multifit_fdfsolver s);
  public native gsl_multifit_function_fdf fdf(); public native gsl_multifit_fdfridge fdf(gsl_multifit_function_fdf fdf);   /* user defined fdf */
  public native @ByRef gsl_multifit_function_fdf fdftik(); public native gsl_multifit_fdfridge fdftik(gsl_multifit_function_fdf fdftik); /* Tikhonov modified fdf */
}

public static native gsl_multifit_fdfridge gsl_multifit_fdfridge_alloc(@Const gsl_multifit_fdfsolver_type T,
                             @Cast("const size_t") long n, @Cast("const size_t") long p);
public static native void gsl_multifit_fdfridge_free(gsl_multifit_fdfridge work);
public static native @Cast("const char*") BytePointer gsl_multifit_fdfridge_name(@Const gsl_multifit_fdfridge w);
public static native gsl_vector gsl_multifit_fdfridge_position(@Const gsl_multifit_fdfridge w);
public static native gsl_vector gsl_multifit_fdfridge_residual(@Const gsl_multifit_fdfridge w);
public static native @Cast("size_t") long gsl_multifit_fdfridge_niter(@Const gsl_multifit_fdfridge w);
public static native int gsl_multifit_fdfridge_set(gsl_multifit_fdfridge w,
                               gsl_multifit_function_fdf f,
                               @Const gsl_vector x,
                               double lambda);
public static native int gsl_multifit_fdfridge_wset(gsl_multifit_fdfridge w,
                                gsl_multifit_function_fdf f,
                                @Const gsl_vector x,
                                double lambda,
                                @Const gsl_vector wts);
public static native int gsl_multifit_fdfridge_set2(gsl_multifit_fdfridge w,
                                gsl_multifit_function_fdf f,
                                @Const gsl_vector x,
                                @Const gsl_vector lambda);
public static native int gsl_multifit_fdfridge_wset2(gsl_multifit_fdfridge w,
                                 gsl_multifit_function_fdf f,
                                 @Const gsl_vector x,
                                 @Const gsl_vector lambda,
                                 @Const gsl_vector wts);
public static native int gsl_multifit_fdfridge_set3(gsl_multifit_fdfridge w,
                                gsl_multifit_function_fdf f,
                                @Const gsl_vector x,
                                @Const gsl_matrix L);
public static native int gsl_multifit_fdfridge_wset3(gsl_multifit_fdfridge w,
                                 gsl_multifit_function_fdf f,
                                 @Const gsl_vector x,
                                 @Const gsl_matrix L,
                                 @Const gsl_vector wts);
public static native int gsl_multifit_fdfridge_iterate(gsl_multifit_fdfridge w);
public static native int gsl_multifit_fdfridge_driver(gsl_multifit_fdfridge w,
                                  @Cast("const size_t") long maxiter,
                                  double xtol,
                                  double gtol,
                                  double ftol,
                                  IntPointer info);
public static native int gsl_multifit_fdfridge_driver(gsl_multifit_fdfridge w,
                                  @Cast("const size_t") long maxiter,
                                  double xtol,
                                  double gtol,
                                  double ftol,
                                  IntBuffer info);
public static native int gsl_multifit_fdfridge_driver(gsl_multifit_fdfridge w,
                                  @Cast("const size_t") long maxiter,
                                  double xtol,
                                  double gtol,
                                  double ftol,
                                  int[] info);

/* extern const gsl_multifit_fsolver_type * gsl_multifit_fsolver_gradient; */

@MemberGetter public static native @Const gsl_multifit_fdfsolver_type gsl_multifit_fdfsolver_lmsder();
@MemberGetter public static native @Const gsl_multifit_fdfsolver_type gsl_multifit_fdfsolver_lmder();
@MemberGetter public static native @Const gsl_multifit_fdfsolver_type gsl_multifit_fdfsolver_lmniel();

// #endif /* __GSL_MULTIFIT_NLIN_H__ */


// Parsed from gsl/gsl_multimin.h

/* multimin/gsl_multimin.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Fabrice Rossi
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Modified by Tuomo Keskitalo to include fminimizer and 
   Nelder Mead related lines */

// #ifndef __GSL_MULTIMIN_H__
// #define __GSL_MULTIMIN_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_math.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>
// #include <gsl/gsl_min.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* Definition of an arbitrary real-valued function with gsl_vector input and */
/* parameters */
@Name("gsl_multimin_function_struct") public static class gsl_multimin_function extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multimin_function() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multimin_function(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multimin_function(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multimin_function position(long position) {
        return (gsl_multimin_function)super.position(position);
    }

  public static class F_gsl_vector_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    F_gsl_vector_Pointer(Pointer p) { super(p); }
      protected F_gsl_vector_Pointer() { allocate(); }
      private native void allocate();
      public native double call(@Const gsl_vector x, Pointer params);
  }
  public native F_gsl_vector_Pointer f(); public native gsl_multimin_function f(F_gsl_vector_Pointer f);
  public native @Cast("size_t") long n(); public native gsl_multimin_function n(long n);
  public native Pointer params(); public native gsl_multimin_function params(Pointer params);
}

// #define GSL_MULTIMIN_FN_EVAL(F,x) (*((F)->f))(x,(F)->params)

/* Definition of an arbitrary differentiable real-valued function */
/* with gsl_vector input and parameters */
@Name("gsl_multimin_function_fdf_struct") public static class gsl_multimin_function_fdf extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multimin_function_fdf() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multimin_function_fdf(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multimin_function_fdf(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multimin_function_fdf position(long position) {
        return (gsl_multimin_function_fdf)super.position(position);
    }

  public static class F_gsl_vector_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    F_gsl_vector_Pointer(Pointer p) { super(p); }
      protected F_gsl_vector_Pointer() { allocate(); }
      private native void allocate();
      public native double call(@Const gsl_vector x, Pointer params);
  }
  public native F_gsl_vector_Pointer f(); public native gsl_multimin_function_fdf f(F_gsl_vector_Pointer f);
  public static class Df_gsl_vector_Pointer_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Df_gsl_vector_Pointer_gsl_vector(Pointer p) { super(p); }
      protected Df_gsl_vector_Pointer_gsl_vector() { allocate(); }
      private native void allocate();
      public native void call(@Const gsl_vector x, Pointer params,gsl_vector df);
  }
  public native Df_gsl_vector_Pointer_gsl_vector df(); public native gsl_multimin_function_fdf df(Df_gsl_vector_Pointer_gsl_vector df);
  public static class Fdf_gsl_vector_Pointer_DoublePointer_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Fdf_gsl_vector_Pointer_DoublePointer_gsl_vector(Pointer p) { super(p); }
      protected Fdf_gsl_vector_Pointer_DoublePointer_gsl_vector() { allocate(); }
      private native void allocate();
      public native void call(@Const gsl_vector x, Pointer params,DoublePointer f,gsl_vector df);
  }
  public native Fdf_gsl_vector_Pointer_DoublePointer_gsl_vector fdf(); public native gsl_multimin_function_fdf fdf(Fdf_gsl_vector_Pointer_DoublePointer_gsl_vector fdf);
  public native @Cast("size_t") long n(); public native gsl_multimin_function_fdf n(long n);
  public native Pointer params(); public native gsl_multimin_function_fdf params(Pointer params);
}

// #define GSL_MULTIMIN_FN_EVAL_F(F,x) (*((F)->f))(x,(F)->params)
// #define GSL_MULTIMIN_FN_EVAL_DF(F,x,g) (*((F)->df))(x,(F)->params,(g))
// #define GSL_MULTIMIN_FN_EVAL_F_DF(F,x,y,g) (*((F)->fdf))(x,(F)->params,(y),(g))

public static native int gsl_multimin_diff(@Const gsl_multimin_function f,
                       @Const gsl_vector x, gsl_vector g);

/* minimization of non-differentiable functions */

public static class gsl_multimin_fminimizer_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multimin_fminimizer_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multimin_fminimizer_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multimin_fminimizer_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multimin_fminimizer_type position(long position) {
        return (gsl_multimin_fminimizer_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public native @Cast("size_t") long size(); public native gsl_multimin_fminimizer_type size(long size);
  public static class Alloc_Pointer_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Alloc_Pointer_long(Pointer p) { super(p); }
      protected Alloc_Pointer_long() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("size_t") long n);
  }
  public native Alloc_Pointer_long alloc(); public native gsl_multimin_fminimizer_type alloc(Alloc_Pointer_long alloc);
  public static class Set_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Set_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_gsl_vector(Pointer p) { super(p); }
      protected Set_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_gsl_vector() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, gsl_multimin_function f,
                @Const gsl_vector x, 
                DoublePointer size,
                @Const gsl_vector step_size);
  }
  public native Set_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_gsl_vector set(); public native gsl_multimin_fminimizer_type set(Set_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_gsl_vector set);
  public static class Iterate_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Iterate_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_DoublePointer(Pointer p) { super(p); }
      protected Iterate_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_DoublePointer() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, gsl_multimin_function f, 
                    gsl_vector x, 
                    DoublePointer size,
                    DoublePointer fval);
  }
  public native Iterate_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_DoublePointer iterate(); public native gsl_multimin_fminimizer_type iterate(Iterate_Pointer_gsl_multimin_function_gsl_vector_DoublePointer_DoublePointer iterate);
  public static class Free_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Free_Pointer(Pointer p) { super(p); }
      protected Free_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer state);
  }
  public native Free_Pointer free(); public native gsl_multimin_fminimizer_type free(Free_Pointer free);
}

public static class gsl_multimin_fminimizer extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multimin_fminimizer() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multimin_fminimizer(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multimin_fminimizer(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multimin_fminimizer position(long position) {
        return (gsl_multimin_fminimizer)super.position(position);
    }

  /* multi dimensional part */
  @MemberGetter public native @Const gsl_multimin_fminimizer_type type();
  public native gsl_multimin_function f(); public native gsl_multimin_fminimizer f(gsl_multimin_function f);

  public native double fval(); public native gsl_multimin_fminimizer fval(double fval);
  public native gsl_vector x(); public native gsl_multimin_fminimizer x(gsl_vector x);
  
  public native double size(); public native gsl_multimin_fminimizer size(double size);

  public native Pointer state(); public native gsl_multimin_fminimizer state(Pointer state);
}

public static native gsl_multimin_fminimizer gsl_multimin_fminimizer_alloc(@Const gsl_multimin_fminimizer_type T,
                              @Cast("size_t") long n);

public static native int gsl_multimin_fminimizer_set(gsl_multimin_fminimizer s,
                             gsl_multimin_function f,
                             @Const gsl_vector x,
                             @Const gsl_vector step_size);

public static native void gsl_multimin_fminimizer_free(gsl_multimin_fminimizer s);

public static native @Cast("const char*") BytePointer gsl_multimin_fminimizer_name(@Const gsl_multimin_fminimizer s);

public static native int gsl_multimin_fminimizer_iterate(gsl_multimin_fminimizer s);

public static native gsl_vector gsl_multimin_fminimizer_x(@Const gsl_multimin_fminimizer s);

public static native double gsl_multimin_fminimizer_minimum(@Const gsl_multimin_fminimizer s);

public static native double gsl_multimin_fminimizer_size(@Const gsl_multimin_fminimizer s);

/* Convergence test functions */

public static native int gsl_multimin_test_gradient(@Const gsl_vector g, double epsabs);

public static native int gsl_multimin_test_size(double size, double epsabs);

/* minimisation of differentiable functions */

public static class gsl_multimin_fdfminimizer_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multimin_fdfminimizer_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multimin_fdfminimizer_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multimin_fdfminimizer_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multimin_fdfminimizer_type position(long position) {
        return (gsl_multimin_fdfminimizer_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public native @Cast("size_t") long size(); public native gsl_multimin_fdfminimizer_type size(long size);
  public static class Alloc_Pointer_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Alloc_Pointer_long(Pointer p) { super(p); }
      protected Alloc_Pointer_long() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("size_t") long n);
  }
  public native Alloc_Pointer_long alloc(); public native gsl_multimin_fdfminimizer_type alloc(Alloc_Pointer_long alloc);
  public static class Set_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_double_double extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Set_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_double_double(Pointer p) { super(p); }
      protected Set_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_double_double() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, gsl_multimin_function_fdf fdf,
                @Const gsl_vector x, DoublePointer f, 
                gsl_vector gradient, double step_size, double tol);
  }
  public native Set_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_double_double set(); public native gsl_multimin_fdfminimizer_type set(Set_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_double_double set);
  public static class Iterate_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Iterate_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_gsl_vector(Pointer p) { super(p); }
      protected Iterate_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_gsl_vector() { allocate(); }
      private native void allocate();
      public native int call(Pointer state,gsl_multimin_function_fdf fdf, 
                    gsl_vector x, DoublePointer f, 
                    gsl_vector gradient, gsl_vector dx);
  }
  public native Iterate_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_gsl_vector iterate(); public native gsl_multimin_fdfminimizer_type iterate(Iterate_Pointer_gsl_multimin_function_fdf_gsl_vector_DoublePointer_gsl_vector_gsl_vector iterate);
  public static class Restart_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Restart_Pointer(Pointer p) { super(p); }
      protected Restart_Pointer() { allocate(); }
      private native void allocate();
      public native int call(Pointer state);
  }
  public native Restart_Pointer restart(); public native gsl_multimin_fdfminimizer_type restart(Restart_Pointer restart);
  public static class Free_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Free_Pointer(Pointer p) { super(p); }
      protected Free_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer state);
  }
  public native Free_Pointer free(); public native gsl_multimin_fdfminimizer_type free(Free_Pointer free);
}

public static class gsl_multimin_fdfminimizer extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multimin_fdfminimizer() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multimin_fdfminimizer(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multimin_fdfminimizer(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multimin_fdfminimizer position(long position) {
        return (gsl_multimin_fdfminimizer)super.position(position);
    }

  /* multi dimensional part */
  @MemberGetter public native @Const gsl_multimin_fdfminimizer_type type();
  public native gsl_multimin_function_fdf fdf(); public native gsl_multimin_fdfminimizer fdf(gsl_multimin_function_fdf fdf);

  public native double f(); public native gsl_multimin_fdfminimizer f(double f);
  public native gsl_vector x(); public native gsl_multimin_fdfminimizer x(gsl_vector x);
  public native gsl_vector gradient(); public native gsl_multimin_fdfminimizer gradient(gsl_vector gradient);
  public native gsl_vector dx(); public native gsl_multimin_fdfminimizer dx(gsl_vector dx);

  public native Pointer state(); public native gsl_multimin_fdfminimizer state(Pointer state);
}

public static native gsl_multimin_fdfminimizer gsl_multimin_fdfminimizer_alloc(@Const gsl_multimin_fdfminimizer_type T,
                                @Cast("size_t") long n);

public static native int gsl_multimin_fdfminimizer_set(gsl_multimin_fdfminimizer s,
                               gsl_multimin_function_fdf fdf,
                               @Const gsl_vector x,
                               double step_size, double tol);

public static native void gsl_multimin_fdfminimizer_free(gsl_multimin_fdfminimizer s);

public static native @Cast("const char*") BytePointer gsl_multimin_fdfminimizer_name(@Const gsl_multimin_fdfminimizer s);

public static native int gsl_multimin_fdfminimizer_iterate(gsl_multimin_fdfminimizer s);

public static native int gsl_multimin_fdfminimizer_restart(gsl_multimin_fdfminimizer s);

public static native gsl_vector gsl_multimin_fdfminimizer_x(@Const gsl_multimin_fdfminimizer s);

public static native gsl_vector gsl_multimin_fdfminimizer_dx(@Const gsl_multimin_fdfminimizer s);

public static native gsl_vector gsl_multimin_fdfminimizer_gradient(@Const gsl_multimin_fdfminimizer s);

public static native double gsl_multimin_fdfminimizer_minimum(@Const gsl_multimin_fdfminimizer s);

@MemberGetter public static native @Const gsl_multimin_fdfminimizer_type gsl_multimin_fdfminimizer_steepest_descent();
@MemberGetter public static native @Const gsl_multimin_fdfminimizer_type gsl_multimin_fdfminimizer_conjugate_pr();
@MemberGetter public static native @Const gsl_multimin_fdfminimizer_type gsl_multimin_fdfminimizer_conjugate_fr();
@MemberGetter public static native @Const gsl_multimin_fdfminimizer_type gsl_multimin_fdfminimizer_vector_bfgs();
@MemberGetter public static native @Const gsl_multimin_fdfminimizer_type gsl_multimin_fdfminimizer_vector_bfgs2();
@MemberGetter public static native @Const gsl_multimin_fminimizer_type gsl_multimin_fminimizer_nmsimplex();
@MemberGetter public static native @Const gsl_multimin_fminimizer_type gsl_multimin_fminimizer_nmsimplex2();
@MemberGetter public static native @Const gsl_multimin_fminimizer_type gsl_multimin_fminimizer_nmsimplex2rand();

// #endif /* __GSL_MULTIMIN_H__ */


// Parsed from gsl/gsl_multiroots.h

/* multiroots/gsl_multiroots.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MULTIROOTS_H__
// #define __GSL_MULTIROOTS_H__

// #include <stdlib.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_math.h>
// #include <gsl/gsl_vector.h>
// #include <gsl/gsl_matrix.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* Definition of vector-valued functions with parameters based on gsl_vector */

@Name("gsl_multiroot_function_struct") public static class gsl_multiroot_function extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multiroot_function() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multiroot_function(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multiroot_function(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multiroot_function position(long position) {
        return (gsl_multiroot_function)super.position(position);
    }

  public static class F_gsl_vector_Pointer_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    F_gsl_vector_Pointer_gsl_vector(Pointer p) { super(p); }
      protected F_gsl_vector_Pointer_gsl_vector() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector x, Pointer params, gsl_vector f);
  }
  public native F_gsl_vector_Pointer_gsl_vector f(); public native gsl_multiroot_function f(F_gsl_vector_Pointer_gsl_vector f);
  public native @Cast("size_t") long n(); public native gsl_multiroot_function n(long n);
  public native Pointer params(); public native gsl_multiroot_function params(Pointer params);
}

// #define GSL_MULTIROOT_FN_EVAL(F,x,y) (*((F)->f))(x,(F)->params,(y))

public static native int gsl_multiroot_fdjacobian(gsl_multiroot_function F,
                              @Const gsl_vector x, @Const gsl_vector f,
                              double epsrel, gsl_matrix jacobian);


public static class gsl_multiroot_fsolver_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multiroot_fsolver_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multiroot_fsolver_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multiroot_fsolver_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multiroot_fsolver_type position(long position) {
        return (gsl_multiroot_fsolver_type)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native @Cast("size_t") long size(); public native gsl_multiroot_fsolver_type size(long size);
    public static class Alloc_Pointer_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Alloc_Pointer_long(Pointer p) { super(p); }
        protected Alloc_Pointer_long() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, @Cast("size_t") long n);
    }
    public native Alloc_Pointer_long alloc(); public native gsl_multiroot_fsolver_type alloc(Alloc_Pointer_long alloc);
    public static class Set_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Set_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector(Pointer p) { super(p); }
        protected Set_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_multiroot_function function, gsl_vector x, gsl_vector f, gsl_vector dx);
    }
    public native Set_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector set(); public native gsl_multiroot_fsolver_type set(Set_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector set);
    public static class Iterate_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Iterate_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector(Pointer p) { super(p); }
        protected Iterate_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_multiroot_function function, gsl_vector x, gsl_vector f, gsl_vector dx);
    }
    public native Iterate_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector iterate(); public native gsl_multiroot_fsolver_type iterate(Iterate_Pointer_gsl_multiroot_function_gsl_vector_gsl_vector_gsl_vector iterate);
    public static class Free_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Free_Pointer(Pointer p) { super(p); }
        protected Free_Pointer() { allocate(); }
        private native void allocate();
        public native void call(Pointer state);
    }
    public native Free_Pointer free(); public native gsl_multiroot_fsolver_type free(Free_Pointer free);
  }

public static class gsl_multiroot_fsolver extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multiroot_fsolver() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multiroot_fsolver(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multiroot_fsolver(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multiroot_fsolver position(long position) {
        return (gsl_multiroot_fsolver)super.position(position);
    }

    @MemberGetter public native @Const gsl_multiroot_fsolver_type type();
    public native gsl_multiroot_function function(); public native gsl_multiroot_fsolver function(gsl_multiroot_function function);
    public native gsl_vector x(); public native gsl_multiroot_fsolver x(gsl_vector x);
    public native gsl_vector f(); public native gsl_multiroot_fsolver f(gsl_vector f);
    public native gsl_vector dx(); public native gsl_multiroot_fsolver dx(gsl_vector dx);
    public native Pointer state(); public native gsl_multiroot_fsolver state(Pointer state);
  }

public static native gsl_multiroot_fsolver gsl_multiroot_fsolver_alloc(@Const gsl_multiroot_fsolver_type T, 
                                     @Cast("size_t") long n); 

public static native void gsl_multiroot_fsolver_free(gsl_multiroot_fsolver s);

public static native int gsl_multiroot_fsolver_set(gsl_multiroot_fsolver s, 
                               gsl_multiroot_function f, 
                               @Const gsl_vector x);

public static native int gsl_multiroot_fsolver_iterate(gsl_multiroot_fsolver s);

public static native @Cast("const char*") BytePointer gsl_multiroot_fsolver_name(@Const gsl_multiroot_fsolver s);
public static native gsl_vector gsl_multiroot_fsolver_root(@Const gsl_multiroot_fsolver s);
public static native gsl_vector gsl_multiroot_fsolver_dx(@Const gsl_multiroot_fsolver s);
public static native gsl_vector gsl_multiroot_fsolver_f(@Const gsl_multiroot_fsolver s);

/* Definition of vector-valued functions and gradient with parameters
   based on gsl_vector */

@Name("gsl_multiroot_function_fdf_struct") public static class gsl_multiroot_function_fdf extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multiroot_function_fdf() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multiroot_function_fdf(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multiroot_function_fdf(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multiroot_function_fdf position(long position) {
        return (gsl_multiroot_function_fdf)super.position(position);
    }

  public static class F_gsl_vector_Pointer_gsl_vector extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    F_gsl_vector_Pointer_gsl_vector(Pointer p) { super(p); }
      protected F_gsl_vector_Pointer_gsl_vector() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector x, Pointer params, gsl_vector f);
  }
  public native F_gsl_vector_Pointer_gsl_vector f(); public native gsl_multiroot_function_fdf f(F_gsl_vector_Pointer_gsl_vector f);
  public static class Df_gsl_vector_Pointer_gsl_matrix extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Df_gsl_vector_Pointer_gsl_matrix(Pointer p) { super(p); }
      protected Df_gsl_vector_Pointer_gsl_matrix() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector x, Pointer params, gsl_matrix df);
  }
  public native Df_gsl_vector_Pointer_gsl_matrix df(); public native gsl_multiroot_function_fdf df(Df_gsl_vector_Pointer_gsl_matrix df);
  public static class Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix(Pointer p) { super(p); }
      protected Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix() { allocate(); }
      private native void allocate();
      public native int call(@Const gsl_vector x, Pointer params, gsl_vector f, gsl_matrix df);
  }
  public native Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix fdf(); public native gsl_multiroot_function_fdf fdf(Fdf_gsl_vector_Pointer_gsl_vector_gsl_matrix fdf);
  public native @Cast("size_t") long n(); public native gsl_multiroot_function_fdf n(long n);
  public native Pointer params(); public native gsl_multiroot_function_fdf params(Pointer params);
}

// #define GSL_MULTIROOT_FN_EVAL_F(F,x,y) ((*((F)->f))(x,(F)->params,(y)))
// #define GSL_MULTIROOT_FN_EVAL_DF(F,x,dy) ((*((F)->df))(x,(F)->params,(dy)))
// #define GSL_MULTIROOT_FN_EVAL_F_DF(F,x,y,dy) ((*((F)->fdf))(x,(F)->params,(y),(dy)))

public static class gsl_multiroot_fdfsolver_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multiroot_fdfsolver_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multiroot_fdfsolver_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multiroot_fdfsolver_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multiroot_fdfsolver_type position(long position) {
        return (gsl_multiroot_fdfsolver_type)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native @Cast("size_t") long size(); public native gsl_multiroot_fdfsolver_type size(long size);
    public static class Alloc_Pointer_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Alloc_Pointer_long(Pointer p) { super(p); }
        protected Alloc_Pointer_long() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, @Cast("size_t") long n);
    }
    public native Alloc_Pointer_long alloc(); public native gsl_multiroot_fdfsolver_type alloc(Alloc_Pointer_long alloc);
    public static class Set_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Set_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector(Pointer p) { super(p); }
        protected Set_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_multiroot_function_fdf fdf, gsl_vector x, gsl_vector f, gsl_matrix J, gsl_vector dx);
    }
    public native Set_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector set(); public native gsl_multiroot_fdfsolver_type set(Set_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector set);
    public static class Iterate_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Iterate_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector(Pointer p) { super(p); }
        protected Iterate_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector() { allocate(); }
        private native void allocate();
        public native int call(Pointer state, gsl_multiroot_function_fdf fdf, gsl_vector x, gsl_vector f, gsl_matrix J, gsl_vector dx);
    }
    public native Iterate_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector iterate(); public native gsl_multiroot_fdfsolver_type iterate(Iterate_Pointer_gsl_multiroot_function_fdf_gsl_vector_gsl_vector_gsl_matrix_gsl_vector iterate);
    public static class Free_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Free_Pointer(Pointer p) { super(p); }
        protected Free_Pointer() { allocate(); }
        private native void allocate();
        public native void call(Pointer state);
    }
    public native Free_Pointer free(); public native gsl_multiroot_fdfsolver_type free(Free_Pointer free);
  }

public static class gsl_multiroot_fdfsolver extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multiroot_fdfsolver() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multiroot_fdfsolver(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multiroot_fdfsolver(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multiroot_fdfsolver position(long position) {
        return (gsl_multiroot_fdfsolver)super.position(position);
    }

    @MemberGetter public native @Const gsl_multiroot_fdfsolver_type type();
    public native gsl_multiroot_function_fdf fdf(); public native gsl_multiroot_fdfsolver fdf(gsl_multiroot_function_fdf fdf);
    public native gsl_vector x(); public native gsl_multiroot_fdfsolver x(gsl_vector x);
    public native gsl_vector f(); public native gsl_multiroot_fdfsolver f(gsl_vector f);
    public native gsl_matrix J(); public native gsl_multiroot_fdfsolver J(gsl_matrix J);
    public native gsl_vector dx(); public native gsl_multiroot_fdfsolver dx(gsl_vector dx);
    public native Pointer state(); public native gsl_multiroot_fdfsolver state(Pointer state);
  }

public static native gsl_multiroot_fdfsolver gsl_multiroot_fdfsolver_alloc(@Const gsl_multiroot_fdfsolver_type T,
                                      @Cast("size_t") long n);

public static native int gsl_multiroot_fdfsolver_set(gsl_multiroot_fdfsolver s, 
                             gsl_multiroot_function_fdf fdf,
                             @Const gsl_vector x);

public static native int gsl_multiroot_fdfsolver_iterate(gsl_multiroot_fdfsolver s);

public static native void gsl_multiroot_fdfsolver_free(gsl_multiroot_fdfsolver s);

public static native @Cast("const char*") BytePointer gsl_multiroot_fdfsolver_name(@Const gsl_multiroot_fdfsolver s);
public static native gsl_vector gsl_multiroot_fdfsolver_root(@Const gsl_multiroot_fdfsolver s);
public static native gsl_vector gsl_multiroot_fdfsolver_dx(@Const gsl_multiroot_fdfsolver s);
public static native gsl_vector gsl_multiroot_fdfsolver_f(@Const gsl_multiroot_fdfsolver s);

public static native int gsl_multiroot_test_delta(@Const gsl_vector dx, @Const gsl_vector x, 
                              double epsabs, double epsrel);

public static native int gsl_multiroot_test_residual(@Const gsl_vector f, double epsabs);

@MemberGetter public static native @Const gsl_multiroot_fsolver_type gsl_multiroot_fsolver_dnewton();
@MemberGetter public static native @Const gsl_multiroot_fsolver_type gsl_multiroot_fsolver_broyden();
@MemberGetter public static native @Const gsl_multiroot_fsolver_type gsl_multiroot_fsolver_hybrid();
@MemberGetter public static native @Const gsl_multiroot_fsolver_type gsl_multiroot_fsolver_hybrids();

@MemberGetter public static native @Const gsl_multiroot_fdfsolver_type gsl_multiroot_fdfsolver_newton();
@MemberGetter public static native @Const gsl_multiroot_fdfsolver_type gsl_multiroot_fdfsolver_gnewton();
@MemberGetter public static native @Const gsl_multiroot_fdfsolver_type gsl_multiroot_fdfsolver_hybridj();
@MemberGetter public static native @Const gsl_multiroot_fdfsolver_type gsl_multiroot_fdfsolver_hybridsj();

// #endif /* __GSL_MULTIROOTS_H__ */


// Parsed from gsl/gsl_multiset.h

/* multiset/gsl_multiset.h
 * based on combination/gsl_combination.h by Szymon Jaroszewicz
 * based on permutation/gsl_permutation.h by Brian Gough
 *
 * Copyright (C) 2009 Rhys Ulerich
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_MULTISET_H__
// #define __GSL_MULTISET_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_types.h>
// #include <gsl/gsl_inline.h>
// #include <gsl/gsl_check_range.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_multiset_struct") public static class gsl_multiset extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_multiset() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_multiset(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_multiset(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_multiset position(long position) {
        return (gsl_multiset)super.position(position);
    }

  public native @Cast("size_t") long n(); public native gsl_multiset n(long n);
  public native @Cast("size_t") long k(); public native gsl_multiset k(long k);
  public native @Cast("size_t*") SizeTPointer data(); public native gsl_multiset data(SizeTPointer data);
}

public static native gsl_multiset gsl_multiset_alloc(@Cast("const size_t") long n, @Cast("const size_t") long k);
public static native gsl_multiset gsl_multiset_calloc(@Cast("const size_t") long n, @Cast("const size_t") long k);
public static native void gsl_multiset_init_first(gsl_multiset c);
public static native void gsl_multiset_init_last(gsl_multiset c);
public static native void gsl_multiset_free(gsl_multiset c);
public static native int gsl_multiset_memcpy(gsl_multiset dest, @Const gsl_multiset src);

public static native int gsl_multiset_fread(@Cast("FILE*") Pointer stream, gsl_multiset c);
public static native int gsl_multiset_fwrite(@Cast("FILE*") Pointer stream, @Const gsl_multiset c);
public static native int gsl_multiset_fscanf(@Cast("FILE*") Pointer stream, gsl_multiset c);
public static native int gsl_multiset_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_multiset c, @Cast("const char*") BytePointer format);
public static native int gsl_multiset_fprintf(@Cast("FILE*") Pointer stream, @Const gsl_multiset c, String format);

public static native @Cast("size_t") long gsl_multiset_n(@Const gsl_multiset c);
public static native @Cast("size_t") long gsl_multiset_k(@Const gsl_multiset c);
public static native @Cast("size_t*") SizeTPointer gsl_multiset_data(@Const gsl_multiset c);

public static native int gsl_multiset_valid(gsl_multiset c);
public static native int gsl_multiset_next(gsl_multiset c);
public static native int gsl_multiset_prev(gsl_multiset c);

/* */ public static native @Cast("size_t") long gsl_multiset_get(@Const gsl_multiset c, @Cast("const size_t") long i);

// #ifdef HAVE_INLINE

// #endif /* HAVE_INLINE */

// #endif /* __GSL_MULTISET_H__ */


// Parsed from gsl/gsl_ntuple.h

/* histogram/ntuple.h
 * 
 * Copyright (C) 2000 Simone Piccardi
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 */

/* Jan/2001 Modified by Brian Gough. Minor changes for GSL */

// #ifndef __GSL_NTUPLE_H__
// #define __GSL_NTUPLE_H__

// #include <stdlib.h>
// #include <stdio.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_histogram.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static class gsl_ntuple extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_ntuple() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_ntuple(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_ntuple(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_ntuple position(long position) {
        return (gsl_ntuple)super.position(position);
    }

    public native @Cast("FILE*") Pointer file(); public native gsl_ntuple file(Pointer file);
    public native Pointer ntuple_data(); public native gsl_ntuple ntuple_data(Pointer ntuple_data);
    public native @Cast("size_t") long size(); public native gsl_ntuple size(long size);
}

public static class gsl_ntuple_select_fn extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_ntuple_select_fn() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_ntuple_select_fn(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_ntuple_select_fn(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_ntuple_select_fn position(long position) {
        return (gsl_ntuple_select_fn)super.position(position);
    }

  public static class Function_Pointer_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Function_Pointer_Pointer(Pointer p) { super(p); }
      protected Function_Pointer_Pointer() { allocate(); }
      private native void allocate();
      public native int call(Pointer ntuple_data, Pointer params);
  }
  public native Function_Pointer_Pointer function(); public native gsl_ntuple_select_fn function(Function_Pointer_Pointer function);
  public native Pointer params(); public native gsl_ntuple_select_fn params(Pointer params);
}

public static class gsl_ntuple_value_fn extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_ntuple_value_fn() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_ntuple_value_fn(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_ntuple_value_fn(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_ntuple_value_fn position(long position) {
        return (gsl_ntuple_value_fn)super.position(position);
    }

  public static class Function_Pointer_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Function_Pointer_Pointer(Pointer p) { super(p); }
      protected Function_Pointer_Pointer() { allocate(); }
      private native void allocate();
      public native double call(Pointer ntuple_data, Pointer params);
  }
  public native Function_Pointer_Pointer function(); public native gsl_ntuple_value_fn function(Function_Pointer_Pointer function);
  public native Pointer params(); public native gsl_ntuple_value_fn params(Pointer params);
}

public static native gsl_ntuple gsl_ntuple_open(@Cast("char*") BytePointer filename, Pointer ntuple_data, @Cast("size_t") long size);
public static native gsl_ntuple gsl_ntuple_open(@Cast("char*") ByteBuffer filename, Pointer ntuple_data, @Cast("size_t") long size);
public static native gsl_ntuple gsl_ntuple_open(@Cast("char*") byte[] filename, Pointer ntuple_data, @Cast("size_t") long size);

public static native gsl_ntuple gsl_ntuple_create(@Cast("char*") BytePointer filename, Pointer ntuple_data, @Cast("size_t") long size);
public static native gsl_ntuple gsl_ntuple_create(@Cast("char*") ByteBuffer filename, Pointer ntuple_data, @Cast("size_t") long size);
public static native gsl_ntuple gsl_ntuple_create(@Cast("char*") byte[] filename, Pointer ntuple_data, @Cast("size_t") long size);

public static native int gsl_ntuple_write(gsl_ntuple ntuple);
public static native int gsl_ntuple_read(gsl_ntuple ntuple);

public static native int gsl_ntuple_bookdata(gsl_ntuple ntuple);  /* synonym for write */

public static native int gsl_ntuple_project(gsl_histogram h, gsl_ntuple ntuple, 
                        gsl_ntuple_value_fn value_func,
                        gsl_ntuple_select_fn select_func);

public static native int gsl_ntuple_close(gsl_ntuple ntuple);

// #endif /* __GSL_NTUPLE_H__ */






// Parsed from gsl/gsl_odeiv2.h

/* ode-initval/odeiv2.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */
/* Modified by Tuomo Keskitalo */

// #ifndef __GSL_ODEIV2_H__
// #define __GSL_ODEIV2_H__

// #include <stdio.h>
// #include <stdlib.h>
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif
/* Description of a system of ODEs.
 *
 * y' = f(t,y) = dydt(t, y)
 *
 * The system is specified by giving the right-hand-side
 * of the equation and possibly a jacobian function.
 *
 * Some methods require the jacobian function, which calculates
 * the matrix dfdy and the vector dfdt. The matrix dfdy conforms
 * to the GSL standard, being a continuous range of floating point
 * values, in row-order.
 *
 * As with GSL function objects, user-supplied parameter
 * data is also present. 
 */
  public static class gsl_odeiv2_system extends Pointer {
      static { Loader.load(); }
      /** Default native constructor. */
      public gsl_odeiv2_system() { super((Pointer)null); allocate(); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public gsl_odeiv2_system(long size) { super((Pointer)null); allocateArray(size); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public gsl_odeiv2_system(Pointer p) { super(p); }
      private native void allocate();
      private native void allocateArray(long size);
      @Override public gsl_odeiv2_system position(long position) {
          return (gsl_odeiv2_system)super.position(position);
      }
  
  public static class Function_double_DoublePointer_DoublePointer_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Function_double_DoublePointer_DoublePointer_Pointer(Pointer p) { super(p); }
      protected Function_double_DoublePointer_DoublePointer_Pointer() { allocate(); }
      private native void allocate();
      public native int call(double t, @Const DoublePointer y, DoublePointer dydt, Pointer params);
  }
  public native Function_double_DoublePointer_DoublePointer_Pointer function(); public native gsl_odeiv2_system function(Function_double_DoublePointer_DoublePointer_Pointer function);
  public static class Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer(Pointer p) { super(p); }
      protected Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer() { allocate(); }
      private native void allocate();
      public native int call(double t, @Const DoublePointer y, DoublePointer dfdy, DoublePointer dfdt,
                     Pointer params);
  }
  public native Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer jacobian(); public native gsl_odeiv2_system jacobian(Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer jacobian);
  public native @Cast("size_t") long dimension(); public native gsl_odeiv2_system dimension(long dimension);
  public native Pointer params(); public native gsl_odeiv2_system params(Pointer params);
}

/* Function evaluation macros */

// #define GSL_ODEIV_FN_EVAL(S,t,y,f)  (*((S)->function))(t,y,f,(S)->params)
// #define GSL_ODEIV_JA_EVAL(S,t,y,dfdy,dfdt)  (*((S)->jacobian))(t,y,dfdy,dfdt,(S)->params)

/* Type definitions */

/* Stepper object
 *
 * Opaque object for stepping an ODE system from t to t+h.
 * In general the object has some state which facilitates
 * iterating the stepping operation.
 */

public static class gsl_odeiv2_step_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv2_step_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv2_step_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv2_step_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv2_step_type position(long position) {
        return (gsl_odeiv2_step_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public native int can_use_dydt_in(); public native gsl_odeiv2_step_type can_use_dydt_in(int can_use_dydt_in);
  public native int gives_exact_dydt_out(); public native gsl_odeiv2_step_type gives_exact_dydt_out(int gives_exact_dydt_out);
  public static class Alloc_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Alloc_long(Pointer p) { super(p); }
      protected Alloc_long() { allocate(); }
      private native void allocate();
      public native Pointer call(@Cast("size_t") long dim);
  }
  public native Alloc_long alloc(); public native gsl_odeiv2_step_type alloc(Alloc_long alloc);
  public static class Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv2_system extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv2_system(Pointer p) { super(p); }
      protected Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv2_system() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("size_t") long dim, double t, double h, DoublePointer y,
                  DoublePointer yerr, @Const DoublePointer dydt_in, DoublePointer dydt_out,
                  @Const gsl_odeiv2_system dydt);
  }
  public native Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv2_system apply(); public native gsl_odeiv2_step_type apply(Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv2_system apply);
  public static class Set_driver_Pointer_gsl_odeiv2_driver extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Set_driver_Pointer_gsl_odeiv2_driver(Pointer p) { super(p); }
      protected Set_driver_Pointer_gsl_odeiv2_driver() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Const gsl_odeiv2_driver d);
  }
  public native Set_driver_Pointer_gsl_odeiv2_driver set_driver(); public native gsl_odeiv2_step_type set_driver(Set_driver_Pointer_gsl_odeiv2_driver set_driver);
  public static class Reset_Pointer_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Reset_Pointer_long(Pointer p) { super(p); }
      protected Reset_Pointer_long() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("size_t") long dim);
  }
  public native Reset_Pointer_long reset(); public native gsl_odeiv2_step_type reset(Reset_Pointer_long reset);
  public static class Order_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Order_Pointer(Pointer p) { super(p); }
      protected Order_Pointer() { allocate(); }
      private native void allocate();
      public native @Cast("unsigned int") int call(Pointer state);
  }
  public native Order_Pointer order(); public native gsl_odeiv2_step_type order(Order_Pointer order);
  public static class Free_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Free_Pointer(Pointer p) { super(p); }
      protected Free_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer state);
  }
  public native Free_Pointer free(); public native gsl_odeiv2_step_type free(Free_Pointer free);
}

@Name("gsl_odeiv2_step_struct") public static class gsl_odeiv2_step extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv2_step() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv2_step(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv2_step(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv2_step position(long position) {
        return (gsl_odeiv2_step)super.position(position);
    }

  @MemberGetter public native @Const gsl_odeiv2_step_type type();
  public native @Cast("size_t") long dimension(); public native gsl_odeiv2_step dimension(long dimension);
  public native Pointer state(); public native gsl_odeiv2_step state(Pointer state);
}

/* Available stepper types */

@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_rk2();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_rk4();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_rkf45();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_rkck();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_rk8pd();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_rk2imp();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_rk4imp();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_bsimp();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_rk1imp();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_msadams();
@MemberGetter public static native @Const gsl_odeiv2_step_type gsl_odeiv2_step_msbdf();

/* Stepper object methods */

public static native gsl_odeiv2_step gsl_odeiv2_step_alloc(@Const gsl_odeiv2_step_type T,
                                        @Cast("size_t") long dim);
public static native int gsl_odeiv2_step_reset(gsl_odeiv2_step s);
public static native void gsl_odeiv2_step_free(gsl_odeiv2_step s);
public static native @Cast("const char*") BytePointer gsl_odeiv2_step_name(@Const gsl_odeiv2_step s);
public static native @Cast("unsigned int") int gsl_odeiv2_step_order(@Const gsl_odeiv2_step s);
public static native int gsl_odeiv2_step_apply(gsl_odeiv2_step s, double t, double h,
                           DoublePointer y, DoublePointer yerr, @Const DoublePointer dydt_in,
                           DoublePointer dydt_out, @Const gsl_odeiv2_system dydt);
public static native int gsl_odeiv2_step_apply(gsl_odeiv2_step s, double t, double h,
                           DoubleBuffer y, DoubleBuffer yerr, @Const DoubleBuffer dydt_in,
                           DoubleBuffer dydt_out, @Const gsl_odeiv2_system dydt);
public static native int gsl_odeiv2_step_apply(gsl_odeiv2_step s, double t, double h,
                           double[] y, double[] yerr, @Const double[] dydt_in,
                           double[] dydt_out, @Const gsl_odeiv2_system dydt);
public static native int gsl_odeiv2_step_set_driver(gsl_odeiv2_step s,
                                @Const gsl_odeiv2_driver d);

/* Step size control object. */

public static class gsl_odeiv2_control_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv2_control_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv2_control_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv2_control_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv2_control_type position(long position) {
        return (gsl_odeiv2_control_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public static class Pointer_Alloc extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Pointer_Alloc(Pointer p) { super(p); }
      protected Pointer_Alloc() { allocate(); }
      private native void allocate();
      public native Pointer call();
  }
  public native Pointer_Alloc alloc(); public native gsl_odeiv2_control_type alloc(Pointer_Alloc alloc);
  public static class Init_Pointer_double_double_double_double extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Init_Pointer_double_double_double_double(Pointer p) { super(p); }
      protected Init_Pointer_double_double_double_double() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, double eps_abs, double eps_rel, double a_y,
                 double a_dydt);
  }
  public native Init_Pointer_double_double_double_double init(); public native gsl_odeiv2_control_type init(Init_Pointer_double_double_double_double init);
  public static class Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer(Pointer p) { super(p); }
      protected Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("size_t") long dim, @Cast("unsigned int") int ord, @Const DoublePointer y,
                    @Const DoublePointer yerr, @Const DoublePointer yp, DoublePointer h);
  }
  public native Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer hadjust(); public native gsl_odeiv2_control_type hadjust(Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer hadjust);
  public static class Errlevel_Pointer_double_double_double_long_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Errlevel_Pointer_double_double_double_long_DoublePointer(Pointer p) { super(p); }
      protected Errlevel_Pointer_double_double_double_long_DoublePointer() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, double y, double dydt,
                     double h, @Cast("const size_t") long ind, DoublePointer errlev);
  }
  public native Errlevel_Pointer_double_double_double_long_DoublePointer errlevel(); public native gsl_odeiv2_control_type errlevel(Errlevel_Pointer_double_double_double_long_DoublePointer errlevel);
  public static class Set_driver_Pointer_gsl_odeiv2_driver extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Set_driver_Pointer_gsl_odeiv2_driver(Pointer p) { super(p); }
      protected Set_driver_Pointer_gsl_odeiv2_driver() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Const gsl_odeiv2_driver d);
  }
  public native Set_driver_Pointer_gsl_odeiv2_driver set_driver(); public native gsl_odeiv2_control_type set_driver(Set_driver_Pointer_gsl_odeiv2_driver set_driver);
  public static class Free_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Free_Pointer(Pointer p) { super(p); }
      protected Free_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer state);
  }
  public native Free_Pointer free(); public native gsl_odeiv2_control_type free(Free_Pointer free);
}

@Name("gsl_odeiv2_control_struct") public static class gsl_odeiv2_control extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv2_control() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv2_control(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv2_control(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv2_control position(long position) {
        return (gsl_odeiv2_control)super.position(position);
    }

  @MemberGetter public native @Const gsl_odeiv2_control_type type();
  public native Pointer state(); public native gsl_odeiv2_control state(Pointer state);
}

/* Possible return values for an hadjust() evolution method */

public static final int GSL_ODEIV_HADJ_INC =   1;  /* step was increased */
public static final int GSL_ODEIV_HADJ_NIL =   0;  /* step unchanged     */
public static final int GSL_ODEIV_HADJ_DEC = (-1); /* step decreased     */

/* General step size control methods.
 *
 * The hadjust() method controls the adjustment of
 * step size given the result of a step and the error.
 * Valid hadjust() methods must return one of the codes below.
 * errlevel function calculates the desired error level D0.
 *
 * The general data can be used by specializations
 * to store state and control their heuristics.
 */

public static native gsl_odeiv2_control gsl_odeiv2_control_alloc(@Const gsl_odeiv2_control_type T);
public static native int gsl_odeiv2_control_init(gsl_odeiv2_control c, double eps_abs,
                             double eps_rel, double a_y, double a_dydt);
public static native void gsl_odeiv2_control_free(gsl_odeiv2_control c);
public static native int gsl_odeiv2_control_hadjust(gsl_odeiv2_control c, gsl_odeiv2_step s,
                                @Const DoublePointer y, @Const DoublePointer yerr,
                                @Const DoublePointer dydt, DoublePointer h);
public static native int gsl_odeiv2_control_hadjust(gsl_odeiv2_control c, gsl_odeiv2_step s,
                                @Const DoubleBuffer y, @Const DoubleBuffer yerr,
                                @Const DoubleBuffer dydt, DoubleBuffer h);
public static native int gsl_odeiv2_control_hadjust(gsl_odeiv2_control c, gsl_odeiv2_step s,
                                @Const double[] y, @Const double[] yerr,
                                @Const double[] dydt, double[] h);
public static native @Cast("const char*") BytePointer gsl_odeiv2_control_name(@Const gsl_odeiv2_control c);
public static native int gsl_odeiv2_control_errlevel(gsl_odeiv2_control c, double y,
                                 double dydt, double h,
                                 @Cast("const size_t") long ind, DoublePointer errlev);
public static native int gsl_odeiv2_control_errlevel(gsl_odeiv2_control c, double y,
                                 double dydt, double h,
                                 @Cast("const size_t") long ind, DoubleBuffer errlev);
public static native int gsl_odeiv2_control_errlevel(gsl_odeiv2_control c, double y,
                                 double dydt, double h,
                                 @Cast("const size_t") long ind, double[] errlev);
public static native int gsl_odeiv2_control_set_driver(gsl_odeiv2_control c,
                                   @Const gsl_odeiv2_driver d);

/* Available control object constructors.
 *
 * The standard control object is a four parameter heuristic
 * defined as follows:
 *    D0 = eps_abs + eps_rel * (a_y |y| + a_dydt h |y'|)
 *    D1 = |yerr|
 *    q  = consistency order of method (q=4 for 4(5) embedded RK)
 *    S  = safety factor (0.9 say)
 *
 *                      /  (D0/D1)^(1/(q+1))  D0 >= D1
 *    h_NEW = S h_OLD * |
 *                      \  (D0/D1)^(1/q)      D0 < D1
 *
 * This encompasses all the standard error scaling methods.
 *
 * The y method is the standard method with a_y=1, a_dydt=0.
 * The yp method is the standard method with a_y=0, a_dydt=1.
 */

public static native gsl_odeiv2_control gsl_odeiv2_control_standard_new(double eps_abs,
                                                     double eps_rel,
                                                     double a_y,
                                                     double a_dydt);
public static native gsl_odeiv2_control gsl_odeiv2_control_y_new(double eps_abs, double eps_rel);
public static native gsl_odeiv2_control gsl_odeiv2_control_yp_new(double eps_abs,
                                               double eps_rel);

/* This controller computes errors using different absolute errors for
 * each component
 *
 *    D0 = eps_abs * scale_abs[i] + eps_rel * (a_y |y| + a_dydt h |y'|)
 */

public static native gsl_odeiv2_control gsl_odeiv2_control_scaled_new(double eps_abs,
                                                   double eps_rel, double a_y,
                                                   double a_dydt,
                                                   @Const DoublePointer scale_abs,
                                                   @Cast("size_t") long dim);
public static native gsl_odeiv2_control gsl_odeiv2_control_scaled_new(double eps_abs,
                                                   double eps_rel, double a_y,
                                                   double a_dydt,
                                                   @Const DoubleBuffer scale_abs,
                                                   @Cast("size_t") long dim);
public static native gsl_odeiv2_control gsl_odeiv2_control_scaled_new(double eps_abs,
                                                   double eps_rel, double a_y,
                                                   double a_dydt,
                                                   @Const double[] scale_abs,
                                                   @Cast("size_t") long dim);

/* Evolution object */

@Name("gsl_odeiv2_evolve_struct") public static class gsl_odeiv2_evolve extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv2_evolve() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv2_evolve(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv2_evolve(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv2_evolve position(long position) {
        return (gsl_odeiv2_evolve)super.position(position);
    }

  public native @Cast("size_t") long dimension(); public native gsl_odeiv2_evolve dimension(long dimension);
  public native DoublePointer y0(); public native gsl_odeiv2_evolve y0(DoublePointer y0);
  public native DoublePointer yerr(); public native gsl_odeiv2_evolve yerr(DoublePointer yerr);
  public native DoublePointer dydt_in(); public native gsl_odeiv2_evolve dydt_in(DoublePointer dydt_in);
  public native DoublePointer dydt_out(); public native gsl_odeiv2_evolve dydt_out(DoublePointer dydt_out);
  public native double last_step(); public native gsl_odeiv2_evolve last_step(double last_step);
  public native @Cast("unsigned long int") long count(); public native gsl_odeiv2_evolve count(long count);
  public native @Cast("unsigned long int") long failed_steps(); public native gsl_odeiv2_evolve failed_steps(long failed_steps);
  @MemberGetter public native @Const gsl_odeiv2_driver driver();
}

/* Evolution object methods */

public static native gsl_odeiv2_evolve gsl_odeiv2_evolve_alloc(@Cast("size_t") long dim);
public static native int gsl_odeiv2_evolve_apply(gsl_odeiv2_evolve e, gsl_odeiv2_control con,
                             gsl_odeiv2_step step,
                             @Const gsl_odeiv2_system dydt, DoublePointer t,
                             double t1, DoublePointer h, DoublePointer y);
public static native int gsl_odeiv2_evolve_apply(gsl_odeiv2_evolve e, gsl_odeiv2_control con,
                             gsl_odeiv2_step step,
                             @Const gsl_odeiv2_system dydt, DoubleBuffer t,
                             double t1, DoubleBuffer h, DoubleBuffer y);
public static native int gsl_odeiv2_evolve_apply(gsl_odeiv2_evolve e, gsl_odeiv2_control con,
                             gsl_odeiv2_step step,
                             @Const gsl_odeiv2_system dydt, double[] t,
                             double t1, double[] h, double[] y);
public static native int gsl_odeiv2_evolve_apply_fixed_step(gsl_odeiv2_evolve e,
                                        gsl_odeiv2_control con,
                                        gsl_odeiv2_step step,
                                        @Const gsl_odeiv2_system dydt,
                                        DoublePointer t, double h0,
                                        DoublePointer y);
public static native int gsl_odeiv2_evolve_apply_fixed_step(gsl_odeiv2_evolve e,
                                        gsl_odeiv2_control con,
                                        gsl_odeiv2_step step,
                                        @Const gsl_odeiv2_system dydt,
                                        DoubleBuffer t, double h0,
                                        DoubleBuffer y);
public static native int gsl_odeiv2_evolve_apply_fixed_step(gsl_odeiv2_evolve e,
                                        gsl_odeiv2_control con,
                                        gsl_odeiv2_step step,
                                        @Const gsl_odeiv2_system dydt,
                                        double[] t, double h0,
                                        double[] y);
public static native int gsl_odeiv2_evolve_reset(gsl_odeiv2_evolve e);
public static native void gsl_odeiv2_evolve_free(gsl_odeiv2_evolve e);
public static native int gsl_odeiv2_evolve_set_driver(gsl_odeiv2_evolve e,
                                  @Const gsl_odeiv2_driver d);

/* Driver object
 *
 * This is a high level wrapper for step, control and
 * evolve objects. 
 */

@Name("gsl_odeiv2_driver_struct") public static class gsl_odeiv2_driver extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv2_driver() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv2_driver(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv2_driver(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv2_driver position(long position) {
        return (gsl_odeiv2_driver)super.position(position);
    }

  @MemberGetter public native @Const gsl_odeiv2_system sys(); /* ODE system */
  public native gsl_odeiv2_step s(); public native gsl_odeiv2_driver s(gsl_odeiv2_step s);           /* stepper object */
  public native gsl_odeiv2_control c(); public native gsl_odeiv2_driver c(gsl_odeiv2_control c);        /* control object */
  public native gsl_odeiv2_evolve e(); public native gsl_odeiv2_driver e(gsl_odeiv2_evolve e);         /* evolve object */
  public native double h(); public native gsl_odeiv2_driver h(double h);                     /* step size */
  public native double hmin(); public native gsl_odeiv2_driver hmin(double hmin);                  /* minimum step size allowed */
  public native double hmax(); public native gsl_odeiv2_driver hmax(double hmax);                  /* maximum step size allowed */
  public native @Cast("unsigned long int") long n(); public native gsl_odeiv2_driver n(long n);          /* number of steps taken */
  public native @Cast("unsigned long int") long nmax(); public native gsl_odeiv2_driver nmax(long nmax);       /* Maximum number of steps allowed */
}

/* Driver object methods */

public static native gsl_odeiv2_driver gsl_odeiv2_driver_alloc_y_new(@Const gsl_odeiv2_system sys,
                                                  @Const gsl_odeiv2_step_type T, double hstart,
                                                  double epsabs,
                                                  double epsrel);
public static native gsl_odeiv2_driver gsl_odeiv2_driver_alloc_yp_new(@Const gsl_odeiv2_system sys,
                                                   @Const gsl_odeiv2_step_type T, double hstart,
                                                   double epsabs,
                                                   double epsrel);
public static native gsl_odeiv2_driver gsl_odeiv2_driver_alloc_scaled_new(@Const gsl_odeiv2_system sys,
                                                       @Const gsl_odeiv2_step_type T, double hstart,
                                                       double epsabs,
                                                       double epsrel,
                                                       double a_y,
                                                       double a_dydt,
                                                       @Const DoublePointer scale_abs);
public static native gsl_odeiv2_driver gsl_odeiv2_driver_alloc_scaled_new(@Const gsl_odeiv2_system sys,
                                                       @Const gsl_odeiv2_step_type T, double hstart,
                                                       double epsabs,
                                                       double epsrel,
                                                       double a_y,
                                                       double a_dydt,
                                                       @Const DoubleBuffer scale_abs);
public static native gsl_odeiv2_driver gsl_odeiv2_driver_alloc_scaled_new(@Const gsl_odeiv2_system sys,
                                                       @Const gsl_odeiv2_step_type T, double hstart,
                                                       double epsabs,
                                                       double epsrel,
                                                       double a_y,
                                                       double a_dydt,
                                                       @Const double[] scale_abs);
public static native gsl_odeiv2_driver gsl_odeiv2_driver_alloc_standard_new(@Const gsl_odeiv2_system sys,
                                                         @Const gsl_odeiv2_step_type T,
                                                         double hstart,
                                                         double epsabs,
                                                         double epsrel,
                                                         double a_y,
                                                         double a_dydt);
public static native int gsl_odeiv2_driver_set_hmin(gsl_odeiv2_driver d, double hmin);
public static native int gsl_odeiv2_driver_set_hmax(gsl_odeiv2_driver d, double hmax);
public static native int gsl_odeiv2_driver_set_nmax(gsl_odeiv2_driver d,
                                @Cast("const unsigned long int") long nmax);
public static native int gsl_odeiv2_driver_apply(gsl_odeiv2_driver d, DoublePointer t,
                             double t1, DoublePointer y);
public static native int gsl_odeiv2_driver_apply(gsl_odeiv2_driver d, DoubleBuffer t,
                             double t1, DoubleBuffer y);
public static native int gsl_odeiv2_driver_apply(gsl_odeiv2_driver d, double[] t,
                             double t1, double[] y);
public static native int gsl_odeiv2_driver_apply_fixed_step(gsl_odeiv2_driver d, DoublePointer t,
                                        double h,
                                        @Cast("const unsigned long int") long n,
                                        DoublePointer y);
public static native int gsl_odeiv2_driver_apply_fixed_step(gsl_odeiv2_driver d, DoubleBuffer t,
                                        double h,
                                        @Cast("const unsigned long int") long n,
                                        DoubleBuffer y);
public static native int gsl_odeiv2_driver_apply_fixed_step(gsl_odeiv2_driver d, double[] t,
                                        double h,
                                        @Cast("const unsigned long int") long n,
                                        double[] y);
public static native int gsl_odeiv2_driver_reset(gsl_odeiv2_driver d);
public static native int gsl_odeiv2_driver_reset_hstart(gsl_odeiv2_driver d, double hstart);
public static native void gsl_odeiv2_driver_free(gsl_odeiv2_driver state);
// #endif /* __GSL_ODEIV2_H__ */


// Parsed from gsl/gsl_odeiv.h

/* ode-initval/gsl_odeiv.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman
 */
// #ifndef __GSL_ODEIV_H__
// #define __GSL_ODEIV_H__

// #include <stdio.h>
// #include <stdlib.h>
// #include <gsl/gsl_types.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Description of a system of ODEs.
 *
 * y' = f(t,y) = dydt(t, y)
 *
 * The system is specified by giving the right-hand-side
 * of the equation and possibly a jacobian function.
 *
 * Some methods require the jacobian function, which calculates
 * the matrix dfdy and the vector dfdt. The matrix dfdy conforms
 * to the GSL standard, being a continuous range of floating point
 * values, in row-order.
 *
 * As with GSL function objects, user-supplied parameter
 * data is also present. 
 */

public static class gsl_odeiv_system extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv_system() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv_system(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv_system(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv_system position(long position) {
        return (gsl_odeiv_system)super.position(position);
    }

  public static class Function_double_DoublePointer_DoublePointer_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Function_double_DoublePointer_DoublePointer_Pointer(Pointer p) { super(p); }
      protected Function_double_DoublePointer_DoublePointer_Pointer() { allocate(); }
      private native void allocate();
      public native int call(double t, @Const DoublePointer y, DoublePointer dydt, Pointer params);
  }
  public native Function_double_DoublePointer_DoublePointer_Pointer function(); public native gsl_odeiv_system function(Function_double_DoublePointer_DoublePointer_Pointer function);
  public static class Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer(Pointer p) { super(p); }
      protected Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer() { allocate(); }
      private native void allocate();
      public native int call(double t, @Const DoublePointer y, DoublePointer dfdy, DoublePointer dfdt, Pointer params);
  }
  public native Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer jacobian(); public native gsl_odeiv_system jacobian(Jacobian_double_DoublePointer_DoublePointer_DoublePointer_Pointer jacobian);
  public native @Cast("size_t") long dimension(); public native gsl_odeiv_system dimension(long dimension);
  public native Pointer params(); public native gsl_odeiv_system params(Pointer params);
}

// #define GSL_ODEIV_FN_EVAL(S,t,y,f)  (*((S)->function))(t,y,f,(S)->params)
// #define GSL_ODEIV_JA_EVAL(S,t,y,dfdy,dfdt)  (*((S)->jacobian))(t,y,dfdy,dfdt,(S)->params)


/* General stepper object.
 *
 * Opaque object for stepping an ODE system from t to t+h.
 * In general the object has some state which facilitates
 * iterating the stepping operation.
 */

public static class gsl_odeiv_step_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv_step_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv_step_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv_step_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv_step_type position(long position) {
        return (gsl_odeiv_step_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public native int can_use_dydt_in(); public native gsl_odeiv_step_type can_use_dydt_in(int can_use_dydt_in);
  public native int gives_exact_dydt_out(); public native gsl_odeiv_step_type gives_exact_dydt_out(int gives_exact_dydt_out);
  public static class Alloc_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Alloc_long(Pointer p) { super(p); }
      protected Alloc_long() { allocate(); }
      private native void allocate();
      public native Pointer call(@Cast("size_t") long dim);
  }
  public native Alloc_long alloc(); public native gsl_odeiv_step_type alloc(Alloc_long alloc);
  public static class Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv_system extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv_system(Pointer p) { super(p); }
      protected Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv_system() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("size_t") long dim, double t, double h, DoublePointer y, DoublePointer yerr, @Const DoublePointer dydt_in, DoublePointer dydt_out, @Const gsl_odeiv_system dydt);
  }
  public native Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv_system apply(); public native gsl_odeiv_step_type apply(Apply_Pointer_long_double_double_DoublePointer_DoublePointer_DoublePointer_DoublePointer_gsl_odeiv_system apply);
  public static class Reset_Pointer_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Reset_Pointer_long(Pointer p) { super(p); }
      protected Reset_Pointer_long() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("size_t") long dim);
  }
  public native Reset_Pointer_long reset(); public native gsl_odeiv_step_type reset(Reset_Pointer_long reset);
  public static class Order_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Order_Pointer(Pointer p) { super(p); }
      protected Order_Pointer() { allocate(); }
      private native void allocate();
      public native @Cast("unsigned int") int call(Pointer state);
  }
  public native Order_Pointer order(); public native gsl_odeiv_step_type order(Order_Pointer order);
  public static class Free_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Free_Pointer(Pointer p) { super(p); }
      protected Free_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer state);
  }
  public native Free_Pointer free(); public native gsl_odeiv_step_type free(Free_Pointer free);
}

public static class gsl_odeiv_step extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv_step() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv_step(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv_step(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv_step position(long position) {
        return (gsl_odeiv_step)super.position(position);
    }

  @MemberGetter public native @Const gsl_odeiv_step_type type();
  public native @Cast("size_t") long dimension(); public native gsl_odeiv_step dimension(long dimension);
  public native Pointer state(); public native gsl_odeiv_step state(Pointer state);
}


/* Available stepper types.
 *
 * rk2    : embedded 2nd(3rd) Runge-Kutta
 * rk4    : 4th order (classical) Runge-Kutta
 * rkck   : embedded 4th(5th) Runge-Kutta, Cash-Karp
 * rk8pd  : embedded 8th(9th) Runge-Kutta, Prince-Dormand
 * rk2imp : implicit 2nd order Runge-Kutta at Gaussian points
 * rk4imp : implicit 4th order Runge-Kutta at Gaussian points
 * gear1  : M=1 implicit Gear method
 * gear2  : M=2 implicit Gear method
 */

@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_rk2();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_rk4();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_rkf45();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_rkck();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_rk8pd();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_rk2imp();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_rk2simp();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_rk4imp();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_bsimp();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_gear1();
@MemberGetter public static native @Const gsl_odeiv_step_type gsl_odeiv_step_gear2();


/* Constructor for specialized stepper objects.
 */
public static native gsl_odeiv_step gsl_odeiv_step_alloc(@Const gsl_odeiv_step_type T, @Cast("size_t") long dim);
public static native int gsl_odeiv_step_reset(gsl_odeiv_step s);
public static native void gsl_odeiv_step_free(gsl_odeiv_step s);

/* General stepper object methods.
 */
public static native @Cast("const char*") BytePointer gsl_odeiv_step_name(@Const gsl_odeiv_step s);
public static native @Cast("unsigned int") int gsl_odeiv_step_order(@Const gsl_odeiv_step s);

public static native int gsl_odeiv_step_apply(gsl_odeiv_step s, double t, double h, DoublePointer y, DoublePointer yerr, @Const DoublePointer dydt_in, DoublePointer dydt_out, @Const gsl_odeiv_system dydt);
public static native int gsl_odeiv_step_apply(gsl_odeiv_step s, double t, double h, DoubleBuffer y, DoubleBuffer yerr, @Const DoubleBuffer dydt_in, DoubleBuffer dydt_out, @Const gsl_odeiv_system dydt);
public static native int gsl_odeiv_step_apply(gsl_odeiv_step s, double t, double h, double[] y, double[] yerr, @Const double[] dydt_in, double[] dydt_out, @Const gsl_odeiv_system dydt);

/* General step size control object.
 *
 * The hadjust() method controls the adjustment of
 * step size given the result of a step and the error.
 * Valid hadjust() methods must return one of the codes below.
 *
 * The general data can be used by specializations
 * to store state and control their heuristics.
 */

public static class gsl_odeiv_control_type extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv_control_type() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv_control_type(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv_control_type(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv_control_type position(long position) {
        return (gsl_odeiv_control_type)super.position(position);
    }

  @MemberGetter public native @Cast("const char*") BytePointer name();
  public static class Pointer_Alloc extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Pointer_Alloc(Pointer p) { super(p); }
      protected Pointer_Alloc() { allocate(); }
      private native void allocate();
      public native Pointer call();
  }
  public native Pointer_Alloc alloc(); public native gsl_odeiv_control_type alloc(Pointer_Alloc alloc);
  public static class Init_Pointer_double_double_double_double extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Init_Pointer_double_double_double_double(Pointer p) { super(p); }
      protected Init_Pointer_double_double_double_double() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, double eps_abs, double eps_rel, double a_y, double a_dydt);
  }
  public native Init_Pointer_double_double_double_double init(); public native gsl_odeiv_control_type init(Init_Pointer_double_double_double_double init);
  public static class Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer(Pointer p) { super(p); }
      protected Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer() { allocate(); }
      private native void allocate();
      public native int call(Pointer state, @Cast("size_t") long dim, @Cast("unsigned int") int ord, @Const DoublePointer y, @Const DoublePointer yerr, @Const DoublePointer yp, DoublePointer h);
  }
  public native Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer hadjust(); public native gsl_odeiv_control_type hadjust(Hadjust_Pointer_long_int_DoublePointer_DoublePointer_DoublePointer_DoublePointer hadjust);
  public static class Free_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Free_Pointer(Pointer p) { super(p); }
      protected Free_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer state);
  }
  public native Free_Pointer free(); public native gsl_odeiv_control_type free(Free_Pointer free);
}

public static class gsl_odeiv_control extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv_control() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv_control(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv_control(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv_control position(long position) {
        return (gsl_odeiv_control)super.position(position);
    }

  @MemberGetter public native @Const gsl_odeiv_control_type type();
  public native Pointer state(); public native gsl_odeiv_control state(Pointer state);
}

/* Possible return values for an hadjust() evolution method.
 */  /* step was increased */  /* step unchanged     */ /* step decreased     */

public static native gsl_odeiv_control gsl_odeiv_control_alloc(@Const gsl_odeiv_control_type T);
public static native int gsl_odeiv_control_init(gsl_odeiv_control c, double eps_abs, double eps_rel, double a_y, double a_dydt);
public static native void gsl_odeiv_control_free(gsl_odeiv_control c);
public static native int gsl_odeiv_control_hadjust(gsl_odeiv_control c, gsl_odeiv_step s, @Const DoublePointer y, @Const DoublePointer yerr, @Const DoublePointer dydt, DoublePointer h);
public static native int gsl_odeiv_control_hadjust(gsl_odeiv_control c, gsl_odeiv_step s, @Const DoubleBuffer y, @Const DoubleBuffer yerr, @Const DoubleBuffer dydt, DoubleBuffer h);
public static native int gsl_odeiv_control_hadjust(gsl_odeiv_control c, gsl_odeiv_step s, @Const double[] y, @Const double[] yerr, @Const double[] dydt, double[] h);
public static native @Cast("const char*") BytePointer gsl_odeiv_control_name(@Const gsl_odeiv_control c);

/* Available control object constructors.
 *
 * The standard control object is a four parameter heuristic
 * defined as follows:
 *    D0 = eps_abs + eps_rel * (a_y |y| + a_dydt h |y'|)
 *    D1 = |yerr|
 *    q  = consistency order of method (q=4 for 4(5) embedded RK)
 *    S  = safety factor (0.9 say)
 *
 *                      /  (D0/D1)^(1/(q+1))  D0 >= D1
 *    h_NEW = S h_OLD * |
 *                      \  (D0/D1)^(1/q)      D0 < D1
 *
 * This encompasses all the standard error scaling methods.
 *
 * The y method is the standard method with a_y=1, a_dydt=0.
 * The yp method is the standard method with a_y=0, a_dydt=1.
 */

public static native gsl_odeiv_control gsl_odeiv_control_standard_new(double eps_abs, double eps_rel, double a_y, double a_dydt);
public static native gsl_odeiv_control gsl_odeiv_control_y_new(double eps_abs, double eps_rel);
public static native gsl_odeiv_control gsl_odeiv_control_yp_new(double eps_abs, double eps_rel);

/* This controller computes errors using different absolute errors for
 * each component
 *
 *    D0 = eps_abs * scale_abs[i] + eps_rel * (a_y |y| + a_dydt h |y'|)
 */
public static native gsl_odeiv_control gsl_odeiv_control_scaled_new(double eps_abs, double eps_rel, double a_y, double a_dydt, @Const DoublePointer scale_abs, @Cast("size_t") long dim);
public static native gsl_odeiv_control gsl_odeiv_control_scaled_new(double eps_abs, double eps_rel, double a_y, double a_dydt, @Const DoubleBuffer scale_abs, @Cast("size_t") long dim);
public static native gsl_odeiv_control gsl_odeiv_control_scaled_new(double eps_abs, double eps_rel, double a_y, double a_dydt, @Const double[] scale_abs, @Cast("size_t") long dim);

/* General evolution object.
 */
public static class gsl_odeiv_evolve extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_odeiv_evolve() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_odeiv_evolve(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_odeiv_evolve(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_odeiv_evolve position(long position) {
        return (gsl_odeiv_evolve)super.position(position);
    }

  public native @Cast("size_t") long dimension(); public native gsl_odeiv_evolve dimension(long dimension);
  public native DoublePointer y0(); public native gsl_odeiv_evolve y0(DoublePointer y0);
  public native DoublePointer yerr(); public native gsl_odeiv_evolve yerr(DoublePointer yerr);
  public native DoublePointer dydt_in(); public native gsl_odeiv_evolve dydt_in(DoublePointer dydt_in);
  public native DoublePointer dydt_out(); public native gsl_odeiv_evolve dydt_out(DoublePointer dydt_out);
  public native double last_step(); public native gsl_odeiv_evolve last_step(double last_step);
  public native @Cast("unsigned long int") long count(); public native gsl_odeiv_evolve count(long count);
  public native @Cast("unsigned long int") long failed_steps(); public native gsl_odeiv_evolve failed_steps(long failed_steps);
}

/* Evolution object methods.
 */
public static native gsl_odeiv_evolve gsl_odeiv_evolve_alloc(@Cast("size_t") long dim);
public static native int gsl_odeiv_evolve_apply(gsl_odeiv_evolve e, gsl_odeiv_control con, gsl_odeiv_step step, @Const gsl_odeiv_system dydt, DoublePointer t, double t1, DoublePointer h, DoublePointer y);
public static native int gsl_odeiv_evolve_apply(gsl_odeiv_evolve e, gsl_odeiv_control con, gsl_odeiv_step step, @Const gsl_odeiv_system dydt, DoubleBuffer t, double t1, DoubleBuffer h, DoubleBuffer y);
public static native int gsl_odeiv_evolve_apply(gsl_odeiv_evolve e, gsl_odeiv_control con, gsl_odeiv_step step, @Const gsl_odeiv_system dydt, double[] t, double t1, double[] h, double[] y);
public static native int gsl_odeiv_evolve_reset(gsl_odeiv_evolve e);
public static native void gsl_odeiv_evolve_free(gsl_odeiv_evolve e);

// #endif /* __GSL_ODEIV_H__ */


// Parsed from gsl/gsl_permute.h

// #ifndef __GSL_PERMUTE_H__
// #define __GSL_PERMUTE_H__

// #include <gsl/gsl_permute_complex_long_double.h>
// #include <gsl/gsl_permute_complex_double.h>
// #include <gsl/gsl_permute_complex_float.h>

// #include <gsl/gsl_permute_long_double.h>
// #include <gsl/gsl_permute_double.h>
// #include <gsl/gsl_permute_float.h>

// #include <gsl/gsl_permute_ulong.h>
// #include <gsl/gsl_permute_long.h>

// #include <gsl/gsl_permute_uint.h>
// #include <gsl/gsl_permute_int.h>

// #include <gsl/gsl_permute_ushort.h>
// #include <gsl/gsl_permute_short.h>

// #include <gsl/gsl_permute_uchar.h>
// #include <gsl/gsl_permute_char.h>

// #endif /* __GSL_PERMUTE_H__ */


// Parsed from gsl/gsl_permute_complex_double.h

/* permutation/gsl_permute_complex_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_COMPLEX_DOUBLE_H__
// #define __GSL_PERMUTE_COMPLEX_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_complex(@Cast("const size_t*") SizeTPointer p, DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex(@Cast("const size_t*") SizeTPointer p, DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex(@Cast("const size_t*") SizeTPointer p, double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex_inverse(@Cast("const size_t*") SizeTPointer p, DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex_inverse(@Cast("const size_t*") SizeTPointer p, DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex_inverse(@Cast("const size_t*") SizeTPointer p, double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_COMPLEX_DOUBLE_H__ */


// Parsed from gsl/gsl_permute_complex_float.h

/* permutation/gsl_permute_complex_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_COMPLEX_FLOAT_H__
// #define __GSL_PERMUTE_COMPLEX_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_complex.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_complex_float(@Cast("const size_t*") SizeTPointer p, FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex_float(@Cast("const size_t*") SizeTPointer p, FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex_float(@Cast("const size_t*") SizeTPointer p, float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex_float_inverse(@Cast("const size_t*") SizeTPointer p, FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex_float_inverse(@Cast("const size_t*") SizeTPointer p, FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_complex_float_inverse(@Cast("const size_t*") SizeTPointer p, float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_COMPLEX_FLOAT_H__ */


// Parsed from gsl/gsl_permute_double.h

/* permutation/gsl_permute_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_DOUBLE_H__
// #define __GSL_PERMUTE_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute(@Cast("const size_t*") SizeTPointer p, DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute(@Cast("const size_t*") SizeTPointer p, DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute(@Cast("const size_t*") SizeTPointer p, double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_inverse(@Cast("const size_t*") SizeTPointer p, DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_inverse(@Cast("const size_t*") SizeTPointer p, DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_inverse(@Cast("const size_t*") SizeTPointer p, double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_DOUBLE_H__ */


// Parsed from gsl/gsl_permute_float.h

/* permutation/gsl_permute_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_FLOAT_H__
// #define __GSL_PERMUTE_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_float(@Cast("const size_t*") SizeTPointer p, FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_float(@Cast("const size_t*") SizeTPointer p, FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_float(@Cast("const size_t*") SizeTPointer p, float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_float_inverse(@Cast("const size_t*") SizeTPointer p, FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_float_inverse(@Cast("const size_t*") SizeTPointer p, FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_float_inverse(@Cast("const size_t*") SizeTPointer p, float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_FLOAT_H__ */


// Parsed from gsl/gsl_permute_ulong.h

/* permutation/gsl_permute_ulong.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_ULONG_H__
// #define __GSL_PERMUTE_ULONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_ulong(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_ulong_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_ULONG_H__ */


// Parsed from gsl/gsl_permute_long.h

/* permutation/gsl_permute_long.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_LONG_H__
// #define __GSL_PERMUTE_LONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_long(@Cast("const size_t*") SizeTPointer p, CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_long_inverse(@Cast("const size_t*") SizeTPointer p, CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_LONG_H__ */


// Parsed from gsl/gsl_permute_uint.h

/* permutation/gsl_permute_uint.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_UINT_H__
// #define __GSL_PERMUTE_UINT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_uint(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uint(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uint(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uint_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uint_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uint_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_UINT_H__ */


// Parsed from gsl/gsl_permute_int.h

/* permutation/gsl_permute_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_INT_H__
// #define __GSL_PERMUTE_INT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_int(@Cast("const size_t*") SizeTPointer p, IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_int(@Cast("const size_t*") SizeTPointer p, IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_int(@Cast("const size_t*") SizeTPointer p, int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_int_inverse(@Cast("const size_t*") SizeTPointer p, IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_int_inverse(@Cast("const size_t*") SizeTPointer p, IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_int_inverse(@Cast("const size_t*") SizeTPointer p, int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_INT_H__ */


// Parsed from gsl/gsl_permute_ushort.h

/* permutation/gsl_permute_ushort.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_USHORT_H__
// #define __GSL_PERMUTE_USHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_ushort(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_ushort(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_ushort(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_ushort_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_ushort_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_ushort_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_USHORT_H__ */


// Parsed from gsl/gsl_permute_short.h

/* permutation/gsl_permute_short.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_SHORT_H__
// #define __GSL_PERMUTE_SHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_short(@Cast("const size_t*") SizeTPointer p, ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_short(@Cast("const size_t*") SizeTPointer p, ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_short(@Cast("const size_t*") SizeTPointer p, short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_short_inverse(@Cast("const size_t*") SizeTPointer p, ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_short_inverse(@Cast("const size_t*") SizeTPointer p, ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_short_inverse(@Cast("const size_t*") SizeTPointer p, short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_SHORT_H__ */


// Parsed from gsl/gsl_permute_uchar.h

/* permutation/gsl_permute_uchar.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_UCHAR_H__
// #define __GSL_PERMUTE_UCHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_uchar(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uchar(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uchar(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uchar_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uchar_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_uchar_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_UCHAR_H__ */


// Parsed from gsl/gsl_permute_char.h

/* permutation/gsl_permute_char.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_CHAR_H__
// #define __GSL_PERMUTE_CHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_char(@Cast("const size_t*") SizeTPointer p, @Cast("char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_char(@Cast("const size_t*") SizeTPointer p, @Cast("char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_char(@Cast("const size_t*") SizeTPointer p, @Cast("char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_char_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_char_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_permute_char_inverse(@Cast("const size_t*") SizeTPointer p, @Cast("char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_PERMUTE_CHAR_H__ */


// Parsed from gsl/gsl_permute_vector.h

// #ifndef __GSL_PERMUTE_VECTOR_H__
// #define __GSL_PERMUTE_VECTOR_H__

// #include <gsl/gsl_permute_vector_complex_long_double.h>
// #include <gsl/gsl_permute_vector_complex_double.h>
// #include <gsl/gsl_permute_vector_complex_float.h>

// #include <gsl/gsl_permute_vector_long_double.h>
// #include <gsl/gsl_permute_vector_double.h>
// #include <gsl/gsl_permute_vector_float.h>

// #include <gsl/gsl_permute_vector_ulong.h>
// #include <gsl/gsl_permute_vector_long.h>

// #include <gsl/gsl_permute_vector_uint.h>
// #include <gsl/gsl_permute_vector_int.h>

// #include <gsl/gsl_permute_vector_ushort.h>
// #include <gsl/gsl_permute_vector_short.h>

// #include <gsl/gsl_permute_vector_uchar.h>
// #include <gsl/gsl_permute_vector_char.h>

// #endif /* __GSL_PERMUTE_VECTOR_H__ */


// Parsed from gsl/gsl_permute_vector_complex_double.h

/* permutation/gsl_permute_vector_complex_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_COMPLEX_DOUBLE_H__
// #define __GSL_PERMUTE_VECTOR_COMPLEX_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_complex_double.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_complex(@Const gsl_permutation p, gsl_vector_complex v);
public static native int gsl_permute_vector_complex_inverse(@Const gsl_permutation p, gsl_vector_complex v);

// #endif /* __GSL_PERMUTE_VECTOR_COMPLEX_DOUBLE_H__ */


// Parsed from gsl/gsl_permute_vector_complex_float.h

/* permutation/gsl_permute_vector_complex_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_COMPLEX_FLOAT_H__
// #define __GSL_PERMUTE_VECTOR_COMPLEX_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_complex_float.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_complex_float(@Const gsl_permutation p, gsl_vector_complex_float v);
public static native int gsl_permute_vector_complex_float_inverse(@Const gsl_permutation p, gsl_vector_complex_float v);

// #endif /* __GSL_PERMUTE_VECTOR_COMPLEX_FLOAT_H__ */


// Parsed from gsl/gsl_permute_vector_double.h

/* permutation/gsl_permute_vector_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_DOUBLE_H__
// #define __GSL_PERMUTE_VECTOR_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_double.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector(@Const gsl_permutation p, gsl_vector v);
public static native int gsl_permute_vector_inverse(@Const gsl_permutation p, gsl_vector v);

// #endif /* __GSL_PERMUTE_VECTOR_DOUBLE_H__ */


// Parsed from gsl/gsl_permute_vector_float.h

/* permutation/gsl_permute_vector_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_FLOAT_H__
// #define __GSL_PERMUTE_VECTOR_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_float.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_float(@Const gsl_permutation p, gsl_vector_float v);
public static native int gsl_permute_vector_float_inverse(@Const gsl_permutation p, gsl_vector_float v);

// #endif /* __GSL_PERMUTE_VECTOR_FLOAT_H__ */


// Parsed from gsl/gsl_permute_vector_ulong.h

/* permutation/gsl_permute_vector_ulong.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_ULONG_H__
// #define __GSL_PERMUTE_VECTOR_ULONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_ulong.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_ulong(@Const gsl_permutation p, gsl_vector_ulong v);
public static native int gsl_permute_vector_ulong_inverse(@Const gsl_permutation p, gsl_vector_ulong v);

// #endif /* __GSL_PERMUTE_VECTOR_ULONG_H__ */


// Parsed from gsl/gsl_permute_vector_long.h

/* permutation/gsl_permute_vector_long.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_LONG_H__
// #define __GSL_PERMUTE_VECTOR_LONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_long.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_long(@Const gsl_permutation p, gsl_vector_long v);
public static native int gsl_permute_vector_long_inverse(@Const gsl_permutation p, gsl_vector_long v);

// #endif /* __GSL_PERMUTE_VECTOR_LONG_H__ */


// Parsed from gsl/gsl_permute_vector_uint.h

/* permutation/gsl_permute_vector_uint.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_UINT_H__
// #define __GSL_PERMUTE_VECTOR_UINT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_uint.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_uint(@Const gsl_permutation p, gsl_vector_uint v);
public static native int gsl_permute_vector_uint_inverse(@Const gsl_permutation p, gsl_vector_uint v);

// #endif /* __GSL_PERMUTE_VECTOR_UINT_H__ */


// Parsed from gsl/gsl_permute_vector_int.h

/* permutation/gsl_permute_vector_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_INT_H__
// #define __GSL_PERMUTE_VECTOR_INT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_int.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_int(@Const gsl_permutation p, gsl_vector_int v);
public static native int gsl_permute_vector_int_inverse(@Const gsl_permutation p, gsl_vector_int v);

// #endif /* __GSL_PERMUTE_VECTOR_INT_H__ */


// Parsed from gsl/gsl_permute_vector_ushort.h

/* permutation/gsl_permute_vector_ushort.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_USHORT_H__
// #define __GSL_PERMUTE_VECTOR_USHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_ushort.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_ushort(@Const gsl_permutation p, gsl_vector_ushort v);
public static native int gsl_permute_vector_ushort_inverse(@Const gsl_permutation p, gsl_vector_ushort v);

// #endif /* __GSL_PERMUTE_VECTOR_USHORT_H__ */


// Parsed from gsl/gsl_permute_vector_short.h

/* permutation/gsl_permute_vector_short.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_SHORT_H__
// #define __GSL_PERMUTE_VECTOR_SHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_short.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_short(@Const gsl_permutation p, gsl_vector_short v);
public static native int gsl_permute_vector_short_inverse(@Const gsl_permutation p, gsl_vector_short v);

// #endif /* __GSL_PERMUTE_VECTOR_SHORT_H__ */


// Parsed from gsl/gsl_permute_vector_uchar.h

/* permutation/gsl_permute_vector_uchar.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_UCHAR_H__
// #define __GSL_PERMUTE_VECTOR_UCHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_uchar.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_uchar(@Const gsl_permutation p, gsl_vector_uchar v);
public static native int gsl_permute_vector_uchar_inverse(@Const gsl_permutation p, gsl_vector_uchar v);

// #endif /* __GSL_PERMUTE_VECTOR_UCHAR_H__ */


// Parsed from gsl/gsl_permute_vector_char.h

/* permutation/gsl_permute_vector_char.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_PERMUTE_VECTOR_CHAR_H__
// #define __GSL_PERMUTE_VECTOR_CHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_char.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native int gsl_permute_vector_char(@Const gsl_permutation p, gsl_vector_char v);
public static native int gsl_permute_vector_char_inverse(@Const gsl_permutation p, gsl_vector_char v);

// #endif /* __GSL_PERMUTE_VECTOR_CHAR_H__ */


// Parsed from gsl/gsl_specfunc.h

/* Author:  G. Jungman */

        
/* Convenience header */
// #ifndef __GSL_SPECFUNC_H__
// #define __GSL_SPECFUNC_H__

// #include <gsl/gsl_sf.h>

// #endif /* __GSL_SPECFUNC_H__ */


// Parsed from gsl/gsl_sf.h

/* Author:  G. Jungman */

// #ifndef __GSL_SF_H__
// #define __GSL_SF_H__

// #include <gsl/gsl_sf_result.h>

// #include <gsl/gsl_sf_airy.h>
// #include <gsl/gsl_sf_bessel.h>
// #include <gsl/gsl_sf_clausen.h>
// #include <gsl/gsl_sf_coupling.h>
// #include <gsl/gsl_sf_coulomb.h>
// #include <gsl/gsl_sf_dawson.h>
// #include <gsl/gsl_sf_debye.h>
// #include <gsl/gsl_sf_dilog.h>
// #include <gsl/gsl_sf_elementary.h>
// #include <gsl/gsl_sf_ellint.h>
// #include <gsl/gsl_sf_elljac.h>
// #include <gsl/gsl_sf_erf.h>
// #include <gsl/gsl_sf_exp.h>
// #include <gsl/gsl_sf_expint.h>
// #include <gsl/gsl_sf_fermi_dirac.h>
// #include <gsl/gsl_sf_gamma.h>
// #include <gsl/gsl_sf_gegenbauer.h>
// #include <gsl/gsl_sf_hyperg.h>
// #include <gsl/gsl_sf_laguerre.h>
// #include <gsl/gsl_sf_lambert.h>
// #include <gsl/gsl_sf_legendre.h>
// #include <gsl/gsl_sf_log.h>
// #include <gsl/gsl_sf_mathieu.h>
// #include <gsl/gsl_sf_pow_int.h>
// #include <gsl/gsl_sf_psi.h>
// #include <gsl/gsl_sf_synchrotron.h>
// #include <gsl/gsl_sf_transport.h>
// #include <gsl/gsl_sf_trig.h>
// #include <gsl/gsl_sf_zeta.h>


// #endif /* __GSL_SF_H__ */


// Parsed from gsl/gsl_sf_result.h

/* specfunc/gsl_sf_result.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_RESULT_H__
// #define __GSL_SF_RESULT_H__

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

@Name("gsl_sf_result_struct") public static class gsl_sf_result extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_sf_result() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_sf_result(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_sf_result(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_sf_result position(long position) {
        return (gsl_sf_result)super.position(position);
    }

  public native double val(); public native gsl_sf_result val(double val);
  public native double err(); public native gsl_sf_result err(double err);
}

// #define GSL_SF_RESULT_SET(r,v,e) do { (r)->val=(v); (r)->err=(e); } while(0)


@Name("gsl_sf_result_e10_struct") public static class gsl_sf_result_e10 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_sf_result_e10() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_sf_result_e10(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_sf_result_e10(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_sf_result_e10 position(long position) {
        return (gsl_sf_result_e10)super.position(position);
    }

  public native double val(); public native gsl_sf_result_e10 val(double val);
  public native double err(); public native gsl_sf_result_e10 err(double err);
  public native int e10(); public native gsl_sf_result_e10 e10(int e10);
}


public static native int gsl_sf_result_smash_e(@Const gsl_sf_result_e10 re, gsl_sf_result r);

// #endif /* __GSL_SF_RESULT_H__ */


// Parsed from gsl/gsl_sf_airy.h

/* specfunc/gsl_sf_airy.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_AIRY_H__
// #define __GSL_SF_AIRY_H__

// #include <gsl/gsl_mode.h>
// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Airy function Ai(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_airy_Ai_e(double x, @Cast("const gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_airy_Ai(double x, @Cast("gsl_mode_t") int mode);


/* Airy function Bi(x)
 *
 * exceptions: GSL_EOVRFLW
 */
public static native int gsl_sf_airy_Bi_e(double x, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_airy_Bi(double x, @Cast("gsl_mode_t") int mode);


/* scaled Ai(x):
 *                     Ai(x)   x < 0
 *   exp(+2/3 x^{3/2}) Ai(x)   x > 0
 *
 * exceptions: none
 */
public static native int gsl_sf_airy_Ai_scaled_e(double x, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_airy_Ai_scaled(double x, @Cast("gsl_mode_t") int mode);


/* scaled Bi(x):
 *                     Bi(x)   x < 0
 *   exp(-2/3 x^{3/2}) Bi(x)   x > 0
 *
 * exceptions: none
 */
public static native int gsl_sf_airy_Bi_scaled_e(double x, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_airy_Bi_scaled(double x, @Cast("gsl_mode_t") int mode);


/* derivative Ai'(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_airy_Ai_deriv_e(double x, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_airy_Ai_deriv(double x, @Cast("gsl_mode_t") int mode);


/* derivative Bi'(x)
 *
 * exceptions: GSL_EOVRFLW
 */
public static native int gsl_sf_airy_Bi_deriv_e(double x, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_airy_Bi_deriv(double x, @Cast("gsl_mode_t") int mode);


/* scaled derivative Ai'(x):
 *                     Ai'(x)   x < 0
 *   exp(+2/3 x^{3/2}) Ai'(x)   x > 0
 *
 * exceptions: none
 */
public static native int gsl_sf_airy_Ai_deriv_scaled_e(double x, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_airy_Ai_deriv_scaled(double x, @Cast("gsl_mode_t") int mode);


/* scaled derivative:
 *                     Bi'(x)   x < 0
 *   exp(-2/3 x^{3/2}) Bi'(x)   x > 0
 *
 * exceptions: none
 */
public static native int gsl_sf_airy_Bi_deriv_scaled_e(double x, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_airy_Bi_deriv_scaled(double x, @Cast("gsl_mode_t") int mode);


/* Zeros of Ai(x)
 */
public static native int gsl_sf_airy_zero_Ai_e(@Cast("unsigned int") int s, gsl_sf_result result);
public static native double gsl_sf_airy_zero_Ai(@Cast("unsigned int") int s);


/* Zeros of Bi(x)
 */
public static native int gsl_sf_airy_zero_Bi_e(@Cast("unsigned int") int s, gsl_sf_result result);
public static native double gsl_sf_airy_zero_Bi(@Cast("unsigned int") int s);


/* Zeros of Ai'(x)
 */
public static native int gsl_sf_airy_zero_Ai_deriv_e(@Cast("unsigned int") int s, gsl_sf_result result);
public static native double gsl_sf_airy_zero_Ai_deriv(@Cast("unsigned int") int s);


/* Zeros of Bi'(x)
 */
public static native int gsl_sf_airy_zero_Bi_deriv_e(@Cast("unsigned int") int s, gsl_sf_result result);
public static native double gsl_sf_airy_zero_Bi_deriv(@Cast("unsigned int") int s);

// #endif /* __GSL_SF_AIRY_H__ */


// Parsed from gsl/gsl_sf_bessel.h

/* specfunc/gsl_sf_bessel.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_BESSEL_H__
// #define __GSL_SF_BESSEL_H__

// #include <stdlib.h>
// #include <gsl/gsl_mode.h>
// #include <gsl/gsl_precision.h>
// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Regular Bessel Function J_0(x)
 *
 * exceptions: none
 */
public static native int gsl_sf_bessel_J0_e(double x,  gsl_sf_result result);
public static native double gsl_sf_bessel_J0(double x);


/* Regular Bessel Function J_1(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_J1_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_J1(double x);


/* Regular Bessel Function J_n(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Jn_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Jn(int n, double x);


/* Regular Bessel Function J_n(x),  nmin <= n <= nmax
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Jn_array(int nmin, int nmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_Jn_array(int nmin, int nmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_Jn_array(int nmin, int nmax, double x, double[] result_array);


/* Irregular Bessel function Y_0(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Y0_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Y0(double x);


/* Irregular Bessel function Y_1(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Y1_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Y1(double x);


/* Irregular Bessel function Y_n(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Yn_e(int n,double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Yn(int n,double x);


/* Irregular Bessel function Y_n(x), nmin <= n <= nmax
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Yn_array(int nmin, int nmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_Yn_array(int nmin, int nmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_Yn_array(int nmin, int nmax, double x, double[] result_array);


/* Regular modified Bessel function I_0(x)
 *
 * exceptions: GSL_EOVRFLW
 */
public static native int gsl_sf_bessel_I0_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_I0(double x);


/* Regular modified Bessel function I_1(x)
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_I1_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_I1(double x);


/* Regular modified Bessel function I_n(x)
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_In_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_In(int n, double x);


/* Regular modified Bessel function  I_n(x) for n=nmin,...,nmax
 *
 * nmin >=0, nmax >= nmin
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_In_array(int nmin, int nmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_In_array(int nmin, int nmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_In_array(int nmin, int nmax, double x, double[] result_array);


/* Scaled regular modified Bessel function
 *  exp(-|x|) I_0(x)
 *
 * exceptions: none
 */
public static native int gsl_sf_bessel_I0_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_I0_scaled(double x);


/* Scaled regular modified Bessel function
 *  exp(-|x|) I_1(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_I1_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_I1_scaled(double x);


/* Scaled regular modified Bessel function
 *  exp(-|x|) I_n(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_In_scaled_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_In_scaled(int n, double x);


/* Scaled regular modified Bessel function
 *  exp(-|x|) I_n(x)  for n=nmin,...,nmax
 *
 * nmin >=0, nmax >= nmin
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_In_scaled_array(int nmin, int nmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_In_scaled_array(int nmin, int nmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_In_scaled_array(int nmin, int nmax, double x, double[] result_array);


/* Irregular modified Bessel function K_0(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_K0_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_K0(double x);


/* Irregular modified Bessel function K_1(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_K1_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_K1(double x);


/* Irregular modified Bessel function K_n(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Kn_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Kn(int n, double x);


/* Irregular modified Bessel function  K_n(x)  for n=nmin,...,nmax
 *
 * x > 0.0, nmin >=0, nmax >= nmin
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Kn_array(int nmin, int nmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_Kn_array(int nmin, int nmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_Kn_array(int nmin, int nmax, double x, double[] result_array);


/* Scaled irregular modified Bessel function
 *  exp(x) K_0(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_bessel_K0_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_K0_scaled(double x);


/* Scaled irregular modified Bessel function
 *  exp(x) K_1(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_K1_scaled_e(double x, gsl_sf_result result); 
public static native double gsl_sf_bessel_K1_scaled(double x);


/* Scaled irregular modified Bessel function
 *  exp(x) K_n(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Kn_scaled_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Kn_scaled(int n, double x);


/* Scaled irregular modified Bessel function  exp(x) K_n(x)  for n=nmin,...,nmax
 *
 * x > 0.0, nmin >=0, nmax >= nmin
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Kn_scaled_array(int nmin, int nmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_Kn_scaled_array(int nmin, int nmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_Kn_scaled_array(int nmin, int nmax, double x, double[] result_array);


/* Regular spherical Bessel function j_0(x) = sin(x)/x
 *
 * exceptions: none
 */
public static native int gsl_sf_bessel_j0_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_j0(double x);


/* Regular spherical Bessel function j_1(x) = (sin(x)/x - cos(x))/x
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_j1_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_j1(double x);


/* Regular spherical Bessel function j_2(x) = ((3/x^2 - 1)sin(x) - 3cos(x)/x)/x
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_j2_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_j2(double x);


/* Regular spherical Bessel function j_l(x)
 *
 * l >= 0, x >= 0.0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_jl_e(int l, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_jl(int l, double x);


/* Regular spherical Bessel function j_l(x) for l=0,1,...,lmax
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_jl_array(int lmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_jl_array(int lmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_jl_array(int lmax, double x, double[] result_array);


/* Regular spherical Bessel function j_l(x) for l=0,1,...,lmax
 * Uses Steed's method.
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_jl_steed_array(int lmax, double x, DoublePointer jl_x_array);
public static native int gsl_sf_bessel_jl_steed_array(int lmax, double x, DoubleBuffer jl_x_array);
public static native int gsl_sf_bessel_jl_steed_array(int lmax, double x, double[] jl_x_array);


/* Irregular spherical Bessel function y_0(x)
 *
 * exceptions: none
 */
public static native int gsl_sf_bessel_y0_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_y0(double x);


/* Irregular spherical Bessel function y_1(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_y1_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_y1(double x);


/* Irregular spherical Bessel function y_2(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_y2_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_y2(double x);


/* Irregular spherical Bessel function y_l(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_yl_e(int l, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_yl(int l, double x);


/* Irregular spherical Bessel function y_l(x) for l=0,1,...,lmax
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_yl_array(int lmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_yl_array(int lmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_yl_array(int lmax, double x, double[] result_array);


/* Regular scaled modified spherical Bessel function
 *
 * Exp[-|x|] i_0(x)
 *
 * exceptions: none
 */
public static native int gsl_sf_bessel_i0_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_i0_scaled(double x);


/* Regular scaled modified spherical Bessel function
 *
 * Exp[-|x|] i_1(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_i1_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_i1_scaled(double x);


/* Regular scaled modified spherical Bessel function
 *
 * Exp[-|x|] i_2(x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_i2_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_i2_scaled(double x);


/* Regular scaled modified spherical Bessel functions
 *
 * Exp[-|x|] i_l(x)
 *
 * i_l(x) = Sqrt[Pi/(2x)] BesselI[l+1/2,x]
 *
 * l >= 0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_il_scaled_e(int l, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_il_scaled(int l, double x);


/* Regular scaled modified spherical Bessel functions
 *
 * Exp[-|x|] i_l(x)
 * for l=0,1,...,lmax
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_il_scaled_array(int lmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_il_scaled_array(int lmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_il_scaled_array(int lmax, double x, double[] result_array);


/* Irregular scaled modified spherical Bessel function
 * Exp[x] k_0(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_k0_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_k0_scaled(double x);


/* Irregular modified spherical Bessel function
 * Exp[x] k_1(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_bessel_k1_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_k1_scaled(double x);


/* Irregular modified spherical Bessel function
 * Exp[x] k_2(x)
 *
 * x > 0.0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_bessel_k2_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_bessel_k2_scaled(double x);


/* Irregular modified spherical Bessel function
 * Exp[x] k_l[x]
 *
 * k_l(x) = Sqrt[Pi/(2x)] BesselK[l+1/2,x]
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_kl_scaled_e(int l, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_kl_scaled(int l, double x);


/* Irregular scaled modified spherical Bessel function
 * Exp[x] k_l(x)
 *
 * for l=0,1,...,lmax
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_kl_scaled_array(int lmax, double x, DoublePointer result_array);
public static native int gsl_sf_bessel_kl_scaled_array(int lmax, double x, DoubleBuffer result_array);
public static native int gsl_sf_bessel_kl_scaled_array(int lmax, double x, double[] result_array);


/* Regular cylindrical Bessel function J_nu(x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Jnu_e(double nu, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Jnu(double nu, double x);


/* Irregular cylindrical Bessel function Y_nu(x)
 *
 * exceptions:  
 */
public static native int gsl_sf_bessel_Ynu_e(double nu, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Ynu(double nu, double x);


/* Regular cylindrical Bessel function J_nu(x)
 * evaluated at a series of x values. The array
 * contains the x values. They are assumed to be
 * strictly ordered and positive. The array is
 * over-written with the values of J_nu(x_i).
 *
 * exceptions: GSL_EDOM, GSL_EINVAL
 */
public static native int gsl_sf_bessel_sequence_Jnu_e(double nu, @Cast("gsl_mode_t") int mode, @Cast("size_t") long size, DoublePointer v);
public static native int gsl_sf_bessel_sequence_Jnu_e(double nu, @Cast("gsl_mode_t") int mode, @Cast("size_t") long size, DoubleBuffer v);
public static native int gsl_sf_bessel_sequence_Jnu_e(double nu, @Cast("gsl_mode_t") int mode, @Cast("size_t") long size, double[] v);


/* Scaled modified cylindrical Bessel functions
 *
 * Exp[-|x|] BesselI[nu, x]
 * x >= 0, nu >= 0
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_bessel_Inu_scaled_e(double nu, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Inu_scaled(double nu, double x);


/* Modified cylindrical Bessel functions
 *
 * BesselI[nu, x]
 * x >= 0, nu >= 0
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_bessel_Inu_e(double nu, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Inu(double nu, double x);


/* Scaled modified cylindrical Bessel functions
 *
 * Exp[+|x|] BesselK[nu, x]
 * x > 0, nu >= 0
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_bessel_Knu_scaled_e(double nu, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Knu_scaled(double nu, double x);

public static native int gsl_sf_bessel_Knu_scaled_e10_e(double nu, double x, gsl_sf_result_e10 result);

/* Modified cylindrical Bessel functions
 *
 * BesselK[nu, x]
 * x > 0, nu >= 0
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_bessel_Knu_e(double nu, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_Knu(double nu, double x);


/* Logarithm of modified cylindrical Bessel functions.
 *
 * Log[BesselK[nu, x]]
 * x > 0, nu >= 0
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_bessel_lnKnu_e(double nu, double x, gsl_sf_result result);
public static native double gsl_sf_bessel_lnKnu(double nu, double x);


/* s'th positive zero of the Bessel function J_0(x).
 *
 * exceptions: 
 */
public static native int gsl_sf_bessel_zero_J0_e(@Cast("unsigned int") int s, gsl_sf_result result);
public static native double gsl_sf_bessel_zero_J0(@Cast("unsigned int") int s);


/* s'th positive zero of the Bessel function J_1(x).
 *
 * exceptions: 
 */
public static native int gsl_sf_bessel_zero_J1_e(@Cast("unsigned int") int s, gsl_sf_result result);
public static native double gsl_sf_bessel_zero_J1(@Cast("unsigned int") int s);


/* s'th positive zero of the Bessel function J_nu(x).
 *
 * exceptions: 
 */
public static native int gsl_sf_bessel_zero_Jnu_e(double nu, @Cast("unsigned int") int s, gsl_sf_result result);
public static native double gsl_sf_bessel_zero_Jnu(double nu, @Cast("unsigned int") int s);

// #endif /* __GSL_SF_BESSEL_H__ */


// Parsed from gsl/gsl_sf_clausen.h

/* specfunc/gsl_sf_clausen.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_CLAUSEN_H__
// #define __GSL_SF_CLAUSEN_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Calculate the Clausen integral:
 *   Cl_2(x) := Integrate[-Log[2 Sin[t/2]], {t,0,x}]
 *
 * Relation to dilogarithm:
 *   Cl_2(theta) = Im[ Li_2(e^(i theta)) ]
 */
public static native int gsl_sf_clausen_e(double x, gsl_sf_result result);
public static native double gsl_sf_clausen(double x);

// #endif /* __GSL_SF_CLAUSEN_H__ */


// Parsed from gsl/gsl_sf_coulomb.h

/* specfunc/gsl_sf_coulomb.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_COULOMB_H__
// #define __GSL_SF_COULOMB_H__

// #include <gsl/gsl_mode.h>
// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Normalized hydrogenic bound states, radial dependence. */

/* R_1 := 2Z sqrt(Z) exp(-Z r)
 */
public static native int gsl_sf_hydrogenicR_1_e(double Z, double r, gsl_sf_result result);
public static native double gsl_sf_hydrogenicR_1(double Z, double r);

/* R_n := norm exp(-Z r/n) (2Z/n)^l Laguerre[n-l-1, 2l+1, 2Z/n r]
 *
 * normalization such that psi(n,l,r) = R_n Y_{lm}
 */
public static native int gsl_sf_hydrogenicR_e(int n, int l, double Z, double r, gsl_sf_result result);
public static native double gsl_sf_hydrogenicR(int n, int l, double Z, double r);


/* Coulomb wave functions F_{lam_F}(eta,x), G_{lam_G}(eta,x)
 * and their derivatives; lam_G := lam_F - k_lam_G
 *
 * lam_F, lam_G > -0.5
 * x > 0.0
 *
 * Conventions of Abramowitz+Stegun.
 *
 * Because there can be a large dynamic range of values,
 * overflows are handled gracefully. If an overflow occurs,
 * GSL_EOVRFLW is signalled and exponent(s) are returned
 * through exp_F, exp_G. These are such that
 *
 *   F_L(eta,x)  =  fc[k_L] * exp(exp_F)
 *   G_L(eta,x)  =  gc[k_L] * exp(exp_G)
 *   F_L'(eta,x) = fcp[k_L] * exp(exp_F)
 *   G_L'(eta,x) = gcp[k_L] * exp(exp_G)
 */
public static native int gsl_sf_coulomb_wave_FG_e(double eta, double x,
                            double lam_F,
                            int k_lam_G,
                            gsl_sf_result F, gsl_sf_result Fp,
                            gsl_sf_result G, gsl_sf_result Gp,
                            DoublePointer exp_F, DoublePointer exp_G);
public static native int gsl_sf_coulomb_wave_FG_e(double eta, double x,
                            double lam_F,
                            int k_lam_G,
                            gsl_sf_result F, gsl_sf_result Fp,
                            gsl_sf_result G, gsl_sf_result Gp,
                            DoubleBuffer exp_F, DoubleBuffer exp_G);
public static native int gsl_sf_coulomb_wave_FG_e(double eta, double x,
                            double lam_F,
                            int k_lam_G,
                            gsl_sf_result F, gsl_sf_result Fp,
                            gsl_sf_result G, gsl_sf_result Gp,
                            double[] exp_F, double[] exp_G);


/* F_L(eta,x) as array */
public static native int gsl_sf_coulomb_wave_F_array(
  double lam_min, int kmax,
  double eta, double x,
  DoublePointer fc_array,
  DoublePointer F_exponent
  );
public static native int gsl_sf_coulomb_wave_F_array(
  double lam_min, int kmax,
  double eta, double x,
  DoubleBuffer fc_array,
  DoubleBuffer F_exponent
  );
public static native int gsl_sf_coulomb_wave_F_array(
  double lam_min, int kmax,
  double eta, double x,
  double[] fc_array,
  double[] F_exponent
  );

/* F_L(eta,x), G_L(eta,x) as arrays */
public static native int gsl_sf_coulomb_wave_FG_array(double lam_min, int kmax,
                                double eta, double x,
                                DoublePointer fc_array, DoublePointer gc_array,
                                DoublePointer F_exponent,
                                DoublePointer G_exponent
                                );
public static native int gsl_sf_coulomb_wave_FG_array(double lam_min, int kmax,
                                double eta, double x,
                                DoubleBuffer fc_array, DoubleBuffer gc_array,
                                DoubleBuffer F_exponent,
                                DoubleBuffer G_exponent
                                );
public static native int gsl_sf_coulomb_wave_FG_array(double lam_min, int kmax,
                                double eta, double x,
                                double[] fc_array, double[] gc_array,
                                double[] F_exponent,
                                double[] G_exponent
                                );

/* F_L(eta,x), G_L(eta,x), F'_L(eta,x), G'_L(eta,x) as arrays */
public static native int gsl_sf_coulomb_wave_FGp_array(double lam_min, int kmax,
                                double eta, double x,
                                DoublePointer fc_array, DoublePointer fcp_array,
                                DoublePointer gc_array, DoublePointer gcp_array,
                                DoublePointer F_exponent,
                                DoublePointer G_exponent
                                );
public static native int gsl_sf_coulomb_wave_FGp_array(double lam_min, int kmax,
                                double eta, double x,
                                DoubleBuffer fc_array, DoubleBuffer fcp_array,
                                DoubleBuffer gc_array, DoubleBuffer gcp_array,
                                DoubleBuffer F_exponent,
                                DoubleBuffer G_exponent
                                );
public static native int gsl_sf_coulomb_wave_FGp_array(double lam_min, int kmax,
                                double eta, double x,
                                double[] fc_array, double[] fcp_array,
                                double[] gc_array, double[] gcp_array,
                                double[] F_exponent,
                                double[] G_exponent
                                );

/* Coulomb wave function divided by the argument,
 * F(eta, x)/x. This is the function which reduces to
 * spherical Bessel functions in the limit eta->0.
 */
public static native int gsl_sf_coulomb_wave_sphF_array(double lam_min, int kmax,
                                        double eta, double x,
                                        DoublePointer fc_array,
                                        DoublePointer F_exponent
                                        );
public static native int gsl_sf_coulomb_wave_sphF_array(double lam_min, int kmax,
                                        double eta, double x,
                                        DoubleBuffer fc_array,
                                        DoubleBuffer F_exponent
                                        );
public static native int gsl_sf_coulomb_wave_sphF_array(double lam_min, int kmax,
                                        double eta, double x,
                                        double[] fc_array,
                                        double[] F_exponent
                                        );


/* Coulomb wave function normalization constant.
 * [Abramowitz+Stegun 14.1.8, 14.1.9]
 */
public static native int gsl_sf_coulomb_CL_e(double L, double eta, gsl_sf_result result);
public static native int gsl_sf_coulomb_CL_array(double Lmin, int kmax, double eta, DoublePointer cl);
public static native int gsl_sf_coulomb_CL_array(double Lmin, int kmax, double eta, DoubleBuffer cl);
public static native int gsl_sf_coulomb_CL_array(double Lmin, int kmax, double eta, double[] cl);

// #endif /* __GSL_SF_COULOMB_H__ */


// Parsed from gsl/gsl_sf_coupling.h

/* specfunc/gsl_sf_coupling.h
 * 
 * Copyright (C) 1996,1997,1998,1999,2000,2001,2002 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_COUPLING_H__
// #define __GSL_SF_COUPLING_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* 3j Symbols:  / ja jb jc \
 *              \ ma mb mc /
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_coupling_3j_e(int two_ja, int two_jb, int two_jc,
                            int two_ma, int two_mb, int two_mc,
                            gsl_sf_result result
                            );
public static native double gsl_sf_coupling_3j(int two_ja, int two_jb, int two_jc,
                          int two_ma, int two_mb, int two_mc
                          );


/* 6j Symbols:  / ja jb jc \
 *              \ jd je jf /
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_coupling_6j_e(int two_ja, int two_jb, int two_jc,
                         int two_jd, int two_je, int two_jf,
                         gsl_sf_result result
                         );
public static native double gsl_sf_coupling_6j(int two_ja, int two_jb, int two_jc,
                          int two_jd, int two_je, int two_jf
                          );

/* Racah W coefficients:
 *
 *   W(a b c d; e f) = (-1)^{a+b+c+d} / a b e \
 *                                    \ d c f /
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_coupling_RacahW_e(int two_ja, int two_jb, int two_jc,
                             int two_jd, int two_je, int two_jf,
                             gsl_sf_result result
                             );
public static native double gsl_sf_coupling_RacahW(int two_ja, int two_jb, int two_jc,
                              int two_jd, int two_je, int two_jf
                              );


/* 9j Symbols:  / ja jb jc \
 *              | jd je jf |
 *              \ jg jh ji /
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_coupling_9j_e(int two_ja, int two_jb, int two_jc,
                         int two_jd, int two_je, int two_jf,
                         int two_jg, int two_jh, int two_ji,
                         gsl_sf_result result
                         );
public static native double gsl_sf_coupling_9j(int two_ja, int two_jb, int two_jc,
                          int two_jd, int two_je, int two_jf,
                          int two_jg, int two_jh, int two_ji
                          );


/* INCORRECT version of 6j Symbols:
 * This function actually calculates
 *              / ja jb je \
 *              \ jd jc jf /
 * It represents the original implementation,
 * which had the above permutation of the
 * arguments. This was wrong and confusing,
 * and I had to fix it. Sorry for the trouble.
 * [GJ] Tue Nov 26 12:53:39 MST 2002
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
// #ifndef GSL_DISABLE_DEPRECATED
public static native int gsl_sf_coupling_6j_INCORRECT_e(int two_ja, int two_jb, int two_jc,
                                   int two_jd, int two_je, int two_jf,
                                   gsl_sf_result result
                                   );
public static native double gsl_sf_coupling_6j_INCORRECT(int two_ja, int two_jb, int two_jc,
                                    int two_jd, int two_je, int two_jf
                                    );
// #endif /* !GSL_DISABLE_DEPRECATED */

// #endif /* __GSL_SF_COUPLING_H__ */


// Parsed from gsl/gsl_sf_dawson.h

/* specfunc/gsl_sf_dawson.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_DAWSON_H__
// #define __GSL_SF_DAWSON_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Dawson's integral:
 *
 *   Exp[-x^2] Integral[ Exp[t^2], {t,0,x}]
 *
 * exceptions: GSL_EUNDRFLW;
 */
public static native int gsl_sf_dawson_e(double x, gsl_sf_result result);
public static native double gsl_sf_dawson(double x);

// #endif /* __GSL_SF_DAWSON_H__ */


// Parsed from gsl/gsl_sf_debye.h

/* specfunc/gsl_sf_debye.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */
/* augmented by D_5(x) and D_6(x) by Richard J. Mathar, 2005-11-08 */

// #ifndef __GSL_SF_DEBYE_H__
// #define __GSL_SF_DEBYE_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* D_n(x) := n/x^n Integrate[t^n/(e^t - 1), {t,0,x}] */

/* D_1(x)
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_debye_1_e(double x, gsl_sf_result result);
public static native double gsl_sf_debye_1(double x);


/* D_2(x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_debye_2_e(double x, gsl_sf_result result);
public static native double gsl_sf_debye_2(double x);


/* D_3(x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_debye_3_e(double x, gsl_sf_result result);
public static native double gsl_sf_debye_3(double x);


/* D_4(x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_debye_4_e(double x, gsl_sf_result result);
public static native double gsl_sf_debye_4(double x);

/* D_5(x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_debye_5_e(double x, gsl_sf_result result);
public static native double gsl_sf_debye_5(double x);

/* D_6(x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_debye_6_e(double x, gsl_sf_result result);
public static native double gsl_sf_debye_6(double x);

// #endif /* __GSL_SF_DEBYE_H__ */


// Parsed from gsl/gsl_sf_dilog.h

/* specfunc/gsl_sf_dilog.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_DILOG_H__
// #define __GSL_SF_DILOG_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Real part of DiLogarithm(x), for real argument.
 * In Lewin's notation, this is Li_2(x).
 *
 *   Li_2(x) = - Re[ Integrate[ Log[1-s] / s, {s, 0, x}] ]
 *
 * The function in the complex plane has a branch point
 * at z = 1; we place the cut in the conventional way,
 * on [1, +infty). This means that the value for real x > 1
 * is a matter of definition; however, this choice does not
 * affect the real part and so is not relevant to the
 * interpretation of this implemented function.
 */
public static native int gsl_sf_dilog_e(double x, gsl_sf_result result);
public static native double gsl_sf_dilog(double x);


/* DiLogarithm(z), for complex argument z = x + i y.
 * Computes the principal branch.
 *
 * Recall that the branch cut is on the real axis with x > 1.
 * The imaginary part of the computed value on the cut is given
 * by -Pi*log(x), which is the limiting value taken approaching
 * from y < 0. This is a conventional choice, though there is no
 * true standardized choice.
 *
 * Note that there is no canonical way to lift the defining
 * contour to the full Riemann surface because of the appearance
 * of a "hidden branch point" at z = 0 on non-principal sheets.
 * Experts will know the simple algebraic prescription for
 * obtaining the sheet they want; non-experts will not want
 * to know anything about it. This is why GSL chooses to compute
 * only on the principal branch.
 */
public static native int gsl_sf_complex_dilog_xy_e(
  double x,
  double y,
  gsl_sf_result result_re,
  gsl_sf_result result_im
  );



/* DiLogarithm(z), for complex argument z = r Exp[i theta].
 * Computes the principal branch, thereby assuming an
 * implicit reduction of theta to the range (-2 pi, 2 pi).
 *
 * If theta is identically zero, the imaginary part is computed
 * as if approaching from y > 0. For other values of theta no
 * special consideration is given, since it is assumed that
 * no other machine representations of multiples of pi will
 * produce y = 0 precisely. This assumption depends on some
 * subtle properties of the machine arithmetic, such as
 * correct rounding and monotonicity of the underlying
 * implementation of sin() and cos().
 *
 * This function is ok, but the interface is confusing since
 * it makes it appear that the branch structure is resolved.
 * Furthermore the handling of values close to the branch
 * cut is subtle. Perhap this interface should be deprecated.
 */
public static native int gsl_sf_complex_dilog_e(
  double r,
  double theta,
  gsl_sf_result result_re,
  gsl_sf_result result_im
  );



/* Spence integral; spence(s) := Li_2(1-s)
 *
 * This function has a branch point at 0; we place the
 * cut on (-infty,0). Because of our choice for the value
 * of Li_2(z) on the cut, spence(s) is continuous as
 * s approaches the cut from above. In other words,
 * we define spence(x) = spence(x + i 0+).
 */
public static native int gsl_sf_complex_spence_xy_e(
  double x,
  double y,
  gsl_sf_result real_sp,
  gsl_sf_result imag_sp
  );

// #endif /* __GSL_SF_DILOG_H__ */


// Parsed from gsl/gsl_sf_elementary.h

/* specfunc/gsl_sf_elementary.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

/* Miscellaneous elementary functions and operations.
 */
// #ifndef __GSL_SF_ELEMENTARY_H__
// #define __GSL_SF_ELEMENTARY_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Multiplication.
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_multiply_e(double x, double y, gsl_sf_result result);
public static native double gsl_sf_multiply(double x, double y);


/* Multiplication of quantities with associated errors.
 */
public static native int gsl_sf_multiply_err_e(double x, double dx, double y, double dy, gsl_sf_result result);

// #endif /* __GSL_SF_ELEMENTARY_H__ */


// Parsed from gsl/gsl_sf_ellint.h

/* specfunc/gsl_sf_ellint.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author: G. Jungman */

// #ifndef __GSL_SF_ELLINT_H__
// #define __GSL_SF_ELLINT_H__

// #include <gsl/gsl_mode.h>
// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Legendre form of complete elliptic integrals
 *
 * K(k) = Integral[1/Sqrt[1 - k^2 Sin[t]^2], {t, 0, Pi/2}]
 * E(k) = Integral[  Sqrt[1 - k^2 Sin[t]^2], {t, 0, Pi/2}]
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_ellint_Kcomp_e(double k, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_Kcomp(double k, @Cast("gsl_mode_t") int mode);

public static native int gsl_sf_ellint_Ecomp_e(double k, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_Ecomp(double k, @Cast("gsl_mode_t") int mode);

public static native int gsl_sf_ellint_Pcomp_e(double k, double n, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_Pcomp(double k, double n, @Cast("gsl_mode_t") int mode);

public static native int gsl_sf_ellint_Dcomp_e(double k, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_Dcomp(double k, @Cast("gsl_mode_t") int mode);


/* Legendre form of incomplete elliptic integrals
 *
 * F(phi,k)   = Integral[1/Sqrt[1 - k^2 Sin[t]^2], {t, 0, phi}]
 * E(phi,k)   = Integral[  Sqrt[1 - k^2 Sin[t]^2], {t, 0, phi}]
 * P(phi,k,n) = Integral[(1 + n Sin[t]^2)^(-1)/Sqrt[1 - k^2 Sin[t]^2], {t, 0, phi}]
 * D(phi,k,n) = R_D(1-Sin[phi]^2, 1-k^2 Sin[phi]^2, 1.0)
 *
 * F: [Carlson, Numerische Mathematik 33 (1979) 1, (4.1)]
 * E: [Carlson, ", (4.2)]
 * P: [Carlson, ", (4.3)]
 * D: [Carlson, ", (4.4)]
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_ellint_F_e(double phi, double k, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_F(double phi, double k, @Cast("gsl_mode_t") int mode);

public static native int gsl_sf_ellint_E_e(double phi, double k, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_E(double phi, double k, @Cast("gsl_mode_t") int mode);

public static native int gsl_sf_ellint_P_e(double phi, double k, double n, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_P(double phi, double k, double n, @Cast("gsl_mode_t") int mode);

public static native int gsl_sf_ellint_D_e(double phi, double k, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_D(double phi, double k, @Cast("gsl_mode_t") int mode);


/* Carlson's symmetric basis of functions
 *
 * RC(x,y)   = 1/2 Integral[(t+x)^(-1/2) (t+y)^(-1)], {t,0,Inf}]
 * RD(x,y,z) = 3/2 Integral[(t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-3/2), {t,0,Inf}]
 * RF(x,y,z) = 1/2 Integral[(t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2), {t,0,Inf}]
 * RJ(x,y,z,p) = 3/2 Integral[(t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2) (t+p)^(-1), {t,0,Inf}]
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_ellint_RC_e(double x, double y, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_RC(double x, double y, @Cast("gsl_mode_t") int mode);

public static native int gsl_sf_ellint_RD_e(double x, double y, double z, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_RD(double x, double y, double z, @Cast("gsl_mode_t") int mode);

public static native int gsl_sf_ellint_RF_e(double x, double y, double z, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_RF(double x, double y, double z, @Cast("gsl_mode_t") int mode);

public static native int gsl_sf_ellint_RJ_e(double x, double y, double z, double p, @Cast("gsl_mode_t") int mode, gsl_sf_result result);
public static native double gsl_sf_ellint_RJ(double x, double y, double z, double p, @Cast("gsl_mode_t") int mode);

// #endif /* __GSL_SF_ELLINT_H__ */


// Parsed from gsl/gsl_sf_elljac.h

/* specfunc/gsl_sf_elljac.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_ELLJAC_H__
// #define __GSL_SF_ELLJAC_H__

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Jacobian elliptic functions sn, dn, cn,
 * by descending Landen transformations
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_elljac_e(double u, double m, DoublePointer sn, DoublePointer cn, DoublePointer dn);
public static native int gsl_sf_elljac_e(double u, double m, DoubleBuffer sn, DoubleBuffer cn, DoubleBuffer dn);
public static native int gsl_sf_elljac_e(double u, double m, double[] sn, double[] cn, double[] dn);

// #endif /* __GSL_SF_ELLJAC_H__ */


// Parsed from gsl/gsl_sf_erf.h

/* specfunc/gsl_sf_erf.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_ERF_H__
// #define __GSL_SF_ERF_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Complementary Error Function
 * erfc(x) := 2/Sqrt[Pi] Integrate[Exp[-t^2], {t,x,Infinity}]
 *
 * exceptions: none
 */
public static native int gsl_sf_erfc_e(double x, gsl_sf_result result);
public static native double gsl_sf_erfc(double x);


/* Log Complementary Error Function
 *
 * exceptions: none
 */
public static native int gsl_sf_log_erfc_e(double x, gsl_sf_result result);
public static native double gsl_sf_log_erfc(double x);


/* Error Function
 * erf(x) := 2/Sqrt[Pi] Integrate[Exp[-t^2], {t,0,x}]
 *
 * exceptions: none
 */
public static native int gsl_sf_erf_e(double x, gsl_sf_result result);
public static native double gsl_sf_erf(double x);


/* Probability functions:
 * Z(x) :  Abramowitz+Stegun 26.2.1
 * Q(x) :  Abramowitz+Stegun 26.2.3
 *
 * exceptions: none
 */
public static native int gsl_sf_erf_Z_e(double x, gsl_sf_result result);
public static native int gsl_sf_erf_Q_e(double x, gsl_sf_result result);
public static native double gsl_sf_erf_Z(double x);
public static native double gsl_sf_erf_Q(double x);


/* Hazard function, also known as the inverse Mill's ratio.
 *
 *   H(x) := Z(x)/Q(x)
 *         = Sqrt[2/Pi] Exp[-x^2 / 2] / Erfc[x/Sqrt[2]]
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_hazard_e(double x, gsl_sf_result result);
public static native double gsl_sf_hazard(double x);

// #endif /* __GSL_SF_ERF_H__ */


// Parsed from gsl/gsl_sf_exp.h

/* specfunc/gsl_sf_exp.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_EXP_H__
// #define __GSL_SF_EXP_H__

// #include <gsl/gsl_sf_result.h>
// #include <gsl/gsl_precision.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

/* Provide an exp() function with GSL semantics,
 * i.e. with proper error checking, etc.
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_exp_e(double x, gsl_sf_result result);
public static native double gsl_sf_exp(double x);


/* Exp(x)
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_exp_e10_e(double x, gsl_sf_result_e10 result);


/* Exponentiate and multiply by a given factor:  y * Exp(x)
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_exp_mult_e(double x, double y, gsl_sf_result result);
public static native double gsl_sf_exp_mult(double x, double y);


/* Exponentiate and multiply by a given factor:  y * Exp(x)
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_exp_mult_e10_e(double x, double y, gsl_sf_result_e10 result);


/* exp(x)-1
 *
 * exceptions: GSL_EOVRFLW
 */
public static native int gsl_sf_expm1_e(double x, gsl_sf_result result);
public static native double gsl_sf_expm1(double x);


/* (exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + ...
 *
 * exceptions: GSL_EOVRFLW
 */
public static native int gsl_sf_exprel_e(double x, gsl_sf_result result);
public static native double gsl_sf_exprel(double x);


/* 2(exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + ...
 *
 * exceptions: GSL_EOVRFLW
 */
public static native int gsl_sf_exprel_2_e(double x, gsl_sf_result result);
public static native double gsl_sf_exprel_2(double x);


/* Similarly for the N-th generalization of
 * the above. The so-called N-relative exponential
 *
 * exprel_N(x) = N!/x^N (exp(x) - Sum[x^k/k!, {k,0,N-1}])
 *             = 1 + x/(N+1) + x^2/((N+1)(N+2)) + ...
 *             = 1F1(1,1+N,x)
 */
public static native int gsl_sf_exprel_n_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_exprel_n(int n, double x);

public static native int gsl_sf_exprel_n_CF_e(double n, double x, gsl_sf_result result);


/* Exponentiate a quantity with an associated error.
 */
public static native int gsl_sf_exp_err_e(double x, double dx, gsl_sf_result result);

/* Exponentiate a quantity with an associated error.
 */
public static native int gsl_sf_exp_err_e10_e(double x, double dx, gsl_sf_result_e10 result);


/* Exponentiate and multiply by a given factor:  y * Exp(x),
 * for quantities with associated errors.
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_exp_mult_err_e(double x, double dx, double y, double dy, gsl_sf_result result);


/* Exponentiate and multiply by a given factor:  y * Exp(x),
 * for quantities with associated errors.
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_exp_mult_err_e10_e(double x, double dx, double y, double dy, gsl_sf_result_e10 result);

// #endif /* __GSL_SF_EXP_H__ */


// Parsed from gsl/gsl_sf_expint.h

/* specfunc/gsl_sf_expint.h
 * 
 * Copyright (C) 2007 Brian Gough
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author: G. Jungman */

// #ifndef __GSL_SF_EXPINT_H__
// #define __GSL_SF_EXPINT_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* E_1(x) := Re[ Integrate[ Exp[-xt]/t, {t,1,Infinity}] ]
 *
 * x != 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_expint_E1_e(double x, gsl_sf_result result);
public static native double gsl_sf_expint_E1(double x);


/* E_2(x) := Re[ Integrate[ Exp[-xt]/t^2, {t,1,Infinity}] ]
 *
 * x != 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_expint_E2_e(double x, gsl_sf_result result);
public static native double gsl_sf_expint_E2(double x);


/* E_n(x) := Re[ Integrate[ Exp[-xt]/t^n, {t,1,Infinity}] ]
 *
 * x != 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_expint_En_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_expint_En(int n, double x);


/* E_1_scaled(x) := exp(x) E_1(x)
 *
 * x != 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_expint_E1_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_expint_E1_scaled(double x);


/* E_2_scaled(x) := exp(x) E_2(x)
 *
 * x != 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_expint_E2_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_expint_E2_scaled(double x);

/* E_n_scaled(x) := exp(x) E_n(x)
 *
 * x != 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_expint_En_scaled_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_expint_En_scaled(int n, double x);


/* Ei(x) := - PV Integrate[ Exp[-t]/t, {t,-x,Infinity}]
 *       :=   PV Integrate[ Exp[t]/t, {t,-Infinity,x}]
 *
 * x != 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_expint_Ei_e(double x, gsl_sf_result result);
public static native double gsl_sf_expint_Ei(double x);


/* Ei_scaled(x) := exp(-x) Ei(x)
 *
 * x != 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_expint_Ei_scaled_e(double x, gsl_sf_result result);
public static native double gsl_sf_expint_Ei_scaled(double x);


/* Shi(x) := Integrate[ Sinh[t]/t, {t,0,x}]
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_Shi_e(double x, gsl_sf_result result);
public static native double gsl_sf_Shi(double x);


/* Chi(x) := Re[ M_EULER + log(x) + Integrate[(Cosh[t]-1)/t, {t,0,x}] ]
 *
 * x != 0.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_Chi_e(double x, gsl_sf_result result);
public static native double gsl_sf_Chi(double x);


/* Ei_3(x) := Integral[ Exp[-t^3], {t,0,x}]
 *
 * x >= 0.0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_expint_3_e(double x, gsl_sf_result result);
public static native double gsl_sf_expint_3(double x);


/* Si(x) := Integrate[ Sin[t]/t, {t,0,x}]
 *
 * exceptions: none
 */
public static native int gsl_sf_Si_e(double x, gsl_sf_result result);
public static native double gsl_sf_Si(double x);


/* Ci(x) := -Integrate[ Cos[t]/t, {t,x,Infinity}]
 *
 * x > 0.0
 * exceptions: GSL_EDOM 
 */
public static native int gsl_sf_Ci_e(double x, gsl_sf_result result);
public static native double gsl_sf_Ci(double x);


/* AtanInt(x) := Integral[ Arctan[t]/t, {t,0,x}]
 *
 *
 * exceptions:
 */
public static native int gsl_sf_atanint_e(double x, gsl_sf_result result);
public static native double gsl_sf_atanint(double x);

// #endif /* __GSL_SF_EXPINT_H__ */


// Parsed from gsl/gsl_sf_fermi_dirac.h

/* specfunc/gsl_sf_fermi_dirac.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_FERMI_DIRAC_H__
// #define __GSL_SF_FERMI_DIRAC_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Complete Fermi-Dirac Integrals:
 *
 *  F_j(x)   := 1/Gamma[j+1] Integral[ t^j /(Exp[t-x] + 1), {t,0,Infinity}]
 *
 *
 * Incomplete Fermi-Dirac Integrals:
 *
 *  F_j(x,b) := 1/Gamma[j+1] Integral[ t^j /(Exp[t-x] + 1), {t,b,Infinity}]
 */


/* Complete integral F_{-1}(x) = e^x / (1 + e^x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_fermi_dirac_m1_e(double x, gsl_sf_result result);
public static native double gsl_sf_fermi_dirac_m1(double x);


/* Complete integral F_0(x) = ln(1 + e^x)
 *
 * exceptions: GSL_EUNDRFLW
 */
public static native int gsl_sf_fermi_dirac_0_e(double x, gsl_sf_result result);
public static native double gsl_sf_fermi_dirac_0(double x);


/* Complete integral F_1(x)
 *
 * exceptions: GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_fermi_dirac_1_e(double x, gsl_sf_result result);
public static native double gsl_sf_fermi_dirac_1(double x);


/* Complete integral F_2(x)
 *
 * exceptions: GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_fermi_dirac_2_e(double x, gsl_sf_result result);
public static native double gsl_sf_fermi_dirac_2(double x);


/* Complete integral F_j(x)
 * for integer j
 *
 * exceptions: GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_fermi_dirac_int_e(int j, double x, gsl_sf_result result);
public static native double gsl_sf_fermi_dirac_int(int j, double x);


/* Complete integral F_{-1/2}(x)
 *
 * exceptions: GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_fermi_dirac_mhalf_e(double x, gsl_sf_result result);
public static native double gsl_sf_fermi_dirac_mhalf(double x);


/* Complete integral F_{1/2}(x)
 *
 * exceptions: GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_fermi_dirac_half_e(double x, gsl_sf_result result);
public static native double gsl_sf_fermi_dirac_half(double x);


/* Complete integral F_{3/2}(x)
 *
 * exceptions: GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_fermi_dirac_3half_e(double x, gsl_sf_result result);
public static native double gsl_sf_fermi_dirac_3half(double x);


/* Incomplete integral F_0(x,b) = ln(1 + e^(b-x)) - (b-x)
 *
 * exceptions: GSL_EUNDRFLW, GSL_EDOM
 */
public static native int gsl_sf_fermi_dirac_inc_0_e(double x, double b, gsl_sf_result result);
public static native double gsl_sf_fermi_dirac_inc_0(double x, double b);

// #endif /* __GSL_SF_FERMI_DIRAC_H__ */


// Parsed from gsl/gsl_sf_gamma.h

/* specfunc/gsl_sf_gamma.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_GAMMA_H__
// #define __GSL_SF_GAMMA_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Log[Gamma(x)], x not a negative integer
 * Uses real Lanczos method.
 * Returns the real part of Log[Gamma[x]] when x < 0,
 * i.e. Log[|Gamma[x]|].
 *
 * exceptions: GSL_EDOM, GSL_EROUND
 */
public static native int gsl_sf_lngamma_e(double x, gsl_sf_result result);
public static native double gsl_sf_lngamma(double x);


/* Log[Gamma(x)], x not a negative integer
 * Uses real Lanczos method. Determines
 * the sign of Gamma[x] as well as Log[|Gamma[x]|] for x < 0.
 * So Gamma[x] = sgn * Exp[result_lg].
 *
 * exceptions: GSL_EDOM, GSL_EROUND
 */
public static native int gsl_sf_lngamma_sgn_e(double x, gsl_sf_result result_lg, DoublePointer sgn);
public static native int gsl_sf_lngamma_sgn_e(double x, gsl_sf_result result_lg, DoubleBuffer sgn);
public static native int gsl_sf_lngamma_sgn_e(double x, gsl_sf_result result_lg, double[] sgn);


/* Gamma(x), x not a negative integer
 * Uses real Lanczos method.
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EROUND
 */
public static native int gsl_sf_gamma_e(double x, gsl_sf_result result);
public static native double gsl_sf_gamma(double x);


/* Regulated Gamma Function, x > 0
 * Gamma^*(x) = Gamma(x)/(Sqrt[2Pi] x^(x-1/2) exp(-x))
 *            = (1 + 1/(12x) + ...),  x->Inf
 * A useful suggestion of Temme.
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_gammastar_e(double x, gsl_sf_result result);
public static native double gsl_sf_gammastar(double x);


/* 1/Gamma(x)
 * Uses real Lanczos method.
 *
 * exceptions: GSL_EUNDRFLW, GSL_EROUND
 */
public static native int gsl_sf_gammainv_e(double x, gsl_sf_result result);
public static native double gsl_sf_gammainv(double x);


/* Log[Gamma(z)] for z complex, z not a negative integer
 * Uses complex Lanczos method. Note that the phase part (arg)
 * is not well-determined when |z| is very large, due
 * to inevitable roundoff in restricting to (-Pi,Pi].
 * This will raise the GSL_ELOSS exception when it occurs.
 * The absolute value part (lnr), however, never suffers.
 *
 * Calculates:
 *   lnr = log|Gamma(z)|
 *   arg = arg(Gamma(z))  in (-Pi, Pi]
 *
 * exceptions: GSL_EDOM, GSL_ELOSS
 */
public static native int gsl_sf_lngamma_complex_e(double zr, double zi, gsl_sf_result lnr, gsl_sf_result arg);


/* x^n / n!
 *
 * x >= 0.0, n >= 0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_taylorcoeff_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_taylorcoeff(int n, double x);


/* n!
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_fact_e(@Cast("const unsigned int") int n, gsl_sf_result result);
public static native double gsl_sf_fact(@Cast("const unsigned int") int n);


/* n!! = n(n-2)(n-4) ... 
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_doublefact_e(@Cast("const unsigned int") int n, gsl_sf_result result);
public static native double gsl_sf_doublefact(@Cast("const unsigned int") int n);


/* log(n!) 
 * Faster than ln(Gamma(n+1)) for n < 170; defers for larger n.
 *
 * exceptions: none
 */
public static native int gsl_sf_lnfact_e(@Cast("const unsigned int") int n, gsl_sf_result result);
public static native double gsl_sf_lnfact(@Cast("const unsigned int") int n);


/* log(n!!) 
 *
 * exceptions: none
 */
public static native int gsl_sf_lndoublefact_e(@Cast("const unsigned int") int n, gsl_sf_result result);
public static native double gsl_sf_lndoublefact(@Cast("const unsigned int") int n);


/* log(n choose m)
 *
 * exceptions: GSL_EDOM 
 */
public static native int gsl_sf_lnchoose_e(@Cast("unsigned int") int n, @Cast("unsigned int") int m, gsl_sf_result result);
public static native double gsl_sf_lnchoose(@Cast("unsigned int") int n, @Cast("unsigned int") int m);


/* n choose m
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_choose_e(@Cast("unsigned int") int n, @Cast("unsigned int") int m, gsl_sf_result result);
public static native double gsl_sf_choose(@Cast("unsigned int") int n, @Cast("unsigned int") int m);


/* Logarithm of Pochhammer (Apell) symbol
 *   log( (a)_x )
 *   where (a)_x := Gamma[a + x]/Gamma[a]
 *
 * a > 0, a+x > 0
 *
 * exceptions:  GSL_EDOM
 */
public static native int gsl_sf_lnpoch_e(double a, double x, gsl_sf_result result);
public static native double gsl_sf_lnpoch(double a, double x);


/* Logarithm of Pochhammer (Apell) symbol, with sign information.
 *   result = log( |(a)_x| )
 *   sgn    = sgn( (a)_x )
 *   where (a)_x := Gamma[a + x]/Gamma[a]
 *
 * a != neg integer, a+x != neg integer
 *
 * exceptions:  GSL_EDOM
 */
public static native int gsl_sf_lnpoch_sgn_e(double a, double x, gsl_sf_result result, DoublePointer sgn);
public static native int gsl_sf_lnpoch_sgn_e(double a, double x, gsl_sf_result result, DoubleBuffer sgn);
public static native int gsl_sf_lnpoch_sgn_e(double a, double x, gsl_sf_result result, double[] sgn);


/* Pochhammer (Apell) symbol
 *   (a)_x := Gamma[a + x]/Gamma[x]
 *
 * a != neg integer, a+x != neg integer
 *
 * exceptions:  GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_poch_e(double a, double x, gsl_sf_result result);
public static native double gsl_sf_poch(double a, double x);


/* Relative Pochhammer (Apell) symbol
 *   ((a,x) - 1)/x
 *   where (a,x) = (a)_x := Gamma[a + x]/Gamma[a]
 *
 * exceptions:  GSL_EDOM
 */
public static native int gsl_sf_pochrel_e(double a, double x, gsl_sf_result result);
public static native double gsl_sf_pochrel(double a, double x);


/* Normalized Incomplete Gamma Function
 *
 * Q(a,x) = 1/Gamma(a) Integral[ t^(a-1) e^(-t), {t,x,Infinity} ]
 *
 * a >= 0, x >= 0
 *   Q(a,0) := 1
 *   Q(0,x) := 0, x != 0
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_gamma_inc_Q_e(double a, double x, gsl_sf_result result);
public static native double gsl_sf_gamma_inc_Q(double a, double x);


/* Complementary Normalized Incomplete Gamma Function
 *
 * P(a,x) = 1/Gamma(a) Integral[ t^(a-1) e^(-t), {t,0,x} ]
 *
 * a > 0, x >= 0
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_gamma_inc_P_e(double a, double x, gsl_sf_result result);
public static native double gsl_sf_gamma_inc_P(double a, double x);


/* Non-normalized Incomplete Gamma Function
 *
 * Gamma(a,x) := Integral[ t^(a-1) e^(-t), {t,x,Infinity} ]
 *
 * x >= 0.0
 *   Gamma(a, 0) := Gamma(a)
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_gamma_inc_e(double a, double x, gsl_sf_result result);
public static native double gsl_sf_gamma_inc(double a, double x);


/* Logarithm of Beta Function
 * Log[B(a,b)]
 *
 * a > 0, b > 0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_lnbeta_e(double a, double b, gsl_sf_result result);
public static native double gsl_sf_lnbeta(double a, double b);

public static native int gsl_sf_lnbeta_sgn_e(double x, double y, gsl_sf_result result, DoublePointer sgn);
public static native int gsl_sf_lnbeta_sgn_e(double x, double y, gsl_sf_result result, DoubleBuffer sgn);
public static native int gsl_sf_lnbeta_sgn_e(double x, double y, gsl_sf_result result, double[] sgn);


/* Beta Function
 * B(a,b)
 *
 * a > 0, b > 0
 * exceptions: GSL_EDOM, GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_beta_e(double a, double b, gsl_sf_result result);
public static native double gsl_sf_beta(double a, double b);


/* Normalized Incomplete Beta Function
 * B_x(a,b)/B(a,b)
 *
 * a > 0, b > 0, 0 <= x <= 1
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_beta_inc_e(double a, double b, double x, gsl_sf_result result);
public static native double gsl_sf_beta_inc(double a, double b, double x);


/* The maximum x such that gamma(x) is not
 * considered an overflow.
 */
public static final double GSL_SF_GAMMA_XMAX =  171.0;

/* The maximum n such that gsl_sf_fact(n) does not give an overflow. */
public static final int GSL_SF_FACT_NMAX = 170;

/* The maximum n such that gsl_sf_doublefact(n) does not give an overflow. */
public static final int GSL_SF_DOUBLEFACT_NMAX = 297;

// #endif /* __GSL_SF_GAMMA_H__ */


// Parsed from gsl/gsl_sf_gegenbauer.h

/* specfunc/gsl_sf_gegenbauer.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_GEGENBAUER_H__
// #define __GSL_SF_GEGENBAUER_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Evaluate Gegenbauer polynomials
 * using explicit representations.
 *
 * exceptions: none
 */
public static native int gsl_sf_gegenpoly_1_e(double lambda, double x, gsl_sf_result result);
public static native int gsl_sf_gegenpoly_2_e(double lambda, double x, gsl_sf_result result);
public static native int gsl_sf_gegenpoly_3_e(double lambda, double x, gsl_sf_result result);
public static native double gsl_sf_gegenpoly_1(double lambda, double x);
public static native double gsl_sf_gegenpoly_2(double lambda, double x);
public static native double gsl_sf_gegenpoly_3(double lambda, double x);


/* Evaluate Gegenbauer polynomials.
 *
 * lambda > -1/2, n >= 0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_gegenpoly_n_e(int n, double lambda, double x, gsl_sf_result result);
public static native double gsl_sf_gegenpoly_n(int n, double lambda, double x);


/* Calculate array of Gegenbauer polynomials
 * for n = (0, 1, 2, ... nmax)
 *
 * lambda > -1/2, nmax >= 0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_gegenpoly_array(int nmax, double lambda, double x, DoublePointer result_array);
public static native int gsl_sf_gegenpoly_array(int nmax, double lambda, double x, DoubleBuffer result_array);
public static native int gsl_sf_gegenpoly_array(int nmax, double lambda, double x, double[] result_array);

// #endif /* __GSL_SF_GEGENBAUER_H__ */


// Parsed from gsl/gsl_sf_hyperg.h

/* specfunc/gsl_sf_hyperg.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_HYPERG_H__
// #define __GSL_SF_HYPERG_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Hypergeometric function related to Bessel functions
 * 0F1[c,x] =
 *            Gamma[c]    x^(1/2(1-c)) I_{c-1}(2 Sqrt[x])
 *            Gamma[c] (-x)^(1/2(1-c)) J_{c-1}(2 Sqrt[-x])
 *
 * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW
 */
public static native int gsl_sf_hyperg_0F1_e(double c, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_0F1(double c, double x);


/* Confluent hypergeometric function  for integer parameters.
 * 1F1[m,n,x] = M(m,n,x)
 *
 * exceptions: 
 */
public static native int gsl_sf_hyperg_1F1_int_e(int m, int n, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_1F1_int(int m, int n, double x);


/* Confluent hypergeometric function.
 * 1F1[a,b,x] = M(a,b,x)
 *
 * exceptions:
 */
public static native int gsl_sf_hyperg_1F1_e(double a, double b, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_1F1(double a, double b, double x);


/* Confluent hypergeometric function for integer parameters.
 * U(m,n,x)
 *
 * exceptions:
 */
public static native int gsl_sf_hyperg_U_int_e(int m, int n, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_U_int(int m, int n, double x);


/* Confluent hypergeometric function for integer parameters.
 * U(m,n,x)
 *
 * exceptions:
 */
public static native int gsl_sf_hyperg_U_int_e10_e(int m, int n, double x, gsl_sf_result_e10 result);


/* Confluent hypergeometric function.
 * U(a,b,x)
 *
 * exceptions:
 */
public static native int gsl_sf_hyperg_U_e(double a, double b, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_U(double a, double b, double x);


/* Confluent hypergeometric function.
 * U(a,b,x)
 *
 * exceptions:
 */
public static native int gsl_sf_hyperg_U_e10_e(double a, double b, double x, gsl_sf_result_e10 result);


/* Gauss hypergeometric function 2F1[a,b,c,x]
 * |x| < 1
 *
 * exceptions:
 */
public static native int gsl_sf_hyperg_2F1_e(double a, double b, double c, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_2F1(double a, double b, double c, double x);


/* Gauss hypergeometric function
 * 2F1[aR + I aI, aR - I aI, c, x]
 * |x| < 1
 *
 * exceptions:
 */
public static native int gsl_sf_hyperg_2F1_conj_e(double aR, double aI, double c, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_2F1_conj(double aR, double aI, double c, double x);


/* Renormalized Gauss hypergeometric function
 * 2F1[a,b,c,x] / Gamma[c]
 * |x| < 1
 *
 * exceptions:
 */
public static native int gsl_sf_hyperg_2F1_renorm_e(double a, double b, double c, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_2F1_renorm(double a, double b, double c, double x);


/* Renormalized Gauss hypergeometric function
 * 2F1[aR + I aI, aR - I aI, c, x] / Gamma[c]
 * |x| < 1
 *
 * exceptions:
 */
public static native int gsl_sf_hyperg_2F1_conj_renorm_e(double aR, double aI, double c, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_2F1_conj_renorm(double aR, double aI, double c, double x);


/* Mysterious hypergeometric function. The series representation
 * is a divergent hypergeometric series. However, for x < 0 we
 * have 2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_hyperg_2F0_e(double a, double b, double x, gsl_sf_result result);
public static native double gsl_sf_hyperg_2F0(double a, double b, double x);

// #endif /* __GSL_SF_HYPERG_H__ */


// Parsed from gsl/gsl_sf_laguerre.h

/* specfunc/gsl_sf_laguerre.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_LAGUERRE_H__
// #define __GSL_SF_LAGUERRE_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* L^a_n(x) = (a+1)_n / n! 1F1(-n,a+1,x) */


/* Evaluate generalized Laguerre polynomials
 * using explicit representations.
 *
 * exceptions: none
 */
public static native int gsl_sf_laguerre_1_e(double a, double x, gsl_sf_result result);
public static native int gsl_sf_laguerre_2_e(double a, double x, gsl_sf_result result);
public static native int gsl_sf_laguerre_3_e(double a, double x, gsl_sf_result result);
public static native double gsl_sf_laguerre_1(double a, double x);
public static native double gsl_sf_laguerre_2(double a, double x);
public static native double gsl_sf_laguerre_3(double a, double x);


/* Evaluate generalized Laguerre polynomials.
 *
 * a > -1.0
 * n >= 0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_laguerre_n_e(int n, double a, double x, gsl_sf_result result);
public static native double gsl_sf_laguerre_n(int n, double a, double x);

// #endif /* __GSL_SF_LAGUERRE_H__ */


// Parsed from gsl/gsl_sf_lambert.h

/* specfunc/gsl_sf_lambert.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_LAMBERT_H__
// #define __GSL_SF_LAMBERT_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Lambert's Function W_0(x)
 *
 * W_0(x) is the principal branch of the
 * implicit function defined by W e^W = x.
 *
 * -1/E < x < \infty
 *
 * exceptions: GSL_EMAXITER;
 */
public static native int gsl_sf_lambert_W0_e(double x, gsl_sf_result result);
public static native double gsl_sf_lambert_W0(double x);


/* Lambert's Function W_{-1}(x)
 *
 * W_{-1}(x) is the second real branch of the
 * implicit function defined by W e^W = x.
 * It agrees with W_0(x) when x >= 0.
 *
 * -1/E < x < \infty
 *
 * exceptions: GSL_MAXITER;
 */
public static native int gsl_sf_lambert_Wm1_e(double x, gsl_sf_result result);
public static native double gsl_sf_lambert_Wm1(double x);

// #endif /* __GSL_SF_LAMBERT_H__ */


// Parsed from gsl/gsl_sf_legendre.h

/* specfunc/gsl_sf_legendre.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_LEGENDRE_H__
// #define __GSL_SF_LEGENDRE_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* P_l(x)   l >= 0; |x| <= 1
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_Pl_e(int l, double x, gsl_sf_result result);
public static native double gsl_sf_legendre_Pl(int l, double x);


/* P_l(x) for l=0,...,lmax; |x| <= 1
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_Pl_array(
  int lmax, double x,
  DoublePointer result_array
  );
public static native int gsl_sf_legendre_Pl_array(
  int lmax, double x,
  DoubleBuffer result_array
  );
public static native int gsl_sf_legendre_Pl_array(
  int lmax, double x,
  double[] result_array
  );


/* P_l(x) and P_l'(x) for l=0,...,lmax; |x| <= 1
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_Pl_deriv_array(
  int lmax, double x,
  DoublePointer result_array,
  DoublePointer result_deriv_array
  );
public static native int gsl_sf_legendre_Pl_deriv_array(
  int lmax, double x,
  DoubleBuffer result_array,
  DoubleBuffer result_deriv_array
  );
public static native int gsl_sf_legendre_Pl_deriv_array(
  int lmax, double x,
  double[] result_array,
  double[] result_deriv_array
  );


/* P_l(x), l=1,2,3
 *
 * exceptions: none
 */
public static native int gsl_sf_legendre_P1_e(double x, gsl_sf_result result);
public static native int gsl_sf_legendre_P2_e(double x, gsl_sf_result result);
public static native int gsl_sf_legendre_P3_e(double x, gsl_sf_result result);
public static native double gsl_sf_legendre_P1(double x);
public static native double gsl_sf_legendre_P2(double x);
public static native double gsl_sf_legendre_P3(double x);


/* Q_0(x), x > -1, x != 1
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_Q0_e(double x, gsl_sf_result result);
public static native double gsl_sf_legendre_Q0(double x);


/* Q_1(x), x > -1, x != 1
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_Q1_e(double x, gsl_sf_result result);
public static native double gsl_sf_legendre_Q1(double x);


/* Q_l(x), x > -1, x != 1, l >= 0
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_Ql_e(int l, double x, gsl_sf_result result);
public static native double gsl_sf_legendre_Ql(int l, double x);


/* P_l^m(x)  m >= 0; l >= m; |x| <= 1.0
 *
 * Note that this function grows combinatorially with l.
 * Therefore we can easily generate an overflow for l larger
 * than about 150.
 *
 * There is no trouble for small m, but when m and l are both large,
 * then there will be trouble. Rather than allow overflows, these
 * functions refuse to calculate when they can sense that l and m are
 * too big.
 *
 * If you really want to calculate a spherical harmonic, then DO NOT
 * use this. Instead use legendre_sphPlm() below, which  uses a similar
 * recursion, but with the normalized functions.
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_legendre_Plm_e(int l, int m, double x, gsl_sf_result result);
public static native double gsl_sf_legendre_Plm(int l, int m, double x);


/* P_l^m(x)  m >= 0; l >= m; |x| <= 1.0
 * l=|m|,...,lmax
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */



/* P_l^m(x)  and d(P_l^m(x))/dx;  m >= 0; lmax >= m; |x| <= 1.0
 * l=|m|,...,lmax
 *
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */



/* P_l^m(x), normalized properly for use in spherical harmonics
 * m >= 0; l >= m; |x| <= 1.0
 *
 * There is no overflow problem, as there is for the
 * standard normalization of P_l^m(x).
 *
 * Specifically, it returns:
 *
 *        sqrt((2l+1)/(4pi)) sqrt((l-m)!/(l+m)!) P_l^m(x)
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_sphPlm_e(int l, int m, double x, gsl_sf_result result);
public static native double gsl_sf_legendre_sphPlm(int l, int m, double x);


/* sphPlm(l,m,x) values
 * m >= 0; l >= m; |x| <= 1.0
 * l=|m|,...,lmax
 *
 * exceptions: GSL_EDOM
 */



/* sphPlm(l,m,x) and d(sphPlm(l,m,x))/dx values
 * m >= 0; l >= m; |x| <= 1.0
 * l=|m|,...,lmax
 *
 * exceptions: GSL_EDOM
 */




/* size of result_array[] needed for the array versions of Plm
 * (lmax - m + 1)
 */


/* Irregular Spherical Conical Function
 * P^{1/2}_{-1/2 + I lambda}(x)
 *
 * x > -1.0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_conicalP_half_e(double lambda, double x, gsl_sf_result result);
public static native double gsl_sf_conicalP_half(double lambda, double x);


/* Regular Spherical Conical Function
 * P^{-1/2}_{-1/2 + I lambda}(x)
 *
 * x > -1.0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_conicalP_mhalf_e(double lambda, double x, gsl_sf_result result);
public static native double gsl_sf_conicalP_mhalf(double lambda, double x);


/* Conical Function
 * P^{0}_{-1/2 + I lambda}(x)
 *
 * x > -1.0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_conicalP_0_e(double lambda, double x, gsl_sf_result result);
public static native double gsl_sf_conicalP_0(double lambda, double x);


/* Conical Function
 * P^{1}_{-1/2 + I lambda}(x)
 *
 * x > -1.0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_conicalP_1_e(double lambda, double x, gsl_sf_result result);
public static native double gsl_sf_conicalP_1(double lambda, double x);


/* Regular Spherical Conical Function
 * P^{-1/2-l}_{-1/2 + I lambda}(x)
 *
 * x > -1.0, l >= -1
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_conicalP_sph_reg_e(int l, double lambda, double x, gsl_sf_result result);
public static native double gsl_sf_conicalP_sph_reg(int l, double lambda, double x);


/* Regular Cylindrical Conical Function
 * P^{-m}_{-1/2 + I lambda}(x)
 *
 * x > -1.0, m >= -1
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_conicalP_cyl_reg_e(int m, double lambda, double x, gsl_sf_result result);
public static native double gsl_sf_conicalP_cyl_reg(int m, double lambda, double x);


/* The following spherical functions are specializations
 * of Legendre functions which give the regular eigenfunctions
 * of the Laplacian on a 3-dimensional hyperbolic space.
 * Of particular interest is the flat limit, which is
 * Flat-Lim := {lambda->Inf, eta->0, lambda*eta fixed}.
 */
  
/* Zeroth radial eigenfunction of the Laplacian on the
 * 3-dimensional hyperbolic space.
 *
 * legendre_H3d_0(lambda,eta) := sin(lambda*eta)/(lambda*sinh(eta))
 * 
 * Normalization:
 * Flat-Lim legendre_H3d_0(lambda,eta) = j_0(lambda*eta)
 *
 * eta >= 0.0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_H3d_0_e(double lambda, double eta, gsl_sf_result result);
public static native double gsl_sf_legendre_H3d_0(double lambda, double eta);


/* First radial eigenfunction of the Laplacian on the
 * 3-dimensional hyperbolic space.
 *
 * legendre_H3d_1(lambda,eta) :=
 *    1/sqrt(lambda^2 + 1) sin(lam eta)/(lam sinh(eta))
 *    (coth(eta) - lambda cot(lambda*eta))
 * 
 * Normalization:
 * Flat-Lim legendre_H3d_1(lambda,eta) = j_1(lambda*eta)
 *
 * eta >= 0.0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_H3d_1_e(double lambda, double eta, gsl_sf_result result);
public static native double gsl_sf_legendre_H3d_1(double lambda, double eta);


/* l'th radial eigenfunction of the Laplacian on the
 * 3-dimensional hyperbolic space.
 *
 * Normalization:
 * Flat-Lim legendre_H3d_l(l,lambda,eta) = j_l(lambda*eta)
 *
 * eta >= 0.0, l >= 0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_legendre_H3d_e(int l, double lambda, double eta, gsl_sf_result result);
public static native double gsl_sf_legendre_H3d(int l, double lambda, double eta);


/* Array of H3d(ell),  0 <= ell <= lmax
 */
public static native int gsl_sf_legendre_H3d_array(int lmax, double lambda, double eta, DoublePointer result_array);
public static native int gsl_sf_legendre_H3d_array(int lmax, double lambda, double eta, DoubleBuffer result_array);
public static native int gsl_sf_legendre_H3d_array(int lmax, double lambda, double eta, double[] result_array);

/* associated legendre P_{lm} routines */

/** enum gsl_sf_legendre_t */
public static final int
  GSL_SF_LEGENDRE_SCHMIDT = 0,
  GSL_SF_LEGENDRE_SPHARM = 1,
  GSL_SF_LEGENDRE_FULL = 2,
  GSL_SF_LEGENDRE_NONE = 3;

public static native int gsl_sf_legendre_array(@Cast("const gsl_sf_legendre_t") int norm,
                          @Cast("const size_t") long lmax, double x,
                          DoublePointer result_array);
public static native int gsl_sf_legendre_array(@Cast("const gsl_sf_legendre_t") int norm,
                          @Cast("const size_t") long lmax, double x,
                          DoubleBuffer result_array);
public static native int gsl_sf_legendre_array(@Cast("const gsl_sf_legendre_t") int norm,
                          @Cast("const size_t") long lmax, double x,
                          double[] result_array);
public static native int gsl_sf_legendre_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                            @Cast("const size_t") long lmax, double x,
                            double csphase,
                            DoublePointer result_array);
public static native int gsl_sf_legendre_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                            @Cast("const size_t") long lmax, double x,
                            double csphase,
                            DoubleBuffer result_array);
public static native int gsl_sf_legendre_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                            @Cast("const size_t") long lmax, double x,
                            double csphase,
                            double[] result_array);
public static native int gsl_sf_legendre_deriv_array(@Cast("const gsl_sf_legendre_t") int norm,
                                @Cast("const size_t") long lmax, double x,
                                DoublePointer result_array,
                                DoublePointer result_deriv_array);
public static native int gsl_sf_legendre_deriv_array(@Cast("const gsl_sf_legendre_t") int norm,
                                @Cast("const size_t") long lmax, double x,
                                DoubleBuffer result_array,
                                DoubleBuffer result_deriv_array);
public static native int gsl_sf_legendre_deriv_array(@Cast("const gsl_sf_legendre_t") int norm,
                                @Cast("const size_t") long lmax, double x,
                                double[] result_array,
                                double[] result_deriv_array);
public static native int gsl_sf_legendre_deriv_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                  @Cast("const size_t") long lmax, double x,
                                  double csphase,
                                  DoublePointer result_array,
                                  DoublePointer result_deriv_array);
public static native int gsl_sf_legendre_deriv_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                  @Cast("const size_t") long lmax, double x,
                                  double csphase,
                                  DoubleBuffer result_array,
                                  DoubleBuffer result_deriv_array);
public static native int gsl_sf_legendre_deriv_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                  @Cast("const size_t") long lmax, double x,
                                  double csphase,
                                  double[] result_array,
                                  double[] result_deriv_array);
public static native int gsl_sf_legendre_deriv_alt_array(@Cast("const gsl_sf_legendre_t") int norm,
                                    @Cast("const size_t") long lmax, double x,
                                    DoublePointer result_array,
                                    DoublePointer result_deriv_array);
public static native int gsl_sf_legendre_deriv_alt_array(@Cast("const gsl_sf_legendre_t") int norm,
                                    @Cast("const size_t") long lmax, double x,
                                    DoubleBuffer result_array,
                                    DoubleBuffer result_deriv_array);
public static native int gsl_sf_legendre_deriv_alt_array(@Cast("const gsl_sf_legendre_t") int norm,
                                    @Cast("const size_t") long lmax, double x,
                                    double[] result_array,
                                    double[] result_deriv_array);
public static native int gsl_sf_legendre_deriv_alt_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                      @Cast("const size_t") long lmax, double x,
                                      double csphase,
                                      DoublePointer result_array,
                                      DoublePointer result_deriv_array);
public static native int gsl_sf_legendre_deriv_alt_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                      @Cast("const size_t") long lmax, double x,
                                      double csphase,
                                      DoubleBuffer result_array,
                                      DoubleBuffer result_deriv_array);
public static native int gsl_sf_legendre_deriv_alt_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                      @Cast("const size_t") long lmax, double x,
                                      double csphase,
                                      double[] result_array,
                                      double[] result_deriv_array);
public static native int gsl_sf_legendre_deriv2_array(@Cast("const gsl_sf_legendre_t") int norm,
                                 @Cast("const size_t") long lmax, double x,
                                 DoublePointer result_array,
                                 DoublePointer result_deriv_array,
                                 DoublePointer result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_array(@Cast("const gsl_sf_legendre_t") int norm,
                                 @Cast("const size_t") long lmax, double x,
                                 DoubleBuffer result_array,
                                 DoubleBuffer result_deriv_array,
                                 DoubleBuffer result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_array(@Cast("const gsl_sf_legendre_t") int norm,
                                 @Cast("const size_t") long lmax, double x,
                                 double[] result_array,
                                 double[] result_deriv_array,
                                 double[] result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                   @Cast("const size_t") long lmax, double x,
                                   double csphase,
                                   DoublePointer result_array,
                                   DoublePointer result_deriv_array,
                                   DoublePointer result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                   @Cast("const size_t") long lmax, double x,
                                   double csphase,
                                   DoubleBuffer result_array,
                                   DoubleBuffer result_deriv_array,
                                   DoubleBuffer result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                   @Cast("const size_t") long lmax, double x,
                                   double csphase,
                                   double[] result_array,
                                   double[] result_deriv_array,
                                   double[] result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_alt_array(@Cast("const gsl_sf_legendre_t") int norm,
                                     @Cast("const size_t") long lmax, double x,
                                     DoublePointer result_array,
                                     DoublePointer result_deriv_array,
                                     DoublePointer result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_alt_array(@Cast("const gsl_sf_legendre_t") int norm,
                                     @Cast("const size_t") long lmax, double x,
                                     DoubleBuffer result_array,
                                     DoubleBuffer result_deriv_array,
                                     DoubleBuffer result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_alt_array(@Cast("const gsl_sf_legendre_t") int norm,
                                     @Cast("const size_t") long lmax, double x,
                                     double[] result_array,
                                     double[] result_deriv_array,
                                     double[] result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_alt_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                       @Cast("const size_t") long lmax, double x,
                                       double csphase,
                                       DoublePointer result_array,
                                       DoublePointer result_deriv_array,
                                       DoublePointer result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_alt_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                       @Cast("const size_t") long lmax, double x,
                                       double csphase,
                                       DoubleBuffer result_array,
                                       DoubleBuffer result_deriv_array,
                                       DoubleBuffer result_deriv2_array);
public static native int gsl_sf_legendre_deriv2_alt_array_e(@Cast("const gsl_sf_legendre_t") int norm,
                                       @Cast("const size_t") long lmax, double x,
                                       double csphase,
                                       double[] result_array,
                                       double[] result_deriv_array,
                                       double[] result_deriv2_array);
public static native @Cast("size_t") long gsl_sf_legendre_array_n(@Cast("const size_t") long lmax);
public static native @Cast("size_t") long gsl_sf_legendre_array_index(@Cast("const size_t") long l, @Cast("const size_t") long m);
public static native @Cast("size_t") long gsl_sf_legendre_nlm(@Cast("const size_t") long lmax);

// #endif /* __GSL_SF_LEGENDRE_H__ */


// Parsed from gsl/gsl_sf_log.h

/* specfunc/gsl_sf_log.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_LOG_H__
// #define __GSL_SF_LOG_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Provide a logarithm function with GSL semantics.
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_log_e(double x, gsl_sf_result result);
public static native double gsl_sf_log(double x);


/* Log(|x|)
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_log_abs_e(double x, gsl_sf_result result);
public static native double gsl_sf_log_abs(double x);


/* Complex Logarithm
 *   exp(lnr + I theta) = zr + I zi
 * Returns argument in [-pi,pi].
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_complex_log_e(double zr, double zi, gsl_sf_result lnr, gsl_sf_result theta);


/* Log(1 + x)
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_log_1plusx_e(double x, gsl_sf_result result);
public static native double gsl_sf_log_1plusx(double x);


/* Log(1 + x) - x
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_log_1plusx_mx_e(double x, gsl_sf_result result);
public static native double gsl_sf_log_1plusx_mx(double x);

// #endif /* __GSL_SF_LOG_H__ */


// Parsed from gsl/gsl_sf_mathieu.h

/* specfunc/gsl_sf_mathieu.h
 * 
 * Copyright (C) 2002 Lowell Johnson
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/* Author:  L. Johnson */

// #ifndef __GSL_SF_MATHIEU_H__
// #define __GSL_SF_MATHIEU_H__

// #include <gsl/gsl_sf_result.h>
// #include <gsl/gsl_eigen.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static final int GSL_SF_MATHIEU_COEFF = 100;

public static class gsl_sf_mathieu_workspace extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public gsl_sf_mathieu_workspace() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public gsl_sf_mathieu_workspace(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public gsl_sf_mathieu_workspace(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public gsl_sf_mathieu_workspace position(long position) {
        return (gsl_sf_mathieu_workspace)super.position(position);
    }

  public native @Cast("size_t") long size(); public native gsl_sf_mathieu_workspace size(long size);
  public native @Cast("size_t") long even_order(); public native gsl_sf_mathieu_workspace even_order(long even_order);
  public native @Cast("size_t") long odd_order(); public native gsl_sf_mathieu_workspace odd_order(long odd_order);
  public native int extra_values(); public native gsl_sf_mathieu_workspace extra_values(int extra_values);
  public native double qa(); public native gsl_sf_mathieu_workspace qa(double qa);   /* allow for caching of results: not implemented yet */
  public native double qb(); public native gsl_sf_mathieu_workspace qb(double qb);   /* allow for caching of results: not implemented yet */
  public native DoublePointer aa(); public native gsl_sf_mathieu_workspace aa(DoublePointer aa);
  public native DoublePointer bb(); public native gsl_sf_mathieu_workspace bb(DoublePointer bb);
  public native DoublePointer dd(); public native gsl_sf_mathieu_workspace dd(DoublePointer dd);
  public native DoublePointer ee(); public native gsl_sf_mathieu_workspace ee(DoublePointer ee);
  public native DoublePointer tt(); public native gsl_sf_mathieu_workspace tt(DoublePointer tt);
  public native DoublePointer e2(); public native gsl_sf_mathieu_workspace e2(DoublePointer e2);
  public native DoublePointer zz(); public native gsl_sf_mathieu_workspace zz(DoublePointer zz);
  public native gsl_vector eval(); public native gsl_sf_mathieu_workspace eval(gsl_vector eval);
  public native gsl_matrix evec(); public native gsl_sf_mathieu_workspace evec(gsl_matrix evec);
  public native gsl_eigen_symmv_workspace wmat(); public native gsl_sf_mathieu_workspace wmat(gsl_eigen_symmv_workspace wmat);
}


/* Compute an array of characteristic (eigen) values from the recurrence
   matrices for the Mathieu equations. */
public static native int gsl_sf_mathieu_a_array(int order_min, int order_max, double qq, gsl_sf_mathieu_workspace work, DoublePointer result_array);
public static native int gsl_sf_mathieu_a_array(int order_min, int order_max, double qq, gsl_sf_mathieu_workspace work, DoubleBuffer result_array);
public static native int gsl_sf_mathieu_a_array(int order_min, int order_max, double qq, gsl_sf_mathieu_workspace work, double[] result_array);
public static native int gsl_sf_mathieu_b_array(int order_min, int order_max, double qq,  gsl_sf_mathieu_workspace work, DoublePointer result_array);
public static native int gsl_sf_mathieu_b_array(int order_min, int order_max, double qq,  gsl_sf_mathieu_workspace work, DoubleBuffer result_array);
public static native int gsl_sf_mathieu_b_array(int order_min, int order_max, double qq,  gsl_sf_mathieu_workspace work, double[] result_array);

/* Compute the characteristic value for a Mathieu function of order n and
   type ntype. */
public static native int gsl_sf_mathieu_a_e(int order, double qq, gsl_sf_result result);
public static native double gsl_sf_mathieu_a(int order, double qq);
public static native int gsl_sf_mathieu_b_e(int order, double qq, gsl_sf_result result);
public static native double gsl_sf_mathieu_b(int order, double qq);

/* Compute the Fourier coefficients for a Mathieu function. */
public static native int gsl_sf_mathieu_a_coeff(int order, double qq, double aa, DoublePointer coeff);
public static native int gsl_sf_mathieu_a_coeff(int order, double qq, double aa, DoubleBuffer coeff);
public static native int gsl_sf_mathieu_a_coeff(int order, double qq, double aa, double[] coeff);
public static native int gsl_sf_mathieu_b_coeff(int order, double qq, double aa, DoublePointer coeff);
public static native int gsl_sf_mathieu_b_coeff(int order, double qq, double aa, DoubleBuffer coeff);
public static native int gsl_sf_mathieu_b_coeff(int order, double qq, double aa, double[] coeff);

/* Allocate computational storage space for eigenvalue solution. */
public static native gsl_sf_mathieu_workspace gsl_sf_mathieu_alloc(@Cast("const size_t") long nn,
                                               double qq);
public static native void gsl_sf_mathieu_free(gsl_sf_mathieu_workspace workspace);

/* Compute an angular Mathieu function. */
public static native int gsl_sf_mathieu_ce_e(int order, double qq, double zz, gsl_sf_result result);
public static native double gsl_sf_mathieu_ce(int order, double qq, double zz);
public static native int gsl_sf_mathieu_se_e(int order, double qq, double zz, gsl_sf_result result);
public static native double gsl_sf_mathieu_se(int order, double qq, double zz);
public static native int gsl_sf_mathieu_ce_array(int nmin, int nmax, double qq, double zz,
                            gsl_sf_mathieu_workspace work,
                            DoublePointer result_array);
public static native int gsl_sf_mathieu_ce_array(int nmin, int nmax, double qq, double zz,
                            gsl_sf_mathieu_workspace work,
                            DoubleBuffer result_array);
public static native int gsl_sf_mathieu_ce_array(int nmin, int nmax, double qq, double zz,
                            gsl_sf_mathieu_workspace work,
                            double[] result_array);
public static native int gsl_sf_mathieu_se_array(int nmin, int nmax, double qq, double zz,
                            gsl_sf_mathieu_workspace work,
                            DoublePointer result_array);
public static native int gsl_sf_mathieu_se_array(int nmin, int nmax, double qq, double zz,
                            gsl_sf_mathieu_workspace work,
                            DoubleBuffer result_array);
public static native int gsl_sf_mathieu_se_array(int nmin, int nmax, double qq, double zz,
                            gsl_sf_mathieu_workspace work,
                            double[] result_array);

/* Compute a radial Mathieu function. */
public static native int gsl_sf_mathieu_Mc_e(int kind, int order, double qq, double zz,
                      gsl_sf_result result);
public static native double gsl_sf_mathieu_Mc(int kind, int order, double qq, double zz);
public static native int gsl_sf_mathieu_Ms_e(int kind, int order, double qq, double zz,
                      gsl_sf_result result);
public static native double gsl_sf_mathieu_Ms(int kind, int order, double qq, double zz);
public static native int gsl_sf_mathieu_Mc_array(int kind, int nmin, int nmax, double qq,
                            double zz, gsl_sf_mathieu_workspace work,
                            DoublePointer result_array);
public static native int gsl_sf_mathieu_Mc_array(int kind, int nmin, int nmax, double qq,
                            double zz, gsl_sf_mathieu_workspace work,
                            DoubleBuffer result_array);
public static native int gsl_sf_mathieu_Mc_array(int kind, int nmin, int nmax, double qq,
                            double zz, gsl_sf_mathieu_workspace work,
                            double[] result_array);
public static native int gsl_sf_mathieu_Ms_array(int kind, int nmin, int nmax, double qq,
                            double zz, gsl_sf_mathieu_workspace work,
                            DoublePointer result_array);
public static native int gsl_sf_mathieu_Ms_array(int kind, int nmin, int nmax, double qq,
                            double zz, gsl_sf_mathieu_workspace work,
                            DoubleBuffer result_array);
public static native int gsl_sf_mathieu_Ms_array(int kind, int nmin, int nmax, double qq,
                            double zz, gsl_sf_mathieu_workspace work,
                            double[] result_array);

// #endif /* !__GSL_SF_MATHIEU_H__ */


// Parsed from gsl/gsl_sf_pow_int.h

/* specfunc/gsl_sf_pow_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_POW_INT_H__
// #define __GSL_SF_POW_INT_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Calculate x^n.
 * Does not check for overflow/underflow.
 */
public static native int gsl_sf_pow_int_e(double x, int n, gsl_sf_result result);
public static native double gsl_sf_pow_int(double x, int n);

// #endif /* __GSL_SF_POW_INT_H__ */


// Parsed from gsl/gsl_sf_psi.h

/* specfunc/gsl_sf_psi.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_PSI_H__
// #define __GSL_SF_PSI_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Poly-Gamma Functions
 *
 * psi(m,x) := (d/dx)^m psi(0,x) = (d/dx)^{m+1} log(gamma(x))
 */


/* Di-Gamma Function  psi(n) = psi(0,n)
 *
 * n > 0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_psi_int_e(int n, gsl_sf_result result);
public static native double gsl_sf_psi_int(int n);


/* Di-Gamma Function psi(x) = psi(0, x)
 *
 * x != 0.0, -1.0, -2.0, ...
 * exceptions: GSL_EDOM, GSL_ELOSS
 */
public static native int gsl_sf_psi_e(double x, gsl_sf_result result);
public static native double gsl_sf_psi(double x);


/* Di-Gamma Function Re[psi(1 + I y)]
 *
 * exceptions: none
 */
public static native int gsl_sf_psi_1piy_e(double y, gsl_sf_result result);
public static native double gsl_sf_psi_1piy(double y);


/* Di-Gamma Function psi(z) for general complex argument z = x + iy
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_complex_psi_e(
  double x,
  double y,
  gsl_sf_result result_re,
  gsl_sf_result result_im
  );


/* Tri-Gamma Function psi^(1)(n)
 *
 * n > 0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_psi_1_int_e(int n, gsl_sf_result result);
public static native double gsl_sf_psi_1_int(int n);


/* Tri-Gamma Function psi^(1)(x)
 *
 * x != 0.0, -1.0, -2.0, ...
 * exceptions: GSL_EDOM, GSL_ELOSS
 */
public static native int gsl_sf_psi_1_e(double x, gsl_sf_result result);
public static native double gsl_sf_psi_1(double x);


/* Poly-Gamma Function psi^(n)(x)
 *
 * n >= 0, x > 0.0
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_psi_n_e(int n, double x, gsl_sf_result result);
public static native double gsl_sf_psi_n(int n, double x);

// #endif /* __GSL_SF_PSI_H__ */


// Parsed from gsl/gsl_sf_synchrotron.h

/* specfunc/gsl_sf_synchrotron.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_SYNCHROTRON_H__
// #define __GSL_SF_SYNCHROTRON_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* First synchrotron function:
 *   synchrotron_1(x) = x Integral[ K_{5/3}(t), {t, x, Infinity}]
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_synchrotron_1_e(double x, gsl_sf_result result);
public static native double gsl_sf_synchrotron_1(double x);


/* Second synchroton function:
 *   synchrotron_2(x) = x * K_{2/3}(x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_synchrotron_2_e(double x, gsl_sf_result result);
public static native double gsl_sf_synchrotron_2(double x);

// #endif /* __GSL_SF_SYNCHROTRON_H__ */


// Parsed from gsl/gsl_sf_transport.h

/* specfunc/gsl_sf_transport.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_TRANSPORT_H__
// #define __GSL_SF_TRANSPORT_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Transport function:
 *   J(n,x) := Integral[ t^n e^t /(e^t - 1)^2, {t,0,x}]
 */

/* J(2,x)
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_transport_2_e(double x, gsl_sf_result result);
public static native double gsl_sf_transport_2(double x);


/* J(3,x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_transport_3_e(double x, gsl_sf_result result);
public static native double gsl_sf_transport_3(double x);


/* J(4,x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_transport_4_e(double x, gsl_sf_result result);
public static native double gsl_sf_transport_4(double x);


/* J(5,x)
 *
 * exceptions: GSL_EDOM, GSL_EUNDRFLW
 */
public static native int gsl_sf_transport_5_e(double x, gsl_sf_result result);
public static native double gsl_sf_transport_5(double x);

// #endif /* __GSL_SF_TRANSPORT_H__ */


// Parsed from gsl/gsl_sf_trig.h

/* specfunc/gsl_sf_trig.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_TRIG_H__
// #define __GSL_SF_TRIG_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Sin(x) with GSL semantics. This is actually important
 * because we want to control the error estimate, and trying
 * to guess the error for the standard library implementation
 * every time it is used would be a little goofy.
 */
public static native int gsl_sf_sin_e(double x, gsl_sf_result result);
public static native double gsl_sf_sin(double x);


/* Cos(x) with GSL semantics.
 */
public static native int gsl_sf_cos_e(double x, gsl_sf_result result);
public static native double gsl_sf_cos(double x);


/* Hypot(x,y) with GSL semantics.
 */
public static native int gsl_sf_hypot_e(double x, double y, gsl_sf_result result);
public static native double gsl_sf_hypot(double x, double y);


/* Sin(z) for complex z
 *
 * exceptions: GSL_EOVRFLW
 */
public static native int gsl_sf_complex_sin_e(double zr, double zi, gsl_sf_result szr, gsl_sf_result szi);


/* Cos(z) for complex z
 *
 * exceptions: GSL_EOVRFLW
 */
public static native int gsl_sf_complex_cos_e(double zr, double zi, gsl_sf_result czr, gsl_sf_result czi);


/* Log(Sin(z)) for complex z
 *
 * exceptions: GSL_EDOM, GSL_ELOSS
 */
public static native int gsl_sf_complex_logsin_e(double zr, double zi, gsl_sf_result lszr, gsl_sf_result lszi);


/* Sinc(x) = sin(pi x) / (pi x)
 *
 * exceptions: none
 */
public static native int gsl_sf_sinc_e(double x, gsl_sf_result result);
public static native double gsl_sf_sinc(double x);


/* Log(Sinh(x)), x > 0
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_lnsinh_e(double x, gsl_sf_result result);
public static native double gsl_sf_lnsinh(double x);


/* Log(Cosh(x))
 *
 * exceptions: none
 */
public static native int gsl_sf_lncosh_e(double x, gsl_sf_result result);
public static native double gsl_sf_lncosh(double x);


/* Convert polar to rectlinear coordinates.
 *
 * exceptions: GSL_ELOSS
 */
public static native int gsl_sf_polar_to_rect(double r, double theta, gsl_sf_result x, gsl_sf_result y);

/* Convert rectilinear to polar coordinates.
 * return argument in range [-pi, pi]
 *
 * exceptions: GSL_EDOM
 */
public static native int gsl_sf_rect_to_polar(double x, double y, gsl_sf_result r, gsl_sf_result theta);

/* Sin(x) for quantity with an associated error.
 */
public static native int gsl_sf_sin_err_e(double x, double dx, gsl_sf_result result);


/* Cos(x) for quantity with an associated error.
 */
public static native int gsl_sf_cos_err_e(double x, double dx, gsl_sf_result result);


/* Force an angle to lie in the range (-pi,pi].
 *
 * exceptions: GSL_ELOSS
 */
public static native int gsl_sf_angle_restrict_symm_e(DoublePointer theta);
public static native int gsl_sf_angle_restrict_symm_e(DoubleBuffer theta);
public static native int gsl_sf_angle_restrict_symm_e(double[] theta);
public static native double gsl_sf_angle_restrict_symm(double theta);


/* Force an angle to lie in the range [0, 2pi)
 *
 * exceptions: GSL_ELOSS
 */
public static native int gsl_sf_angle_restrict_pos_e(DoublePointer theta);
public static native int gsl_sf_angle_restrict_pos_e(DoubleBuffer theta);
public static native int gsl_sf_angle_restrict_pos_e(double[] theta);
public static native double gsl_sf_angle_restrict_pos(double theta);


public static native int gsl_sf_angle_restrict_symm_err_e(double theta, gsl_sf_result result);

public static native int gsl_sf_angle_restrict_pos_err_e(double theta, gsl_sf_result result);

// #endif /* __GSL_SF_TRIG_H__ */


// Parsed from gsl/gsl_sf_zeta.h

/* specfunc/gsl_sf_zeta.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004 Gerard Jungman
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/* Author:  G. Jungman */

// #ifndef __GSL_SF_ZETA_H__
// #define __GSL_SF_ZETA_H__

// #include <gsl/gsl_sf_result.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif


/* Riemann Zeta Function
 * zeta(n) = Sum[ k^(-n), {k,1,Infinity} ]
 *
 * n=integer, n != 1
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_zeta_int_e(int n, gsl_sf_result result);
public static native double gsl_sf_zeta_int(int n);


/* Riemann Zeta Function
 * zeta(x) = Sum[ k^(-s), {k,1,Infinity} ], s != 1.0
 *
 * s != 1.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_zeta_e(double s, gsl_sf_result result);
public static native double gsl_sf_zeta(double s);


/* Riemann Zeta Function minus 1
 *   useful for evaluating the fractional part
 *   of Riemann zeta for large argument
 *
 * s != 1.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_zetam1_e(double s, gsl_sf_result result);
public static native double gsl_sf_zetam1(double s);


/* Riemann Zeta Function minus 1 for integer arg
 *   useful for evaluating the fractional part
 *   of Riemann zeta for large argument
 *
 * s != 1.0
 * exceptions: GSL_EDOM, GSL_EOVRFLW
 */
public static native int gsl_sf_zetam1_int_e(int s, gsl_sf_result result);
public static native double gsl_sf_zetam1_int(int s);


/* Hurwitz Zeta Function
 * zeta(s,q) = Sum[ (k+q)^(-s), {k,0,Infinity} ]
 *
 * s > 1.0, q > 0.0
 * exceptions: GSL_EDOM, GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_hzeta_e(double s, double q, gsl_sf_result result);
public static native double gsl_sf_hzeta(double s, double q);


/* Eta Function
 * eta(n) = (1-2^(1-n)) zeta(n)
 *
 * exceptions: GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_eta_int_e(int n, gsl_sf_result result);
public static native double gsl_sf_eta_int(int n);


/* Eta Function
 * eta(s) = (1-2^(1-s)) zeta(s)
 *
 * exceptions: GSL_EUNDRFLW, GSL_EOVRFLW
 */
public static native int gsl_sf_eta_e(double s, gsl_sf_result result);
public static native double gsl_sf_eta(double s);

// #endif /* __GSL_SF_ZETA_H__ */


// Parsed from gsl/gsl_sort.h

// #ifndef __GSL_SORT_H__
// #define __GSL_SORT_H__

// #include <gsl/gsl_sort_long_double.h>
// #include <gsl/gsl_sort_double.h>
// #include <gsl/gsl_sort_float.h>

// #include <gsl/gsl_sort_ulong.h>
// #include <gsl/gsl_sort_long.h>

// #include <gsl/gsl_sort_uint.h>
// #include <gsl/gsl_sort_int.h>

// #include <gsl/gsl_sort_ushort.h>
// #include <gsl/gsl_sort_short.h>

// #include <gsl/gsl_sort_uchar.h>
// #include <gsl/gsl_sort_char.h>

// #endif /* __GSL_SORT_H__ */


// Parsed from gsl/gsl_sort_double.h

/* sort/gsl_sort_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_DOUBLE_H__
// #define __GSL_SORT_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort(DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort(DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort(double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2(DoublePointer data1, @Cast("const size_t") long stride1, DoublePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2(DoubleBuffer data1, @Cast("const size_t") long stride1, DoubleBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2(double[] data1, @Cast("const size_t") long stride1, double[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_index(@Cast("size_t*") SizeTPointer p, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_index(@Cast("size_t*") SizeTPointer p, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_index(@Cast("size_t*") SizeTPointer p, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_smallest(DoublePointer dest, @Cast("const size_t") long k, @Const DoublePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_smallest(DoubleBuffer dest, @Cast("const size_t") long k, @Const DoubleBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_smallest(double[] dest, @Cast("const size_t") long k, @Const double[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const DoublePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const DoubleBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const double[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_largest(DoublePointer dest, @Cast("const size_t") long k, @Const DoublePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_largest(DoubleBuffer dest, @Cast("const size_t") long k, @Const DoubleBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_largest(double[] dest, @Cast("const size_t") long k, @Const double[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const DoublePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const DoubleBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const double[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_DOUBLE_H__ */


// Parsed from gsl/gsl_sort_float.h

/* sort/gsl_sort_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_FLOAT_H__
// #define __GSL_SORT_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_float(FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_float(FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_float(float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2_float(FloatPointer data1, @Cast("const size_t") long stride1, FloatPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_float(FloatBuffer data1, @Cast("const size_t") long stride1, FloatBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_float(float[] data1, @Cast("const size_t") long stride1, float[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_float_index(@Cast("size_t*") SizeTPointer p, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_float_index(@Cast("size_t*") SizeTPointer p, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_float_index(@Cast("size_t*") SizeTPointer p, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_float_smallest(FloatPointer dest, @Cast("const size_t") long k, @Const FloatPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_smallest(FloatBuffer dest, @Cast("const size_t") long k, @Const FloatBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_smallest(float[] dest, @Cast("const size_t") long k, @Const float[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const FloatPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const FloatBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const float[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_float_largest(FloatPointer dest, @Cast("const size_t") long k, @Const FloatPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_largest(FloatBuffer dest, @Cast("const size_t") long k, @Const FloatBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_largest(float[] dest, @Cast("const size_t") long k, @Const float[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const FloatPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const FloatBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_float_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const float[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_FLOAT_H__ */


// Parsed from gsl/gsl_sort_ulong.h

/* sort/gsl_sort_ulong.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_ULONG_H__
// #define __GSL_SORT_ULONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_ulong(@Cast("unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2_ulong(@Cast("unsigned long*") CLongPointer data1, @Cast("const size_t") long stride1, @Cast("unsigned long*") CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_ulong_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_ulong_smallest(@Cast("unsigned long*") CLongPointer dest, @Cast("const size_t") long k, @Cast("const unsigned long*") CLongPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ulong_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned long*") CLongPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_ulong_largest(@Cast("unsigned long*") CLongPointer dest, @Cast("const size_t") long k, @Cast("const unsigned long*") CLongPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ulong_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned long*") CLongPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_ULONG_H__ */


// Parsed from gsl/gsl_sort_long.h

/* sort/gsl_sort_long.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_LONG_H__
// #define __GSL_SORT_LONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_long(CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2_long(CLongPointer data1, @Cast("const size_t") long stride1, CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_long_index(@Cast("size_t*") SizeTPointer p, @Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_long_smallest(CLongPointer dest, @Cast("const size_t") long k, @Const CLongPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_long_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const CLongPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_long_largest(CLongPointer dest, @Cast("const size_t") long k, @Const CLongPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_long_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const CLongPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_LONG_H__ */


// Parsed from gsl/gsl_sort_uint.h

/* sort/gsl_sort_uint.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_UINT_H__
// #define __GSL_SORT_UINT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_uint(@Cast("unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_uint(@Cast("unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_uint(@Cast("unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2_uint(@Cast("unsigned int*") IntPointer data1, @Cast("const size_t") long stride1, @Cast("unsigned int*") IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_uint(@Cast("unsigned int*") IntBuffer data1, @Cast("const size_t") long stride1, @Cast("unsigned int*") IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_uint(@Cast("unsigned int*") int[] data1, @Cast("const size_t") long stride1, @Cast("unsigned int*") int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_uint_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_uint_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_uint_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_uint_smallest(@Cast("unsigned int*") IntPointer dest, @Cast("const size_t") long k, @Cast("const unsigned int*") IntPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_smallest(@Cast("unsigned int*") IntBuffer dest, @Cast("const size_t") long k, @Cast("const unsigned int*") IntBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_smallest(@Cast("unsigned int*") int[] dest, @Cast("const size_t") long k, @Cast("const unsigned int*") int[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned int*") IntPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned int*") IntBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned int*") int[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_uint_largest(@Cast("unsigned int*") IntPointer dest, @Cast("const size_t") long k, @Cast("const unsigned int*") IntPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_largest(@Cast("unsigned int*") IntBuffer dest, @Cast("const size_t") long k, @Cast("const unsigned int*") IntBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_largest(@Cast("unsigned int*") int[] dest, @Cast("const size_t") long k, @Cast("const unsigned int*") int[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned int*") IntPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned int*") IntBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uint_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned int*") int[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_UINT_H__ */


// Parsed from gsl/gsl_sort_int.h

/* sort/gsl_sort_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_INT_H__
// #define __GSL_SORT_INT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_int(IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_int(IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_int(int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2_int(IntPointer data1, @Cast("const size_t") long stride1, IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_int(IntBuffer data1, @Cast("const size_t") long stride1, IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_int(int[] data1, @Cast("const size_t") long stride1, int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_int_index(@Cast("size_t*") SizeTPointer p, @Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_int_index(@Cast("size_t*") SizeTPointer p, @Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_int_index(@Cast("size_t*") SizeTPointer p, @Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_int_smallest(IntPointer dest, @Cast("const size_t") long k, @Const IntPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_smallest(IntBuffer dest, @Cast("const size_t") long k, @Const IntBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_smallest(int[] dest, @Cast("const size_t") long k, @Const int[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const IntPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const IntBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const int[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_int_largest(IntPointer dest, @Cast("const size_t") long k, @Const IntPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_largest(IntBuffer dest, @Cast("const size_t") long k, @Const IntBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_largest(int[] dest, @Cast("const size_t") long k, @Const int[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const IntPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const IntBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_int_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const int[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_INT_H__ */


// Parsed from gsl/gsl_sort_ushort.h

/* sort/gsl_sort_ushort.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_USHORT_H__
// #define __GSL_SORT_USHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_ushort(@Cast("unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_ushort(@Cast("unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_ushort(@Cast("unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2_ushort(@Cast("unsigned short*") ShortPointer data1, @Cast("const size_t") long stride1, @Cast("unsigned short*") ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_ushort(@Cast("unsigned short*") ShortBuffer data1, @Cast("const size_t") long stride1, @Cast("unsigned short*") ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_ushort(@Cast("unsigned short*") short[] data1, @Cast("const size_t") long stride1, @Cast("unsigned short*") short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_ushort_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_ushort_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_ushort_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_ushort_smallest(@Cast("unsigned short*") ShortPointer dest, @Cast("const size_t") long k, @Cast("const unsigned short*") ShortPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_smallest(@Cast("unsigned short*") ShortBuffer dest, @Cast("const size_t") long k, @Cast("const unsigned short*") ShortBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_smallest(@Cast("unsigned short*") short[] dest, @Cast("const size_t") long k, @Cast("const unsigned short*") short[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned short*") ShortPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned short*") ShortBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned short*") short[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_ushort_largest(@Cast("unsigned short*") ShortPointer dest, @Cast("const size_t") long k, @Cast("const unsigned short*") ShortPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_largest(@Cast("unsigned short*") ShortBuffer dest, @Cast("const size_t") long k, @Cast("const unsigned short*") ShortBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_largest(@Cast("unsigned short*") short[] dest, @Cast("const size_t") long k, @Cast("const unsigned short*") short[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned short*") ShortPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned short*") ShortBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_ushort_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned short*") short[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_USHORT_H__ */


// Parsed from gsl/gsl_sort_short.h

/* sort/gsl_sort_short.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_SHORT_H__
// #define __GSL_SORT_SHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_short(ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_short(ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_short(short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2_short(ShortPointer data1, @Cast("const size_t") long stride1, ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_short(ShortBuffer data1, @Cast("const size_t") long stride1, ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_short(short[] data1, @Cast("const size_t") long stride1, short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_short_index(@Cast("size_t*") SizeTPointer p, @Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_short_index(@Cast("size_t*") SizeTPointer p, @Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_short_index(@Cast("size_t*") SizeTPointer p, @Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_short_smallest(ShortPointer dest, @Cast("const size_t") long k, @Const ShortPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_smallest(ShortBuffer dest, @Cast("const size_t") long k, @Const ShortBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_smallest(short[] dest, @Cast("const size_t") long k, @Const short[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const ShortPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const ShortBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const short[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_short_largest(ShortPointer dest, @Cast("const size_t") long k, @Const ShortPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_largest(ShortBuffer dest, @Cast("const size_t") long k, @Const ShortBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_largest(short[] dest, @Cast("const size_t") long k, @Const short[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const ShortPointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const ShortBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_short_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const short[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_SHORT_H__ */


// Parsed from gsl/gsl_sort_uchar.h

/* sort/gsl_sort_uchar.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_UCHAR_H__
// #define __GSL_SORT_UCHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_uchar(@Cast("unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_uchar(@Cast("unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_uchar(@Cast("unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2_uchar(@Cast("unsigned char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("unsigned char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_uchar(@Cast("unsigned char*") ByteBuffer data1, @Cast("const size_t") long stride1, @Cast("unsigned char*") ByteBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_uchar(@Cast("unsigned char*") byte[] data1, @Cast("const size_t") long stride1, @Cast("unsigned char*") byte[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_uchar_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_uchar_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_uchar_index(@Cast("size_t*") SizeTPointer p, @Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_uchar_smallest(@Cast("unsigned char*") BytePointer dest, @Cast("const size_t") long k, @Cast("const unsigned char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_smallest(@Cast("unsigned char*") ByteBuffer dest, @Cast("const size_t") long k, @Cast("const unsigned char*") ByteBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_smallest(@Cast("unsigned char*") byte[] dest, @Cast("const size_t") long k, @Cast("const unsigned char*") byte[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned char*") ByteBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned char*") byte[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_uchar_largest(@Cast("unsigned char*") BytePointer dest, @Cast("const size_t") long k, @Cast("const unsigned char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_largest(@Cast("unsigned char*") ByteBuffer dest, @Cast("const size_t") long k, @Cast("const unsigned char*") ByteBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_largest(@Cast("unsigned char*") byte[] dest, @Cast("const size_t") long k, @Cast("const unsigned char*") byte[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned char*") ByteBuffer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_uchar_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const unsigned char*") byte[] src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_UCHAR_H__ */


// Parsed from gsl/gsl_sort_char.h

/* sort/gsl_sort_char.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_CHAR_H__
// #define __GSL_SORT_CHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_char(@Cast("char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_char(@Cast("char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_char(@Cast("char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort2_char(@Cast("char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_char(@Cast("char*") ByteBuffer data1, @Cast("const size_t") long stride1, @Cast("char*") ByteBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort2_char(@Cast("char*") byte[] data1, @Cast("const size_t") long stride1, @Cast("char*") byte[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native void gsl_sort_char_index(@Cast("size_t*") SizeTPointer p, @Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_sort_char_index(@Cast("size_t*") SizeTPointer p, String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_char_smallest(@Cast("char*") BytePointer dest, @Cast("const size_t") long k, @Cast("const char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_smallest(@Cast("char*") ByteBuffer dest, @Cast("const size_t") long k, String src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_smallest(@Cast("char*") byte[] dest, @Cast("const size_t") long k, @Cast("const char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_smallest(@Cast("char*") BytePointer dest, @Cast("const size_t") long k, String src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_smallest(@Cast("char*") ByteBuffer dest, @Cast("const size_t") long k, @Cast("const char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_smallest(@Cast("char*") byte[] dest, @Cast("const size_t") long k, String src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, String src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native int gsl_sort_char_largest(@Cast("char*") BytePointer dest, @Cast("const size_t") long k, @Cast("const char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_largest(@Cast("char*") ByteBuffer dest, @Cast("const size_t") long k, String src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_largest(@Cast("char*") byte[] dest, @Cast("const size_t") long k, @Cast("const char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_largest(@Cast("char*") BytePointer dest, @Cast("const size_t") long k, String src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_largest(@Cast("char*") ByteBuffer dest, @Cast("const size_t") long k, @Cast("const char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_largest(@Cast("char*") byte[] dest, @Cast("const size_t") long k, String src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Cast("const char*") BytePointer src, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_sort_char_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, String src, @Cast("const size_t") long stride, @Cast("const size_t") long n);

// #endif /* __GSL_SORT_CHAR_H__ */


// Parsed from gsl/gsl_sort_vector.h

// #ifndef __GSL_SORT_VECTOR_H__
// #define __GSL_SORT_VECTOR_H__

// #include <gsl/gsl_sort_vector_long_double.h>
// #include <gsl/gsl_sort_vector_double.h>
// #include <gsl/gsl_sort_vector_float.h>

// #include <gsl/gsl_sort_vector_ulong.h>
// #include <gsl/gsl_sort_vector_long.h>

// #include <gsl/gsl_sort_vector_uint.h>
// #include <gsl/gsl_sort_vector_int.h>

// #include <gsl/gsl_sort_vector_ushort.h>
// #include <gsl/gsl_sort_vector_short.h>

// #include <gsl/gsl_sort_vector_uchar.h>
// #include <gsl/gsl_sort_vector_char.h>

// #endif /* __GSL_SORT_VECTOR_H__ */


// Parsed from gsl/gsl_sort_vector_double.h

/* sort/gsl_sort_vector_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_DOUBLE_H__
// #define __GSL_SORT_VECTOR_DOUBLE_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_double.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector(gsl_vector v);
public static native void gsl_sort_vector2(gsl_vector v1, gsl_vector v2);
public static native int gsl_sort_vector_index(gsl_permutation p, @Const gsl_vector v);

public static native int gsl_sort_vector_smallest(DoublePointer dest, @Cast("const size_t") long k, @Const gsl_vector v);
public static native int gsl_sort_vector_smallest(DoubleBuffer dest, @Cast("const size_t") long k, @Const gsl_vector v);
public static native int gsl_sort_vector_smallest(double[] dest, @Cast("const size_t") long k, @Const gsl_vector v);
public static native int gsl_sort_vector_largest(DoublePointer dest, @Cast("const size_t") long k, @Const gsl_vector v);
public static native int gsl_sort_vector_largest(DoubleBuffer dest, @Cast("const size_t") long k, @Const gsl_vector v);
public static native int gsl_sort_vector_largest(double[] dest, @Cast("const size_t") long k, @Const gsl_vector v);

public static native int gsl_sort_vector_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector v);
public static native int gsl_sort_vector_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector v);

// #endif /* __GSL_SORT_VECTOR_DOUBLE_H__ */


// Parsed from gsl/gsl_sort_vector_float.h

/* sort/gsl_sort_vector_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_FLOAT_H__
// #define __GSL_SORT_VECTOR_FLOAT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_float.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector_float(gsl_vector_float v);
public static native void gsl_sort_vector2_float(gsl_vector_float v1, gsl_vector_float v2);
public static native int gsl_sort_vector_float_index(gsl_permutation p, @Const gsl_vector_float v);

public static native int gsl_sort_vector_float_smallest(FloatPointer dest, @Cast("const size_t") long k, @Const gsl_vector_float v);
public static native int gsl_sort_vector_float_smallest(FloatBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_float v);
public static native int gsl_sort_vector_float_smallest(float[] dest, @Cast("const size_t") long k, @Const gsl_vector_float v);
public static native int gsl_sort_vector_float_largest(FloatPointer dest, @Cast("const size_t") long k, @Const gsl_vector_float v);
public static native int gsl_sort_vector_float_largest(FloatBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_float v);
public static native int gsl_sort_vector_float_largest(float[] dest, @Cast("const size_t") long k, @Const gsl_vector_float v);

public static native int gsl_sort_vector_float_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_float v);
public static native int gsl_sort_vector_float_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_float v);

// #endif /* __GSL_SORT_VECTOR_FLOAT_H__ */


// Parsed from gsl/gsl_sort_vector_ulong.h

/* sort/gsl_sort_vector_ulong.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_ULONG_H__
// #define __GSL_SORT_VECTOR_ULONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_ulong.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector_ulong(gsl_vector_ulong v);
public static native void gsl_sort_vector2_ulong(gsl_vector_ulong v1, gsl_vector_ulong v2);
public static native int gsl_sort_vector_ulong_index(gsl_permutation p, @Const gsl_vector_ulong v);

public static native int gsl_sort_vector_ulong_smallest(@Cast("unsigned long*") CLongPointer dest, @Cast("const size_t") long k, @Const gsl_vector_ulong v);
public static native int gsl_sort_vector_ulong_largest(@Cast("unsigned long*") CLongPointer dest, @Cast("const size_t") long k, @Const gsl_vector_ulong v);

public static native int gsl_sort_vector_ulong_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_ulong v);
public static native int gsl_sort_vector_ulong_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_ulong v);

// #endif /* __GSL_SORT_VECTOR_ULONG_H__ */


// Parsed from gsl/gsl_sort_vector_long.h

/* sort/gsl_sort_vector_long.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_LONG_H__
// #define __GSL_SORT_VECTOR_LONG_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_long.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector_long(gsl_vector_long v);
public static native void gsl_sort_vector2_long(gsl_vector_long v1, gsl_vector_long v2);
public static native int gsl_sort_vector_long_index(gsl_permutation p, @Const gsl_vector_long v);

public static native int gsl_sort_vector_long_smallest(CLongPointer dest, @Cast("const size_t") long k, @Const gsl_vector_long v);
public static native int gsl_sort_vector_long_largest(CLongPointer dest, @Cast("const size_t") long k, @Const gsl_vector_long v);

public static native int gsl_sort_vector_long_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_long v);
public static native int gsl_sort_vector_long_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_long v);

// #endif /* __GSL_SORT_VECTOR_LONG_H__ */


// Parsed from gsl/gsl_sort_vector_uint.h

/* sort/gsl_sort_vector_uint.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_UINT_H__
// #define __GSL_SORT_VECTOR_UINT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_uint.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector_uint(gsl_vector_uint v);
public static native void gsl_sort_vector2_uint(gsl_vector_uint v1, gsl_vector_uint v2);
public static native int gsl_sort_vector_uint_index(gsl_permutation p, @Const gsl_vector_uint v);

public static native int gsl_sort_vector_uint_smallest(@Cast("unsigned int*") IntPointer dest, @Cast("const size_t") long k, @Const gsl_vector_uint v);
public static native int gsl_sort_vector_uint_smallest(@Cast("unsigned int*") IntBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_uint v);
public static native int gsl_sort_vector_uint_smallest(@Cast("unsigned int*") int[] dest, @Cast("const size_t") long k, @Const gsl_vector_uint v);
public static native int gsl_sort_vector_uint_largest(@Cast("unsigned int*") IntPointer dest, @Cast("const size_t") long k, @Const gsl_vector_uint v);
public static native int gsl_sort_vector_uint_largest(@Cast("unsigned int*") IntBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_uint v);
public static native int gsl_sort_vector_uint_largest(@Cast("unsigned int*") int[] dest, @Cast("const size_t") long k, @Const gsl_vector_uint v);

public static native int gsl_sort_vector_uint_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_uint v);
public static native int gsl_sort_vector_uint_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_uint v);

// #endif /* __GSL_SORT_VECTOR_UINT_H__ */


// Parsed from gsl/gsl_sort_vector_int.h

/* sort/gsl_sort_vector_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_INT_H__
// #define __GSL_SORT_VECTOR_INT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_int.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector_int(gsl_vector_int v);
public static native void gsl_sort_vector2_int(gsl_vector_int v1, gsl_vector_int v2);
public static native int gsl_sort_vector_int_index(gsl_permutation p, @Const gsl_vector_int v);

public static native int gsl_sort_vector_int_smallest(IntPointer dest, @Cast("const size_t") long k, @Const gsl_vector_int v);
public static native int gsl_sort_vector_int_smallest(IntBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_int v);
public static native int gsl_sort_vector_int_smallest(int[] dest, @Cast("const size_t") long k, @Const gsl_vector_int v);
public static native int gsl_sort_vector_int_largest(IntPointer dest, @Cast("const size_t") long k, @Const gsl_vector_int v);
public static native int gsl_sort_vector_int_largest(IntBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_int v);
public static native int gsl_sort_vector_int_largest(int[] dest, @Cast("const size_t") long k, @Const gsl_vector_int v);

public static native int gsl_sort_vector_int_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_int v);
public static native int gsl_sort_vector_int_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_int v);

// #endif /* __GSL_SORT_VECTOR_INT_H__ */


// Parsed from gsl/gsl_sort_vector_ushort.h

/* sort/gsl_sort_vector_ushort.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_USHORT_H__
// #define __GSL_SORT_VECTOR_USHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_ushort.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector_ushort(gsl_vector_ushort v);
public static native void gsl_sort_vector2_ushort(gsl_vector_ushort v1, gsl_vector_ushort v2);
public static native int gsl_sort_vector_ushort_index(gsl_permutation p, @Const gsl_vector_ushort v);

public static native int gsl_sort_vector_ushort_smallest(@Cast("unsigned short*") ShortPointer dest, @Cast("const size_t") long k, @Const gsl_vector_ushort v);
public static native int gsl_sort_vector_ushort_smallest(@Cast("unsigned short*") ShortBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_ushort v);
public static native int gsl_sort_vector_ushort_smallest(@Cast("unsigned short*") short[] dest, @Cast("const size_t") long k, @Const gsl_vector_ushort v);
public static native int gsl_sort_vector_ushort_largest(@Cast("unsigned short*") ShortPointer dest, @Cast("const size_t") long k, @Const gsl_vector_ushort v);
public static native int gsl_sort_vector_ushort_largest(@Cast("unsigned short*") ShortBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_ushort v);
public static native int gsl_sort_vector_ushort_largest(@Cast("unsigned short*") short[] dest, @Cast("const size_t") long k, @Const gsl_vector_ushort v);

public static native int gsl_sort_vector_ushort_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_ushort v);
public static native int gsl_sort_vector_ushort_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_ushort v);

// #endif /* __GSL_SORT_VECTOR_USHORT_H__ */


// Parsed from gsl/gsl_sort_vector_short.h

/* sort/gsl_sort_vector_short.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_SHORT_H__
// #define __GSL_SORT_VECTOR_SHORT_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_short.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector_short(gsl_vector_short v);
public static native void gsl_sort_vector2_short(gsl_vector_short v1, gsl_vector_short v2);
public static native int gsl_sort_vector_short_index(gsl_permutation p, @Const gsl_vector_short v);

public static native int gsl_sort_vector_short_smallest(ShortPointer dest, @Cast("const size_t") long k, @Const gsl_vector_short v);
public static native int gsl_sort_vector_short_smallest(ShortBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_short v);
public static native int gsl_sort_vector_short_smallest(short[] dest, @Cast("const size_t") long k, @Const gsl_vector_short v);
public static native int gsl_sort_vector_short_largest(ShortPointer dest, @Cast("const size_t") long k, @Const gsl_vector_short v);
public static native int gsl_sort_vector_short_largest(ShortBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_short v);
public static native int gsl_sort_vector_short_largest(short[] dest, @Cast("const size_t") long k, @Const gsl_vector_short v);

public static native int gsl_sort_vector_short_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_short v);
public static native int gsl_sort_vector_short_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_short v);

// #endif /* __GSL_SORT_VECTOR_SHORT_H__ */


// Parsed from gsl/gsl_sort_vector_uchar.h

/* sort/gsl_sort_vector_uchar.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_UCHAR_H__
// #define __GSL_SORT_VECTOR_UCHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_uchar.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector_uchar(gsl_vector_uchar v);
public static native void gsl_sort_vector2_uchar(gsl_vector_uchar v1, gsl_vector_uchar v2);
public static native int gsl_sort_vector_uchar_index(gsl_permutation p, @Const gsl_vector_uchar v);

public static native int gsl_sort_vector_uchar_smallest(@Cast("unsigned char*") BytePointer dest, @Cast("const size_t") long k, @Const gsl_vector_uchar v);
public static native int gsl_sort_vector_uchar_smallest(@Cast("unsigned char*") ByteBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_uchar v);
public static native int gsl_sort_vector_uchar_smallest(@Cast("unsigned char*") byte[] dest, @Cast("const size_t") long k, @Const gsl_vector_uchar v);
public static native int gsl_sort_vector_uchar_largest(@Cast("unsigned char*") BytePointer dest, @Cast("const size_t") long k, @Const gsl_vector_uchar v);
public static native int gsl_sort_vector_uchar_largest(@Cast("unsigned char*") ByteBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_uchar v);
public static native int gsl_sort_vector_uchar_largest(@Cast("unsigned char*") byte[] dest, @Cast("const size_t") long k, @Const gsl_vector_uchar v);

public static native int gsl_sort_vector_uchar_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_uchar v);
public static native int gsl_sort_vector_uchar_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_uchar v);

// #endif /* __GSL_SORT_VECTOR_UCHAR_H__ */


// Parsed from gsl/gsl_sort_vector_char.h

/* sort/gsl_sort_vector_char.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Thomas Walter, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_SORT_VECTOR_CHAR_H__
// #define __GSL_SORT_VECTOR_CHAR_H__

// #include <stdlib.h>
// #include <gsl/gsl_errno.h>
// #include <gsl/gsl_permutation.h>
// #include <gsl/gsl_vector_char.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native void gsl_sort_vector_char(gsl_vector_char v);
public static native void gsl_sort_vector2_char(gsl_vector_char v1, gsl_vector_char v2);
public static native int gsl_sort_vector_char_index(gsl_permutation p, @Const gsl_vector_char v);

public static native int gsl_sort_vector_char_smallest(@Cast("char*") BytePointer dest, @Cast("const size_t") long k, @Const gsl_vector_char v);
public static native int gsl_sort_vector_char_smallest(@Cast("char*") ByteBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_char v);
public static native int gsl_sort_vector_char_smallest(@Cast("char*") byte[] dest, @Cast("const size_t") long k, @Const gsl_vector_char v);
public static native int gsl_sort_vector_char_largest(@Cast("char*") BytePointer dest, @Cast("const size_t") long k, @Const gsl_vector_char v);
public static native int gsl_sort_vector_char_largest(@Cast("char*") ByteBuffer dest, @Cast("const size_t") long k, @Const gsl_vector_char v);
public static native int gsl_sort_vector_char_largest(@Cast("char*") byte[] dest, @Cast("const size_t") long k, @Const gsl_vector_char v);

public static native int gsl_sort_vector_char_smallest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_char v);
public static native int gsl_sort_vector_char_largest_index(@Cast("size_t*") SizeTPointer p, @Cast("const size_t") long k, @Const gsl_vector_char v);

// #endif /* __GSL_SORT_VECTOR_CHAR_H__ */


// Parsed from gsl/gsl_statistics.h

// #ifndef __GSL_STATISTICS_H__
// #define __GSL_STATISTICS_H__

// #include <gsl/gsl_statistics_long_double.h>
// #include <gsl/gsl_statistics_double.h>
// #include <gsl/gsl_statistics_float.h>

// #include <gsl/gsl_statistics_ulong.h>
// #include <gsl/gsl_statistics_long.h>

// #include <gsl/gsl_statistics_uint.h>
// #include <gsl/gsl_statistics_int.h>

// #include <gsl/gsl_statistics_ushort.h>
// #include <gsl/gsl_statistics_short.h>

// #include <gsl/gsl_statistics_uchar.h>
// #include <gsl/gsl_statistics_char.h>

// #endif /* __GSL_STATISTICS_H__ */


// Parsed from gsl/gsl_statistics_double.h

/* statistics/gsl_statistics_double.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_DOUBLE_H__
// #define __GSL_STATISTICS_DOUBLE_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_mean(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_mean(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_mean(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_variance(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_variance(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_variance(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_sd(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_sd(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_sd(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_variance_with_fixed_mean(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_variance_with_fixed_mean(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_variance_with_fixed_mean(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_sd_with_fixed_mean(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_sd_with_fixed_mean(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_sd_with_fixed_mean(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_tss(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_tss(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_tss(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_tss_m(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_tss_m(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_tss_m(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_absdev(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_absdev(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_absdev(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_skew(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_skew(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_skew(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_kurtosis(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_kurtosis(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_kurtosis(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_lag1_autocorrelation(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_lag1_autocorrelation(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_lag1_autocorrelation(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_covariance(@Const DoublePointer data1, @Cast("const size_t") long stride1,@Const DoublePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_covariance(@Const DoubleBuffer data1, @Cast("const size_t") long stride1,@Const DoubleBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_covariance(@Const double[] data1, @Cast("const size_t") long stride1,@Const double[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_correlation(@Const DoublePointer data1, @Cast("const size_t") long stride1,@Const DoublePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_correlation(@Const DoubleBuffer data1, @Cast("const size_t") long stride1,@Const DoubleBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_correlation(@Const double[] data1, @Cast("const size_t") long stride1,@Const double[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_spearman(@Const DoublePointer data1, @Cast("const size_t") long stride1, @Const DoublePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_spearman(@Const DoubleBuffer data1, @Cast("const size_t") long stride1, @Const DoubleBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_spearman(@Const double[] data1, @Cast("const size_t") long stride1, @Const double[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_variance_m(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_variance_m(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_variance_m(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_sd_m(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_sd_m(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_sd_m(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_absdev_m(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_absdev_m(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_absdev_m(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_skew_m_sd(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_skew_m_sd(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_skew_m_sd(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_kurtosis_m_sd(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_kurtosis_m_sd(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_kurtosis_m_sd(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_lag1_autocorrelation_m(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_lag1_autocorrelation_m(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_lag1_autocorrelation_m(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_covariance_m(@Const DoublePointer data1, @Cast("const size_t") long stride1,@Const DoublePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_covariance_m(@Const DoubleBuffer data1, @Cast("const size_t") long stride1,@Const DoubleBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_covariance_m(@Const double[] data1, @Cast("const size_t") long stride1,@Const double[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);

/* DEFINED FOR FLOATING POINT TYPES ONLY */

public static native double gsl_stats_wmean(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wmean(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wmean(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wvariance(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wvariance(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wvariance(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wsd(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wsd(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wsd(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wvariance_with_fixed_mean(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_wvariance_with_fixed_mean(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_wvariance_with_fixed_mean(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_wsd_with_fixed_mean(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_wsd_with_fixed_mean(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_wsd_with_fixed_mean(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_wtss(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wtss(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wtss(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wtss_m(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wtss_m(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wtss_m(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wabsdev(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wabsdev(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wabsdev(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wskew(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wskew(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wskew(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wkurtosis(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wkurtosis(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_wkurtosis(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_wvariance_m(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wvariance_m(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wvariance_m(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wsd_m(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wsd_m(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wsd_m(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wabsdev_m(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wabsdev_m(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wabsdev_m(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_wskew_m_sd(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_wskew_m_sd(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_wskew_m_sd(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_wkurtosis_m_sd(@Const DoublePointer w, @Cast("const size_t") long wstride, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_wkurtosis_m_sd(@Const DoubleBuffer w, @Cast("const size_t") long wstride, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_wkurtosis_m_sd(@Const double[] w, @Cast("const size_t") long wstride, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);

/* END OF FLOATING POINT TYPES */

public static native double gsl_stats_pvariance(@Const DoublePointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const DoublePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_pvariance(@Const DoubleBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const DoubleBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_pvariance(@Const double[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const double[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_ttest(@Const DoublePointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const DoublePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_ttest(@Const DoubleBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const DoubleBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_ttest(@Const double[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const double[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native double gsl_stats_max(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_max(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_max(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_min(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_min(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_min(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_minmax(DoublePointer min, DoublePointer max, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_minmax(DoubleBuffer min, DoubleBuffer max, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_minmax(double[] min, double[] max, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_max_index(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_max_index(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_max_index(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_min_index(@Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_min_index(@Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_min_index(@Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const DoublePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const DoubleBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const double[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_median_from_sorted_data(@Const DoublePointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_median_from_sorted_data(@Const DoubleBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_median_from_sorted_data(@Const double[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_quantile_from_sorted_data(@Const DoublePointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_quantile_from_sorted_data(@Const DoubleBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_quantile_from_sorted_data(@Const double[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_DOUBLE_H__ */


// Parsed from gsl/gsl_statistics_float.h

/* statistics/gsl_statistics_float.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_FLOAT_H__
// #define __GSL_STATISTICS_FLOAT_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_float_mean(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_mean(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_mean(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_variance(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_variance(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_variance(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_sd(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_sd(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_sd(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_variance_with_fixed_mean(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_variance_with_fixed_mean(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_variance_with_fixed_mean(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_sd_with_fixed_mean(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_sd_with_fixed_mean(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_sd_with_fixed_mean(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_tss(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_tss(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_tss(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_tss_m(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_tss_m(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_tss_m(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_float_absdev(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_absdev(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_absdev(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_skew(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_skew(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_skew(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_kurtosis(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_kurtosis(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_kurtosis(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_lag1_autocorrelation(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_lag1_autocorrelation(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_lag1_autocorrelation(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_float_covariance(@Const FloatPointer data1, @Cast("const size_t") long stride1,@Const FloatPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_float_covariance(@Const FloatBuffer data1, @Cast("const size_t") long stride1,@Const FloatBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_float_covariance(@Const float[] data1, @Cast("const size_t") long stride1,@Const float[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_float_correlation(@Const FloatPointer data1, @Cast("const size_t") long stride1,@Const FloatPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_float_correlation(@Const FloatBuffer data1, @Cast("const size_t") long stride1,@Const FloatBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_float_correlation(@Const float[] data1, @Cast("const size_t") long stride1,@Const float[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_float_spearman(@Const FloatPointer data1, @Cast("const size_t") long stride1, @Const FloatPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_float_spearman(@Const FloatBuffer data1, @Cast("const size_t") long stride1, @Const FloatBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_float_spearman(@Const float[] data1, @Cast("const size_t") long stride1, @Const float[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_float_variance_m(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_variance_m(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_variance_m(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_sd_m(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_sd_m(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_sd_m(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_absdev_m(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_absdev_m(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_absdev_m(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_skew_m_sd(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_float_skew_m_sd(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_float_skew_m_sd(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_float_kurtosis_m_sd(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_float_kurtosis_m_sd(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_float_kurtosis_m_sd(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_float_lag1_autocorrelation_m(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_lag1_autocorrelation_m(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_lag1_autocorrelation_m(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_float_covariance_m(@Const FloatPointer data1, @Cast("const size_t") long stride1,@Const FloatPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_float_covariance_m(@Const FloatBuffer data1, @Cast("const size_t") long stride1,@Const FloatBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_float_covariance_m(@Const float[] data1, @Cast("const size_t") long stride1,@Const float[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);

/* DEFINED FOR FLOATING POINT TYPES ONLY */

public static native double gsl_stats_float_wmean(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wmean(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wmean(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wvariance(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wvariance(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wvariance(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wsd(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wsd(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wsd(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wvariance_with_fixed_mean(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_wvariance_with_fixed_mean(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_wvariance_with_fixed_mean(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_wsd_with_fixed_mean(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_wsd_with_fixed_mean(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_wsd_with_fixed_mean(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_float_wtss(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wtss(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wtss(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wtss_m(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wtss_m(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wtss_m(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wabsdev(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wabsdev(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wabsdev(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wskew(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wskew(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wskew(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wkurtosis(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wkurtosis(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_wkurtosis(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_float_wvariance_m(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wvariance_m(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wvariance_m(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wsd_m(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wsd_m(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wsd_m(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wabsdev_m(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wabsdev_m(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wabsdev_m(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean);
public static native double gsl_stats_float_wskew_m_sd(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_float_wskew_m_sd(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_float_wskew_m_sd(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_float_wkurtosis_m_sd(@Const FloatPointer w, @Cast("const size_t") long wstride, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_float_wkurtosis_m_sd(@Const FloatBuffer w, @Cast("const size_t") long wstride, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);
public static native double gsl_stats_float_wkurtosis_m_sd(@Const float[] w, @Cast("const size_t") long wstride, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double wmean, double wsd);

/* END OF FLOATING POINT TYPES */

public static native double gsl_stats_float_pvariance(@Const FloatPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const FloatPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_float_pvariance(@Const FloatBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const FloatBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_float_pvariance(@Const float[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const float[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_float_ttest(@Const FloatPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const FloatPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_float_ttest(@Const FloatBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const FloatBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_float_ttest(@Const float[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const float[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native float gsl_stats_float_max(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native float gsl_stats_float_max(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native float gsl_stats_float_max(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native float gsl_stats_float_min(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native float gsl_stats_float_min(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native float gsl_stats_float_min(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_float_minmax(FloatPointer min, FloatPointer max, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_float_minmax(FloatBuffer min, FloatBuffer max, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_float_minmax(float[] min, float[] max, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_float_max_index(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_float_max_index(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_float_max_index(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_float_min_index(@Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_float_min_index(@Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_float_min_index(@Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_float_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const FloatPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_float_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const FloatBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_float_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const float[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_float_median_from_sorted_data(@Const FloatPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_median_from_sorted_data(@Const FloatBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_median_from_sorted_data(@Const float[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_float_quantile_from_sorted_data(@Const FloatPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_float_quantile_from_sorted_data(@Const FloatBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_float_quantile_from_sorted_data(@Const float[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_FLOAT_H__ */


// Parsed from gsl/gsl_statistics_ulong.h

/* statistics/gsl_statistics_ulong.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_ULONG_H__
// #define __GSL_STATISTICS_ULONG_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_ulong_mean(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_variance(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_sd(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_variance_with_fixed_mean(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ulong_sd_with_fixed_mean(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ulong_tss(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_tss_m(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_ulong_absdev(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_skew(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_kurtosis(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_lag1_autocorrelation(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_ulong_covariance(@Cast("const unsigned long*") CLongPointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned long*") CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_correlation(@Cast("const unsigned long*") CLongPointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned long*") CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_spearman(@Cast("const unsigned long*") CLongPointer data1, @Cast("const size_t") long stride1, @Cast("const unsigned long*") CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_ulong_spearman(@Cast("const unsigned long*") CLongPointer data1, @Cast("const size_t") long stride1, @Cast("const unsigned long*") CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_ulong_spearman(@Cast("const unsigned long*") CLongPointer data1, @Cast("const size_t") long stride1, @Cast("const unsigned long*") CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_ulong_variance_m(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ulong_sd_m(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ulong_absdev_m(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ulong_skew_m_sd(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_ulong_kurtosis_m_sd(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_ulong_lag1_autocorrelation_m(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_ulong_covariance_m(@Cast("const unsigned long*") CLongPointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned long*") CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);


public static native double gsl_stats_ulong_pvariance(@Cast("const unsigned long*") CLongPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned long*") CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_ulong_ttest(@Cast("const unsigned long*") CLongPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned long*") CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native @Cast("unsigned long") long gsl_stats_ulong_max(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned long") long gsl_stats_ulong_min(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_ulong_minmax(@Cast("unsigned long*") CLongPointer min, @Cast("unsigned long*") CLongPointer max, @Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_ulong_max_index(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_ulong_min_index(@Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_ulong_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned long*") CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_ulong_median_from_sorted_data(@Cast("const unsigned long*") CLongPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ulong_quantile_from_sorted_data(@Cast("const unsigned long*") CLongPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_ULONG_H__ */


// Parsed from gsl/gsl_statistics_long.h

/* statistics/gsl_statistics_long.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_LONG_H__
// #define __GSL_STATISTICS_LONG_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_long_mean(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_long_variance(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_long_sd(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_long_variance_with_fixed_mean(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_long_sd_with_fixed_mean(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_long_tss(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_long_tss_m(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_long_absdev(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_long_skew(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_long_kurtosis(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_long_lag1_autocorrelation(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_long_covariance(@Const CLongPointer data1, @Cast("const size_t") long stride1,@Const CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_long_correlation(@Const CLongPointer data1, @Cast("const size_t") long stride1,@Const CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_long_spearman(@Const CLongPointer data1, @Cast("const size_t") long stride1, @Const CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_long_spearman(@Const CLongPointer data1, @Cast("const size_t") long stride1, @Const CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_long_spearman(@Const CLongPointer data1, @Cast("const size_t") long stride1, @Const CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_long_variance_m(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_long_sd_m(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_long_absdev_m(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_long_skew_m_sd(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_long_kurtosis_m_sd(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_long_lag1_autocorrelation_m(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_long_covariance_m(@Const CLongPointer data1, @Cast("const size_t") long stride1,@Const CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);


public static native double gsl_stats_long_pvariance(@Const CLongPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_long_ttest(@Const CLongPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const CLongPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native long gsl_stats_long_max(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native long gsl_stats_long_min(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_long_minmax(CLongPointer min, CLongPointer max, @Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_long_max_index(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_long_min_index(@Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_long_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const CLongPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_long_median_from_sorted_data(@Const CLongPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_long_quantile_from_sorted_data(@Const CLongPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_LONG_H__ */


// Parsed from gsl/gsl_statistics_uint.h

/* statistics/gsl_statistics_uint.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_UINT_H__
// #define __GSL_STATISTICS_UINT_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_uint_mean(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_mean(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_mean(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_variance(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_variance(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_variance(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_sd(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_sd(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_sd(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_variance_with_fixed_mean(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_variance_with_fixed_mean(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_variance_with_fixed_mean(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_sd_with_fixed_mean(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_sd_with_fixed_mean(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_sd_with_fixed_mean(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_tss(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_tss(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_tss(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_tss_m(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_tss_m(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_tss_m(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_uint_absdev(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_absdev(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_absdev(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_skew(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_skew(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_skew(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_kurtosis(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_kurtosis(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_kurtosis(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_lag1_autocorrelation(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_lag1_autocorrelation(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_lag1_autocorrelation(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_uint_covariance(@Cast("const unsigned int*") IntPointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned int*") IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uint_covariance(@Cast("const unsigned int*") IntBuffer data1, @Cast("const size_t") long stride1,@Cast("const unsigned int*") IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uint_covariance(@Cast("const unsigned int*") int[] data1, @Cast("const size_t") long stride1,@Cast("const unsigned int*") int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uint_correlation(@Cast("const unsigned int*") IntPointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned int*") IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uint_correlation(@Cast("const unsigned int*") IntBuffer data1, @Cast("const size_t") long stride1,@Cast("const unsigned int*") IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uint_correlation(@Cast("const unsigned int*") int[] data1, @Cast("const size_t") long stride1,@Cast("const unsigned int*") int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uint_spearman(@Cast("const unsigned int*") IntPointer data1, @Cast("const size_t") long stride1, @Cast("const unsigned int*") IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_uint_spearman(@Cast("const unsigned int*") IntBuffer data1, @Cast("const size_t") long stride1, @Cast("const unsigned int*") IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_uint_spearman(@Cast("const unsigned int*") int[] data1, @Cast("const size_t") long stride1, @Cast("const unsigned int*") int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_uint_variance_m(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_variance_m(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_variance_m(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_sd_m(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_sd_m(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_sd_m(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_absdev_m(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_absdev_m(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_absdev_m(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_skew_m_sd(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uint_skew_m_sd(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uint_skew_m_sd(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uint_kurtosis_m_sd(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uint_kurtosis_m_sd(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uint_kurtosis_m_sd(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uint_lag1_autocorrelation_m(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_lag1_autocorrelation_m(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uint_lag1_autocorrelation_m(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_uint_covariance_m(@Cast("const unsigned int*") IntPointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned int*") IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_uint_covariance_m(@Cast("const unsigned int*") IntBuffer data1, @Cast("const size_t") long stride1,@Cast("const unsigned int*") IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_uint_covariance_m(@Cast("const unsigned int*") int[] data1, @Cast("const size_t") long stride1,@Cast("const unsigned int*") int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);


public static native double gsl_stats_uint_pvariance(@Cast("const unsigned int*") IntPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned int*") IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uint_pvariance(@Cast("const unsigned int*") IntBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned int*") IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uint_pvariance(@Cast("const unsigned int*") int[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned int*") int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uint_ttest(@Cast("const unsigned int*") IntPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned int*") IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uint_ttest(@Cast("const unsigned int*") IntBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned int*") IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uint_ttest(@Cast("const unsigned int*") int[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned int*") int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native @Cast("unsigned int") int gsl_stats_uint_max(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned int") int gsl_stats_uint_max(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned int") int gsl_stats_uint_max(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned int") int gsl_stats_uint_min(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned int") int gsl_stats_uint_min(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned int") int gsl_stats_uint_min(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uint_minmax(@Cast("unsigned int*") IntPointer min, @Cast("unsigned int*") IntPointer max, @Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uint_minmax(@Cast("unsigned int*") IntBuffer min, @Cast("unsigned int*") IntBuffer max, @Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uint_minmax(@Cast("unsigned int*") int[] min, @Cast("unsigned int*") int[] max, @Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_uint_max_index(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uint_max_index(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uint_max_index(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uint_min_index(@Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uint_min_index(@Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uint_min_index(@Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uint_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned int*") IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uint_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned int*") IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uint_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned int*") int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_uint_median_from_sorted_data(@Cast("const unsigned int*") IntPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_median_from_sorted_data(@Cast("const unsigned int*") IntBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_median_from_sorted_data(@Cast("const unsigned int*") int[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uint_quantile_from_sorted_data(@Cast("const unsigned int*") IntPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_uint_quantile_from_sorted_data(@Cast("const unsigned int*") IntBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_uint_quantile_from_sorted_data(@Cast("const unsigned int*") int[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_UINT_H__ */


// Parsed from gsl/gsl_statistics_int.h

/* statistics/gsl_statistics_int.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_INT_H__
// #define __GSL_STATISTICS_INT_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_int_mean(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_mean(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_mean(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_variance(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_variance(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_variance(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_sd(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_sd(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_sd(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_variance_with_fixed_mean(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_variance_with_fixed_mean(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_variance_with_fixed_mean(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_sd_with_fixed_mean(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_sd_with_fixed_mean(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_sd_with_fixed_mean(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_tss(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_tss(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_tss(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_tss_m(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_tss_m(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_tss_m(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_int_absdev(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_absdev(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_absdev(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_skew(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_skew(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_skew(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_kurtosis(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_kurtosis(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_kurtosis(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_lag1_autocorrelation(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_lag1_autocorrelation(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_lag1_autocorrelation(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_int_covariance(@Const IntPointer data1, @Cast("const size_t") long stride1,@Const IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_int_covariance(@Const IntBuffer data1, @Cast("const size_t") long stride1,@Const IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_int_covariance(@Const int[] data1, @Cast("const size_t") long stride1,@Const int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_int_correlation(@Const IntPointer data1, @Cast("const size_t") long stride1,@Const IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_int_correlation(@Const IntBuffer data1, @Cast("const size_t") long stride1,@Const IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_int_correlation(@Const int[] data1, @Cast("const size_t") long stride1,@Const int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_int_spearman(@Const IntPointer data1, @Cast("const size_t") long stride1, @Const IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_int_spearman(@Const IntBuffer data1, @Cast("const size_t") long stride1, @Const IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_int_spearman(@Const int[] data1, @Cast("const size_t") long stride1, @Const int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_int_variance_m(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_variance_m(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_variance_m(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_sd_m(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_sd_m(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_sd_m(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_absdev_m(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_absdev_m(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_absdev_m(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_skew_m_sd(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_int_skew_m_sd(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_int_skew_m_sd(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_int_kurtosis_m_sd(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_int_kurtosis_m_sd(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_int_kurtosis_m_sd(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_int_lag1_autocorrelation_m(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_lag1_autocorrelation_m(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_int_lag1_autocorrelation_m(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_int_covariance_m(@Const IntPointer data1, @Cast("const size_t") long stride1,@Const IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_int_covariance_m(@Const IntBuffer data1, @Cast("const size_t") long stride1,@Const IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_int_covariance_m(@Const int[] data1, @Cast("const size_t") long stride1,@Const int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);


public static native double gsl_stats_int_pvariance(@Const IntPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_int_pvariance(@Const IntBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_int_pvariance(@Const int[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_int_ttest(@Const IntPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const IntPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_int_ttest(@Const IntBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const IntBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_int_ttest(@Const int[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const int[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native int gsl_stats_int_max(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_stats_int_max(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_stats_int_max(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_stats_int_min(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_stats_int_min(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native int gsl_stats_int_min(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_int_minmax(IntPointer min, IntPointer max, @Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_int_minmax(IntBuffer min, IntBuffer max, @Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_int_minmax(int[] min, int[] max, @Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_int_max_index(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_int_max_index(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_int_max_index(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_int_min_index(@Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_int_min_index(@Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_int_min_index(@Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_int_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const IntPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_int_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const IntBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_int_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const int[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_int_median_from_sorted_data(@Const IntPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_median_from_sorted_data(@Const IntBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_median_from_sorted_data(@Const int[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_int_quantile_from_sorted_data(@Const IntPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_int_quantile_from_sorted_data(@Const IntBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_int_quantile_from_sorted_data(@Const int[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_INT_H__ */


// Parsed from gsl/gsl_statistics_ushort.h

/* statistics/gsl_statistics_ushort.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_USHORT_H__
// #define __GSL_STATISTICS_USHORT_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_ushort_mean(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_mean(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_mean(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_variance(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_variance(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_variance(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_sd(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_sd(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_sd(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_variance_with_fixed_mean(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_variance_with_fixed_mean(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_variance_with_fixed_mean(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_sd_with_fixed_mean(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_sd_with_fixed_mean(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_sd_with_fixed_mean(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_tss(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_tss(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_tss(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_tss_m(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_tss_m(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_tss_m(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_ushort_absdev(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_absdev(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_absdev(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_skew(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_skew(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_skew(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_kurtosis(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_kurtosis(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_kurtosis(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_lag1_autocorrelation(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_lag1_autocorrelation(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_lag1_autocorrelation(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_ushort_covariance(@Cast("const unsigned short*") ShortPointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned short*") ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_covariance(@Cast("const unsigned short*") ShortBuffer data1, @Cast("const size_t") long stride1,@Cast("const unsigned short*") ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_covariance(@Cast("const unsigned short*") short[] data1, @Cast("const size_t") long stride1,@Cast("const unsigned short*") short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_correlation(@Cast("const unsigned short*") ShortPointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned short*") ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_correlation(@Cast("const unsigned short*") ShortBuffer data1, @Cast("const size_t") long stride1,@Cast("const unsigned short*") ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_correlation(@Cast("const unsigned short*") short[] data1, @Cast("const size_t") long stride1,@Cast("const unsigned short*") short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_spearman(@Cast("const unsigned short*") ShortPointer data1, @Cast("const size_t") long stride1, @Cast("const unsigned short*") ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_ushort_spearman(@Cast("const unsigned short*") ShortBuffer data1, @Cast("const size_t") long stride1, @Cast("const unsigned short*") ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_ushort_spearman(@Cast("const unsigned short*") short[] data1, @Cast("const size_t") long stride1, @Cast("const unsigned short*") short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_ushort_variance_m(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_variance_m(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_variance_m(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_sd_m(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_sd_m(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_sd_m(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_absdev_m(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_absdev_m(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_absdev_m(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_skew_m_sd(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_ushort_skew_m_sd(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_ushort_skew_m_sd(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_ushort_kurtosis_m_sd(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_ushort_kurtosis_m_sd(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_ushort_kurtosis_m_sd(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_ushort_lag1_autocorrelation_m(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_lag1_autocorrelation_m(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_ushort_lag1_autocorrelation_m(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_ushort_covariance_m(@Cast("const unsigned short*") ShortPointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned short*") ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_ushort_covariance_m(@Cast("const unsigned short*") ShortBuffer data1, @Cast("const size_t") long stride1,@Cast("const unsigned short*") ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_ushort_covariance_m(@Cast("const unsigned short*") short[] data1, @Cast("const size_t") long stride1,@Cast("const unsigned short*") short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);


public static native double gsl_stats_ushort_pvariance(@Cast("const unsigned short*") ShortPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned short*") ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_ushort_pvariance(@Cast("const unsigned short*") ShortBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned short*") ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_ushort_pvariance(@Cast("const unsigned short*") short[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned short*") short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_ushort_ttest(@Cast("const unsigned short*") ShortPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned short*") ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_ushort_ttest(@Cast("const unsigned short*") ShortBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned short*") ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_ushort_ttest(@Cast("const unsigned short*") short[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned short*") short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native @Cast("unsigned short") short gsl_stats_ushort_max(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned short") short gsl_stats_ushort_max(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned short") short gsl_stats_ushort_max(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned short") short gsl_stats_ushort_min(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned short") short gsl_stats_ushort_min(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned short") short gsl_stats_ushort_min(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_ushort_minmax(@Cast("unsigned short*") ShortPointer min, @Cast("unsigned short*") ShortPointer max, @Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_ushort_minmax(@Cast("unsigned short*") ShortBuffer min, @Cast("unsigned short*") ShortBuffer max, @Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_ushort_minmax(@Cast("unsigned short*") short[] min, @Cast("unsigned short*") short[] max, @Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_ushort_max_index(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_ushort_max_index(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_ushort_max_index(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_ushort_min_index(@Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_ushort_min_index(@Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_ushort_min_index(@Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_ushort_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned short*") ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_ushort_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned short*") ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_ushort_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned short*") short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_ushort_median_from_sorted_data(@Cast("const unsigned short*") ShortPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_median_from_sorted_data(@Cast("const unsigned short*") ShortBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_median_from_sorted_data(@Cast("const unsigned short*") short[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_ushort_quantile_from_sorted_data(@Cast("const unsigned short*") ShortPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_ushort_quantile_from_sorted_data(@Cast("const unsigned short*") ShortBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_ushort_quantile_from_sorted_data(@Cast("const unsigned short*") short[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_USHORT_H__ */


// Parsed from gsl/gsl_statistics_short.h

/* statistics/gsl_statistics_short.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_SHORT_H__
// #define __GSL_STATISTICS_SHORT_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_short_mean(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_mean(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_mean(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_variance(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_variance(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_variance(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_sd(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_sd(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_sd(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_variance_with_fixed_mean(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_variance_with_fixed_mean(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_variance_with_fixed_mean(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_sd_with_fixed_mean(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_sd_with_fixed_mean(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_sd_with_fixed_mean(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_tss(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_tss(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_tss(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_tss_m(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_tss_m(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_tss_m(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_short_absdev(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_absdev(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_absdev(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_skew(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_skew(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_skew(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_kurtosis(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_kurtosis(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_kurtosis(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_lag1_autocorrelation(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_lag1_autocorrelation(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_lag1_autocorrelation(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_short_covariance(@Const ShortPointer data1, @Cast("const size_t") long stride1,@Const ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_short_covariance(@Const ShortBuffer data1, @Cast("const size_t") long stride1,@Const ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_short_covariance(@Const short[] data1, @Cast("const size_t") long stride1,@Const short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_short_correlation(@Const ShortPointer data1, @Cast("const size_t") long stride1,@Const ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_short_correlation(@Const ShortBuffer data1, @Cast("const size_t") long stride1,@Const ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_short_correlation(@Const short[] data1, @Cast("const size_t") long stride1,@Const short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_short_spearman(@Const ShortPointer data1, @Cast("const size_t") long stride1, @Const ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_short_spearman(@Const ShortBuffer data1, @Cast("const size_t") long stride1, @Const ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_short_spearman(@Const short[] data1, @Cast("const size_t") long stride1, @Const short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_short_variance_m(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_variance_m(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_variance_m(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_sd_m(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_sd_m(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_sd_m(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_absdev_m(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_absdev_m(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_absdev_m(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_skew_m_sd(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_short_skew_m_sd(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_short_skew_m_sd(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_short_kurtosis_m_sd(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_short_kurtosis_m_sd(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_short_kurtosis_m_sd(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_short_lag1_autocorrelation_m(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_lag1_autocorrelation_m(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_short_lag1_autocorrelation_m(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_short_covariance_m(@Const ShortPointer data1, @Cast("const size_t") long stride1,@Const ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_short_covariance_m(@Const ShortBuffer data1, @Cast("const size_t") long stride1,@Const ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_short_covariance_m(@Const short[] data1, @Cast("const size_t") long stride1,@Const short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);


public static native double gsl_stats_short_pvariance(@Const ShortPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_short_pvariance(@Const ShortBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_short_pvariance(@Const short[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_short_ttest(@Const ShortPointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const ShortPointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_short_ttest(@Const ShortBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const ShortBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_short_ttest(@Const short[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Const short[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native short gsl_stats_short_max(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native short gsl_stats_short_max(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native short gsl_stats_short_max(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native short gsl_stats_short_min(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native short gsl_stats_short_min(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native short gsl_stats_short_min(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_short_minmax(ShortPointer min, ShortPointer max, @Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_short_minmax(ShortBuffer min, ShortBuffer max, @Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_short_minmax(short[] min, short[] max, @Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_short_max_index(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_short_max_index(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_short_max_index(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_short_min_index(@Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_short_min_index(@Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_short_min_index(@Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_short_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const ShortPointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_short_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const ShortBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_short_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Const short[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_short_median_from_sorted_data(@Const ShortPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_median_from_sorted_data(@Const ShortBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_median_from_sorted_data(@Const short[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_short_quantile_from_sorted_data(@Const ShortPointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_short_quantile_from_sorted_data(@Const ShortBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_short_quantile_from_sorted_data(@Const short[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_SHORT_H__ */


// Parsed from gsl/gsl_statistics_uchar.h

/* statistics/gsl_statistics_uchar.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_UCHAR_H__
// #define __GSL_STATISTICS_UCHAR_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_uchar_mean(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_mean(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_mean(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_variance(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_variance(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_variance(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_sd(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_sd(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_sd(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_variance_with_fixed_mean(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_variance_with_fixed_mean(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_variance_with_fixed_mean(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_sd_with_fixed_mean(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_sd_with_fixed_mean(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_sd_with_fixed_mean(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_tss(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_tss(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_tss(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_tss_m(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_tss_m(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_tss_m(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_uchar_absdev(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_absdev(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_absdev(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_skew(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_skew(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_skew(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_kurtosis(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_kurtosis(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_kurtosis(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_lag1_autocorrelation(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_lag1_autocorrelation(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_lag1_autocorrelation(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_uchar_covariance(@Cast("const unsigned char*") BytePointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_covariance(@Cast("const unsigned char*") ByteBuffer data1, @Cast("const size_t") long stride1,@Cast("const unsigned char*") ByteBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_covariance(@Cast("const unsigned char*") byte[] data1, @Cast("const size_t") long stride1,@Cast("const unsigned char*") byte[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_correlation(@Cast("const unsigned char*") BytePointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_correlation(@Cast("const unsigned char*") ByteBuffer data1, @Cast("const size_t") long stride1,@Cast("const unsigned char*") ByteBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_correlation(@Cast("const unsigned char*") byte[] data1, @Cast("const size_t") long stride1,@Cast("const unsigned char*") byte[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_spearman(@Cast("const unsigned char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("const unsigned char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_uchar_spearman(@Cast("const unsigned char*") ByteBuffer data1, @Cast("const size_t") long stride1, @Cast("const unsigned char*") ByteBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_uchar_spearman(@Cast("const unsigned char*") byte[] data1, @Cast("const size_t") long stride1, @Cast("const unsigned char*") byte[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_uchar_variance_m(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_variance_m(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_variance_m(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_sd_m(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_sd_m(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_sd_m(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_absdev_m(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_absdev_m(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_absdev_m(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_skew_m_sd(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uchar_skew_m_sd(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uchar_skew_m_sd(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uchar_kurtosis_m_sd(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uchar_kurtosis_m_sd(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uchar_kurtosis_m_sd(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_uchar_lag1_autocorrelation_m(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_lag1_autocorrelation_m(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_uchar_lag1_autocorrelation_m(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_uchar_covariance_m(@Cast("const unsigned char*") BytePointer data1, @Cast("const size_t") long stride1,@Cast("const unsigned char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_uchar_covariance_m(@Cast("const unsigned char*") ByteBuffer data1, @Cast("const size_t") long stride1,@Cast("const unsigned char*") ByteBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_uchar_covariance_m(@Cast("const unsigned char*") byte[] data1, @Cast("const size_t") long stride1,@Cast("const unsigned char*") byte[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);


public static native double gsl_stats_uchar_pvariance(@Cast("const unsigned char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uchar_pvariance(@Cast("const unsigned char*") ByteBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned char*") ByteBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uchar_pvariance(@Cast("const unsigned char*") byte[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned char*") byte[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uchar_ttest(@Cast("const unsigned char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uchar_ttest(@Cast("const unsigned char*") ByteBuffer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned char*") ByteBuffer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_uchar_ttest(@Cast("const unsigned char*") byte[] data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const unsigned char*") byte[] data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native @Cast("unsigned char") byte gsl_stats_uchar_max(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned char") byte gsl_stats_uchar_max(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned char") byte gsl_stats_uchar_max(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned char") byte gsl_stats_uchar_min(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned char") byte gsl_stats_uchar_min(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("unsigned char") byte gsl_stats_uchar_min(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uchar_minmax(@Cast("unsigned char*") BytePointer min, @Cast("unsigned char*") BytePointer max, @Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uchar_minmax(@Cast("unsigned char*") ByteBuffer min, @Cast("unsigned char*") ByteBuffer max, @Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uchar_minmax(@Cast("unsigned char*") byte[] min, @Cast("unsigned char*") byte[] max, @Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_uchar_max_index(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uchar_max_index(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uchar_max_index(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uchar_min_index(@Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uchar_min_index(@Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_uchar_min_index(@Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uchar_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uchar_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned char*") ByteBuffer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_uchar_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const unsigned char*") byte[] data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_uchar_median_from_sorted_data(@Cast("const unsigned char*") BytePointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_median_from_sorted_data(@Cast("const unsigned char*") ByteBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_median_from_sorted_data(@Cast("const unsigned char*") byte[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_uchar_quantile_from_sorted_data(@Cast("const unsigned char*") BytePointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_uchar_quantile_from_sorted_data(@Cast("const unsigned char*") ByteBuffer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_uchar_quantile_from_sorted_data(@Cast("const unsigned char*") byte[] sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_UCHAR_H__ */


// Parsed from gsl/gsl_statistics_char.h

/* statistics/gsl_statistics_char.h
 * 
 * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

// #ifndef __GSL_STATISTICS_CHAR_H__
// #define __GSL_STATISTICS_CHAR_H__

// #include <stddef.h>

// #undef __BEGIN_DECLS
// #undef __END_DECLS
// #ifdef __cplusplus
// # define __BEGIN_DECLS extern "C" {
// # define __END_DECLS }
// #else
// #endif

public static native double gsl_stats_char_mean(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_mean(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_variance(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_variance(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_sd(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_sd(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_variance_with_fixed_mean(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_variance_with_fixed_mean(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_sd_with_fixed_mean(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_sd_with_fixed_mean(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_tss(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_tss(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_tss_m(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_tss_m(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_char_absdev(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_absdev(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_skew(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_skew(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_kurtosis(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_kurtosis(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_lag1_autocorrelation(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_lag1_autocorrelation(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_char_covariance(@Cast("const char*") BytePointer data1, @Cast("const size_t") long stride1,@Cast("const char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_char_covariance(String data1, @Cast("const size_t") long stride1,String data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_char_correlation(@Cast("const char*") BytePointer data1, @Cast("const size_t") long stride1,@Cast("const char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_char_correlation(String data1, @Cast("const size_t") long stride1,String data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n);
public static native double gsl_stats_char_spearman(@Cast("const char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("const char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_char_spearman(String data1, @Cast("const size_t") long stride1, String data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_char_spearman(@Cast("const char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("const char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);
public static native double gsl_stats_char_spearman(String data1, @Cast("const size_t") long stride1, String data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoublePointer work);
public static native double gsl_stats_char_spearman(@Cast("const char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("const char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, DoubleBuffer work);
public static native double gsl_stats_char_spearman(String data1, @Cast("const size_t") long stride1, String data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double[] work);

public static native double gsl_stats_char_variance_m(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_variance_m(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_sd_m(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_sd_m(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_absdev_m(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_absdev_m(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_skew_m_sd(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_char_skew_m_sd(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_char_kurtosis_m_sd(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_char_kurtosis_m_sd(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean, double sd);
public static native double gsl_stats_char_lag1_autocorrelation_m(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);
public static native double gsl_stats_char_lag1_autocorrelation_m(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double mean);

public static native double gsl_stats_char_covariance_m(@Cast("const char*") BytePointer data1, @Cast("const size_t") long stride1,@Cast("const char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);
public static native double gsl_stats_char_covariance_m(String data1, @Cast("const size_t") long stride1,String data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n, double mean1, double mean2);


public static native double gsl_stats_char_pvariance(@Cast("const char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_char_pvariance(String data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, String data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_char_ttest(@Cast("const char*") BytePointer data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, @Cast("const char*") BytePointer data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);
public static native double gsl_stats_char_ttest(String data1, @Cast("const size_t") long stride1, @Cast("const size_t") long n1, String data2, @Cast("const size_t") long stride2, @Cast("const size_t") long n2);

public static native @Cast("char") byte gsl_stats_char_max(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("char") byte gsl_stats_char_max(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("char") byte gsl_stats_char_min(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("char") byte gsl_stats_char_min(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_char_minmax(@Cast("char*") BytePointer min, @Cast("char*") BytePointer max, @Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_char_minmax(@Cast("char*") ByteBuffer min, @Cast("char*") ByteBuffer max, String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_char_minmax(@Cast("char*") byte[] min, @Cast("char*") byte[] max, @Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_char_minmax(@Cast("char*") BytePointer min, @Cast("char*") BytePointer max, String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_char_minmax(@Cast("char*") ByteBuffer min, @Cast("char*") ByteBuffer max, @Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_char_minmax(@Cast("char*") byte[] min, @Cast("char*") byte[] max, String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native @Cast("size_t") long gsl_stats_char_max_index(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_char_max_index(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_char_min_index(@Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native @Cast("size_t") long gsl_stats_char_min_index(String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_char_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, @Cast("const char*") BytePointer data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native void gsl_stats_char_minmax_index(@Cast("size_t*") SizeTPointer min_index, @Cast("size_t*") SizeTPointer max_index, String data, @Cast("const size_t") long stride, @Cast("const size_t") long n);

public static native double gsl_stats_char_median_from_sorted_data(@Cast("const char*") BytePointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_median_from_sorted_data(String sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n);
public static native double gsl_stats_char_quantile_from_sorted_data(@Cast("const char*") BytePointer sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);
public static native double gsl_stats_char_quantile_from_sorted_data(String sorted_data, @Cast("const size_t") long stride, @Cast("const size_t") long n, double f);

// #endif /* __GSL_STATISTICS_CHAR_H__ */


}
