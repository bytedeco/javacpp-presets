// Targeted by JavaCPP version 1.5.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.libecl.global;

import org.bytedeco.libecl.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class libecl extends org.bytedeco.libecl.presets.libecl {
    static { Loader.load(); }

// Parsed from ert/util/vector_util.hpp

/*
   Copyright (C) 2018  Equinor ASA, Norway.

   The file 'vector_util.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #include <stdio.h>

// #include <vector>
// #include <algorithm>


// Parsed from ert/util/node_data.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'node_data.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_NODE_DATA_H
// #define ERT_NODE_DATA_H

// #include <stdbool.h>

// #ifdef __cplusplus
// Targeting ../copyc_ftype.java


// Targeting ../free_ftype.java


// Targeting ../node_data_type.java




public static native void node_data_free(node_data_type arg0);
public static native void node_data_free_container(node_data_type arg0 );
public static native node_data_type node_data_alloc_deep_copy(@Const node_data_type arg0 );
public static native node_data_type node_data_alloc_shallow_copy(@Const node_data_type arg0 );
public static native node_data_type node_data_alloc_copy(@Const node_data_type node, @Cast("bool") boolean deep_copy);
public static native Pointer node_data_get_ptr(@Const node_data_type arg0);
public static native @Const Pointer node_data_get_const_ptr(@Const node_data_type arg0);
public static native node_data_type node_data_alloc_buffer(@Const Pointer arg0, int arg1 );
public static native node_data_type node_data_alloc_ptr(@Const Pointer arg0, copyc_ftype arg1, free_ftype arg2);

public static native node_data_type node_data_alloc_int(int arg0 );
public static native int node_data_get_int( @Const node_data_type arg0 );
public static native int node_data_fetch_and_inc_int( node_data_type node_data );
public static native node_data_type node_data_alloc_double(double arg0 );
public static native double node_data_get_double( @Const node_data_type arg0 );
public static native node_data_type node_data_alloc_string(@Cast("const char*") BytePointer arg0);
public static native node_data_type node_data_alloc_string(String arg0);
public static native @Cast("char*") BytePointer node_data_get_string( @Const node_data_type arg0 );



// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/ert_api_config.h

// #define ERT_HAVE_ZLIB
// #define ERT_HAVE_ISFINITE
// #define ERT_HAVE_GETOPT
// #define ERT_HAVE_UNISTD
// #define ERT_HAVE_SPAWN
// #define ERT_HAVE_THREAD_POOL
// #define ERT_HAVE_OPENDIR
// #define ERT_HAVE_SYMLINK
// #define ERT_HAVE_READLINKAT
// #define ERT_HAVE_READLINKAT_DECLARATION
// #define ERT_HAVE_GLOB
// #define ERT_HAVE_GETUID
// #define ERT_HAVE_REGEXP
// #define ERT_HAVE_LOCKF
// #define ERT_TIME_T_64BIT_ACCEPT_PRE1970
/* #undef ERT_WINDOWS_LFS */
/* #undef ERT_HAVE_PING */
/* #undef PING_CMD */




// Parsed from ert/util/ert_api_config.hpp

// #include <ert/util/ert_api_config.h>


// Parsed from ert/util/util.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'util.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_UTIL_H
// #define ERT_UTIL_H

// #include <stdbool.h>
// #include <stdio.h>
// #include <stdint.h>
// #include <stdarg.h>
// #include <sys/types.h>
// #include <time.h>


// #include <ert/util/ert_api_config.hpp>



// #ifdef ERT_HAVE_GETUID
// #endif

// #ifdef ERT_WINDOWS
public static final String UTIL_PATH_SEP_STRING =           "\\";   /* A \0 terminated separator used when we want a (char *) instance.                   */
public static final int UTIL_PATH_SEP_CHAR =             '\\';   /* A simple character used when we want an actual char instance (i.e. not a pointer). */
// #else   /* A \0 terminated separator used when we want a (char *) instance.                   */   /* A simple character used when we want an actual char instance (i.e. not a pointer). */
// #endif

public static final int UTIL_WINDOWS_PATH_SEP_CHAR = '\\';
public static final int UTIL_POSIX_PATH_SEP_CHAR =   '/';

public static final String UTIL_NEWLINE_STRING = "          \n";
public static final int UTIL_DEFAULT_MKDIR_MODE = 0777;         /* Directories are by default created with mode a+rwx - and then comes the umask ... */


// #ifdef __cplusplus
// Targeting ../stat_type.java


// #else
// #ifdef HAVE_FSEEKO
// #else
// Targeting ../walk_file_callback_ftype.java


// Targeting ../walk_dir_callback_ftype.java

       /* Arbitrary argument */


  public static native @Cast("char*") BytePointer util_get_timezone();
  public static native @ByVal @Cast("time_t*") Pointer util_make_datetime_utc(int arg0, int arg1, int arg2, int arg3, int arg4, int arg5 );
  public static native @Cast("bool") boolean util_make_datetime_utc_validated(int sec, int min, int hour, int mday, int month, int year, @Cast("time_t*") Pointer t);
  public static native @ByVal @Cast("time_t*") Pointer util_make_date_utc(int arg0, int arg1, int arg2);
  public static native @ByVal @Cast("time_t*") Pointer util_make_pure_date_utc(@ByVal @Cast("time_t*") Pointer t);
  public static native void util_inplace_forward_seconds_utc(@Cast("time_t*") Pointer t, double seconds);
  public static native void util_inplace_forward_days_utc(@Cast("time_t*") Pointer t, double days);

  public static native @ByVal @Cast("time_t*") Pointer util_file_mtime(@Cast("const char*") BytePointer file);
  public static native @ByVal @Cast("time_t*") Pointer util_file_mtime(String file);
  public static native double util_difftime(@ByVal @Cast("time_t*") Pointer arg0, @ByVal @Cast("time_t*") Pointer arg1, IntPointer arg2, IntPointer arg3, IntPointer arg4, IntPointer arg5);
  public static native double util_difftime(@ByVal @Cast("time_t*") Pointer arg0, @ByVal @Cast("time_t*") Pointer arg1, IntBuffer arg2, IntBuffer arg3, IntBuffer arg4, IntBuffer arg5);
  public static native double util_difftime(@ByVal @Cast("time_t*") Pointer arg0, @ByVal @Cast("time_t*") Pointer arg1, int[] arg2, int[] arg3, int[] arg4, int[] arg5);
  public static native double util_difftime_days(@ByVal @Cast("time_t*") Pointer arg0, @ByVal @Cast("time_t*") Pointer arg1 );
  public static native double util_difftime_seconds( @ByVal @Cast("time_t*") Pointer start_time, @ByVal @Cast("time_t*") Pointer end_time);
  public static native @Cast("bool") boolean util_after( @ByVal @Cast("time_t*") Pointer t, @ByVal @Cast("time_t*") Pointer _limit);
  public static native @Cast("bool") boolean util_before( @ByVal @Cast("time_t*") Pointer t, @ByVal @Cast("time_t*") Pointer _limit);
  public static native @Cast("bool") boolean util_file_newer( @Cast("const char*") BytePointer file, @ByVal @Cast("time_t*") Pointer t0);
  public static native @Cast("bool") boolean util_file_newer( String file, @ByVal @Cast("time_t*") Pointer t0);
  public static native @Cast("bool") boolean util_file_older( @Cast("const char*") BytePointer file, @ByVal @Cast("time_t*") Pointer t0);
  public static native @Cast("bool") boolean util_file_older( String file, @ByVal @Cast("time_t*") Pointer t0);

  public static native @Cast("char*") BytePointer util_alloc_date_string_utc( @ByVal @Cast("time_t*") Pointer t );
  public static native @Cast("char*") BytePointer util_alloc_date_stamp_utc( );

  public static native double util_pow10(double x);
  public static native @Cast("bool") boolean util_char_in(@Cast("char") byte c, int arg1, @Cast("const char*") BytePointer arg2);
  public static native @Cast("bool") boolean util_char_in(@Cast("char") byte c, int arg1, String arg2);
  public static native @Cast("char*") BytePointer util_alloc_sprintf_va(@Cast("const char*") BytePointer fmt, @ByVal @Cast("va_list*") Pointer ap);
  public static native @Cast("char*") ByteBuffer util_alloc_sprintf_va(String fmt, @ByVal @Cast("va_list*") Pointer ap);
  public static native @Cast("char*") BytePointer util_alloc_sprintf(@Cast("const char*") BytePointer arg0);
  public static native @Cast("char*") ByteBuffer util_alloc_sprintf(String arg0);
  public static native @Cast("char*") BytePointer util_realloc_sprintf(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("char*") ByteBuffer util_realloc_sprintf(@Cast("char*") ByteBuffer arg0, String arg1);
  public static native @Cast("char*") byte[] util_realloc_sprintf(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("char*") BytePointer util_realloc_sprintf(@Cast("char*") BytePointer arg0, String arg1);
  public static native @Cast("char*") ByteBuffer util_realloc_sprintf(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("char*") byte[] util_realloc_sprintf(@Cast("char*") byte[] arg0, String arg1);
  public static native @Cast("bool") boolean util_fscanf_date_utc(@Cast("FILE*") Pointer arg0, @Cast("time_t*") Pointer arg1);
  public static native @Cast("bool") boolean util_sscanf_date_utc(@Cast("const char*") BytePointer arg0, @Cast("time_t*") Pointer arg1);
  public static native @Cast("bool") boolean util_sscanf_date_utc(String arg0, @Cast("time_t*") Pointer arg1);
  public static native @Cast("bool") boolean util_sscanf_isodate(@Cast("const char*") BytePointer arg0, @Cast("time_t*") Pointer arg1);
  public static native @Cast("bool") boolean util_sscanf_isodate(String arg0, @Cast("time_t*") Pointer arg1);
  public static native @Cast("bool") boolean util_sscanf_percent(@Cast("const char*") BytePointer string, DoublePointer value);
  public static native @Cast("bool") boolean util_sscanf_percent(String string, DoubleBuffer value);
  public static native @Cast("bool") boolean util_sscanf_percent(@Cast("const char*") BytePointer string, double[] value);
  public static native @Cast("bool") boolean util_sscanf_percent(String string, DoublePointer value);
  public static native @Cast("bool") boolean util_sscanf_percent(@Cast("const char*") BytePointer string, DoubleBuffer value);
  public static native @Cast("bool") boolean util_sscanf_percent(String string, double[] value);
  public static native @Cast("bool") boolean util_is_executable(@Cast("const char*") BytePointer arg0 );
  public static native @Cast("bool") boolean util_is_executable(String arg0 );
  public static native @Cast("bool") boolean util_entry_exists( @Cast("const char*") BytePointer entry );
  public static native @Cast("bool") boolean util_entry_exists( String entry );
  public static native @Cast("bool") boolean util_file_exists(@Cast("const char*") BytePointer arg0);
  public static native @Cast("bool") boolean util_file_exists(String arg0);
  public static native @Cast("bool") boolean util_is_abs_path(@Cast("const char*") BytePointer arg0 );
  public static native @Cast("bool") boolean util_is_abs_path(String arg0 );
  public static native @Cast("char*") BytePointer util_alloc_abs_path( @Cast("const char*") BytePointer path );
  public static native @Cast("char*") ByteBuffer util_alloc_abs_path( String path );
  public static native @Cast("char*") BytePointer util_alloc_rel_path( @Cast("const char*") BytePointer __root_path, @Cast("const char*") BytePointer path);
  public static native @Cast("char*") ByteBuffer util_alloc_rel_path( String __root_path, String path);
  public static native @Cast("bool") boolean util_fmt_bit8(@Cast("const char*") BytePointer arg0);
  public static native @Cast("bool") boolean util_fmt_bit8(String arg0);
  public static native @Cast("bool") boolean util_fmt_bit8_stream(@Cast("FILE*") Pointer arg0 );
  public static native @Cast("char*") BytePointer util_strstr_int_format(@Cast("const char*") BytePointer string );
  public static native @Cast("char*") ByteBuffer util_strstr_int_format(String string );
  public static native int util_int_format_count(@Cast("const char*") BytePointer string );
  public static native int util_int_format_count(String string );
  public static native @Cast("bool") boolean util_mkdir_p(@Cast("const char*") BytePointer path);
  public static native @Cast("bool") boolean util_mkdir_p(String path);
  public static native void util_make_path(@Cast("const char*") BytePointer arg0);
  public static native void util_make_path(String arg0);
  public static native @Cast("char*") BytePointer util_newest_file(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("char*") ByteBuffer util_newest_file(String arg0, String arg1);
  public static native double util_file_difftime(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
  public static native double util_file_difftime(String arg0, String arg1);
  public static native @Cast("bool") boolean util_file_update_required(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("bool") boolean util_file_update_required(String arg0, String arg1);
  public static native @Cast("size_t") long util_file_size(@Cast("const char*") BytePointer arg0);
  public static native @Cast("size_t") long util_file_size(String arg0);
  public static native @Cast("size_t") long util_fd_size(int fd);
  public static native void util_clear_directory(@Cast("const char*") BytePointer path, @Cast("bool") boolean strict_uid, @Cast("bool") boolean unlink_root);
  public static native void util_clear_directory(String path, @Cast("bool") boolean strict_uid, @Cast("bool") boolean unlink_root);
  public static native void util_unlink_existing(@Cast("const char*") BytePointer filename);
  public static native void util_unlink_existing(String filename);
  public static native void util_strupr(@Cast("char*") BytePointer arg0);
  public static native void util_strupr(@Cast("char*") ByteBuffer arg0);
  public static native void util_strupr(@Cast("char*") byte[] arg0);
  public static native @Cast("bool") boolean util_string_equal(@Cast("const char*") BytePointer s1, @Cast("const char*") BytePointer s2 );
  public static native @Cast("bool") boolean util_string_equal(String s1, String s2 );
  public static native @Cast("char*") BytePointer util_alloc_strupr_copy(@Cast("const char*") BytePointer arg0 );
  public static native @Cast("char*") ByteBuffer util_alloc_strupr_copy(String arg0 );
  public static native void util_string_tr(@Cast("char*") BytePointer arg0, @Cast("char") byte arg1, @Cast("char") byte arg2);
  public static native void util_string_tr(@Cast("char*") ByteBuffer arg0, @Cast("char") byte arg1, @Cast("char") byte arg2);
  public static native void util_string_tr(@Cast("char*") byte[] arg0, @Cast("char") byte arg1, @Cast("char") byte arg2);
  public static native @Cast("bool") boolean util_copy_stream(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("bool") boolean abort_on_error);
  public static native void util_move_file(@Cast("const char*") BytePointer src_file, @Cast("const char*") BytePointer target_file);
  public static native void util_move_file(String src_file, String target_file);
  public static native void util_move_file4( @Cast("const char*") BytePointer src_name, @Cast("const char*") BytePointer target_name, @Cast("const char*") BytePointer src_path, @Cast("const char*") BytePointer target_path);
  public static native void util_move_file4( String src_name, String target_name, String src_path, String target_path);
  public static native @Cast("bool") boolean util_copy_file(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1 );
  public static native @Cast("bool") boolean util_copy_file(String arg0, String arg1 );
  public static native @Cast("bool") boolean util_copy_file__(@Cast("const char*") BytePointer src_file, @Cast("const char*") BytePointer target_file, @Cast("size_t") long buffer_size, Pointer buffer, @Cast("bool") boolean abort_on_error);
  public static native @Cast("bool") boolean util_copy_file__(String src_file, String target_file, @Cast("size_t") long buffer_size, Pointer buffer, @Cast("bool") boolean abort_on_error);
  public static native @Cast("char*") BytePointer util_alloc_cwd();
  public static native @Cast("bool") boolean util_is_cwd( @Cast("const char*") BytePointer path );
  public static native @Cast("bool") boolean util_is_cwd( String path );
  public static native @Cast("char*") BytePointer util_alloc_normal_path( @Cast("const char*") BytePointer input_path );
  public static native @Cast("char*") ByteBuffer util_alloc_normal_path( String input_path );
  public static native @Cast("char*") BytePointer util_alloc_realpath(@Cast("const char*") BytePointer arg0 );
  public static native @Cast("char*") ByteBuffer util_alloc_realpath(String arg0 );
  public static native @Cast("char*") BytePointer util_alloc_realpath__(@Cast("const char*") BytePointer input_path);
  public static native @Cast("char*") ByteBuffer util_alloc_realpath__(String input_path);
  public static native @Cast("bool") boolean util_string_match(@Cast("const char*") BytePointer string, @Cast("const char*") BytePointer pattern);
  public static native @Cast("bool") boolean util_string_match(String string, String pattern);
  public static native @Cast("bool") boolean util_string_has_wildcard( @Cast("const char*") BytePointer s);
  public static native @Cast("bool") boolean util_string_has_wildcard( String s);
  public static native @Cast("bool") boolean util_file_readable( @Cast("const char*") BytePointer file );
  public static native @Cast("bool") boolean util_file_readable( String file );
  public static native @Cast("bool") boolean util_entry_readable( @Cast("const char*") BytePointer entry );
  public static native @Cast("bool") boolean util_entry_readable( String entry );
  public static native @Cast("bool") boolean util_entry_writable( @Cast("const char*") BytePointer entry );
  public static native @Cast("bool") boolean util_entry_writable( String entry );
  public static native @Cast("bool") boolean util_ftruncate(@Cast("FILE*") Pointer stream, long size);

  public static native void util_usleep( @Cast("unsigned long") long micro_seconds );

  public static native int util_roundf( float x );
  public static native int util_round( double x );

  public static native @Cast("offset_type") long util_ftell(@Cast("FILE*") Pointer stream);
  public static native int util_fseek(@Cast("FILE*") Pointer stream, @Cast("offset_type") long offset, int whence);
  public static native void util_rewind(@Cast("FILE*") Pointer stream);
  public static native int util_stat(@Cast("const char*") BytePointer filename, stat_type stat_info);
  public static native int util_stat(String filename, stat_type stat_info);
  public static native int util_fstat(int fileno, stat_type stat_info);



// #ifdef ERT_HAVE_OPENDIR
// #endif


// #ifdef ERT_HAVE_GETUID
// #endif

  public static native int util_forward_line(@Cast("FILE*") Pointer arg0, @Cast("bool*") BoolPointer arg1 );
  public static native int util_forward_line(@Cast("FILE*") Pointer arg0, @Cast("bool*") boolean[] arg1 );
  public static native void util_rewind_line(@Cast("FILE*") Pointer arg0);

  public static native int util_count_content_file_lines(@Cast("FILE*") Pointer arg0 );
  public static native @Cast("FILE*") Pointer util_mkdir_fopen( @Cast("const char*") BytePointer filename, @Cast("const char*") BytePointer mode );
  public static native @Cast("FILE*") Pointer util_mkdir_fopen( String filename, String mode );
  public static native int util_fmove( @Cast("FILE*") Pointer stream, long offset, long shift);
  public static native @Cast("FILE*") Pointer util_fopen(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("FILE*") Pointer util_fopen(String arg0, String arg1);
  public static native @Cast("FILE*") Pointer util_fopen__(@Cast("const char*") BytePointer filename, @Cast("const char*") BytePointer mode);
  public static native @Cast("FILE*") Pointer util_fopen__(String filename, String mode);
  public static native @Cast("bool") boolean util_fopen_test(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("bool") boolean util_fopen_test(String arg0, String arg1);
  public static native @Cast("char*") BytePointer util_split_alloc_dirname( @Cast("const char*") BytePointer input_path );
  public static native @Cast("char*") ByteBuffer util_split_alloc_dirname( String input_path );
  public static native @Cast("char*") BytePointer util_split_alloc_filename( @Cast("const char*") BytePointer input_path );
  public static native @Cast("char*") ByteBuffer util_split_alloc_filename( String input_path );
  public static native void util_alloc_file_components(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, @Cast("char**") PointerPointer arg2, @Cast("char**") PointerPointer arg3);
  public static native void util_alloc_file_components(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, @Cast("char**") @ByPtrPtr BytePointer arg2, @Cast("char**") @ByPtrPtr BytePointer arg3);
  public static native void util_alloc_file_components(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3);
  public static native void util_alloc_file_components(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, @Cast("char**") @ByPtrPtr byte[] arg2, @Cast("char**") @ByPtrPtr byte[] arg3);
  public static native void util_alloc_file_components(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, @Cast("char**") @ByPtrPtr BytePointer arg2, @Cast("char**") @ByPtrPtr BytePointer arg3);
  public static native void util_alloc_file_components(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3);
  public static native void util_alloc_file_components(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, @Cast("char**") @ByPtrPtr byte[] arg2, @Cast("char**") @ByPtrPtr byte[] arg3);
  //char           * util_realloc_full_path(char * , const char *, const char *);
  public static native @Cast("char*") BytePointer util_alloc_tmp_file(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("bool") boolean arg2 );
  public static native @Cast("char*") ByteBuffer util_alloc_tmp_file(String arg0, String arg1, @Cast("bool") boolean arg2 );
  public static native @Cast("char*") BytePointer util_fscanf_alloc_line(@Cast("FILE*") Pointer arg0, @Cast("bool*") BoolPointer arg1);
  public static native @Cast("char*") ByteBuffer util_fscanf_alloc_line(@Cast("FILE*") Pointer arg0, @Cast("bool*") boolean[] arg1);
  public static native @Cast("char*") BytePointer util_fscanf_alloc_token(@Cast("FILE*") Pointer arg0 );
  public static native void util_fskip_token(@Cast("FILE*") Pointer arg0 );
  public static native void util_fskip_space(@Cast("FILE*") Pointer arg0,  @Cast("bool*") BoolPointer arg1);
  public static native void util_fskip_space(@Cast("FILE*") Pointer arg0,  @Cast("bool*") boolean[] arg1);
  public static native void util_fskip_chars(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1, @Cast("bool*") BoolPointer arg2);
  public static native void util_fskip_chars(@Cast("FILE*") Pointer arg0, String arg1, @Cast("bool*") boolean[] arg2);
  public static native void util_fskip_cchars(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1, @Cast("bool*") BoolPointer arg2);
  public static native void util_fskip_cchars(@Cast("FILE*") Pointer arg0, String arg1, @Cast("bool*") boolean[] arg2);
  public static native @Cast("bool") boolean util_fscanf_int(@Cast("FILE*") Pointer arg0, IntPointer arg1 );
  public static native @Cast("bool") boolean util_fscanf_int(@Cast("FILE*") Pointer arg0, IntBuffer arg1 );
  public static native @Cast("bool") boolean util_fscanf_int(@Cast("FILE*") Pointer arg0, int[] arg1 );
  public static native @Cast("bool") boolean util_fscanf_bool(@Cast("FILE*") Pointer stream, @Cast("bool*") BoolPointer value);
  public static native @Cast("bool") boolean util_fscanf_bool(@Cast("FILE*") Pointer stream, @Cast("bool*") boolean[] value);
  public static native @Cast("bool") boolean util_sscanf_bool(@Cast("const char*") BytePointer arg0, @Cast("bool*") BoolPointer arg1);
  public static native @Cast("bool") boolean util_sscanf_bool(String arg0, @Cast("bool*") boolean[] arg1);
  public static native @Cast("bool") boolean util_sscanf_octal_int(@Cast("const char*") BytePointer buffer, IntPointer value);
  public static native @Cast("bool") boolean util_sscanf_octal_int(String buffer, IntBuffer value);
  public static native @Cast("bool") boolean util_sscanf_octal_int(@Cast("const char*") BytePointer buffer, int[] value);
  public static native @Cast("bool") boolean util_sscanf_octal_int(String buffer, IntPointer value);
  public static native @Cast("bool") boolean util_sscanf_octal_int(@Cast("const char*") BytePointer buffer, IntBuffer value);
  public static native @Cast("bool") boolean util_sscanf_octal_int(String buffer, int[] value);
  public static native int util_strcmp_int( @Cast("const char*") BytePointer s1, @Cast("const char*") BytePointer s2);
  public static native int util_strcmp_int( String s1, String s2);
  public static native int util_strcmp_float( @Cast("const char*") BytePointer s1, @Cast("const char*") BytePointer s2);
  public static native int util_strcmp_float( String s1, String s2);
  public static native @Cast("bool") boolean util_sscanf_int(@Cast("const char*") BytePointer arg0, IntPointer arg1 );
  public static native @Cast("bool") boolean util_sscanf_int(String arg0, IntBuffer arg1 );
  public static native @Cast("bool") boolean util_sscanf_int(@Cast("const char*") BytePointer arg0, int[] arg1 );
  public static native @Cast("bool") boolean util_sscanf_int(String arg0, IntPointer arg1 );
  public static native @Cast("bool") boolean util_sscanf_int(@Cast("const char*") BytePointer arg0, IntBuffer arg1 );
  public static native @Cast("bool") boolean util_sscanf_int(String arg0, int[] arg1 );
  public static native @Cast("const char*") BytePointer util_parse_int(@Cast("const char*") BytePointer arg0, IntPointer arg1, @Cast("bool*") BoolPointer arg2);
  public static native String util_parse_int(String arg0, IntBuffer arg1, @Cast("bool*") boolean[] arg2);
  public static native @Cast("const char*") BytePointer util_parse_int(@Cast("const char*") BytePointer arg0, int[] arg1, @Cast("bool*") BoolPointer arg2);
  public static native String util_parse_int(String arg0, IntPointer arg1, @Cast("bool*") boolean[] arg2);
  public static native @Cast("const char*") BytePointer util_parse_int(@Cast("const char*") BytePointer arg0, IntBuffer arg1, @Cast("bool*") BoolPointer arg2);
  public static native String util_parse_int(String arg0, int[] arg1, @Cast("bool*") boolean[] arg2);
  public static native @Cast("const char*") BytePointer util_skip_sep(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("bool*") BoolPointer arg2);
  public static native String util_skip_sep(String arg0, String arg1, @Cast("bool*") boolean[] arg2);
 public static native @Cast("bool") boolean util_sscanf_double(@Cast("const char*") BytePointer arg0, DoublePointer arg1 );
 public static native @Cast("bool") boolean util_sscanf_double(String arg0, DoubleBuffer arg1 );
 public static native @Cast("bool") boolean util_sscanf_double(@Cast("const char*") BytePointer arg0, double[] arg1 );
 public static native @Cast("bool") boolean util_sscanf_double(String arg0, DoublePointer arg1 );
 public static native @Cast("bool") boolean util_sscanf_double(@Cast("const char*") BytePointer arg0, DoubleBuffer arg1 );
 public static native @Cast("bool") boolean util_sscanf_double(String arg0, double[] arg1 );
  //char   * util_alloc_full_path(const char *, const char *);
  public static native @Cast("char*") BytePointer util_alloc_filename(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char*") ByteBuffer util_alloc_filename(String arg0, String arg1, String arg2 );
  public static native @Cast("char*") BytePointer util_realloc_filename(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native @Cast("char*") ByteBuffer util_realloc_filename(@Cast("char*") ByteBuffer arg0, String arg1, String arg2, String arg3 );
  public static native @Cast("char*") byte[] util_realloc_filename(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native @Cast("char*") BytePointer util_realloc_filename(@Cast("char*") BytePointer arg0, String arg1, String arg2, String arg3 );
  public static native @Cast("char*") ByteBuffer util_realloc_filename(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native @Cast("char*") byte[] util_realloc_filename(@Cast("char*") byte[] arg0, String arg1, String arg2, String arg3 );
  public static native @Cast("char*") BytePointer util_alloc_strip_copy(@Cast("const char*") BytePointer arg0);
  public static native @Cast("char*") ByteBuffer util_alloc_strip_copy(String arg0);
  public static native @Cast("char*") BytePointer util_alloc_string_sum(@Cast("const char**") PointerPointer arg0, int arg1);
  public static native @Cast("char*") BytePointer util_alloc_string_sum(@Cast("const char**") @ByPtrPtr BytePointer arg0, int arg1);
  public static native @Cast("char*") ByteBuffer util_alloc_string_sum(@Cast("const char**") @ByPtrPtr ByteBuffer arg0, int arg1);
  public static native @Cast("char*") byte[] util_alloc_string_sum(@Cast("const char**") @ByPtrPtr byte[] arg0, int arg1);
  public static native @Cast("char*") BytePointer util_strcat_realloc(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1 );
  public static native @Cast("char*") ByteBuffer util_strcat_realloc(@Cast("char*") ByteBuffer arg0, String arg1 );
  public static native @Cast("char*") byte[] util_strcat_realloc(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1 );
  public static native @Cast("char*") BytePointer util_strcat_realloc(@Cast("char*") BytePointer arg0, String arg1 );
  public static native @Cast("char*") ByteBuffer util_strcat_realloc(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1 );
  public static native @Cast("char*") byte[] util_strcat_realloc(@Cast("char*") byte[] arg0, String arg1 );
  public static native @Cast("char*") BytePointer util_alloc_string_copy(@Cast("const char*") BytePointer arg0);
  public static native @Cast("char*") ByteBuffer util_alloc_string_copy(String arg0);
  public static native @Cast("char**") PointerPointer util_stringlist_append_copy(@Cast("char**") PointerPointer arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char**") @ByPtrPtr BytePointer util_stringlist_append_copy(@Cast("char**") @ByPtrPtr BytePointer arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char**") @ByPtrPtr ByteBuffer util_stringlist_append_copy(@Cast("char**") @ByPtrPtr ByteBuffer arg0, int arg1, String arg2 );
  public static native @Cast("char**") @ByPtrPtr byte[] util_stringlist_append_copy(@Cast("char**") @ByPtrPtr byte[] arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char**") @ByPtrPtr BytePointer util_stringlist_append_copy(@Cast("char**") @ByPtrPtr BytePointer arg0, int arg1, String arg2 );
  public static native @Cast("char**") @ByPtrPtr ByteBuffer util_stringlist_append_copy(@Cast("char**") @ByPtrPtr ByteBuffer arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char**") @ByPtrPtr byte[] util_stringlist_append_copy(@Cast("char**") @ByPtrPtr byte[] arg0, int arg1, String arg2 );
  public static native @Cast("char**") PointerPointer util_stringlist_append_ref(@Cast("char**") PointerPointer arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char**") @ByPtrPtr BytePointer util_stringlist_append_ref(@Cast("char**") @ByPtrPtr BytePointer arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char**") @ByPtrPtr ByteBuffer util_stringlist_append_ref(@Cast("char**") @ByPtrPtr ByteBuffer arg0, int arg1, String arg2 );
  public static native @Cast("char**") @ByPtrPtr byte[] util_stringlist_append_ref(@Cast("char**") @ByPtrPtr byte[] arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char**") @ByPtrPtr BytePointer util_stringlist_append_ref(@Cast("char**") @ByPtrPtr BytePointer arg0, int arg1, String arg2 );
  public static native @Cast("char**") @ByPtrPtr ByteBuffer util_stringlist_append_ref(@Cast("char**") @ByPtrPtr ByteBuffer arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char**") @ByPtrPtr byte[] util_stringlist_append_ref(@Cast("char**") @ByPtrPtr byte[] arg0, int arg1, String arg2 );
  public static native @Cast("char**") PointerPointer util_alloc_stringlist_copy(@Cast("const char*const*") PointerPointer arg0, int arg1 );
  public static native @Cast("char**") @ByPtrPtr BytePointer util_alloc_stringlist_copy(@Cast("const char*const*") @ByPtrPtr BytePointer arg0, int arg1 );
  public static native @Cast("char**") @ByPtrPtr ByteBuffer util_alloc_stringlist_copy(@Cast("const char*const*") @ByPtrPtr ByteBuffer arg0, int arg1 );
  public static native @Cast("char**") @ByPtrPtr byte[] util_alloc_stringlist_copy(@Cast("const char*const*") @ByPtrPtr byte[] arg0, int arg1 );
  public static native void util_split_string(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, IntPointer arg2, @Cast("char***") @ByPtrPtr PointerPointer arg3);
  public static native void util_split_string(String arg0, String arg1, IntBuffer arg2, @Cast("char***") @ByPtrPtr PointerPointer arg3);
  public static native void util_split_string(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int[] arg2, @Cast("char***") @ByPtrPtr PointerPointer arg3);
  public static native void util_split_string(String arg0, String arg1, IntPointer arg2, @Cast("char***") @ByPtrPtr PointerPointer arg3);
  public static native void util_split_string(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, IntBuffer arg2, @Cast("char***") @ByPtrPtr PointerPointer arg3);
  public static native void util_split_string(String arg0, String arg1, int[] arg2, @Cast("char***") @ByPtrPtr PointerPointer arg3);
  public static native void util_path_split(@Cast("const char*") BytePointer arg0, IntPointer arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2);
  public static native void util_path_split(String arg0, IntBuffer arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2);
  public static native void util_path_split(@Cast("const char*") BytePointer arg0, int[] arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2);
  public static native void util_path_split(String arg0, IntPointer arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2);
  public static native void util_path_split(@Cast("const char*") BytePointer arg0, IntBuffer arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2);
  public static native void util_path_split(String arg0, int[] arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2);
  public static native @Cast("char*") BytePointer util_alloc_parent_path( @Cast("const char*") BytePointer path);
  public static native @Cast("char*") ByteBuffer util_alloc_parent_path( String path);
  public static native void util_binary_split_string(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("bool") boolean arg2, @Cast("char**") PointerPointer arg3, @Cast("char**") PointerPointer arg4 );
  public static native void util_binary_split_string(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("bool") boolean arg2, @Cast("char**") @ByPtrPtr BytePointer arg3, @Cast("char**") @ByPtrPtr BytePointer arg4 );
  public static native void util_binary_split_string(String arg0, String arg1, @Cast("bool") boolean arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3, @Cast("char**") @ByPtrPtr ByteBuffer arg4 );
  public static native void util_binary_split_string(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("bool") boolean arg2, @Cast("char**") @ByPtrPtr byte[] arg3, @Cast("char**") @ByPtrPtr byte[] arg4 );
  public static native void util_binary_split_string(String arg0, String arg1, @Cast("bool") boolean arg2, @Cast("char**") @ByPtrPtr BytePointer arg3, @Cast("char**") @ByPtrPtr BytePointer arg4 );
  public static native void util_binary_split_string(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("bool") boolean arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3, @Cast("char**") @ByPtrPtr ByteBuffer arg4 );
  public static native void util_binary_split_string(String arg0, String arg1, @Cast("bool") boolean arg2, @Cast("char**") @ByPtrPtr byte[] arg3, @Cast("char**") @ByPtrPtr byte[] arg4 );
  public static native void util_binary_split_string_from_max_length(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2, @Cast("char**") PointerPointer arg3, @Cast("char**") PointerPointer arg4 );
  public static native void util_binary_split_string_from_max_length(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2, @Cast("char**") @ByPtrPtr BytePointer arg3, @Cast("char**") @ByPtrPtr BytePointer arg4 );
  public static native void util_binary_split_string_from_max_length(String arg0, String arg1, int arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3, @Cast("char**") @ByPtrPtr ByteBuffer arg4 );
  public static native void util_binary_split_string_from_max_length(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2, @Cast("char**") @ByPtrPtr byte[] arg3, @Cast("char**") @ByPtrPtr byte[] arg4 );
  public static native void util_binary_split_string_from_max_length(String arg0, String arg1, int arg2, @Cast("char**") @ByPtrPtr BytePointer arg3, @Cast("char**") @ByPtrPtr BytePointer arg4 );
  public static native void util_binary_split_string_from_max_length(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3, @Cast("char**") @ByPtrPtr ByteBuffer arg4 );
  public static native void util_binary_split_string_from_max_length(String arg0, String arg1, int arg2, @Cast("char**") @ByPtrPtr byte[] arg3, @Cast("char**") @ByPtrPtr byte[] arg4 );
  public static native @Cast("char*") BytePointer util_alloc_joined_string(@Cast("const char**") PointerPointer arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char*") BytePointer util_alloc_joined_string(@Cast("const char**") @ByPtrPtr BytePointer arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char*") ByteBuffer util_alloc_joined_string(@Cast("const char**") @ByPtrPtr ByteBuffer arg0, int arg1, String arg2 );
  public static native @Cast("char*") byte[] util_alloc_joined_string(@Cast("const char**") @ByPtrPtr byte[] arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char*") BytePointer util_alloc_joined_string(@Cast("const char**") @ByPtrPtr BytePointer arg0, int arg1, String arg2 );
  public static native @Cast("char*") ByteBuffer util_alloc_joined_string(@Cast("const char**") @ByPtrPtr ByteBuffer arg0, int arg1, @Cast("const char*") BytePointer arg2 );
  public static native @Cast("char*") byte[] util_alloc_joined_string(@Cast("const char**") @ByPtrPtr byte[] arg0, int arg1, String arg2 );
  public static native @Cast("char*") BytePointer util_alloc_multiline_string(@Cast("const char**") PointerPointer arg0, int arg1 );
  public static native @Cast("char*") BytePointer util_alloc_multiline_string(@Cast("const char**") @ByPtrPtr BytePointer arg0, int arg1 );
  public static native @Cast("char*") ByteBuffer util_alloc_multiline_string(@Cast("const char**") @ByPtrPtr ByteBuffer arg0, int arg1 );
  public static native @Cast("char*") byte[] util_alloc_multiline_string(@Cast("const char**") @ByPtrPtr byte[] arg0, int arg1 );
  public static native @Cast("char*") BytePointer util_string_replace_alloc(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2);
  public static native @Cast("char*") ByteBuffer util_string_replace_alloc(String arg0, String arg1, String arg2);
  public static native @Cast("char*") BytePointer util_string_replacen_alloc(@Cast("const char*") BytePointer arg0, int arg1, @Cast("const char**") PointerPointer arg2, @Cast("const char**") PointerPointer arg3);
  public static native @Cast("char*") BytePointer util_string_replacen_alloc(@Cast("const char*") BytePointer arg0, int arg1, @Cast("const char**") @ByPtrPtr BytePointer arg2, @Cast("const char**") @ByPtrPtr BytePointer arg3);
  public static native @Cast("char*") ByteBuffer util_string_replacen_alloc(String arg0, int arg1, @Cast("const char**") @ByPtrPtr ByteBuffer arg2, @Cast("const char**") @ByPtrPtr ByteBuffer arg3);
  public static native @Cast("char*") byte[] util_string_replacen_alloc(@Cast("const char*") BytePointer arg0, int arg1, @Cast("const char**") @ByPtrPtr byte[] arg2, @Cast("const char**") @ByPtrPtr byte[] arg3);
  public static native @Cast("char*") BytePointer util_string_replacen_alloc(String arg0, int arg1, @Cast("const char**") @ByPtrPtr BytePointer arg2, @Cast("const char**") @ByPtrPtr BytePointer arg3);
  public static native @Cast("char*") ByteBuffer util_string_replacen_alloc(@Cast("const char*") BytePointer arg0, int arg1, @Cast("const char**") @ByPtrPtr ByteBuffer arg2, @Cast("const char**") @ByPtrPtr ByteBuffer arg3);
  public static native @Cast("char*") byte[] util_string_replacen_alloc(String arg0, int arg1, @Cast("const char**") @ByPtrPtr byte[] arg2, @Cast("const char**") @ByPtrPtr byte[] arg3);
  public static native int util_string_replace_inplace(@Cast("char**") PointerPointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2);
  public static native int util_string_replace_inplace(@Cast("char**") @ByPtrPtr BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2);
  public static native int util_string_replace_inplace(@Cast("char**") @ByPtrPtr ByteBuffer arg0, String arg1, String arg2);
  public static native int util_string_replace_inplace(@Cast("char**") @ByPtrPtr byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2);
  public static native int util_string_replace_inplace(@Cast("char**") @ByPtrPtr BytePointer arg0, String arg1, String arg2);
  public static native int util_string_replace_inplace(@Cast("char**") @ByPtrPtr ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2);
  public static native int util_string_replace_inplace(@Cast("char**") @ByPtrPtr byte[] arg0, String arg1, String arg2);
  public static native @Cast("char*") BytePointer util_string_strip_chars_alloc(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1 );
  public static native @Cast("char*") ByteBuffer util_string_strip_chars_alloc(String arg0, String arg1 );
  public static native @Cast("char*") BytePointer util_realloc_string_copy(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("char*") ByteBuffer util_realloc_string_copy(@Cast("char*") ByteBuffer arg0, String arg1);
  public static native @Cast("char*") byte[] util_realloc_string_copy(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("char*") BytePointer util_realloc_string_copy(@Cast("char*") BytePointer arg0, String arg1);
  public static native @Cast("char*") ByteBuffer util_realloc_string_copy(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1);
  public static native @Cast("char*") byte[] util_realloc_string_copy(@Cast("char*") byte[] arg0, String arg1);
  public static native @Cast("char*") BytePointer util_realloc_substring_copy(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int N);
  public static native @Cast("char*") ByteBuffer util_realloc_substring_copy(@Cast("char*") ByteBuffer arg0, String arg1, int N);
  public static native @Cast("char*") byte[] util_realloc_substring_copy(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, int N);
  public static native @Cast("char*") BytePointer util_realloc_substring_copy(@Cast("char*") BytePointer arg0, String arg1, int N);
  public static native @Cast("char*") ByteBuffer util_realloc_substring_copy(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, int N);
  public static native @Cast("char*") byte[] util_realloc_substring_copy(@Cast("char*") byte[] arg0, String arg1, int N);
  public static native @Cast("char*") BytePointer util_realloc_dequoted_string(@Cast("char*") BytePointer arg0);
  public static native @Cast("char*") ByteBuffer util_realloc_dequoted_string(@Cast("char*") ByteBuffer arg0);
  public static native @Cast("char*") byte[] util_realloc_dequoted_string(@Cast("char*") byte[] arg0);
  public static native @Cast("char*") BytePointer util_alloc_dequoted_copy(@Cast("const char*") BytePointer s);
  public static native @Cast("char*") ByteBuffer util_alloc_dequoted_copy(String s);
  public static native void util_free_stringlist(@Cast("char**") PointerPointer arg0, int arg1 );
  public static native void util_free_stringlist(@Cast("char**") @ByPtrPtr BytePointer arg0, int arg1 );
  public static native void util_free_stringlist(@Cast("char**") @ByPtrPtr ByteBuffer arg0, int arg1 );
  public static native void util_free_stringlist(@Cast("char**") @ByPtrPtr byte[] arg0, int arg1 );
  public static native void util_free_NULL_terminated_stringlist(@Cast("char**") PointerPointer string_list);
  public static native void util_free_NULL_terminated_stringlist(@Cast("char**") @ByPtrPtr BytePointer string_list);
  public static native void util_free_NULL_terminated_stringlist(@Cast("char**") @ByPtrPtr ByteBuffer string_list);
  public static native void util_free_NULL_terminated_stringlist(@Cast("char**") @ByPtrPtr byte[] string_list);
  public static native @Cast("char*") BytePointer util_alloc_substring_copy(@Cast("const char*") BytePointer arg0, int offset, int N);
  public static native @Cast("char*") ByteBuffer util_alloc_substring_copy(String arg0, int offset, int N);
  public static native @Cast("bool") boolean util_is_directory(@Cast("const char*") BytePointer arg0 );
  public static native @Cast("bool") boolean util_is_directory(String arg0 );
  public static native @Cast("bool") boolean util_is_file(@Cast("const char*") BytePointer arg0 );
  public static native @Cast("bool") boolean util_is_file(String arg0 );


  public static native void util_set_datetime_values_utc(@ByVal @Cast("time_t*") Pointer arg0, IntPointer arg1, IntPointer arg2, IntPointer arg3, IntPointer arg4, IntPointer arg5, IntPointer arg6);
  public static native void util_set_datetime_values_utc(@ByVal @Cast("time_t*") Pointer arg0, IntBuffer arg1, IntBuffer arg2, IntBuffer arg3, IntBuffer arg4, IntBuffer arg5, IntBuffer arg6);
  public static native void util_set_datetime_values_utc(@ByVal @Cast("time_t*") Pointer arg0, int[] arg1, int[] arg2, int[] arg3, int[] arg4, int[] arg5, int[] arg6);
  public static native void util_set_date_values_utc(@ByVal @Cast("time_t*") Pointer arg0, IntPointer arg1, IntPointer arg2, IntPointer arg3 );
  public static native void util_set_date_values_utc(@ByVal @Cast("time_t*") Pointer arg0, IntBuffer arg1, IntBuffer arg2, IntBuffer arg3 );
  public static native void util_set_date_values_utc(@ByVal @Cast("time_t*") Pointer arg0, int[] arg1, int[] arg2, int[] arg3 );

  public static native @Cast("bool") boolean util_is_first_day_in_month_utc( @ByVal @Cast("time_t*") Pointer t);

  public static native @Cast("unsigned int") int util_dev_urandom_seed( );
  public static native @Cast("unsigned int") int util_clock_seed( );
  public static native void util_fread_dev_random(int arg0, @Cast("char*") BytePointer arg1 );
  public static native void util_fread_dev_random(int arg0, @Cast("char*") ByteBuffer arg1 );
  public static native void util_fread_dev_random(int arg0, @Cast("char*") byte[] arg1 );
  public static native void util_fread_dev_urandom(int arg0, @Cast("char*") BytePointer arg1 );
  public static native void util_fread_dev_urandom(int arg0, @Cast("char*") ByteBuffer arg1 );
  public static native void util_fread_dev_urandom(int arg0, @Cast("char*") byte[] arg1 );
  public static native @Cast("bool") boolean util_string_isspace(@Cast("const char*") BytePointer s);
  public static native @Cast("bool") boolean util_string_isspace(String s);

  public static native @Cast("char*") BytePointer util_alloc_dump_filename();
  public static native void util_abort_test_set_intercept_function(@Cast("const char*") BytePointer arg0);
  public static native void util_abort_test_set_intercept_function(String arg0);
  public static native @Cast("bool") boolean util_addr2line_lookup(@Const Pointer arg0, @Cast("char**") PointerPointer arg1, @Cast("char**") PointerPointer arg2, IntPointer arg3);
  public static native @Cast("bool") boolean util_addr2line_lookup(@Const Pointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, @Cast("char**") @ByPtrPtr BytePointer arg2, IntPointer arg3);
  public static native @Cast("bool") boolean util_addr2line_lookup(@Const Pointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2, IntBuffer arg3);
  public static native @Cast("bool") boolean util_addr2line_lookup(@Const Pointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, @Cast("char**") @ByPtrPtr byte[] arg2, int[] arg3);
  public static native void util_exit(@Cast("const char*") BytePointer fmt);
  public static native void util_exit(String fmt);
  public static native void util_install_signals();
  public static native void util_update_signals();


  public static native Pointer util_realloc(Pointer arg0, @Cast("size_t") long arg1  );
  public static native Pointer util_malloc(@Cast("size_t") long arg0 );
  public static native Pointer util_calloc( @Cast("size_t") long elements, @Cast("size_t") long element_size );
  public static native Pointer util_realloc_copy(Pointer org_ptr, @Const Pointer src, @Cast("size_t") long byte_size );
  public static native Pointer util_alloc_copy(@Const Pointer arg0, @Cast("size_t") long arg1 );
  public static native void util_double_to_float(FloatPointer arg0, @Const DoublePointer arg1, int arg2 );
  public static native void util_double_to_float(FloatBuffer arg0, @Const DoubleBuffer arg1, int arg2 );
  public static native void util_double_to_float(float[] arg0, @Const double[] arg1, int arg2 );
  public static native void util_float_to_double(DoublePointer arg0, @Const FloatPointer arg1, int arg2 );
  public static native void util_float_to_double(DoubleBuffer arg0, @Const FloatBuffer arg1, int arg2 );
  public static native void util_float_to_double(double[] arg0, @Const float[] arg1, int arg2 );

  public static native int util_get_month_nr(@Cast("const char*") BytePointer arg0 );
  public static native int util_get_month_nr(String arg0 );

  public static native @Cast("char*") BytePointer util_fread_alloc_file_content(@Cast("const char*") BytePointer arg0, IntPointer arg1);
  public static native @Cast("char*") ByteBuffer util_fread_alloc_file_content(String arg0, IntBuffer arg1);
  public static native @Cast("char*") byte[] util_fread_alloc_file_content(@Cast("const char*") BytePointer arg0, int[] arg1);
  public static native @Cast("char*") BytePointer util_fread_alloc_file_content(String arg0, IntPointer arg1);
  public static native @Cast("char*") ByteBuffer util_fread_alloc_file_content(@Cast("const char*") BytePointer arg0, IntBuffer arg1);
  public static native @Cast("char*") byte[] util_fread_alloc_file_content(String arg0, int[] arg1);
  public static native void util_fwrite_string(@Cast("const char*") BytePointer arg0, @Cast("FILE*") Pointer arg1);
  public static native void util_fwrite_string(String arg0, @Cast("FILE*") Pointer arg1);
  public static native @Cast("char*") BytePointer util_fread_realloc_string(@Cast("char*") BytePointer arg0, @Cast("FILE*") Pointer arg1);
  public static native @Cast("char*") ByteBuffer util_fread_realloc_string(@Cast("char*") ByteBuffer arg0, @Cast("FILE*") Pointer arg1);
  public static native @Cast("char*") byte[] util_fread_realloc_string(@Cast("char*") byte[] arg0, @Cast("FILE*") Pointer arg1);
  public static native @Cast("char*") BytePointer util_fread_alloc_string(@Cast("FILE*") Pointer arg0);
  public static native void util_fskip_string(@Cast("FILE*") Pointer stream);
  public static native void util_endian_flip_vector(Pointer data, int element_size, int elements);


  public static native void util_clamp_double(DoublePointer value, double limit1, double limit2);
  public static native void util_clamp_double(DoubleBuffer value, double limit1, double limit2);
  public static native void util_clamp_double(double[] value, double limit1, double limit2);
  public static native double util_double_vector_mean(int arg0, @Const DoublePointer arg1 );
  public static native double util_double_vector_mean(int arg0, @Const DoubleBuffer arg1 );
  public static native double util_double_vector_mean(int arg0, @Const double[] arg1 );
  public static native double util_double_vector_stddev(int arg0, @Const DoublePointer arg1 );
  public static native double util_double_vector_stddev(int arg0, @Const DoubleBuffer arg1 );
  public static native double util_double_vector_stddev(int arg0, @Const double[] arg1 );
  public static native void util_double_vector_max_min(int arg0, @Const DoublePointer arg1, DoublePointer arg2, DoublePointer arg3);
  public static native void util_double_vector_max_min(int arg0, @Const DoubleBuffer arg1, DoubleBuffer arg2, DoubleBuffer arg3);
  public static native void util_double_vector_max_min(int arg0, @Const double[] arg1, double[] arg2, double[] arg3);
  public static native void util_update_double_max_min(double arg0, DoublePointer arg1, DoublePointer arg2 );
  public static native void util_update_double_max_min(double arg0, DoubleBuffer arg1, DoubleBuffer arg2 );
  public static native void util_update_double_max_min(double arg0, double[] arg1, double[] arg2 );
  public static native void util_update_float_max_min(float arg0, FloatPointer arg1, FloatPointer arg2 );
  public static native void util_update_float_max_min(float arg0, FloatBuffer arg1, FloatBuffer arg2 );
  public static native void util_update_float_max_min(float arg0, float[] arg1, float[] arg2 );
  public static native void util_update_int_max_min(int arg0, IntPointer arg1, IntPointer arg2 );
  public static native void util_update_int_max_min(int arg0, IntBuffer arg1, IntBuffer arg2 );
  public static native void util_update_int_max_min(int arg0, int[] arg1, int[] arg2 );
  public static native float util_float_max(float arg0, float arg1 );
  public static native long util_long_max(long a, long b);
  public static native int util_int_max(int arg0, int arg1);
  public static native double util_double_max(double arg0, double arg1 );
  public static native float util_float_min(float arg0, float arg1 );
  public static native int util_int_min(int arg0, int arg1);
  public static native @Cast("size_t") long util_size_t_min(@Cast("size_t") long a, @Cast("size_t") long b);
  public static native @Cast("size_t") long util_size_t_max(@Cast("size_t") long a, @Cast("size_t") long b);
  public static native @ByVal @Cast("time_t*") Pointer util_time_t_min(@ByVal @Cast("time_t*") Pointer a, @ByVal @Cast("time_t*") Pointer b);
  public static native @ByVal @Cast("time_t*") Pointer util_time_t_max(@ByVal @Cast("time_t*") Pointer a, @ByVal @Cast("time_t*") Pointer b);
  public static native double util_double_min(double arg0, double arg1 );
  public static native void util_fskip_lines(@Cast("FILE*") Pointer arg0, int arg1);
  public static native @Cast("bool") boolean util_same_file(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1 );
  public static native @Cast("bool") boolean util_same_file(String arg0, String arg1 );
  public static native void util_fread(Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2, @Cast("FILE*") Pointer arg3, @Cast("const char*") BytePointer arg4 );
  public static native void util_fread(Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2, @Cast("FILE*") Pointer arg3, String arg4 );
  public static native void util_fwrite(@Const Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2, @Cast("FILE*") Pointer arg3, @Cast("const char*") BytePointer arg4 );
  public static native void util_fwrite(@Const Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2, @Cast("FILE*") Pointer arg3, String arg4 );
  public static native @ByVal @Cast("time_t*") Pointer util_fread_time_t(@Cast("FILE*") Pointer stream);
  public static native int util_fread_int(@Cast("FILE*") Pointer arg0 );
  public static native long util_fread_long(@Cast("FILE*") Pointer arg0 );
  public static native @Cast("bool") boolean util_fread_bool(@Cast("FILE*") Pointer arg0 );
  public static native double util_fread_double(@Cast("FILE*") Pointer stream);
  public static native void util_fwrite_offset(@Cast("offset_type") long arg0, @Cast("FILE*") Pointer arg1 );
  public static native void util_fwrite_size_t(@Cast("size_t") long arg0, @Cast("FILE*") Pointer arg1 );
  public static native void util_fwrite_int(int arg0, @Cast("FILE*") Pointer arg1 );
  public static native void util_fwrite_long(long arg0, @Cast("FILE*") Pointer arg1 );
  public static native void util_fwrite_bool(@Cast("bool") boolean arg0, @Cast("FILE*") Pointer arg1 );
  public static native void util_fwrite_time_t(@ByVal @Cast("time_t*") Pointer arg0, @Cast("FILE*") Pointer arg1 );
  public static native void util_fwrite_double(double arg0, @Cast("FILE*") Pointer arg1 );
  public static native void util_fwrite_int_vector(@Const IntPointer arg0, int arg1, @Cast("FILE*") Pointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native void util_fwrite_int_vector(@Const IntBuffer arg0, int arg1, @Cast("FILE*") Pointer arg2, String arg3 );
  public static native void util_fwrite_int_vector(@Const int[] arg0, int arg1, @Cast("FILE*") Pointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native void util_fwrite_int_vector(@Const IntPointer arg0, int arg1, @Cast("FILE*") Pointer arg2, String arg3 );
  public static native void util_fwrite_int_vector(@Const IntBuffer arg0, int arg1, @Cast("FILE*") Pointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native void util_fwrite_int_vector(@Const int[] arg0, int arg1, @Cast("FILE*") Pointer arg2, String arg3 );
  public static native void util_fwrite_double_vector(@Const DoublePointer arg0, int arg1, @Cast("FILE*") Pointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native void util_fwrite_double_vector(@Const DoubleBuffer arg0, int arg1, @Cast("FILE*") Pointer arg2, String arg3 );
  public static native void util_fwrite_double_vector(@Const double[] arg0, int arg1, @Cast("FILE*") Pointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native void util_fwrite_double_vector(@Const DoublePointer arg0, int arg1, @Cast("FILE*") Pointer arg2, String arg3 );
  public static native void util_fwrite_double_vector(@Const DoubleBuffer arg0, int arg1, @Cast("FILE*") Pointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native void util_fwrite_double_vector(@Const double[] arg0, int arg1, @Cast("FILE*") Pointer arg2, String arg3 );
  public static native void util_fread_char_vector(@Cast("char*") BytePointer arg0, int arg1, @Cast("FILE*") Pointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native void util_fread_char_vector(@Cast("char*") ByteBuffer arg0, int arg1, @Cast("FILE*") Pointer arg2, String arg3 );
  public static native void util_fread_char_vector(@Cast("char*") byte[] arg0, int arg1, @Cast("FILE*") Pointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native void util_fread_char_vector(@Cast("char*") BytePointer arg0, int arg1, @Cast("FILE*") Pointer arg2, String arg3 );
  public static native void util_fread_char_vector(@Cast("char*") ByteBuffer arg0, int arg1, @Cast("FILE*") Pointer arg2, @Cast("const char*") BytePointer arg3 );
  public static native void util_fread_char_vector(@Cast("char*") byte[] arg0, int arg1, @Cast("FILE*") Pointer arg2, String arg3 );
  public static native int util_type_get_id( @Const Pointer data );


  public static native @Cast("bool") boolean util_sscanf_bytesize(@Cast("const char*") BytePointer arg0, @Cast("size_t*") SizeTPointer arg1);
  public static native @Cast("bool") boolean util_sscanf_bytesize(String arg0, @Cast("size_t*") SizeTPointer arg1);
  public static native int util_get_current_linenr(@Cast("FILE*") Pointer stream);
  public static native @Cast("const char*") BytePointer util_update_path_var(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("bool") boolean arg2 );
  public static native String util_update_path_var(String arg0, String arg1, @Cast("bool") boolean arg2 );


  public static native void util_fskip_int(@Cast("FILE*") Pointer stream);
  public static native void util_fskip_long(@Cast("FILE*") Pointer stream);
  public static native void util_fskip_bool(@Cast("FILE*") Pointer stream);
  public static native @Cast("bool") boolean util_fseek_string(@Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer string, @Cast("bool") boolean skip_string, @Cast("bool") boolean case_sensitive);
  public static native @Cast("bool") boolean util_fseek_string(@Cast("FILE*") Pointer stream, String string, @Cast("bool") boolean skip_string, @Cast("bool") boolean case_sensitive);
  public static native @Cast("char*") BytePointer util_fscanf_alloc_upto(@Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer stop_string, @Cast("bool") boolean include_stop_string);
  public static native @Cast("char*") ByteBuffer util_fscanf_alloc_upto(@Cast("FILE*") Pointer stream, String stop_string, @Cast("bool") boolean include_stop_string);
  public static native @Cast("bool") boolean util_files_equal( @Cast("const char*") BytePointer file1, @Cast("const char*") BytePointer file2 );
  public static native @Cast("bool") boolean util_files_equal( String file1, String file2 );
  public static native double util_kahan_sum(@Const DoublePointer data, @Cast("size_t") long N);
  public static native double util_kahan_sum(@Const DoubleBuffer data, @Cast("size_t") long N);
  public static native double util_kahan_sum(@Const double[] data, @Cast("size_t") long N);
  public static native @Cast("bool") boolean util_double_approx_equal( double d1, double d2);
  public static native @Cast("bool") boolean util_double_approx_equal__( double d1, double d2, double rel_eps, double abs_eps);
  public static native @Cast("bool") boolean util_float_approx_equal__( float d1, float d2, float rel_eps, float abs_eps);
  public static native int util_fnmatch( @Cast("const char*") BytePointer pattern, @Cast("const char*") BytePointer string );
  public static native int util_fnmatch( String pattern, String string );
  public static native void util_time_utc( @Cast("time_t*") Pointer t, @Cast("tm*") Pointer ts );

  public static native @Cast("bool") boolean util_is_link(@Cast("const char*") BytePointer arg0 );
  public static native @Cast("bool") boolean util_is_link(String arg0 );  // Will always return false on windows
  public static native int util_chdir(@Cast("const char*") BytePointer path);
  public static native int util_chdir(String path);
  public static native @Cast("bool") boolean util_chdir_file( @Cast("const char*") BytePointer filename );
  public static native @Cast("bool") boolean util_chdir_file( String filename );

// #ifdef ERT_HAVE_UNISTD
// #else
  public static native @Cast("bool") boolean util_access(@Cast("const char*") BytePointer entry, int mode);
  public static native @Cast("bool") boolean util_access(String entry, int mode);
public static final int F_OK = 0;
public static final int R_OK = 4;
public static final int W_OK = 2;
public static final int X_OK = 1;
// #endif

// #define UTIL_FWRITE_SCALAR(s,stream) { if (fwrite(&s , sizeof s , 1 , stream) != 1) util_abort("%s: write failed: %s\n",__func__ , strerror(errno)); }

// #define UTIL_FREAD_SCALAR(s,stream)  {
//   int fread_return = fread(&s , sizeof s , 1 , stream);
//   if (fread_return == 0) {
//      if (errno == 0)
//         util_abort("%s: read failed - premature EOF\n",__func__);
// 
//      util_abort("%s: read failed: %s\n",__func__ , strerror(errno));
//   }
// }


// #define UTIL_FWRITE_VECTOR(s,n,stream) { if (fwrite(s , sizeof s , (n) , stream) != (n)) util_abort("%s: write failed: %s \n",__func__ , strerror(errno)); }
// #define UTIL_FREAD_VECTOR(s,n,stream)  { if (fread(s , sizeof s , (n) , stream) != (n)) util_abort("%s: read failed: %s \n",__func__ , strerror(errno)); }

// #define CONTAINS_HEADER(TYPE) int util_sorted_contains_ ## TYPE(const TYPE * data , int size , TYPE value)
  public static native int util_sorted_contains_int(@Const IntPointer data, int size, int value);
  public static native int util_sorted_contains_int(@Const IntBuffer data, int size, int value);
  public static native int util_sorted_contains_int(@Const int[] data, int size, int value);
  public static native int util_sorted_contains_time_t(@Cast("const time_t*") Pointer data, int size, @ByVal @Cast("time_t*") Pointer value);
  public static native int util_sorted_contains_size_t(@Cast("const size_t*") SizeTPointer data, int size, @Cast("size_t") long value);
// #undef CONTAINS_HEADER

// #ifdef _MSC_VER
// #define util_abort(fmt , ...) util_abort__(__FILE__ , __func__ , __LINE__ , fmt , __VA_ARGS__)
// #elif __GNUC__
/* Also clang defines the __GNUC__ symbol */
// #define util_abort(fmt , ...) util_abort__(__FILE__ , __func__ , __LINE__ , fmt , ##__VA_ARGS__)
// #endif



/*****************************************************************/
/* Conditional section below here */

public static native void util_abort__(@Cast("const char*") BytePointer file, @Cast("const char*") BytePointer function, int line, @Cast("const char*") BytePointer fmt);
public static native void util_abort__(String file, String function, int line, String fmt);
public static native void util_abort_signal(int arg0 );



// #ifdef ERT_HAVE_ZLIB
// #endif

// #ifdef ERT_HAVE_SYMLINK
// #endif


// #ifdef ERT_HAVE_SPAWN
// #endif


// #ifdef ERT_HAVE_LOCKF
// #endif

// #include "util_unlink.h"

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/type_macros.hpp

// #ifndef ERT_TYPE_MACROS_H
// #define ERT_TYPE_MACROS_H

// #ifdef __cplusplus
// #endif

// #include <ert/util/util.h>


/*****************************************************************/
/**
   <p>
   The four macros UTIL_IS_INSTANCE_FUNCTION, UTIL_SAFE_CAST_FUNTION,
   UTIL_TYPE_ID_DECLARATION and UTIL_TYPE_ID_INIT can be used to
   implement a simple system for type checking (void *) at
   runtime. The system is based on a unique integer for each class,
   this must be provided by the user.
   <p>
   The motivation for these functions is to be able to to type-check
   the arguments to callback functions like pthread_create.
    <p>
    UTIL_TYPE_ID_DECLARATION: Adds a field "int __type_id;" to the
      struct defintion.
    <p>
    UTIL_TYPE_ID_INIT: Should be added to the allocation routine,
      inserts a "->__type_id = magic_int;" code line in the alloc
      routine.
    <p>
    UTIL_IS_INSTANCE_FUNCTION: This macro will generate a function
      <type>_is_instance(void *) which will cast the (void *) input to
      (type *), and check the value of __type_id. If this is the
      correct value true is returned, otherwise the function will
      return false. Observe that the function will accept NULL as
      input; in which case it will return false.
    <p>
    UTIL_SAFE_CAST_FUNCTION: This is similar to
      UTIL_IS_INSTANCE_FUNCTION, but it will return (type *) if the
      cast succeeds, and fail hard if it fails. There is also a _CONST
      variety of this function.
<p>
*/




// #define UTIL_IS_INSTANCE_FUNCTION(type , TYPE_ID)
// bool type ## _is_instance( const void * __arg ) {
//    if (__arg == NULL)
//       return false;
//    else {
//      const type ## _type * arg =  (const type ## _type * ) __arg;
//       if ( arg->__type_id == TYPE_ID)
//          return true;
//       else
//          return false;
//    }
// }


// #define UTIL_IS_INSTANCE_HEADER(type) bool type ## _is_instance( const void * __arg )


// #define UTIL_SAFE_CAST_FUNCTION(type , TYPE_ID)
// type ## _type * type ## _safe_cast( void * __arg ) {
//    if (__arg == NULL) {
//       util_abort("%s: runtime cast failed - tried to dereference NULL\n",__func__);
//       return NULL;
//    }
//    {
//       type ## _type * arg = (type ## _type *) __arg;
//       if ( arg->__type_id == TYPE_ID)
//          return arg;
//       else {
//          util_abort("%s: runtime cast failed: Got ID:%d  Expected ID:%d \n", __func__ , arg->__type_id , TYPE_ID);
//          return NULL;
//       }
//    }
// }
// #define UTIL_SAFE_CAST_HEADER( type ) type ## _type * type ## _safe_cast( void * __arg )


// #define UTIL_SAFE_CAST_FUNCTION_CONST(type , TYPE_ID)
// const type ## _type * type ## _safe_cast_const( const void * __arg ) {
//    if (__arg == NULL) {
//       util_abort("%s: runtime cast failed - tried to dereference NULL\n",__func__);
//       return NULL;
//    }
//    {
//    const type ## _type * arg = (const type ## _type *) __arg;
//    if ( arg->__type_id == TYPE_ID)
//       return arg;
//    else {
//       util_abort("%s: runtime cast failed: Got ID:%d  Expected ID:%d \n", __func__ , arg->__type_id , TYPE_ID);
//       return NULL;
//    }
//    }
// }
// #define UTIL_SAFE_CAST_HEADER_CONST( type ) const type ## _type * type ## _safe_cast_const( const void * __arg )




// #define UTIL_TRY_CAST_FUNCTION(type , TYPE_ID)
// type ## _type * type ## _try_cast( void * __arg ) {
//    if (__arg == NULL)
//       return NULL;
//    {
//       type ## _type * arg = (type ## _type *) __arg;
//       if ( arg->__type_id == TYPE_ID)
//          return arg;
//       else
//          return NULL;
//    }
// }
// #define UTIL_TRY_CAST_HEADER( type ) type ## _type * type ## _try_cast( void * __arg )


// #define UTIL_TRY_CAST_FUNCTION_CONST(type , TYPE_ID)
// const type ## _type * type ## _try_cast_const( const void * __arg ) {
//    if (__arg == NULL)
//       return NULL;
//    {
//       const type ## _type * arg = (type ## _type *) __arg;
//       if ( arg->__type_id == TYPE_ID)
//          return arg;
//       else
//          return NULL;
//    }
// }
// #define UTIL_TRY_CAST_HEADER_CONST( type ) const type ## _type * type ## _try_cast_const( const void * __arg )




public static native @MemberGetter int UTIL_TYPE_ID_DECLARATION();
public static final int UTIL_TYPE_ID_DECLARATION = UTIL_TYPE_ID_DECLARATION();
// #define UTIL_TYPE_ID_INIT(var , TYPE_ID)   var->__type_id = TYPE_ID;



// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/perm_vector.hpp

/*
   Copyright (C) 2016  Equinor ASA, Norway.

   The file 'perm_vector.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef PERM_VECTOR_H
// #define PERM_VECTOR_H

// #include <ert/util/type_macros.hpp>

// #ifdef __cplusplus
// Targeting ../perm_vector_type.java



public static native perm_vector_type perm_vector_alloc( IntPointer perm_input, int size );
public static native perm_vector_type perm_vector_alloc( IntBuffer perm_input, int size );
public static native perm_vector_type perm_vector_alloc( int[] perm_input, int size );
public static native void perm_vector_free( perm_vector_type perm_vector );
public static native int perm_vector_get_size( @Const perm_vector_type perm);
public static native int perm_vector_iget( @Const perm_vector_type perm, int index);

// #ifdef __cplusplus
// #endif //__cplusplus

// #endif



// Parsed from ert/util/perm_vector.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/perm_vector.hpp>




// Parsed from ert/util/type_macros.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/type_macros.hpp>




// Parsed from ert/util/int_vector.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_int_VECTOR_H
// #define ERT_int_VECTOR_H
// #ifdef __cplusplus
// #endif
// #include <stdio.h>
// #include <stdbool.h>

// #include <ert/util/type_macros.h>
// #include <ert/util/perm_vector.h>
// Targeting ../int_vector_type.java


// Targeting ../int_ftype.java




  public static native int int_vector_lookup_bin( @Const int_vector_type limits, int value, int guess);
  public static native int int_vector_lookup_bin__( @Const int_vector_type limits, int value, int guess);
  public static native void int_vector_inplace_div( int_vector_type vector, @Const int_vector_type inv_factor);
  public static native void int_vector_inplace_mul( int_vector_type vector, @Const int_vector_type factor);
  public static native void int_vector_inplace_add( int_vector_type vector, @Const int_vector_type delta);
  public static native void int_vector_inplace_sub( int_vector_type vector, @Const int_vector_type delta);
  public static native void int_vector_set_read_only( int_vector_type vector, @Cast("bool") boolean read_only);
  public static native @Cast("bool") boolean int_vector_get_read_only( @Const int_vector_type vector );
  public static native void int_vector_memcpy_data( IntPointer target, @Const int_vector_type src );
  public static native void int_vector_memcpy_data( IntBuffer target, @Const int_vector_type src );
  public static native void int_vector_memcpy_data( int[] target, @Const int_vector_type src );
  public static native void int_vector_memcpy_from_data( int_vector_type target, @Const IntPointer src, int src_size );
  public static native void int_vector_memcpy_from_data( int_vector_type target, @Const IntBuffer src, int src_size );
  public static native void int_vector_memcpy_from_data( int_vector_type target, @Const int[] src, int src_size );
  public static native void int_vector_memcpy(  int_vector_type target, @Const int_vector_type src);
  public static native void int_vector_memcpy_data_block( int_vector_type target, @Const int_vector_type src, int target_offset, int src_offset, int len);
  public static native @Cast("bool") boolean int_vector_growable( @Const int_vector_type vector);
  public static native void int_vector_select_unique(int_vector_type vector);
  public static native int_vector_type int_vector_alloc( int init_size, int arg1 );
  public static native int_vector_type int_vector_alloc_private_wrapper(int init_size, int default_value, IntPointer data, int alloc_size);
  public static native int_vector_type int_vector_alloc_private_wrapper(int init_size, int default_value, IntBuffer data, int alloc_size);
  public static native int_vector_type int_vector_alloc_private_wrapper(int init_size, int default_value, int[] data, int alloc_size);
  public static native int_vector_type int_vector_alloc_shared_wrapper(int init_size, int default_value, IntPointer data, int alloc_size);
  public static native int_vector_type int_vector_alloc_shared_wrapper(int init_size, int default_value, IntBuffer data, int alloc_size);
  public static native int_vector_type int_vector_alloc_shared_wrapper(int init_size, int default_value, int[] data, int alloc_size);
  public static native int_vector_type int_vector_alloc_strided_copy( @Const int_vector_type src, int start, int stop, int stride );
  public static native int_vector_type int_vector_alloc_copy( @Const int_vector_type src);
  public static native void int_vector_imul(int_vector_type vector, int index, int factor);
  public static native void int_vector_scale(int_vector_type vector, int factor);
  public static native void int_vector_div(int_vector_type vector, int divisor);
  public static native int int_vector_reverse_iget(@Const int_vector_type vector, int index);
  public static native int int_vector_iget(@Const int_vector_type arg0, int arg1);
  public static native int int_vector_safe_iget(@Const int_vector_type arg0, int arg1);
  public static native int int_vector_get_min(@Const int_vector_type vector);
  public static native int int_vector_get_max(@Const int_vector_type vector);
  public static native int int_vector_get_min_index(@Const int_vector_type vector, @Cast("bool") boolean reverse);
  public static native int int_vector_get_max_index(@Const int_vector_type vector, @Cast("bool") boolean reverse);
  public static native int int_vector_iadd( int_vector_type vector, int index, int delta);
  public static native void int_vector_resize( int_vector_type vector, int new_size, int default_value );
  public static native void int_vector_iset(int_vector_type arg0, int arg1, int arg2);
  public static native void int_vector_iset_block(int_vector_type vector, int index, int block_size, int value);
  public static native void int_vector_idel_block( int_vector_type vector, int index, int block_size);
  public static native int int_vector_idel( int_vector_type vector, int index);
  public static native int int_vector_del_value( int_vector_type vector, int del_value);
  public static native void int_vector_insert( int_vector_type vector, int index, int value);
  public static native void int_vector_append(int_vector_type arg0, int arg1);
  public static native void int_vector_free_container(int_vector_type vector);
  public static native void int_vector_free(int_vector_type arg0);
  public static native void int_vector_free__(Pointer arg0);
  public static native void int_vector_free_data(int_vector_type arg0);
  public static native void int_vector_reset(int_vector_type arg0);
  public static native void int_vector_reset__(Pointer __vector);
  public static native int int_vector_size(@Const int_vector_type arg0 );
  public static native void int_vector_lshift(int_vector_type vector, int shift);
  public static native void int_vector_rshift(int_vector_type vector, int shift);
  public static native int int_vector_pop(int_vector_type vector);
  public static native int int_vector_get_first(@Const int_vector_type vector);
  public static native int int_vector_get_last(@Const int_vector_type arg0 );
  public static native IntPointer int_vector_get_ptr(@Const int_vector_type arg0 );
  public static native IntPointer int_vector_alloc_data_copy( @Const int_vector_type vector );
  public static native @Const IntPointer int_vector_get_const_ptr(@Const int_vector_type arg0 );
  public static native @Cast("bool") boolean int_vector_init_linear(int_vector_type vector, int start_value, int end_value, int num_values);
  public static native void int_vector_init_range(int_vector_type vector, int value1, int value2, int delta);
  public static native void int_vector_set_many(int_vector_type arg0, int arg1, @Const IntPointer arg2, int arg3 );
  public static native void int_vector_set_many(int_vector_type arg0, int arg1, @Const IntBuffer arg2, int arg3 );
  public static native void int_vector_set_many(int_vector_type arg0, int arg1, @Const int[] arg2, int arg3 );
  public static native void int_vector_set_all(int_vector_type vector, int value);
  public static native void int_vector_append_many(int_vector_type vector, @Const IntPointer data, int length);
  public static native void int_vector_append_many(int_vector_type vector, @Const IntBuffer data, int length);
  public static native void int_vector_append_many(int_vector_type vector, @Const int[] data, int length);
  public static native void int_vector_append_vector(int_vector_type vector, @Const int_vector_type other);
  public static native void int_vector_shrink(int_vector_type arg0 );
  public static native int int_vector_sum(@Const int_vector_type arg0 );
  public static native int int_vector_get_default(@Const int_vector_type arg0 );
  public static native void int_vector_set_default(int_vector_type vector, int default_value);
  public static native void int_vector_append_default(int_vector_type vector, int default_value);
  public static native void int_vector_iset_default(int_vector_type vector, int index, int default_value);
  public static native @Cast("bool") boolean int_vector_is_sorted( @Const int_vector_type vector, @Cast("bool") boolean reverse);
  public static native @Cast("bool") boolean int_vector_contains(@Const int_vector_type vector, int value);
  public static native @Cast("bool") boolean int_vector_contains_sorted(@Const int_vector_type vector, int value);
  public static native int int_vector_index(@Const int_vector_type vector, int value);
  public static native int int_vector_index_sorted(@Const int_vector_type vector, int value);
  public static native void int_vector_sort(int_vector_type vector);
  public static native void int_vector_rsort(int_vector_type vector);
  public static native void int_vector_permute(int_vector_type vector, @Const perm_vector_type perm);
  public static native perm_vector_type int_vector_alloc_sort_perm(@Const int_vector_type vector);
  public static native perm_vector_type int_vector_alloc_rsort_perm(@Const int_vector_type vector);
  public static native void int_vector_fprintf(@Const int_vector_type vector, @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer fmt);
  public static native void int_vector_fprintf(@Const int_vector_type vector, @Cast("FILE*") Pointer stream, String name, String fmt);
  public static native void int_vector_fwrite(@Const int_vector_type vector, @Cast("FILE*") Pointer stream);
  public static native int_vector_type int_vector_fread_alloc( @Cast("FILE*") Pointer stream );
  public static native void int_vector_fread( int_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void int_vector_fwrite_data( @Const int_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void int_vector_fread_data( int_vector_type vector, int size, @Cast("FILE*") Pointer stream);
  public static native @Cast("bool") boolean int_vector_equal(@Const int_vector_type vector1, @Const int_vector_type vector2);
  public static native int int_vector_first_equal(@Const int_vector_type vector1, @Const int_vector_type vector2, int offset);
  public static native int int_vector_first_not_equal(@Const int_vector_type vector1, @Const int_vector_type vector2, int offset);
  public static native void int_vector_apply(int_vector_type vector, int_ftype func);
  public static native int int_vector_count_equal( @Const int_vector_type vector, int cmp_value);
  public static native int int_vector_element_size( @Const int_vector_type vector );
  public static native void int_vector_range_fill(int_vector_type vector, int limit1, int delta, int limit2);
  public static native void int_vector_shift(int_vector_type vector, int delta);

  public static native int_vector_type int_vector_safe_cast( Pointer __arg );
  public static native @Cast("bool") boolean int_vector_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif
//






// Parsed from ert/util/int_vector.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.hpp' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_int_VECTOR_CXX
// #define ERT_int_VECTOR_CXX

// #include <ert/util/int_vector.h>

// #endif


// Parsed from ert/util/vector.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_VECTOR_H
// #define ERT_VECTOR_H

// #include <ert/util/node_data.hpp>
// #include <ert/util/type_macros.hpp>
// #include <ert/util/int_vector.hpp>

// #ifdef __cplusplus
// Targeting ../vector_func_type.java


// Targeting ../vector_cmp_ftype.java


// Targeting ../vector_type.java




  public static native vector_type vector_alloc_new();
  public static native void vector_grow_NULL( vector_type vector, int new_size );
  public static native vector_type vector_alloc_NULL_initialized( int size );

  public static native int vector_append_ref( vector_type arg0, @Const Pointer arg1);
  public static native int vector_append_owned_ref( vector_type arg0, @Const Pointer arg1, free_ftype del);
  public static native int vector_append_copy(vector_type arg0, @Const Pointer arg1, copyc_ftype arg2, free_ftype arg3);

  public static native void vector_iset_ref( vector_type arg0, int arg1, @Const Pointer arg2);
  public static native void vector_iset_owned_ref( vector_type arg0, int arg1, @Const Pointer arg2, free_ftype del);
  public static native void vector_iset_copy(vector_type arg0, int arg1, @Const Pointer arg2, copyc_ftype arg3, free_ftype arg4);

  public static native void vector_safe_iset_copy(vector_type vector, int index, @Const Pointer data, copyc_ftype copyc, free_ftype del);
  public static native void vector_safe_iset_owned_ref(vector_type vector, int index, @Const Pointer data, free_ftype del);
  public static native void vector_safe_iset_ref(vector_type vector, int index, @Const Pointer data);

  public static native void vector_insert_ref( vector_type arg0, int arg1, @Const Pointer arg2);
  public static native void vector_insert_owned_ref( vector_type arg0, int arg1, @Const Pointer arg2, free_ftype del);
  public static native void vector_insert_copy(vector_type arg0, int arg1, @Const Pointer arg2, copyc_ftype arg3, free_ftype arg4);
  public static native void vector_insert_buffer(vector_type vector, int index, @Const Pointer buffer, int buffer_size);

  public static native void vector_push_front_ref( vector_type arg0,  @Const Pointer arg1);
  public static native void vector_push_front_owned_ref( vector_type arg0,  @Const Pointer arg1, free_ftype del);
  public static native void vector_push_front_copy(vector_type arg0,  @Const Pointer arg1, copyc_ftype arg2, free_ftype arg3);


  public static native void vector_clear(vector_type vector);
  public static native void vector_free(vector_type arg0 );
  public static native void vector_free__( Pointer arg );
  public static native void vector_append_buffer(vector_type arg0, @Const Pointer arg1, int arg2);
  public static native void vector_push_buffer(vector_type arg0, @Const Pointer arg1, int arg2);
  public static native Pointer vector_safe_iget(@Const vector_type vector, int index);
  public static native @Const Pointer vector_safe_iget_const(@Const vector_type vector, int index);
  public static native @Const Pointer vector_iget_const(@Const vector_type arg0, int arg1 );
  public static native Pointer vector_iget(@Const vector_type arg0, int arg1 );
  public static native void vector_idel(vector_type vector, int index);
  public static native void vector_shrink( vector_type vector, int new_size );
  public static native Pointer vector_get_last(@Const vector_type arg0 );
  public static native @Const Pointer vector_get_last_const(@Const vector_type arg0 );
  public static native int vector_get_size( @Const vector_type arg0 );
  public static native Pointer vector_pop_back(vector_type arg0 );
  public static native Pointer vector_pop_front(vector_type arg0 );
  public static native void vector_sort(vector_type vector, vector_cmp_ftype cmp);
  public static native int_vector_type vector_alloc_sort_perm(@Const vector_type vector, vector_cmp_ftype cmp);
  public static native void vector_permute(vector_type vector, @Const int_vector_type perm_vector);
  public static native void vector_inplace_reverse(vector_type vector);
  public static native vector_type vector_alloc_copy(@Const vector_type src, @Cast("bool") boolean deep_copy);

  public static native void vector_iset_buffer(vector_type vector, int index, @Const Pointer buffer, int buffer_size);
  public static native int vector_find( @Const vector_type vector, @Const Pointer ptr);

  public static native @Cast("bool") boolean vector_is_instance( @Const Pointer __arg );
  public static native vector_type vector_safe_cast( Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/vector.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/vector.hpp>




// Parsed from ert/util/util_unlink.h

/*
   Copyright (C) 2017  Equinor ASA, Norway.

   The file 'util_unlink.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_UTIL_UNLINK_H
// #define ERT_UTIL_UNLINK_H


// #ifdef __cplusplus
// #endif

  public static native int util_unlink(@Cast("const char*") BytePointer filename);
  public static native int util_unlink(String filename);

// #ifdef __cplusplus
// #endif
// #endif



// Parsed from ert/util/util_endian.h

/*
   Copyright (C) 2012  Equinor ASA, Norway.

   The file 'util_endian.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_UTIL_ENDIAN_H
// #define ERT_UTIL_ENDIAN_H

// #ifdef __cplusplus
// #endif

// #ifdef __cplusplus
// #endif
// #endif



// Parsed from ert/util/util.hpp

/*
   Copyright (C) 2018 Equinor ASA, Norway.

   This is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or1
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef UTIL_CXX
// #define UTIL_CXX

// #include <ert/util/util.h>

// #endif


// Parsed from ert/util/double_vector.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_double_VECTOR_H
// #define ERT_double_VECTOR_H
// #ifdef __cplusplus
// #endif
// #include <stdio.h>
// #include <stdbool.h>

// #include <ert/util/type_macros.h>
// #include <ert/util/perm_vector.h>
// Targeting ../double_vector_type.java


// Targeting ../double_ftype.java




  public static native int double_vector_lookup_bin( @Const double_vector_type limits, double value, int guess);
  public static native int double_vector_lookup_bin__( @Const double_vector_type limits, double value, int guess);
  public static native void double_vector_inplace_div( double_vector_type vector, @Const double_vector_type inv_factor);
  public static native void double_vector_inplace_mul( double_vector_type vector, @Const double_vector_type factor);
  public static native void double_vector_inplace_add( double_vector_type vector, @Const double_vector_type delta);
  public static native void double_vector_inplace_sub( double_vector_type vector, @Const double_vector_type delta);
  public static native void double_vector_set_read_only( double_vector_type vector, @Cast("bool") boolean read_only);
  public static native @Cast("bool") boolean double_vector_get_read_only( @Const double_vector_type vector );
  public static native void double_vector_memcpy_data( DoublePointer target, @Const double_vector_type src );
  public static native void double_vector_memcpy_data( DoubleBuffer target, @Const double_vector_type src );
  public static native void double_vector_memcpy_data( double[] target, @Const double_vector_type src );
  public static native void double_vector_memcpy_from_data( double_vector_type target, @Const DoublePointer src, int src_size );
  public static native void double_vector_memcpy_from_data( double_vector_type target, @Const DoubleBuffer src, int src_size );
  public static native void double_vector_memcpy_from_data( double_vector_type target, @Const double[] src, int src_size );
  public static native void double_vector_memcpy(  double_vector_type target, @Const double_vector_type src);
  public static native void double_vector_memcpy_data_block( double_vector_type target, @Const double_vector_type src, int target_offset, int src_offset, int len);
  public static native @Cast("bool") boolean double_vector_growable( @Const double_vector_type vector);
  public static native void double_vector_select_unique(double_vector_type vector);
  public static native double_vector_type double_vector_alloc( int init_size, double arg1 );
  public static native double_vector_type double_vector_alloc_private_wrapper(int init_size, double default_value, DoublePointer data, int alloc_size);
  public static native double_vector_type double_vector_alloc_private_wrapper(int init_size, double default_value, DoubleBuffer data, int alloc_size);
  public static native double_vector_type double_vector_alloc_private_wrapper(int init_size, double default_value, double[] data, int alloc_size);
  public static native double_vector_type double_vector_alloc_shared_wrapper(int init_size, double default_value, DoublePointer data, int alloc_size);
  public static native double_vector_type double_vector_alloc_shared_wrapper(int init_size, double default_value, DoubleBuffer data, int alloc_size);
  public static native double_vector_type double_vector_alloc_shared_wrapper(int init_size, double default_value, double[] data, int alloc_size);
  public static native double_vector_type double_vector_alloc_strided_copy( @Const double_vector_type src, int start, int stop, int stride );
  public static native double_vector_type double_vector_alloc_copy( @Const double_vector_type src);
  public static native void double_vector_imul(double_vector_type vector, int index, double factor);
  public static native void double_vector_scale(double_vector_type vector, double factor);
  public static native void double_vector_div(double_vector_type vector, double divisor);
  public static native double double_vector_reverse_iget(@Const double_vector_type vector, int index);
  public static native double double_vector_iget(@Const double_vector_type arg0, int arg1);
  public static native double double_vector_safe_iget(@Const double_vector_type arg0, int arg1);
  public static native double double_vector_get_min(@Const double_vector_type vector);
  public static native double double_vector_get_max(@Const double_vector_type vector);
  public static native int double_vector_get_min_index(@Const double_vector_type vector, @Cast("bool") boolean reverse);
  public static native int double_vector_get_max_index(@Const double_vector_type vector, @Cast("bool") boolean reverse);
  public static native double double_vector_iadd( double_vector_type vector, int index, double delta);
  public static native void double_vector_resize( double_vector_type vector, int new_size, double default_value );
  public static native void double_vector_iset(double_vector_type arg0, int arg1, double arg2);
  public static native void double_vector_iset_block(double_vector_type vector, int index, int block_size, double value);
  public static native void double_vector_idel_block( double_vector_type vector, int index, int block_size);
  public static native double double_vector_idel( double_vector_type vector, int index);
  public static native double double_vector_del_value( double_vector_type vector, double del_value);
  public static native void double_vector_insert( double_vector_type vector, int index, double value);
  public static native void double_vector_append(double_vector_type arg0, double arg1);
  public static native void double_vector_free_container(double_vector_type vector);
  public static native void double_vector_free(double_vector_type arg0);
  public static native void double_vector_free__(Pointer arg0);
  public static native void double_vector_free_data(double_vector_type arg0);
  public static native void double_vector_reset(double_vector_type arg0);
  public static native void double_vector_reset__(Pointer __vector);
  public static native int double_vector_size(@Const double_vector_type arg0 );
  public static native void double_vector_lshift(double_vector_type vector, int shift);
  public static native void double_vector_rshift(double_vector_type vector, int shift);
  public static native double double_vector_pop(double_vector_type vector);
  public static native double double_vector_get_first(@Const double_vector_type vector);
  public static native double double_vector_get_last(@Const double_vector_type arg0 );
  public static native DoublePointer double_vector_get_ptr(@Const double_vector_type arg0 );
  public static native DoublePointer double_vector_alloc_data_copy( @Const double_vector_type vector );
  public static native @Const DoublePointer double_vector_get_const_ptr(@Const double_vector_type arg0 );
  public static native @Cast("bool") boolean double_vector_init_linear(double_vector_type vector, double start_value, double end_value, int num_values);
  public static native void double_vector_init_range(double_vector_type vector, double value1, double value2, double delta);
  public static native void double_vector_set_many(double_vector_type arg0, int arg1, @Const DoublePointer arg2, int arg3 );
  public static native void double_vector_set_many(double_vector_type arg0, int arg1, @Const DoubleBuffer arg2, int arg3 );
  public static native void double_vector_set_many(double_vector_type arg0, int arg1, @Const double[] arg2, int arg3 );
  public static native void double_vector_set_all(double_vector_type vector, double value);
  public static native void double_vector_append_many(double_vector_type vector, @Const DoublePointer data, int length);
  public static native void double_vector_append_many(double_vector_type vector, @Const DoubleBuffer data, int length);
  public static native void double_vector_append_many(double_vector_type vector, @Const double[] data, int length);
  public static native void double_vector_append_vector(double_vector_type vector, @Const double_vector_type other);
  public static native void double_vector_shrink(double_vector_type arg0 );
  public static native double double_vector_sum(@Const double_vector_type arg0 );
  public static native double double_vector_get_default(@Const double_vector_type arg0 );
  public static native void double_vector_set_default(double_vector_type vector, double default_value);
  public static native void double_vector_append_default(double_vector_type vector, double default_value);
  public static native void double_vector_iset_default(double_vector_type vector, int index, double default_value);
  public static native @Cast("bool") boolean double_vector_is_sorted( @Const double_vector_type vector, @Cast("bool") boolean reverse);
  public static native @Cast("bool") boolean double_vector_contains(@Const double_vector_type vector, double value);
  public static native @Cast("bool") boolean double_vector_contains_sorted(@Const double_vector_type vector, double value);
  public static native int double_vector_index(@Const double_vector_type vector, double value);
  public static native int double_vector_index_sorted(@Const double_vector_type vector, double value);
  public static native void double_vector_sort(double_vector_type vector);
  public static native void double_vector_rsort(double_vector_type vector);
  public static native void double_vector_permute(double_vector_type vector, @Const perm_vector_type perm);
  public static native perm_vector_type double_vector_alloc_sort_perm(@Const double_vector_type vector);
  public static native perm_vector_type double_vector_alloc_rsort_perm(@Const double_vector_type vector);
  public static native void double_vector_fprintf(@Const double_vector_type vector, @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer fmt);
  public static native void double_vector_fprintf(@Const double_vector_type vector, @Cast("FILE*") Pointer stream, String name, String fmt);
  public static native void double_vector_fwrite(@Const double_vector_type vector, @Cast("FILE*") Pointer stream);
  public static native double_vector_type double_vector_fread_alloc( @Cast("FILE*") Pointer stream );
  public static native void double_vector_fread( double_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void double_vector_fwrite_data( @Const double_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void double_vector_fread_data( double_vector_type vector, int size, @Cast("FILE*") Pointer stream);
  public static native @Cast("bool") boolean double_vector_equal(@Const double_vector_type vector1, @Const double_vector_type vector2);
  public static native int double_vector_first_equal(@Const double_vector_type vector1, @Const double_vector_type vector2, int offset);
  public static native int double_vector_first_not_equal(@Const double_vector_type vector1, @Const double_vector_type vector2, int offset);
  public static native void double_vector_apply(double_vector_type vector, double_ftype func);
  public static native int double_vector_count_equal( @Const double_vector_type vector, double cmp_value);
  public static native int double_vector_element_size( @Const double_vector_type vector );
  public static native void double_vector_range_fill(double_vector_type vector, double limit1, double delta, double limit2);
  public static native void double_vector_shift(double_vector_type vector, double delta);

  public static native double_vector_type double_vector_safe_cast( Pointer __arg );
  public static native @Cast("bool") boolean double_vector_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif
//






// Parsed from ert/util/double_vector.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.hpp' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_double_VECTOR_CXX
// #define ERT_double_VECTOR_CXX

// #include <ert/util/double_vector.h>

// #endif


// Parsed from ert/util/bool_vector.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_bool_VECTOR_H
// #define ERT_bool_VECTOR_H
// #ifdef __cplusplus
// #endif
// #include <stdio.h>
// #include <stdbool.h>

// #include <ert/util/type_macros.h>
// #include <ert/util/perm_vector.h>
// Targeting ../bool_vector_type.java


// Targeting ../bool_ftype.java




  public static native int bool_vector_lookup_bin( @Const bool_vector_type limits, @Cast("bool") boolean value, int guess);
  public static native int bool_vector_lookup_bin__( @Const bool_vector_type limits, @Cast("bool") boolean value, int guess);
  public static native void bool_vector_inplace_div( bool_vector_type vector, @Const bool_vector_type inv_factor);
  public static native void bool_vector_inplace_mul( bool_vector_type vector, @Const bool_vector_type factor);
  public static native void bool_vector_inplace_add( bool_vector_type vector, @Const bool_vector_type delta);
  public static native void bool_vector_inplace_sub( bool_vector_type vector, @Const bool_vector_type delta);
  public static native void bool_vector_set_read_only( bool_vector_type vector, @Cast("bool") boolean read_only);
  public static native @Cast("bool") boolean bool_vector_get_read_only( @Const bool_vector_type vector );
  public static native void bool_vector_memcpy_data( @Cast("bool*") BoolPointer target, @Const bool_vector_type src );
  public static native void bool_vector_memcpy_data( @Cast("bool*") boolean[] target, @Const bool_vector_type src );
  public static native void bool_vector_memcpy_from_data( bool_vector_type target, @Cast("const bool*") BoolPointer src, int src_size );
  public static native void bool_vector_memcpy_from_data( bool_vector_type target, @Cast("const bool*") boolean[] src, int src_size );
  public static native void bool_vector_memcpy(  bool_vector_type target, @Const bool_vector_type src);
  public static native void bool_vector_memcpy_data_block( bool_vector_type target, @Const bool_vector_type src, int target_offset, int src_offset, int len);
  public static native @Cast("bool") boolean bool_vector_growable( @Const bool_vector_type vector);
  public static native void bool_vector_select_unique(bool_vector_type vector);
  public static native bool_vector_type bool_vector_alloc( int init_size, @Cast("bool") boolean arg1 );
  public static native bool_vector_type bool_vector_alloc_private_wrapper(int init_size, @Cast("bool") boolean default_value, @Cast("bool*") BoolPointer data, int alloc_size);
  public static native bool_vector_type bool_vector_alloc_private_wrapper(int init_size, @Cast("bool") boolean default_value, @Cast("bool*") boolean[] data, int alloc_size);
  public static native bool_vector_type bool_vector_alloc_shared_wrapper(int init_size, @Cast("bool") boolean default_value, @Cast("bool*") BoolPointer data, int alloc_size);
  public static native bool_vector_type bool_vector_alloc_shared_wrapper(int init_size, @Cast("bool") boolean default_value, @Cast("bool*") boolean[] data, int alloc_size);
  public static native bool_vector_type bool_vector_alloc_strided_copy( @Const bool_vector_type src, int start, int stop, int stride );
  public static native bool_vector_type bool_vector_alloc_copy( @Const bool_vector_type src);
  public static native void bool_vector_imul(bool_vector_type vector, int index, @Cast("bool") boolean factor);
  public static native void bool_vector_scale(bool_vector_type vector, @Cast("bool") boolean factor);
  public static native void bool_vector_div(bool_vector_type vector, @Cast("bool") boolean divisor);
  public static native @Cast("bool") boolean bool_vector_reverse_iget(@Const bool_vector_type vector, int index);
  public static native @Cast("bool") boolean bool_vector_iget(@Const bool_vector_type arg0, int arg1);
  public static native @Cast("bool") boolean bool_vector_safe_iget(@Const bool_vector_type arg0, int arg1);
  public static native @Cast("bool") boolean bool_vector_get_min(@Const bool_vector_type vector);
  public static native @Cast("bool") boolean bool_vector_get_max(@Const bool_vector_type vector);
  public static native int bool_vector_get_min_index(@Const bool_vector_type vector, @Cast("bool") boolean reverse);
  public static native int bool_vector_get_max_index(@Const bool_vector_type vector, @Cast("bool") boolean reverse);
  public static native @Cast("bool") boolean bool_vector_iadd( bool_vector_type vector, int index, @Cast("bool") boolean delta);
  public static native void bool_vector_resize( bool_vector_type vector, int new_size, @Cast("bool") boolean default_value );
  public static native void bool_vector_iset(bool_vector_type arg0, int arg1, @Cast("bool") boolean arg2);
  public static native void bool_vector_iset_block(bool_vector_type vector, int index, int block_size, @Cast("bool") boolean value);
  public static native void bool_vector_idel_block( bool_vector_type vector, int index, int block_size);
  public static native @Cast("bool") boolean bool_vector_idel( bool_vector_type vector, int index);
  public static native @Cast("bool") boolean bool_vector_del_value( bool_vector_type vector, @Cast("bool") boolean del_value);
  public static native void bool_vector_insert( bool_vector_type vector, int index, @Cast("bool") boolean value);
  public static native void bool_vector_append(bool_vector_type arg0, @Cast("bool") boolean arg1);
  public static native void bool_vector_free_container(bool_vector_type vector);
  public static native void bool_vector_free(bool_vector_type arg0);
  public static native void bool_vector_free__(Pointer arg0);
  public static native void bool_vector_free_data(bool_vector_type arg0);
  public static native void bool_vector_reset(bool_vector_type arg0);
  public static native void bool_vector_reset__(Pointer __vector);
  public static native int bool_vector_size(@Const bool_vector_type arg0 );
  public static native void bool_vector_lshift(bool_vector_type vector, int shift);
  public static native void bool_vector_rshift(bool_vector_type vector, int shift);
  public static native @Cast("bool") boolean bool_vector_pop(bool_vector_type vector);
  public static native @Cast("bool") boolean bool_vector_get_first(@Const bool_vector_type vector);
  public static native @Cast("bool") boolean bool_vector_get_last(@Const bool_vector_type arg0 );
  public static native @Cast("bool*") BoolPointer bool_vector_get_ptr(@Const bool_vector_type arg0 );
  public static native @Cast("bool*") BoolPointer bool_vector_alloc_data_copy( @Const bool_vector_type vector );
  public static native @Cast("const bool*") BoolPointer bool_vector_get_const_ptr(@Const bool_vector_type arg0 );
  public static native @Cast("bool") boolean bool_vector_init_linear(bool_vector_type vector, @Cast("bool") boolean start_value, @Cast("bool") boolean end_value, int num_values);
  public static native void bool_vector_init_range(bool_vector_type vector, @Cast("bool") boolean value1, @Cast("bool") boolean value2, @Cast("bool") boolean delta);
  public static native void bool_vector_set_many(bool_vector_type arg0, int arg1, @Cast("const bool*") BoolPointer arg2, int arg3 );
  public static native void bool_vector_set_many(bool_vector_type arg0, int arg1, @Cast("const bool*") boolean[] arg2, int arg3 );
  public static native void bool_vector_set_all(bool_vector_type vector, @Cast("bool") boolean value);
  public static native void bool_vector_append_many(bool_vector_type vector, @Cast("const bool*") BoolPointer data, int length);
  public static native void bool_vector_append_many(bool_vector_type vector, @Cast("const bool*") boolean[] data, int length);
  public static native void bool_vector_append_vector(bool_vector_type vector, @Const bool_vector_type other);
  public static native void bool_vector_shrink(bool_vector_type arg0 );
  public static native @Cast("bool") boolean bool_vector_sum(@Const bool_vector_type arg0 );
  public static native @Cast("bool") boolean bool_vector_get_default(@Const bool_vector_type arg0 );
  public static native void bool_vector_set_default(bool_vector_type vector, @Cast("bool") boolean default_value);
  public static native void bool_vector_append_default(bool_vector_type vector, @Cast("bool") boolean default_value);
  public static native void bool_vector_iset_default(bool_vector_type vector, int index, @Cast("bool") boolean default_value);
  public static native @Cast("bool") boolean bool_vector_is_sorted( @Const bool_vector_type vector, @Cast("bool") boolean reverse);
  public static native @Cast("bool") boolean bool_vector_contains(@Const bool_vector_type vector, @Cast("bool") boolean value);
  public static native @Cast("bool") boolean bool_vector_contains_sorted(@Const bool_vector_type vector, @Cast("bool") boolean value);
  public static native int bool_vector_index(@Const bool_vector_type vector, @Cast("bool") boolean value);
  public static native int bool_vector_index_sorted(@Const bool_vector_type vector, @Cast("bool") boolean value);
  public static native void bool_vector_sort(bool_vector_type vector);
  public static native void bool_vector_rsort(bool_vector_type vector);
  public static native void bool_vector_permute(bool_vector_type vector, @Const perm_vector_type perm);
  public static native perm_vector_type bool_vector_alloc_sort_perm(@Const bool_vector_type vector);
  public static native perm_vector_type bool_vector_alloc_rsort_perm(@Const bool_vector_type vector);
  public static native void bool_vector_fprintf(@Const bool_vector_type vector, @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer fmt);
  public static native void bool_vector_fprintf(@Const bool_vector_type vector, @Cast("FILE*") Pointer stream, String name, String fmt);
  public static native void bool_vector_fwrite(@Const bool_vector_type vector, @Cast("FILE*") Pointer stream);
  public static native bool_vector_type bool_vector_fread_alloc( @Cast("FILE*") Pointer stream );
  public static native void bool_vector_fread( bool_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void bool_vector_fwrite_data( @Const bool_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void bool_vector_fread_data( bool_vector_type vector, int size, @Cast("FILE*") Pointer stream);
  public static native @Cast("bool") boolean bool_vector_equal(@Const bool_vector_type vector1, @Const bool_vector_type vector2);
  public static native int bool_vector_first_equal(@Const bool_vector_type vector1, @Const bool_vector_type vector2, int offset);
  public static native int bool_vector_first_not_equal(@Const bool_vector_type vector1, @Const bool_vector_type vector2, int offset);
  public static native void bool_vector_apply(bool_vector_type vector, bool_ftype func);
  public static native int bool_vector_count_equal( @Const bool_vector_type vector, @Cast("bool") boolean cmp_value);
  public static native int bool_vector_element_size( @Const bool_vector_type vector );
  public static native void bool_vector_range_fill(bool_vector_type vector, @Cast("bool") boolean limit1, @Cast("bool") boolean delta, @Cast("bool") boolean limit2);
  public static native void bool_vector_shift(bool_vector_type vector, @Cast("bool") boolean delta);

  public static native bool_vector_type bool_vector_safe_cast( Pointer __arg );
  public static native @Cast("bool") boolean bool_vector_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif
//






// Parsed from ert/util/bool_vector.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.hpp' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_bool_VECTOR_CXX
// #define ERT_bool_VECTOR_CXX

// #include <ert/util/bool_vector.h>

// #endif


// Parsed from ert/util/type_vector_functions.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'type_vector_functions.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/
// #ifndef ERT_TYPE_VECTOR_FUNCTIONS_H
// #define ERT_TYPE_VECTOR_FUNCTIONS_H

// #include <ert/util/int_vector.hpp>
// #include <ert/util/bool_vector.hpp>
// #include <ert/util/double_vector.hpp>

// #ifdef __cplusplus
// #endif

  public static native int_vector_type bool_vector_alloc_active_list( @Const bool_vector_type mask );
  public static native bool_vector_type int_vector_alloc_mask( @Const int_vector_type active_list );
  public static native int_vector_type bool_vector_alloc_active_index_list(@Const bool_vector_type mask, int default_value);
  public static native @Cast("bool") boolean double_vector_approx_equal( @Const double_vector_type v1, @Const double_vector_type v12, double epsilon);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/type_vector_functions.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/type_vector_functions.hpp>




// Parsed from ert/util/timer.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'timer.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_TIMER_H
// #define ERT_TIMER_H

// #ifdef __cplusplus
// #endif

// #include <time.h>
// #include <stdlib.h>
// Targeting ../timer_type.java



  public static native timer_type timer_alloc( @Cast("bool") boolean arg0 );
  public static native void timer_free(timer_type arg0);
  public static native void timer_start(timer_type arg0);
  public static native double timer_stop(timer_type arg0);
  public static native void timer_reset(timer_type arg0);

  public static native double timer_get_total_time(@Const timer_type timer);
  public static native double timer_get_max_time(@Const timer_type timer);
  public static native double timer_get_min_time(@Const timer_type timer);
  public static native double timer_get_avg_time(@Const timer_type timer);


// #ifdef __cplusplus
// #endif
// #endif



// Parsed from ert/util/timer.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/timer.hpp>




// Parsed from ert/util/time_t_vector.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_time_t_VECTOR_H
// #define ERT_time_t_VECTOR_H
// #ifdef __cplusplus
// #endif
// #include <stdio.h>
// #include <stdbool.h>

// #include <ert/util/type_macros.h>
// #include <ert/util/perm_vector.h>
// Targeting ../time_t_vector_type.java


// Targeting ../time_t_ftype.java




  public static native int time_t_vector_lookup_bin( @Const time_t_vector_type limits, @ByVal @Cast("time_t*") Pointer value, int guess);
  public static native int time_t_vector_lookup_bin__( @Const time_t_vector_type limits, @ByVal @Cast("time_t*") Pointer value, int guess);
  public static native void time_t_vector_inplace_div( time_t_vector_type vector, @Const time_t_vector_type inv_factor);
  public static native void time_t_vector_inplace_mul( time_t_vector_type vector, @Const time_t_vector_type factor);
  public static native void time_t_vector_inplace_add( time_t_vector_type vector, @Const time_t_vector_type delta);
  public static native void time_t_vector_inplace_sub( time_t_vector_type vector, @Const time_t_vector_type delta);
  public static native void time_t_vector_set_read_only( time_t_vector_type vector, @Cast("bool") boolean read_only);
  public static native @Cast("bool") boolean time_t_vector_get_read_only( @Const time_t_vector_type vector );
  public static native void time_t_vector_memcpy_data( @Cast("time_t*") Pointer target, @Const time_t_vector_type src );
  public static native void time_t_vector_memcpy_from_data( time_t_vector_type target, @Cast("const time_t*") Pointer src, int src_size );
  public static native void time_t_vector_memcpy(  time_t_vector_type target, @Const time_t_vector_type src);
  public static native void time_t_vector_memcpy_data_block( time_t_vector_type target, @Const time_t_vector_type src, int target_offset, int src_offset, int len);
  public static native @Cast("bool") boolean time_t_vector_growable( @Const time_t_vector_type vector);
  public static native void time_t_vector_select_unique(time_t_vector_type vector);
  public static native time_t_vector_type time_t_vector_alloc( int init_size, @ByVal @Cast("time_t*") Pointer arg1 );
  public static native time_t_vector_type time_t_vector_alloc_private_wrapper(int init_size, @ByVal @Cast("time_t*") Pointer default_value, @Cast("time_t*") Pointer data, int alloc_size);
  public static native time_t_vector_type time_t_vector_alloc_shared_wrapper(int init_size, @ByVal @Cast("time_t*") Pointer default_value, @Cast("time_t*") Pointer data, int alloc_size);
  public static native time_t_vector_type time_t_vector_alloc_strided_copy( @Const time_t_vector_type src, int start, int stop, int stride );
  public static native time_t_vector_type time_t_vector_alloc_copy( @Const time_t_vector_type src);
  public static native void time_t_vector_imul(time_t_vector_type vector, int index, @ByVal @Cast("time_t*") Pointer factor);
  public static native void time_t_vector_scale(time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer factor);
  public static native void time_t_vector_div(time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer divisor);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_reverse_iget(@Const time_t_vector_type vector, int index);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_iget(@Const time_t_vector_type arg0, int arg1);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_safe_iget(@Const time_t_vector_type arg0, int arg1);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_get_min(@Const time_t_vector_type vector);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_get_max(@Const time_t_vector_type vector);
  public static native int time_t_vector_get_min_index(@Const time_t_vector_type vector, @Cast("bool") boolean reverse);
  public static native int time_t_vector_get_max_index(@Const time_t_vector_type vector, @Cast("bool") boolean reverse);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_iadd( time_t_vector_type vector, int index, @ByVal @Cast("time_t*") Pointer delta);
  public static native void time_t_vector_resize( time_t_vector_type vector, int new_size, @ByVal @Cast("time_t*") Pointer default_value );
  public static native void time_t_vector_iset(time_t_vector_type arg0, int arg1, @ByVal @Cast("time_t*") Pointer arg2);
  public static native void time_t_vector_iset_block(time_t_vector_type vector, int index, int block_size, @ByVal @Cast("time_t*") Pointer value);
  public static native void time_t_vector_idel_block( time_t_vector_type vector, int index, int block_size);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_idel( time_t_vector_type vector, int index);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_del_value( time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer del_value);
  public static native void time_t_vector_insert( time_t_vector_type vector, int index, @ByVal @Cast("time_t*") Pointer value);
  public static native void time_t_vector_append(time_t_vector_type arg0, @ByVal @Cast("time_t*") Pointer arg1);
  public static native void time_t_vector_free_container(time_t_vector_type vector);
  public static native void time_t_vector_free(time_t_vector_type arg0);
  public static native void time_t_vector_free__(Pointer arg0);
  public static native void time_t_vector_free_data(time_t_vector_type arg0);
  public static native void time_t_vector_reset(time_t_vector_type arg0);
  public static native void time_t_vector_reset__(Pointer __vector);
  public static native int time_t_vector_size(@Const time_t_vector_type arg0 );
  public static native void time_t_vector_lshift(time_t_vector_type vector, int shift);
  public static native void time_t_vector_rshift(time_t_vector_type vector, int shift);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_pop(time_t_vector_type vector);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_get_first(@Const time_t_vector_type vector);
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_get_last(@Const time_t_vector_type arg0 );
  public static native @Cast("time_t*") Pointer time_t_vector_get_ptr(@Const time_t_vector_type arg0 );
  public static native @Cast("time_t*") Pointer time_t_vector_alloc_data_copy( @Const time_t_vector_type vector );
  public static native @Cast("const time_t*") Pointer time_t_vector_get_const_ptr(@Const time_t_vector_type arg0 );
  public static native @Cast("bool") boolean time_t_vector_init_linear(time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer start_value, @ByVal @Cast("time_t*") Pointer end_value, int num_values);
  public static native void time_t_vector_init_range(time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer value1, @ByVal @Cast("time_t*") Pointer value2, @ByVal @Cast("time_t*") Pointer delta);
  public static native void time_t_vector_set_many(time_t_vector_type arg0, int arg1, @Cast("const time_t*") Pointer arg2, int arg3 );
  public static native void time_t_vector_set_all(time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer value);
  public static native void time_t_vector_append_many(time_t_vector_type vector, @Cast("const time_t*") Pointer data, int length);
  public static native void time_t_vector_append_vector(time_t_vector_type vector, @Const time_t_vector_type other);
  public static native void time_t_vector_shrink(time_t_vector_type arg0 );
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_sum(@Const time_t_vector_type arg0 );
  public static native @ByVal @Cast("time_t*") Pointer time_t_vector_get_default(@Const time_t_vector_type arg0 );
  public static native void time_t_vector_set_default(time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer default_value);
  public static native void time_t_vector_append_default(time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer default_value);
  public static native void time_t_vector_iset_default(time_t_vector_type vector, int index, @ByVal @Cast("time_t*") Pointer default_value);
  public static native @Cast("bool") boolean time_t_vector_is_sorted( @Const time_t_vector_type vector, @Cast("bool") boolean reverse);
  public static native @Cast("bool") boolean time_t_vector_contains(@Const time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer value);
  public static native @Cast("bool") boolean time_t_vector_contains_sorted(@Const time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer value);
  public static native int time_t_vector_index(@Const time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer value);
  public static native int time_t_vector_index_sorted(@Const time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer value);
  public static native void time_t_vector_sort(time_t_vector_type vector);
  public static native void time_t_vector_rsort(time_t_vector_type vector);
  public static native void time_t_vector_permute(time_t_vector_type vector, @Const perm_vector_type perm);
  public static native perm_vector_type time_t_vector_alloc_sort_perm(@Const time_t_vector_type vector);
  public static native perm_vector_type time_t_vector_alloc_rsort_perm(@Const time_t_vector_type vector);
  public static native void time_t_vector_fprintf(@Const time_t_vector_type vector, @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer fmt);
  public static native void time_t_vector_fprintf(@Const time_t_vector_type vector, @Cast("FILE*") Pointer stream, String name, String fmt);
  public static native void time_t_vector_fwrite(@Const time_t_vector_type vector, @Cast("FILE*") Pointer stream);
  public static native time_t_vector_type time_t_vector_fread_alloc( @Cast("FILE*") Pointer stream );
  public static native void time_t_vector_fread( time_t_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void time_t_vector_fwrite_data( @Const time_t_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void time_t_vector_fread_data( time_t_vector_type vector, int size, @Cast("FILE*") Pointer stream);
  public static native @Cast("bool") boolean time_t_vector_equal(@Const time_t_vector_type vector1, @Const time_t_vector_type vector2);
  public static native int time_t_vector_first_equal(@Const time_t_vector_type vector1, @Const time_t_vector_type vector2, int offset);
  public static native int time_t_vector_first_not_equal(@Const time_t_vector_type vector1, @Const time_t_vector_type vector2, int offset);
  public static native void time_t_vector_apply(time_t_vector_type vector, time_t_ftype func);
  public static native int time_t_vector_count_equal( @Const time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer cmp_value);
  public static native int time_t_vector_element_size( @Const time_t_vector_type vector );
  public static native void time_t_vector_range_fill(time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer limit1, @ByVal @Cast("time_t*") Pointer delta, @ByVal @Cast("time_t*") Pointer limit2);
  public static native void time_t_vector_shift(time_t_vector_type vector, @ByVal @Cast("time_t*") Pointer delta);

  public static native time_t_vector_type time_t_vector_safe_cast( Pointer __arg );
  public static native @Cast("bool") boolean time_t_vector_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif
//






// Parsed from ert/util/time_t_vector.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.hpp' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_time_t_VECTOR_CXX
// #define ERT_time_t_VECTOR_CXX

// #include <ert/util/time_t_vector.h>

// #endif


// Parsed from ert/util/time_interval.hpp

/*
   Copyright (C) 2018 Equinor ASA, Norway.

   This is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or1
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef TIME_INTERVAL_CXX
// #define TIME_INTERVAL_CXX

// #include <ert/util/time_interval.hpp>

// #endif


// Parsed from ert/util/thread_pool1.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'thread_pool1.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_THREAD_POOL_H
// #define ERT_THREAD_POOL_H
// #ifdef __cplusplus
// Targeting ../thread_pool_type.java



public static native void thread_pool_join(thread_pool_type arg0 );
public static native thread_pool_type thread_pool_alloc(int arg0 );
// Targeting ../Arg1_Pointer.java


public static native void thread_pool_add_job(thread_pool_type arg0,Arg1_Pointer arg1, Pointer arg2);
public static native void thread_pool_free(thread_pool_type arg0);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/test_work_area.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'test_work_area.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_TEST_WORK_AREA_H
// #define ERT_TEST_WORK_AREA_H

// #include <string>
// Targeting ../TestArea.java







// #ifdef __cplusplus
// #endif

// #include <stdbool.h>

  public static native @Cast("char*") BytePointer test_work_area_alloc_input_path( @Cast("const test_work_area_type*") TestArea work_area, @Cast("const char*") BytePointer input_path );
  public static native @Cast("char*") ByteBuffer test_work_area_alloc_input_path( @Cast("const test_work_area_type*") TestArea work_area, String input_path );
  public static native @Cast("test_work_area_type*") TestArea test_work_area_alloc(@Cast("const char*") BytePointer test_name );
  public static native @Cast("test_work_area_type*") TestArea test_work_area_alloc(String test_name );
  public static native @Cast("test_work_area_type*") TestArea test_work_area_alloc__(@Cast("const char*") BytePointer test_name, @Cast("bool") boolean store_area );
  public static native @Cast("test_work_area_type*") TestArea test_work_area_alloc__(String test_name, @Cast("bool") boolean store_area );
  public static native @Cast("test_work_area_type*") TestArea test_work_area_alloc_relative(@Cast("const char*") BytePointer prefix, @Cast("const char*") BytePointer test_path);
  public static native @Cast("test_work_area_type*") TestArea test_work_area_alloc_relative(String prefix, String test_path);

  public static native void test_work_area_free(@Cast("test_work_area_type*") TestArea work_area);
  public static native @Cast("const char*") BytePointer test_work_area_get_cwd( @Cast("const test_work_area_type*") TestArea work_area );
  public static native @Cast("const char*") BytePointer test_work_area_get_original_cwd( @Cast("const test_work_area_type*") TestArea work_area );
  public static native void test_work_area_install_file( @Cast("const test_work_area_type*") TestArea work_area, @Cast("const char*") BytePointer input_src_file );
  public static native void test_work_area_install_file( @Cast("const test_work_area_type*") TestArea work_area, String input_src_file );
  public static native void test_work_area_copy_directory( @Cast("const test_work_area_type*") TestArea work_area, @Cast("const char*") BytePointer input_directory);
  public static native void test_work_area_copy_directory( @Cast("const test_work_area_type*") TestArea work_area, String input_directory);
  public static native void test_work_area_copy_directory_content( @Cast("const test_work_area_type*") TestArea work_area, @Cast("const char*") BytePointer input_directory);
  public static native void test_work_area_copy_directory_content( @Cast("const test_work_area_type*") TestArea work_area, String input_directory);
  public static native void test_work_area_copy_file( @Cast("const test_work_area_type*") TestArea work_area, @Cast("const char*") BytePointer input_file);
  public static native void test_work_area_copy_file( @Cast("const test_work_area_type*") TestArea work_area, String input_file);
  public static native @Cast("bool") boolean test_work_area_copy_parent_directory( @Cast("const test_work_area_type*") TestArea work_area, @Cast("const char*") BytePointer input_path);
  public static native @Cast("bool") boolean test_work_area_copy_parent_directory( @Cast("const test_work_area_type*") TestArea work_area, String input_path);
  public static native @Cast("bool") boolean test_work_area_copy_parent_content( @Cast("const test_work_area_type*") TestArea work_area, @Cast("const char*") BytePointer input_path);
  public static native @Cast("bool") boolean test_work_area_copy_parent_content( @Cast("const test_work_area_type*") TestArea work_area, String input_path);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/test_work_area.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/test_work_area.hpp>




// Parsed from ert/util/test_util.hpp

/*
   Copyright (C) 2012  Equinor ASA, Norway.

   The file 'test_util.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_TEST_UTIL_H
// #define ERT_TEST_UTIL_H

// #include <stdlib.h>
// #include <stdbool.h>
// #include <setjmp.h>
// #include <ert/util/ert_api_config.hpp>

// #if defined(__APPLE__)
// #include <wchar.h>
// #include <time.h>
// #endif

// #ifdef __cplusplus
// #endif


  public static native void test_error_exit( @Cast("const char*") BytePointer fmt);
  public static native void test_error_exit( String fmt);
  public static native Pointer test_argpack_is_stringlist( Pointer arg );
  public static native Pointer thread_pool_test_func1( Pointer arg );

// #define test_exit( fmt, ...) test_exit__( __FILE__ , __LINE__ , fmt , __VA_ARGS__);
  public static native void test_exit__(@Cast("const char*") BytePointer file, int line, @Cast("const char*") BytePointer fmt);
  public static native void test_exit__(String file, int line, String fmt);

// #define test_assert_string_equal( s1 , s2 ) test_assert_string_equal__(s1 , s2 , __FILE__ , __LINE__)
  public static native void test_assert_string_equal__( @Cast("const char*") BytePointer s1, @Cast("const char*") BytePointer s2, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_string_equal__( String s1, String s2, String file, int line);
// #define test_assert_string_not_equal( s1 , s2 ) test_assert_string_not_equal__(s1 , s2 , __FILE__ , __LINE__)
  public static native void test_assert_string_not_equal__( @Cast("const char*") BytePointer s1, @Cast("const char*") BytePointer s2, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_string_not_equal__( String s1, String s2, String file, int line);

  public static native @Cast("bool") boolean test_check_string_equal( @Cast("const char*") BytePointer s1, @Cast("const char*") BytePointer s2);
  public static native @Cast("bool") boolean test_check_string_equal( String s1, String s2);

// #define test_assert_int_equal( i1 , i2 ) test_assert_int_equal__( (i1) , (i2) , __FILE__ , __LINE__  )
  public static native void test_assert_int_equal__( int i1, int i2, @Cast("const char*") BytePointer file, int line );
  public static native void test_assert_int_equal__( int i1, int i2, String file, int line );

// #define test_assert_int_not_equal( i1 , i2 ) test_assert_int_not_equal__( (i1) , (i2) , __FILE__ , __LINE__  )
  public static native void test_assert_int_not_equal__( int i1, int i2, @Cast("const char*") BytePointer file, int line );
  public static native void test_assert_int_not_equal__( int i1, int i2, String file, int line );

// #define test_assert_long_equal( i1 , i2 ) test_assert_long_equal__( (i1) , (i2) , __FILE__ , __LINE__  )
  public static native void test_assert_long_equal__( long i1, long i2, @Cast("const char*") BytePointer file, long line );
  public static native void test_assert_long_equal__( long i1, long i2, String file, long line );

// #define test_assert_long_not_equal( i1 , i2 ) test_assert_long_not_equal__( (i1) , (i2) , __FILE__ , __LINE__  )
  public static native void test_assert_long_not_equal__( long i1, long i2, @Cast("const char*") BytePointer file, long line );
  public static native void test_assert_long_not_equal__( long i1, long i2, String file, long line );

// #define test_assert_uint_equal( i1 , i2 ) test_assert_uint_equal__( (i1) , (i2) , __FILE__ , __LINE__  )
  public static native void test_assert_uint_equal__( @Cast("unsigned int") int i1, @Cast("unsigned int") int i2, @Cast("const char*") BytePointer file, int line );
  public static native void test_assert_uint_equal__( @Cast("unsigned int") int i1, @Cast("unsigned int") int i2, String file, int line );

// #define test_assert_uint_not_equal( i1 , i2 ) test_assert_uint_not_equal__( (i1) , (i2) , __FILE__ , __LINE__  )
  public static native void test_assert_uint_not_equal__( @Cast("unsigned int") int i1, @Cast("unsigned int") int i2, @Cast("const char*") BytePointer file, int line );
  public static native void test_assert_uint_not_equal__( @Cast("unsigned int") int i1, @Cast("unsigned int") int i2, String file, int line );

// #define test_assert_size_t_equal( s1 , s2 ) test_assert_size_t_equal__( (s1) , (s2) , __FILE__ , __LINE__  )
  public static native void test_assert_size_t_equal__( @Cast("size_t") long s1, @Cast("size_t") long s2, @Cast("const char*") BytePointer file, int line );
  public static native void test_assert_size_t_equal__( @Cast("size_t") long s1, @Cast("size_t") long s2, String file, int line );

// #define test_assert_size_t_not_equal( s1 , s2 ) test_assert_size_t_not_equal__( (s1) , (s2) , __FILE__ , __LINE__  )
  public static native void test_assert_size_t_not_equal__( @Cast("size_t") long s1, @Cast("size_t") long s2, @Cast("const char*") BytePointer file, int line );
  public static native void test_assert_size_t_not_equal__( @Cast("size_t") long s1, @Cast("size_t") long s2, String file, int line );


// #define test_assert_double_equal( d1 , d2 ) test_assert_double_equal__( (d1) , (d2) , __FILE__ , __LINE__  )
  public static native void test_assert_double_equal__( double d1, double d2, @Cast("const char*") BytePointer file, int line );
  public static native void test_assert_double_equal__( double d1, double d2, String file, int line );
  public static native @Cast("bool") boolean test_check_double_equal( double d1, double d2);

// #define test_assert_float_equal( d1 , d2 ) test_assert_float_equal__( (d1) , (d2) , __FILE__ , __LINE__  )
  public static native void test_assert_float_equal__( float d1, float d2, @Cast("const char*") BytePointer file, int line );
  public static native void test_assert_float_equal__( float d1, float d2, String file, int line );
  public static native @Cast("bool") boolean test_check_float_equal( float d1, float d2);

// #define test_assert_double_not_equal( d1 , d2 ) test_assert_double_not_equal__( (d1) , (d2) , __FILE__ , __LINE__  )
  public static native void test_assert_double_not_equal__( double d1, double d2, @Cast("const char*") BytePointer file, int line );
  public static native void test_assert_double_not_equal__( double d1, double d2, String file, int line );

// #define test_assert_bool_equal( b1 , b2 ) test_assert_bool_equal__( (b1) , (b2) , __FILE__ , __LINE__ )
  public static native void test_assert_bool_equal__( @Cast("bool") boolean b1, @Cast("bool") boolean b2, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_bool_equal__( @Cast("bool") boolean b1, @Cast("bool") boolean b2, String file, int line);

// #define test_assert_bool_not_equal( b1 , b2 ) test_assert_bool_not_equal__( (b1) , (b2) , __FILE__ , __LINE__ )
  public static native void test_assert_bool_not_equal__( @Cast("bool") boolean b1, @Cast("bool") boolean b2, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_bool_not_equal__( @Cast("bool") boolean b1, @Cast("bool") boolean b2, String file, int line);

// #define test_assert_true( value ) test_assert_true__( (value) , __FILE__ , __LINE__)
  public static native void test_assert_true__( @Cast("bool") boolean value, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_true__( @Cast("bool") boolean value, String file, int line);

// #define test_assert_false( value ) test_assert_false__( (value) , __FILE__ , __LINE__)
  public static native void test_assert_false__( @Cast("bool") boolean value, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_false__( @Cast("bool") boolean value, String file, int line);

// #define test_assert_time_t_equal( t1 , t2) test_assert_time_t_equal__((t1) , (t2) , __FILE__ , __LINE__)
  public static native void test_assert_time_t_equal__( @ByVal @Cast("time_t*") Pointer t1, @ByVal @Cast("time_t*") Pointer t2, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_time_t_equal__( @ByVal @Cast("time_t*") Pointer t1, @ByVal @Cast("time_t*") Pointer t2, String file, int line);

// #define test_assert_time_t_not_equal( t1 , t2) test_assert_time_t_not_equal__((t1) , (t2) , __FILE__ , __LINE__)
  public static native void test_assert_time_t_not_equal__( @ByVal @Cast("time_t*") Pointer t1, @ByVal @Cast("time_t*") Pointer t2, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_time_t_not_equal__( @ByVal @Cast("time_t*") Pointer t1, @ByVal @Cast("time_t*") Pointer t2, String file, int line);

// #define test_assert_ptr_equal( p1 , p2 ) test_assert_ptr_equal__( (p1) , (p2) , __FILE__ , __LINE__)
  public static native void test_assert_ptr_equal__( @Const Pointer p1, @Const Pointer p2, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_ptr_equal__( @Const Pointer p1, @Const Pointer p2, String file, int line);

// #define test_assert_ptr_not_equal(p1 , p2) test_assert_ptr_not_equal__( (p1) , (p2) , __FILE__ , __LINE__)
  public static native void test_assert_ptr_not_equal__( @Const Pointer p1, @Const Pointer p2, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_ptr_not_equal__( @Const Pointer p1, @Const Pointer p2, String file, int line);

// #define test_assert_NULL( p ) test_assert_NULL__( (p) , __FILE__ , __LINE__)
  public static native void test_assert_NULL__( @Const Pointer p, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_NULL__( @Const Pointer p, String file, int line);

// #define test_assert_not_NULL( p ) test_assert_not_NULL__( (p) , __FILE__ , __LINE__)
  public static native void test_assert_not_NULL__( @Const Pointer p, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_not_NULL__( @Const Pointer p, String file, int line);

// #define test_assert_mem_equal( p1 , p2 , byte_size ) test_assert_mem_equal__( (p1) , (p2) , (byte_size), __FILE__ , __LINE__)
  public static native void test_assert_mem_equal__( @Const Pointer p1, @Const Pointer p2, @Cast("size_t") long byte_size, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_mem_equal__( @Const Pointer p1, @Const Pointer p2, @Cast("size_t") long byte_size, String file, int line);

// #define test_assert_mem_not_equal( p1 , p2 , byte_size ) test_assert_mem_not_equal__( (p1) , (p2) , (byte_size), __FILE__ , __LINE__)
  public static native void test_assert_mem_not_equal__( @Const Pointer p1, @Const Pointer p2, @Cast("size_t") long byte_size, @Cast("const char*") BytePointer file, int line);
  public static native void test_assert_mem_not_equal__( @Const Pointer p1, @Const Pointer p2, @Cast("size_t") long byte_size, String file, int line);

// #define test_assert_file_content( input_file , expected) test_assert_file_content__( input_file , expected , __FILE__ , __LINE__)
  public static native void test_assert_file_content__( @Cast("const char*") BytePointer input_file, @Cast("const char*") BytePointer expected, @Cast("const char*") BytePointer src_file, int line);
  public static native void test_assert_file_content__( String input_file, String expected, String src_file, int line);

  public static native void test_install_SIGNALS();

  public static native @Cast("jmp_buf*") Pointer util_abort_test_jump_buffer();
  public static native void test_util_addr2line();
  public static native void test_assert_util_abort(@Cast("const char*") BytePointer function_name, Pointer arg);
  public static native void test_assert_util_abort(String function_name, Pointer arg);


// #ifdef __cplusplus
// #endif

// #ifdef __cplusplus

// #define test_assert_throw(expr , exception_type )
//   {
//     bool throw_ok = false;
//     try {
//       expr;
//     }
//     catch (std::exception &e) {
//       if (dynamic_cast<exception_type *>(&e))
//         throw_ok = true;
//     }
//     if (!throw_ok)
//       test_error_exit("Correct exception not thrown at %s:%d\n",__FILE__ , __LINE__);
//   }

// #define test_assert_std_string_equal(s0, s1)
//   {
//     if (s0.compare(s1) != 0)
//       test_error_exit("Strings not equal at%s:%d (%s != %s)\n",
//                       __FILE__ , __LINE__, s0.c_str(), s1.c_str());
//   }


// #endif


// #endif


// Parsed from ert/util/test_util.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/test_util.hpp>




// Parsed from ert/util/stringlist.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'stringlist.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_STRINGLIST_H
// #define ERT_STRINGLIST_H

// #include <stdbool.h>
// #include <stdio.h>

// #include <ert/util/ert_api_config.hpp>
// #include <ert/util/type_macros.hpp>
// #include <ert/util/int_vector.hpp>

// #ifdef __cplusplus
// Targeting ../stringlist_type.java


// Targeting ../string_cmp_ftype.java


// Targeting ../file_pred_ftype.java



  public static native int stringlist_select_files(stringlist_type names, @Cast("const char*") BytePointer path, file_pred_ftype predicate, @Const Pointer pred_arg);
  public static native int stringlist_select_files(stringlist_type names, String path, file_pred_ftype predicate, @Const Pointer pred_arg);

  public static native @Cast("const char*") BytePointer stringlist_get_last( @Const stringlist_type stringlist );
  public static native @Cast("char*") BytePointer stringlist_pop( stringlist_type stringlist);
  public static native void stringlist_deep_copy( stringlist_type target, @Const stringlist_type src);
  public static native stringlist_type stringlist_alloc_deep_copy_with_limits(@Const stringlist_type src, int offset, int num_strings);
  public static native stringlist_type stringlist_alloc_deep_copy_with_offset(@Const stringlist_type src, int offset);
  public static native stringlist_type stringlist_alloc_deep_copy( @Const stringlist_type src );

  public static native stringlist_type stringlist_alloc_new();
  public static native void stringlist_free__(Pointer arg0 );
  public static native void stringlist_free(stringlist_type arg0);
  public static native void stringlist_clear(stringlist_type arg0 );

  public static native void stringlist_append_copy(stringlist_type arg0, @Cast("const char*") BytePointer arg1);
  public static native void stringlist_append_copy(stringlist_type arg0, String arg1);

  public static native @Cast("const char*") BytePointer stringlist_safe_iget( @Const stringlist_type stringlist, int index);
  public static native @Cast("bool") boolean stringlist_unique(@Const stringlist_type stringlist );
  public static native @Cast("bool") boolean stringlist_iequal( @Const stringlist_type stringlist, int index, @Cast("const char*") BytePointer s );
  public static native @Cast("bool") boolean stringlist_iequal( @Const stringlist_type stringlist, int index, String s );
  public static native @Cast("const char*") BytePointer stringlist_iget(@Const stringlist_type arg0, int arg1);
  public static native int stringlist_iget_as_int( @Const stringlist_type stringlist, int index, @Cast("bool*") BoolPointer valid);
  public static native int stringlist_iget_as_int( @Const stringlist_type stringlist, int index, @Cast("bool*") boolean[] valid);
  public static native double stringlist_iget_as_double( @Const stringlist_type stringlist, int index, @Cast("bool*") BoolPointer valid);
  public static native double stringlist_iget_as_double( @Const stringlist_type stringlist, int index, @Cast("bool*") boolean[] valid);
  public static native @Cast("bool") boolean stringlist_iget_as_bool( @Const stringlist_type stringlist, int index, @Cast("bool*") BoolPointer valid);
  public static native @Cast("bool") boolean stringlist_iget_as_bool( @Const stringlist_type stringlist, int index, @Cast("bool*") boolean[] valid);
  public static native @Cast("char*") BytePointer stringlist_iget_copy(@Const stringlist_type stringlist, int arg1 );
  public static native @Cast("char*") BytePointer stringlist_alloc_joined_string(@Const stringlist_type arg0, @Cast("const char*") BytePointer arg1 );
  public static native @Cast("char*") ByteBuffer stringlist_alloc_joined_string(@Const stringlist_type arg0, String arg1 );
  public static native @Cast("char*") BytePointer stringlist_alloc_joined_substring( @Const stringlist_type s, int start_index, int end_index, @Cast("const char*") BytePointer sep );
  public static native @Cast("char*") ByteBuffer stringlist_alloc_joined_substring( @Const stringlist_type s, int start_index, int end_index, String sep );
  public static native @Cast("const char*") BytePointer stringlist_front(@Const stringlist_type stringlist);
  public static native @Cast("const char*") BytePointer stringlist_back(@Const stringlist_type stringlist);



  public static native void stringlist_iset_copy(stringlist_type arg0, int index, @Cast("const char*") BytePointer arg2);
  public static native void stringlist_iset_copy(stringlist_type arg0, int index, String arg2);
  public static native void stringlist_iset_ref(stringlist_type arg0, int index, @Cast("const char*") BytePointer arg2);
  public static native void stringlist_iset_ref(stringlist_type arg0, int index, String arg2);
  public static native void stringlist_iset_owned_ref(stringlist_type arg0, int index, @Cast("const char*") BytePointer arg2);
  public static native void stringlist_iset_owned_ref(stringlist_type arg0, int index, String arg2);

  public static native void stringlist_insert_copy(stringlist_type arg0, int index, @Cast("const char*") BytePointer arg2);
  public static native void stringlist_insert_copy(stringlist_type arg0, int index, String arg2);
  public static native void stringlist_insert_ref(stringlist_type arg0, int index, @Cast("const char*") BytePointer arg2);
  public static native void stringlist_insert_ref(stringlist_type arg0, int index, String arg2);
  public static native void stringlist_insert_owned_ref(stringlist_type arg0, int index, @Cast("const char*") BytePointer arg2);
  public static native void stringlist_insert_owned_ref(stringlist_type arg0, int index, String arg2);

  public static native void stringlist_idel(stringlist_type stringlist, int index);

  public static native int stringlist_get_size(@Const stringlist_type arg0 );
  public static native void stringlist_fprintf(@Const stringlist_type arg0, @Cast("const char*") BytePointer arg1, @Cast("FILE*") Pointer arg2);
  public static native void stringlist_fprintf(@Const stringlist_type arg0, String arg1, @Cast("FILE*") Pointer arg2);
  public static native void stringlist_fprintf_fmt(@Const stringlist_type stringlist, @Const stringlist_type fmt_list, @Cast("FILE*") Pointer stream);


  public static native stringlist_type stringlist_alloc_argv_copy(@Cast("const char**") PointerPointer arg0, int arg1 );
  public static native stringlist_type stringlist_alloc_argv_copy(@Cast("const char**") @ByPtrPtr BytePointer arg0, int arg1 );
  public static native stringlist_type stringlist_alloc_argv_copy(@Cast("const char**") @ByPtrPtr ByteBuffer arg0, int arg1 );
  public static native stringlist_type stringlist_alloc_argv_copy(@Cast("const char**") @ByPtrPtr byte[] arg0, int arg1 );
  public static native stringlist_type stringlist_alloc_argv_ref(@Cast("const char**") PointerPointer arg0, int arg1 );
  public static native stringlist_type stringlist_alloc_argv_ref(@Cast("const char**") @ByPtrPtr BytePointer arg0, int arg1 );
  public static native stringlist_type stringlist_alloc_argv_ref(@Cast("const char**") @ByPtrPtr ByteBuffer arg0, int arg1 );
  public static native stringlist_type stringlist_alloc_argv_ref(@Cast("const char**") @ByPtrPtr byte[] arg0, int arg1 );
  public static native stringlist_type stringlist_alloc_argv_owned_ref(@Cast("const char**") PointerPointer argv, int argc);
  public static native stringlist_type stringlist_alloc_argv_owned_ref(@Cast("const char**") @ByPtrPtr BytePointer argv, int argc);
  public static native stringlist_type stringlist_alloc_argv_owned_ref(@Cast("const char**") @ByPtrPtr ByteBuffer argv, int argc);
  public static native stringlist_type stringlist_alloc_argv_owned_ref(@Cast("const char**") @ByPtrPtr byte[] argv, int argc);
  public static native stringlist_type stringlist_alloc_from_split( @Cast("const char*") BytePointer input_string, @Cast("const char*") BytePointer sep );
  public static native stringlist_type stringlist_alloc_from_split( String input_string, String sep );
  public static native stringlist_type stringlist_fread_alloc(@Cast("FILE*") Pointer arg0 );

  public static native void stringlist_append_stringlist_copy(stringlist_type arg0, @Const stringlist_type arg1 );
  public static native void stringlist_insert_stringlist_copy(stringlist_type arg0, @Const stringlist_type arg1, int arg2);

  public static native @Cast("bool") boolean stringlist_equal(@Const stringlist_type arg0, @Const stringlist_type arg1);
  public static native @Cast("bool") boolean stringlist_contains(@Const stringlist_type arg0, @Cast("const char*") BytePointer arg1 );
  public static native @Cast("bool") boolean stringlist_contains(@Const stringlist_type arg0, String arg1 );
  public static native int_vector_type stringlist_find(@Const stringlist_type arg0, @Cast("const char*") BytePointer arg1);
  public static native int_vector_type stringlist_find(@Const stringlist_type arg0, String arg1);
  public static native int stringlist_find_first(@Const stringlist_type arg0, @Cast("const char*") BytePointer arg1 );
  public static native int stringlist_find_first(@Const stringlist_type arg0, String arg1 );
  public static native int stringlist_get_argc(@Const stringlist_type arg0 );
  public static native @Cast("char**") PointerPointer stringlist_alloc_char_copy(@Const stringlist_type arg0 );
  public static native @Cast("char**") PointerPointer stringlist_alloc_char_ref(@Const stringlist_type stringlist);
  public static native void stringlist_fread(stringlist_type arg0, @Cast("FILE*") Pointer arg1 );
  public static native void stringlist_fwrite(@Const stringlist_type arg0, @Cast("FILE*") Pointer arg1 );
  public static native void stringlist_sort(stringlist_type arg0, string_cmp_ftype string_cmp);
  public static native void stringlist_reverse( stringlist_type s );
  public static native void stringlist_python_sort( stringlist_type s, int cmp_flag);

// #ifdef ERT_HAVE_GLOB
// #endif
  public static native int stringlist_select_matching_files(stringlist_type names, @Cast("const char*") BytePointer path, @Cast("const char*") BytePointer file_pattern);
  public static native int stringlist_select_matching_files(stringlist_type names, String path, String file_pattern);
  public static native int stringlist_select_matching_elements(stringlist_type target, @Const stringlist_type src, @Cast("const char*") BytePointer pattern);
  public static native int stringlist_select_matching_elements(stringlist_type target, @Const stringlist_type src, String pattern);
  public static native int stringlist_append_matching_elements(stringlist_type target, @Const stringlist_type src, @Cast("const char*") BytePointer pattern);
  public static native int stringlist_append_matching_elements(stringlist_type target, @Const stringlist_type src, String pattern);
  public static native @Cast("bool") boolean stringlist_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/stringlist.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/stringlist.hpp>




// Parsed from ert/util/string_util.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'string_util.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/
// #ifndef ERT_STRING_UTIL_H
// #define ERT_STRING_UTIL_H

// #include <ert/util/int_vector.hpp>
// #include <ert/util/bool_vector.hpp>

// #ifdef __cplusplus
// #endif

  public static native @Cast("bool") boolean string_util_init_active_list( @Cast("const char*") BytePointer range_string, int_vector_type active_list );
  public static native @Cast("bool") boolean string_util_init_active_list( String range_string, int_vector_type active_list );
  public static native @Cast("bool") boolean string_util_update_active_list( @Cast("const char*") BytePointer range_string, int_vector_type active_list );
  public static native @Cast("bool") boolean string_util_update_active_list( String range_string, int_vector_type active_list );
  public static native int_vector_type string_util_alloc_active_list( @Cast("const char*") BytePointer range_string );
  public static native int_vector_type string_util_alloc_active_list( String range_string );

  public static native @Cast("bool") boolean string_util_init_active_mask( @Cast("const char*") BytePointer range_string, bool_vector_type active_mask);
  public static native @Cast("bool") boolean string_util_init_active_mask( String range_string, bool_vector_type active_mask);
  public static native @Cast("bool") boolean string_util_update_active_mask( @Cast("const char*") BytePointer range_string, bool_vector_type active_mask);
  public static native @Cast("bool") boolean string_util_update_active_mask( String range_string, bool_vector_type active_mask);
  public static native bool_vector_type string_util_alloc_active_mask( @Cast("const char*") BytePointer range_string );
  public static native bool_vector_type string_util_alloc_active_mask( String range_string );

  public static native @Cast("bool") boolean string_util_update_value_list( @Cast("const char*") BytePointer range_string, int_vector_type value_list);
  public static native @Cast("bool") boolean string_util_update_value_list( String range_string, int_vector_type value_list);
  public static native @Cast("bool") boolean string_util_init_value_list( @Cast("const char*") BytePointer range_string, int_vector_type value_list );
  public static native @Cast("bool") boolean string_util_init_value_list( String range_string, int_vector_type value_list );
  public static native int_vector_type string_util_alloc_value_list(@Cast("const char*") BytePointer range_string);
  public static native int_vector_type string_util_alloc_value_list(String range_string);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/string_util.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/string_util.hpp>




// Parsed from ert/util/statistics.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'statistics.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_STATISTICS_H
// #define ERT_STATISTICS_H

// #ifdef __cplusplus
// #endif
// #include <ert/util/double_vector.hpp>

public static native double statistics_std( @Const double_vector_type data_vector );
public static native double statistics_mean( @Const double_vector_type data_vector );
public static native double statistics_empirical_quantile( double_vector_type data, double quantile );
public static native double statistics_empirical_quantile__( @Const double_vector_type data, double quantile );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/statistics.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/statistics.hpp>




// Parsed from ert/util/ssize_t.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ssize_t.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_SSIZE_T_H
// #define ERT_SSIZE_T_H

// #ifdef _MSC_VER
/* maximum number of bytes addressable */
// #ifdef _WIN64
// #else
// #endif
// #else
/* POSIX 2008 states that it should be defined here */
// #include <sys/types.h>
// #endif

// #endif


// Parsed from ert/util/ssize_t.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/ssize_t.hpp>




// Parsed from ert/util/size_t_vector.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_size_t_VECTOR_H
// #define ERT_size_t_VECTOR_H
// #ifdef __cplusplus
// #endif
// #include <stdio.h>
// #include <stdbool.h>

// #include <ert/util/type_macros.h>
// #include <ert/util/perm_vector.h>
// Targeting ../size_t_vector_type.java


// Targeting ../size_t_ftype.java




  public static native int size_t_vector_lookup_bin( @Const size_t_vector_type limits, @Cast("size_t") long value, int guess);
  public static native int size_t_vector_lookup_bin__( @Const size_t_vector_type limits, @Cast("size_t") long value, int guess);
  public static native void size_t_vector_inplace_div( size_t_vector_type vector, @Const size_t_vector_type inv_factor);
  public static native void size_t_vector_inplace_mul( size_t_vector_type vector, @Const size_t_vector_type factor);
  public static native void size_t_vector_inplace_add( size_t_vector_type vector, @Const size_t_vector_type delta);
  public static native void size_t_vector_inplace_sub( size_t_vector_type vector, @Const size_t_vector_type delta);
  public static native void size_t_vector_set_read_only( size_t_vector_type vector, @Cast("bool") boolean read_only);
  public static native @Cast("bool") boolean size_t_vector_get_read_only( @Const size_t_vector_type vector );
  public static native void size_t_vector_memcpy_data( @Cast("size_t*") SizeTPointer target, @Const size_t_vector_type src );
  public static native void size_t_vector_memcpy_from_data( size_t_vector_type target, @Cast("const size_t*") SizeTPointer src, int src_size );
  public static native void size_t_vector_memcpy(  size_t_vector_type target, @Const size_t_vector_type src);
  public static native void size_t_vector_memcpy_data_block( size_t_vector_type target, @Const size_t_vector_type src, int target_offset, int src_offset, int len);
  public static native @Cast("bool") boolean size_t_vector_growable( @Const size_t_vector_type vector);
  public static native void size_t_vector_select_unique(size_t_vector_type vector);
  public static native size_t_vector_type size_t_vector_alloc( int init_size, @Cast("size_t") long arg1 );
  public static native size_t_vector_type size_t_vector_alloc_private_wrapper(int init_size, @Cast("size_t") long default_value, @Cast("size_t*") SizeTPointer data, int alloc_size);
  public static native size_t_vector_type size_t_vector_alloc_shared_wrapper(int init_size, @Cast("size_t") long default_value, @Cast("size_t*") SizeTPointer data, int alloc_size);
  public static native size_t_vector_type size_t_vector_alloc_strided_copy( @Const size_t_vector_type src, int start, int stop, int stride );
  public static native size_t_vector_type size_t_vector_alloc_copy( @Const size_t_vector_type src);
  public static native void size_t_vector_imul(size_t_vector_type vector, int index, @Cast("size_t") long factor);
  public static native void size_t_vector_scale(size_t_vector_type vector, @Cast("size_t") long factor);
  public static native void size_t_vector_div(size_t_vector_type vector, @Cast("size_t") long divisor);
  public static native @Cast("size_t") long size_t_vector_reverse_iget(@Const size_t_vector_type vector, int index);
  public static native @Cast("size_t") long size_t_vector_iget(@Const size_t_vector_type arg0, int arg1);
  public static native @Cast("size_t") long size_t_vector_safe_iget(@Const size_t_vector_type arg0, int arg1);
  public static native @Cast("size_t") long size_t_vector_get_min(@Const size_t_vector_type vector);
  public static native @Cast("size_t") long size_t_vector_get_max(@Const size_t_vector_type vector);
  public static native int size_t_vector_get_min_index(@Const size_t_vector_type vector, @Cast("bool") boolean reverse);
  public static native int size_t_vector_get_max_index(@Const size_t_vector_type vector, @Cast("bool") boolean reverse);
  public static native @Cast("size_t") long size_t_vector_iadd( size_t_vector_type vector, int index, @Cast("size_t") long delta);
  public static native void size_t_vector_resize( size_t_vector_type vector, int new_size, @Cast("size_t") long default_value );
  public static native void size_t_vector_iset(size_t_vector_type arg0, int arg1, @Cast("size_t") long arg2);
  public static native void size_t_vector_iset_block(size_t_vector_type vector, int index, int block_size, @Cast("size_t") long value);
  public static native void size_t_vector_idel_block( size_t_vector_type vector, int index, int block_size);
  public static native @Cast("size_t") long size_t_vector_idel( size_t_vector_type vector, int index);
  public static native @Cast("size_t") long size_t_vector_del_value( size_t_vector_type vector, @Cast("size_t") long del_value);
  public static native void size_t_vector_insert( size_t_vector_type vector, int index, @Cast("size_t") long value);
  public static native void size_t_vector_append(size_t_vector_type arg0, @Cast("size_t") long arg1);
  public static native void size_t_vector_free_container(size_t_vector_type vector);
  public static native void size_t_vector_free(size_t_vector_type arg0);
  public static native void size_t_vector_free__(Pointer arg0);
  public static native void size_t_vector_free_data(size_t_vector_type arg0);
  public static native void size_t_vector_reset(size_t_vector_type arg0);
  public static native void size_t_vector_reset__(Pointer __vector);
  public static native int size_t_vector_size(@Const size_t_vector_type arg0 );
  public static native void size_t_vector_lshift(size_t_vector_type vector, int shift);
  public static native void size_t_vector_rshift(size_t_vector_type vector, int shift);
  public static native @Cast("size_t") long size_t_vector_pop(size_t_vector_type vector);
  public static native @Cast("size_t") long size_t_vector_get_first(@Const size_t_vector_type vector);
  public static native @Cast("size_t") long size_t_vector_get_last(@Const size_t_vector_type arg0 );
  public static native @Cast("size_t*") SizeTPointer size_t_vector_get_ptr(@Const size_t_vector_type arg0 );
  public static native @Cast("size_t*") SizeTPointer size_t_vector_alloc_data_copy( @Const size_t_vector_type vector );
  public static native @Cast("const size_t*") SizeTPointer size_t_vector_get_const_ptr(@Const size_t_vector_type arg0 );
  public static native @Cast("bool") boolean size_t_vector_init_linear(size_t_vector_type vector, @Cast("size_t") long start_value, @Cast("size_t") long end_value, int num_values);
  public static native void size_t_vector_init_range(size_t_vector_type vector, @Cast("size_t") long value1, @Cast("size_t") long value2, @Cast("size_t") long delta);
  public static native void size_t_vector_set_many(size_t_vector_type arg0, int arg1, @Cast("const size_t*") SizeTPointer arg2, int arg3 );
  public static native void size_t_vector_set_all(size_t_vector_type vector, @Cast("size_t") long value);
  public static native void size_t_vector_append_many(size_t_vector_type vector, @Cast("const size_t*") SizeTPointer data, int length);
  public static native void size_t_vector_append_vector(size_t_vector_type vector, @Const size_t_vector_type other);
  public static native void size_t_vector_shrink(size_t_vector_type arg0 );
  public static native @Cast("size_t") long size_t_vector_sum(@Const size_t_vector_type arg0 );
  public static native @Cast("size_t") long size_t_vector_get_default(@Const size_t_vector_type arg0 );
  public static native void size_t_vector_set_default(size_t_vector_type vector, @Cast("size_t") long default_value);
  public static native void size_t_vector_append_default(size_t_vector_type vector, @Cast("size_t") long default_value);
  public static native void size_t_vector_iset_default(size_t_vector_type vector, int index, @Cast("size_t") long default_value);
  public static native @Cast("bool") boolean size_t_vector_is_sorted( @Const size_t_vector_type vector, @Cast("bool") boolean reverse);
  public static native @Cast("bool") boolean size_t_vector_contains(@Const size_t_vector_type vector, @Cast("size_t") long value);
  public static native @Cast("bool") boolean size_t_vector_contains_sorted(@Const size_t_vector_type vector, @Cast("size_t") long value);
  public static native int size_t_vector_index(@Const size_t_vector_type vector, @Cast("size_t") long value);
  public static native int size_t_vector_index_sorted(@Const size_t_vector_type vector, @Cast("size_t") long value);
  public static native void size_t_vector_sort(size_t_vector_type vector);
  public static native void size_t_vector_rsort(size_t_vector_type vector);
  public static native void size_t_vector_permute(size_t_vector_type vector, @Const perm_vector_type perm);
  public static native perm_vector_type size_t_vector_alloc_sort_perm(@Const size_t_vector_type vector);
  public static native perm_vector_type size_t_vector_alloc_rsort_perm(@Const size_t_vector_type vector);
  public static native void size_t_vector_fprintf(@Const size_t_vector_type vector, @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer fmt);
  public static native void size_t_vector_fprintf(@Const size_t_vector_type vector, @Cast("FILE*") Pointer stream, String name, String fmt);
  public static native void size_t_vector_fwrite(@Const size_t_vector_type vector, @Cast("FILE*") Pointer stream);
  public static native size_t_vector_type size_t_vector_fread_alloc( @Cast("FILE*") Pointer stream );
  public static native void size_t_vector_fread( size_t_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void size_t_vector_fwrite_data( @Const size_t_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void size_t_vector_fread_data( size_t_vector_type vector, int size, @Cast("FILE*") Pointer stream);
  public static native @Cast("bool") boolean size_t_vector_equal(@Const size_t_vector_type vector1, @Const size_t_vector_type vector2);
  public static native int size_t_vector_first_equal(@Const size_t_vector_type vector1, @Const size_t_vector_type vector2, int offset);
  public static native int size_t_vector_first_not_equal(@Const size_t_vector_type vector1, @Const size_t_vector_type vector2, int offset);
  public static native void size_t_vector_apply(size_t_vector_type vector, size_t_ftype func);
  public static native int size_t_vector_count_equal( @Const size_t_vector_type vector, @Cast("size_t") long cmp_value);
  public static native int size_t_vector_element_size( @Const size_t_vector_type vector );
  public static native void size_t_vector_range_fill(size_t_vector_type vector, @Cast("size_t") long limit1, @Cast("size_t") long delta, @Cast("size_t") long limit2);
  public static native void size_t_vector_shift(size_t_vector_type vector, @Cast("size_t") long delta);

  public static native size_t_vector_type size_t_vector_safe_cast( Pointer __arg );
  public static native @Cast("bool") boolean size_t_vector_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif
//






// Parsed from ert/util/size_t_vector.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.hpp' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_size_t_VECTOR_CXX
// #define ERT_size_t_VECTOR_CXX

// #include <ert/util/size_t_vector.h>

// #endif


// Parsed from ert/util/rng.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'rng.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_RNG_H
// #define ERT_RNG_H

// #ifdef __cplusplus
// #endif
// #include <stdio.h>

// #include <ert/util/type_macros.hpp>


/** enum rng_init_mode */
public static final int
  INIT_DEFAULT      = 0,   /* The rng is initialized with the default seed values. */
  INIT_CLOCK        = 1,   /* Four random seeds are calculated with the util_clock_seed() function. */
  INIT_DEV_RANDOM   = 2,   /* Random content is read with the function util_fread_dev_random(). */
  INIT_DEV_URANDOM  = 3;    /* Random content is read with the function util_fread_dev_urandom(). */


/** enum rng_alg_type */
public static final int
  MZRAN = 1;
// Targeting ../rng_forward_ftype.java


// Targeting ../rng_set_state_ftype.java


// Targeting ../rng_get_state_ftype.java


// Targeting ../rng_alloc_ftype.java


// Targeting ../rng_free_ftype.java


// Targeting ../rng_fscanf_ftype.java


// Targeting ../rng_fprintf_ftype.java


// Targeting ../rng_type.java



  public static native rng_type rng_alloc( @Cast("rng_alg_type") int type, @Cast("rng_init_mode") int init_mode );
  public static native void rng_free( rng_type rng);
  public static native @Cast("unsigned int") int rng_forward( rng_type rng );
  public static native double rng_get_double( rng_type rng);
  public static native void rng_rng_init( rng_type rng, rng_type seed_src);
  public static native void rng_init( rng_type rng, @Cast("rng_init_mode") int init_mode );
  public static native @Cast("rng_alg_type") int rng_get_type( @Const rng_type rng );
  public static native void rng_fprintf_state( rng_type rng, @Cast("FILE*") Pointer stream );
  public static native void rng_fscanf_state( rng_type rng, @Cast("FILE*") Pointer stream );
  public static native int rng_state_size( @Const rng_type rng );
  public static native void rng_save_state( rng_type rng, @Cast("const char*") BytePointer filename);
  public static native void rng_save_state( rng_type rng, String filename);
  public static native void rng_load_state( rng_type rng, @Cast("const char*") BytePointer filename);
  public static native void rng_load_state( rng_type rng, String filename);

  public static native void rng_set_state( rng_type rng, @Cast("const char*") BytePointer state);
  public static native void rng_set_state( rng_type rng, String state);
  public static native void rng_get_state( @Const rng_type rng, @Cast("char*") BytePointer state);
  public static native void rng_get_state( @Const rng_type rng, @Cast("char*") ByteBuffer state);
  public static native void rng_get_state( @Const rng_type rng, @Cast("char*") byte[] state);
  public static native int rng_get_int( rng_type rng, int max_value );
  public static native @Cast("unsigned int") int rng_get_max_int(@Const rng_type rng);

  public static native double rng_std_normal( rng_type rng );
  public static native void rng_shuffle_int( rng_type rng, IntPointer data, @Cast("size_t") long num_elements);
  public static native void rng_shuffle_int( rng_type rng, IntBuffer data, @Cast("size_t") long num_elements);
  public static native void rng_shuffle_int( rng_type rng, int[] data, @Cast("size_t") long num_elements);
  public static native void rng_shuffle( rng_type rng, @Cast("char*") BytePointer data, @Cast("size_t") long element_size, @Cast("size_t") long num_elements);
  public static native void rng_shuffle( rng_type rng, @Cast("char*") ByteBuffer data, @Cast("size_t") long element_size, @Cast("size_t") long num_elements);
  public static native void rng_shuffle( rng_type rng, @Cast("char*") byte[] data, @Cast("size_t") long element_size, @Cast("size_t") long num_elements);
  public static native void rng_free__( Pointer arg);

  public static native rng_type rng_safe_cast( Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/rng.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/rng.hpp>




// Parsed from ert/util/path_stack.hpp

/*
   Copyright (C) 2012  Equinor ASA, Norway.

   The file 'path_stack.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_PATH_STACK_H
// #define ERT_PATH_STACK_H

// #ifdef __cplusplus
// Targeting ../path_stack_type.java



  public static native path_stack_type path_stack_alloc();
  public static native void path_stack_pop( path_stack_type path_stack );
  public static native void path_stack_push_cwd( path_stack_type path_stack );
  public static native @Cast("bool") boolean path_stack_push( path_stack_type path_stack, @Cast("const char*") BytePointer path );
  public static native @Cast("bool") boolean path_stack_push( path_stack_type path_stack, String path );
  public static native void path_stack_free( path_stack_type path_stack );
  public static native int path_stack_size( @Const path_stack_type path_stack );

// #ifdef __cplusplus
// #endif


// #endif


// Parsed from ert/util/path_stack.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/path_stack.hpp>




// Parsed from ert/util/parser.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'parser.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_PARSER_H
// #define ERT_PARSER_H
// #include <ert/util/stringlist.hpp>

// #ifdef __cplusplus
// Targeting ../basic_parser_type.java




/**
  GENERAL OVERVIEW
  <p>
  The parser_type is used to create a series of "tokens"
  from a file or string buffer. In it's simplest form,
  we define a token as a subset of a string separated by
  by some split characters.
  <p>
  For example, if we define the normal space (i.e. " ") as
  the only split character, "tokenizing" the string
  "I like     beer  " would give the following result:
  <p>
  Token number 0 is "I"
  Token number 1 is "like"
  Token number 2 is "beer"
  <p>
  Note that all the white space (i.e. split characters) have been
  removed.
  <p>
  <p>
  <p>
  COMMENTS
  <p>
  The parser can ignore comments when tokenzing
  a file or buffer. To enable this feature, allocate
  the parser_type with comment_start and comment_end
  different from NULL. For example if we set both
  comment_start and comment_end to "##", tokenizing
  "I ## really  ## like beer" would give:
  <p>
  Token number 0 is "I"
  Token number 1 is "like"
  Token number 2 is "beer"
  <p>
  <p>
  <p>
  SPECIAL CHARACTERS
  <p>
  Some times it can be useful to define a set of characters which
  behave like white space in the sense that they separate tokens in
  the source, but they do not get dropped. For example, letting "=" be
  a special character, tokenzing "key=value" would give:
  <p>
  Token number 0 is "key"
  Token number 1 is "="
  Token number 2 is "value"
  <p>
  The special characters are given in the "specials" string when
  allocating the parser.
  <p>
  <p>
  <p>
  QUOTERS
  <p>
  When parsing user input, the user often wants to provide e.g. a
  filename with a white-space character in it. To support this, the
  parser can be given a set of quoters. For example, letting " " be
  white space and adding "'" to the quoters, tokenizing
   <p>
   "my_file = 'my documents with space in.txt'"
  <p>
  would give:
  <p>
  Token number 0 is "my_file"
  Token number 1 is "="
  Token number 2 is "'my documents with space in.txt'"
  <p>
  If wanted, the quoting characters can be removed
  using the strip_quote_marks options when running
  the parser on the buffer. The last token
  in the example above would then be:
  <p>
  Token number 2 is "my documents with space in.txt"
  <p>
  To use one of the quoter characters in a string,
  place a "\" in front of it. Building on our previous
  example, let the string be "my_file = 'my \'doc.txt'"
  Tokenzing this with strip_quote_marks set to true
  would give:
  <p>
  Token number 0 is "my_file"
  Token number 1 is "="
  Token number 2 is "my 'doc.txt"
  <p>
  Note that the "\" in front of"'" has been removed.
  If strip_quote_marks is set to false, the result is:
  <p>
  <p>
  Token number 0 is "my_file"
  Token number 1 is "="
  Token number 2 is "'my \'doc.txt'"
<p>
*/


public static native basic_parser_type basic_parser_alloc(
  @Cast("const char*") BytePointer whitespace,
  @Cast("const char*") BytePointer quoters,
  @Cast("const char*") BytePointer specials,
  @Cast("const char*") BytePointer delete_set,
  @Cast("const char*") BytePointer comment_start,
  @Cast("const char*") BytePointer comment_end);
public static native basic_parser_type basic_parser_alloc(
  String whitespace,
  String quoters,
  String specials,
  String delete_set,
  String comment_start,
  String comment_end);     /** Set to NULL if not interessting.         */


public static native void basic_parser_set_splitters( basic_parser_type parser, @Cast("const char*") BytePointer splitters );
public static native void basic_parser_set_splitters( basic_parser_type parser, String splitters );
public static native void basic_parser_set_quoters( basic_parser_type parser, @Cast("const char*") BytePointer quoters );
public static native void basic_parser_set_quoters( basic_parser_type parser, String quoters );
public static native void basic_parser_set_specials( basic_parser_type parser, @Cast("const char*") BytePointer specials );
public static native void basic_parser_set_specials( basic_parser_type parser, String specials );
public static native void basic_parser_set_delete_set( basic_parser_type parser, @Cast("const char*") BytePointer delete_set );
public static native void basic_parser_set_delete_set( basic_parser_type parser, String delete_set );
public static native void basic_parser_set_comment_start( basic_parser_type parser, @Cast("const char*") BytePointer comment_start );
public static native void basic_parser_set_comment_start( basic_parser_type parser, String comment_start );
public static native void basic_parser_set_comment_end( basic_parser_type parser, @Cast("const char*") BytePointer comment_end );
public static native void basic_parser_set_comment_end( basic_parser_type parser, String comment_end );


public static native void basic_parser_free(
  basic_parser_type parser);


public static native stringlist_type basic_parser_tokenize_buffer(
  @Const basic_parser_type parser,
  @Cast("const char*") BytePointer buffer,
  @Cast("bool") boolean strip_quote_marks);
public static native stringlist_type basic_parser_tokenize_buffer(
  @Const basic_parser_type parser,
  String buffer,
  @Cast("bool") boolean strip_quote_marks);


public static native stringlist_type basic_parser_tokenize_file(
  @Const basic_parser_type parser,
  @Cast("const char*") BytePointer filename,
  @Cast("bool") boolean strip_quote_marks);
public static native stringlist_type basic_parser_tokenize_file(
  @Const basic_parser_type parser,
  String filename,
  @Cast("bool") boolean strip_quote_marks);


/* Pollution by Joakim: */

public static native void basic_parser_strip_buffer(@Const basic_parser_type parser, @Cast("char**") PointerPointer __buffer);
public static native void basic_parser_strip_buffer(@Const basic_parser_type parser, @Cast("char**") @ByPtrPtr BytePointer __buffer);
public static native void basic_parser_strip_buffer(@Const basic_parser_type parser, @Cast("char**") @ByPtrPtr ByteBuffer __buffer);
public static native void basic_parser_strip_buffer(@Const basic_parser_type parser, @Cast("char**") @ByPtrPtr byte[] __buffer);
public static native @Cast("bool") boolean basic_parser_fseek_string(@Const basic_parser_type parser, @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer string, @Cast("bool") boolean skip_string, @Cast("bool") boolean case_sensitive);
public static native @Cast("bool") boolean basic_parser_fseek_string(@Const basic_parser_type parser, @Cast("FILE*") Pointer stream, String string, @Cast("bool") boolean skip_string, @Cast("bool") boolean case_sensitive);
public static native @Cast("char*") BytePointer basic_parser_fread_alloc_file_content(@Cast("const char*") BytePointer filename, @Cast("const char*") BytePointer quote_set, @Cast("const char*") BytePointer delete_set, @Cast("const char*") BytePointer comment_start, @Cast("const char*") BytePointer comment_end);
public static native @Cast("char*") ByteBuffer basic_parser_fread_alloc_file_content(String filename, String quote_set, String delete_set, String comment_start, String comment_end);
// #ifdef __cplusplus
// #endif // __cplusplus

// #endif



// Parsed from ert/util/parser.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/parser.hpp>




// Parsed from ert/util/node_data.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/node_data.hpp>




// Parsed from ert/util/node_ctype.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'node_ctype.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_NODE_CTYPE_H
// #define ERT_NODE_CTYPE_H
// #ifdef __cplusplus
// #endif


/*
  value : means a scalar which has been packed into the container
          object.

  pointer: means a (typed) pointer which points to a memory location
           outside the container object (however the container can own
           the memory).

*/

/** enum node_ctype */
public static final int CTYPE_VOID_POINTER = 1,
	       CTYPE_INT_VALUE    = 2,
	       CTYPE_DOUBLE_VALUE = 3,
	       CTYPE_FLOAT_VALUE  = 4,
	       CTYPE_CHAR_VALUE   = 5,
	       CTYPE_BOOL_VALUE   = 6,
	       CTYPE_SIZE_T_VALUE = 7,
	       CTYPE_INVALID      = 100;


public static native @Cast("const char*") BytePointer node_ctype_name(@Cast("node_ctype") int arg0 );
// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/node_ctype.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/node_ctype.hpp>




// Parsed from ert/util/mzran.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'mzran.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_MZRAN_H
// #define ERT_MZRAN_H

// #ifdef __cplusplus
// #endif
// #include <stdlib.h>
// #include <stdio.h>
// Targeting ../mzran_type.java



public static final long MZRAN_MAX_VALUE =  4294967296L;
public static final int MZRAN_STATE_SIZE = 16;             /* Size of the seed buffer - in bytes. */


public static native void mzran_fscanf_state( Pointer __rng, @Cast("FILE*") Pointer stream );
public static native @Cast("unsigned int") int mzran_forward(Pointer __rng);
public static native Pointer mzran_alloc( );
public static native void mzran_set_state(Pointer __rng, @Cast("const char*") BytePointer seed_buffer);
public static native void mzran_set_state(Pointer __rng, String seed_buffer);
public static native void mzran_get_state(Pointer __rng, @Cast("char*") BytePointer state_buffer);
public static native void mzran_get_state(Pointer __rng, @Cast("char*") ByteBuffer state_buffer);
public static native void mzran_get_state(Pointer __rng, @Cast("char*") byte[] state_buffer);
public static native double mzran_get_double(mzran_type rng);
public static native int mzran_get_int( mzran_type rng, int max);
public static native void mzran_fprintf_state( @Const Pointer __rng, @Cast("FILE*") Pointer stream);
public static native void mzran_free( Pointer __rng );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/mzran.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/mzran.hpp>




// Parsed from ert/util/msvc_stdbool.h

/*
  When building with MSVC this file is renamed to stdbool.h and copied into the
  list of headers. The situation is as follows:

  - The ERT code makes use of stdbool in many places.  The msvc C
    compiler does not have a stdbool header, i.e. the #include <stdbool.h>
    statements fail when compiling.

  - When included in a C++ project the compiler already has a bool
    defined; it is therefore important not to redefine this symbol if
    we are compiling C++.

*/

// #ifndef __cplusplus
public static final int TRUE = 1;
public static final int FALSE = 0;

// #endif


// Parsed from ert/util/lookup_table.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'lookup_table.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_LOOKUP_TABLE_H
// #define ERT_LOOKUP_TABLE_H

// #ifdef __cplusplus
// #endif

// #include <ert/util/double_vector.hpp>
// Targeting ../lookup_table_type.java




  public static native void lookup_table_set_data( lookup_table_type lt, double_vector_type x, double_vector_type y, @Cast("bool") boolean data_owner );
  public static native lookup_table_type lookup_table_alloc( double_vector_type x, double_vector_type y, @Cast("bool") boolean data_owner);
  public static native lookup_table_type lookup_table_alloc_empty();
  public static native void lookup_table_append( lookup_table_type lt, double x, double y);
  public static native void lookup_table_free( lookup_table_type lt );
  public static native double lookup_table_interp( lookup_table_type lt, double x);
  public static native double lookup_table_get_max_value(  lookup_table_type lookup_table );
  public static native double lookup_table_get_min_value(  lookup_table_type lookup_table );
  public static native double lookup_table_get_max_arg(  lookup_table_type lookup_table );
  public static native double lookup_table_get_min_arg( lookup_table_type lookup_table );
  public static native int lookup_table_get_size( @Const lookup_table_type lt );
  public static native void lookup_table_set_low_limit( lookup_table_type lt, double _limit);
  public static native @Cast("bool") boolean lookup_table_has_low_limit(@Const lookup_table_type lt  );
  public static native void lookup_table_set_high_limit( lookup_table_type lt, double _limit);
  public static native @Cast("bool") boolean lookup_table_has_high_limit(@Const lookup_table_type lt  );



// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/lookup_table.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/lookup_table.hpp>




// Parsed from ert/util/long_vector.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_long_VECTOR_H
// #define ERT_long_VECTOR_H
// #ifdef __cplusplus
// #endif
// #include <stdio.h>
// #include <stdbool.h>

// #include <ert/util/type_macros.h>
// #include <ert/util/perm_vector.h>
// Targeting ../long_vector_type.java


// Targeting ../long_ftype.java




  public static native int long_vector_lookup_bin( @Const long_vector_type limits, long value, int guess);
  public static native int long_vector_lookup_bin__( @Const long_vector_type limits, long value, int guess);
  public static native void long_vector_inplace_div( long_vector_type vector, @Const long_vector_type inv_factor);
  public static native void long_vector_inplace_mul( long_vector_type vector, @Const long_vector_type factor);
  public static native void long_vector_inplace_add( long_vector_type vector, @Const long_vector_type delta);
  public static native void long_vector_inplace_sub( long_vector_type vector, @Const long_vector_type delta);
  public static native void long_vector_set_read_only( long_vector_type vector, @Cast("bool") boolean read_only);
  public static native @Cast("bool") boolean long_vector_get_read_only( @Const long_vector_type vector );
  public static native void long_vector_memcpy_data( CLongPointer target, @Const long_vector_type src );
  public static native void long_vector_memcpy_from_data( long_vector_type target, @Const CLongPointer src, int src_size );
  public static native void long_vector_memcpy(  long_vector_type target, @Const long_vector_type src);
  public static native void long_vector_memcpy_data_block( long_vector_type target, @Const long_vector_type src, int target_offset, int src_offset, int len);
  public static native @Cast("bool") boolean long_vector_growable( @Const long_vector_type vector);
  public static native void long_vector_select_unique(long_vector_type vector);
  public static native long_vector_type long_vector_alloc( int init_size, long arg1 );
  public static native long_vector_type long_vector_alloc_private_wrapper(int init_size, long default_value, CLongPointer data, int alloc_size);
  public static native long_vector_type long_vector_alloc_shared_wrapper(int init_size, long default_value, CLongPointer data, int alloc_size);
  public static native long_vector_type long_vector_alloc_strided_copy( @Const long_vector_type src, int start, int stop, int stride );
  public static native long_vector_type long_vector_alloc_copy( @Const long_vector_type src);
  public static native void long_vector_imul(long_vector_type vector, int index, long factor);
  public static native void long_vector_scale(long_vector_type vector, long factor);
  public static native void long_vector_div(long_vector_type vector, long divisor);
  public static native long long_vector_reverse_iget(@Const long_vector_type vector, int index);
  public static native long long_vector_iget(@Const long_vector_type arg0, int arg1);
  public static native long long_vector_safe_iget(@Const long_vector_type arg0, int arg1);
  public static native long long_vector_get_min(@Const long_vector_type vector);
  public static native long long_vector_get_max(@Const long_vector_type vector);
  public static native int long_vector_get_min_index(@Const long_vector_type vector, @Cast("bool") boolean reverse);
  public static native int long_vector_get_max_index(@Const long_vector_type vector, @Cast("bool") boolean reverse);
  public static native long long_vector_iadd( long_vector_type vector, int index, long delta);
  public static native void long_vector_resize( long_vector_type vector, int new_size, long default_value );
  public static native void long_vector_iset(long_vector_type arg0, int arg1, long arg2);
  public static native void long_vector_iset_block(long_vector_type vector, int index, int block_size, long value);
  public static native void long_vector_idel_block( long_vector_type vector, int index, int block_size);
  public static native long long_vector_idel( long_vector_type vector, int index);
  public static native long long_vector_del_value( long_vector_type vector, long del_value);
  public static native void long_vector_insert( long_vector_type vector, int index, long value);
  public static native void long_vector_append(long_vector_type arg0, long arg1);
  public static native void long_vector_free_container(long_vector_type vector);
  public static native void long_vector_free(long_vector_type arg0);
  public static native void long_vector_free__(Pointer arg0);
  public static native void long_vector_free_data(long_vector_type arg0);
  public static native void long_vector_reset(long_vector_type arg0);
  public static native void long_vector_reset__(Pointer __vector);
  public static native int long_vector_size(@Const long_vector_type arg0 );
  public static native void long_vector_lshift(long_vector_type vector, int shift);
  public static native void long_vector_rshift(long_vector_type vector, int shift);
  public static native long long_vector_pop(long_vector_type vector);
  public static native long long_vector_get_first(@Const long_vector_type vector);
  public static native long long_vector_get_last(@Const long_vector_type arg0 );
  public static native CLongPointer long_vector_get_ptr(@Const long_vector_type arg0 );
  public static native CLongPointer long_vector_alloc_data_copy( @Const long_vector_type vector );
  public static native @Const CLongPointer long_vector_get_const_ptr(@Const long_vector_type arg0 );
  public static native @Cast("bool") boolean long_vector_init_linear(long_vector_type vector, long start_value, long end_value, int num_values);
  public static native void long_vector_init_range(long_vector_type vector, long value1, long value2, long delta);
  public static native void long_vector_set_many(long_vector_type arg0, int arg1, @Const CLongPointer arg2, int arg3 );
  public static native void long_vector_set_all(long_vector_type vector, long value);
  public static native void long_vector_append_many(long_vector_type vector, @Const CLongPointer data, int length);
  public static native void long_vector_append_vector(long_vector_type vector, @Const long_vector_type other);
  public static native void long_vector_shrink(long_vector_type arg0 );
  public static native long long_vector_sum(@Const long_vector_type arg0 );
  public static native long long_vector_get_default(@Const long_vector_type arg0 );
  public static native void long_vector_set_default(long_vector_type vector, long default_value);
  public static native void long_vector_append_default(long_vector_type vector, long default_value);
  public static native void long_vector_iset_default(long_vector_type vector, int index, long default_value);
  public static native @Cast("bool") boolean long_vector_is_sorted( @Const long_vector_type vector, @Cast("bool") boolean reverse);
  public static native @Cast("bool") boolean long_vector_contains(@Const long_vector_type vector, long value);
  public static native @Cast("bool") boolean long_vector_contains_sorted(@Const long_vector_type vector, long value);
  public static native int long_vector_index(@Const long_vector_type vector, long value);
  public static native int long_vector_index_sorted(@Const long_vector_type vector, long value);
  public static native void long_vector_sort(long_vector_type vector);
  public static native void long_vector_rsort(long_vector_type vector);
  public static native void long_vector_permute(long_vector_type vector, @Const perm_vector_type perm);
  public static native perm_vector_type long_vector_alloc_sort_perm(@Const long_vector_type vector);
  public static native perm_vector_type long_vector_alloc_rsort_perm(@Const long_vector_type vector);
  public static native void long_vector_fprintf(@Const long_vector_type vector, @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer fmt);
  public static native void long_vector_fprintf(@Const long_vector_type vector, @Cast("FILE*") Pointer stream, String name, String fmt);
  public static native void long_vector_fwrite(@Const long_vector_type vector, @Cast("FILE*") Pointer stream);
  public static native long_vector_type long_vector_fread_alloc( @Cast("FILE*") Pointer stream );
  public static native void long_vector_fread( long_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void long_vector_fwrite_data( @Const long_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void long_vector_fread_data( long_vector_type vector, int size, @Cast("FILE*") Pointer stream);
  public static native @Cast("bool") boolean long_vector_equal(@Const long_vector_type vector1, @Const long_vector_type vector2);
  public static native int long_vector_first_equal(@Const long_vector_type vector1, @Const long_vector_type vector2, int offset);
  public static native int long_vector_first_not_equal(@Const long_vector_type vector1, @Const long_vector_type vector2, int offset);
  public static native void long_vector_apply(long_vector_type vector, long_ftype func);
  public static native int long_vector_count_equal( @Const long_vector_type vector, long cmp_value);
  public static native int long_vector_element_size( @Const long_vector_type vector );
  public static native void long_vector_range_fill(long_vector_type vector, long limit1, long delta, long limit2);
  public static native void long_vector_shift(long_vector_type vector, long delta);

  public static native long_vector_type long_vector_safe_cast( Pointer __arg );
  public static native @Cast("bool") boolean long_vector_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif
//






// Parsed from ert/util/long_vector.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.hpp' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_long_VECTOR_CXX
// #define ERT_long_VECTOR_CXX

// #include <ert/util/long_vector.h>

// #endif


// Parsed from ert/util/hash_node.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'hash_node.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_HASH_NODE_H
// #define ERT_HASH_NODE_H
// #ifdef __cplusplus
// #endif
// #include <stdbool.h>
// #include <stdint.h>

// #include <ert/util/node_data.hpp>
// Targeting ../hash_node_type.java


// Targeting ../hashf_type.java


/** enum hash_data_type */
public static final int hash_ref_data = 0, hash_int_data = 1, hash_double_data = 2, hash_string_data = 3;


public static native @Cast("bool") boolean hash_node_key_eq(@Const hash_node_type arg0, @Cast("uint32_t") int arg1, @Cast("const char*") BytePointer arg2);
public static native @Cast("bool") boolean hash_node_key_eq(@Const hash_node_type arg0, @Cast("uint32_t") int arg1, String arg2);
public static native hash_node_type hash_node_get_next(@Const hash_node_type arg0 );
public static native @Cast("uint32_t") int hash_node_get_insert_nr(@Const hash_node_type arg0 );
public static native void hash_node_set_next(hash_node_type arg0, @Const hash_node_type arg1 );
public static native hash_node_type hash_node_alloc_new(@Cast("const char*") BytePointer arg0, node_data_type arg1, hashf_type arg2, @Cast("uint32_t") int arg3);
public static native hash_node_type hash_node_alloc_new(String arg0, node_data_type arg1, hashf_type arg2, @Cast("uint32_t") int arg3);
public static native void hash_node_set_insert_nr(hash_node_type arg0, @Cast("uint32_t") int arg1 );
public static native @Cast("uint32_t") int hash_node_get_table_index(@Const hash_node_type arg0 );
public static native @Cast("uint32_t") int hash_node_get_global_index(@Const hash_node_type arg0 );
public static native @Cast("const char*") BytePointer hash_node_get_key(@Const hash_node_type arg0 );
public static native node_data_type hash_node_get_data(@Const hash_node_type arg0);
public static native void hash_node_free(hash_node_type arg0);
public static native @Cast("uint32_t") int hash_node_set_table_index(hash_node_type arg0, @Cast("uint32_t") int arg1 );
// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/hash_sll.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'hash_sll.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_HASH_SLL_H
// #define ERT_HASH_SLL_H
// #ifdef __cplusplus
// #endif

// #include <ert/util/hash_node.hpp>
// Targeting ../hash_sll_type.java



public static native @Cast("hash_sll_type**") PointerPointer hash_sll_alloc_table(int arg0 );
/*hash_sll_type *  hash_sll_alloc(void);*/
public static native void hash_sll_del_node(hash_sll_type arg0, hash_node_type arg1);
public static native void hash_sll_add_node(hash_sll_type arg0, hash_node_type arg1);
public static native void hash_sll_free(hash_sll_type arg0);
public static native @Cast("bool") boolean hash_sll_has_key(@Const hash_sll_type arg0, @Cast("uint32_t") int arg1, @Cast("const char*") BytePointer arg2);
public static native @Cast("bool") boolean hash_sll_has_key(@Const hash_sll_type arg0, @Cast("uint32_t") int arg1, String arg2);
public static native @Cast("bool") boolean hash_sll_empty(@Const hash_sll_type hash_sll);
public static native hash_node_type hash_sll_get(@Const hash_sll_type arg0, @Cast("uint32_t") int arg1, @Cast("const char*") BytePointer arg2);
public static native hash_node_type hash_sll_get(@Const hash_sll_type arg0, @Cast("uint32_t") int arg1, String arg2);
public static native hash_node_type hash_sll_get_head(@Const hash_sll_type arg0);
// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/hash_sll.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/hash_sll.hpp>




// Parsed from ert/util/hash_node.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/hash_node.hpp>




// Parsed from ert/util/hash.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'hash.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_HASH_H
// #define ERT_HASH_H
// #ifdef __cplusplus
// #endif

// #include <stdlib.h>

// #include <ert/util/stringlist.hpp>
// #include <ert/util/type_macros.hpp>
// #include <ert/util/node_data.hpp>
// Targeting ../hash_type.java


// Targeting ../hash_iter_type.java


// Targeting ../hash_apply_ftype.java



public static native hash_type hash_safe_cast( Pointer __arg );
public static native @Const hash_type hash_safe_cast_const( @Const Pointer __arg );

public static native hash_type hash_alloc();
public static native void hash_iter_complete(hash_type arg0 );
public static native void hash_free(hash_type arg0);
public static native void hash_free__(Pointer arg0);
public static native void hash_insert_ref(hash_type arg0, @Cast("const char*") BytePointer arg1, @Const Pointer arg2);
public static native void hash_insert_ref(hash_type arg0, String arg1, @Const Pointer arg2);
public static native void hash_insert_copy(hash_type arg0, @Cast("const char*") BytePointer arg1, @Const Pointer arg2, copyc_ftype arg3, free_ftype arg4);
public static native void hash_insert_copy(hash_type arg0, String arg1, @Const Pointer arg2, copyc_ftype arg3, free_ftype arg4);
public static native void hash_insert_string(hash_type arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2);
public static native void hash_insert_string(hash_type arg0, String arg1, String arg2);
public static native @Cast("bool") boolean hash_has_key(@Const hash_type arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("bool") boolean hash_has_key(@Const hash_type arg0, String arg1);
public static native Pointer hash_pop( hash_type hash, @Cast("const char*") BytePointer key);
public static native Pointer hash_pop( hash_type hash, String key);
public static native Pointer hash_safe_get( @Const hash_type hash, @Cast("const char*") BytePointer key );
public static native Pointer hash_safe_get( @Const hash_type hash, String key );
public static native Pointer hash_get(@Const hash_type arg0, @Cast("const char*") BytePointer arg1);
public static native Pointer hash_get(@Const hash_type arg0, String arg1);
public static native @Cast("char*") BytePointer hash_get_string(@Const hash_type arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer hash_get_string(@Const hash_type arg0, String arg1);
public static native void hash_del(hash_type arg0, @Cast("const char*") BytePointer arg1);
public static native void hash_del(hash_type arg0, String arg1);
public static native void hash_safe_del(hash_type arg0, @Cast("const char*") BytePointer arg1 );
public static native void hash_safe_del(hash_type arg0, String arg1 );
public static native void hash_clear(hash_type arg0);
public static native int hash_get_size(@Const hash_type arg0);
public static native void hash_set_keylist(@Const hash_type arg0, @Cast("char**") PointerPointer arg1);
public static native void hash_set_keylist(@Const hash_type arg0, @Cast("char**") @ByPtrPtr BytePointer arg1);
public static native void hash_set_keylist(@Const hash_type arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1);
public static native void hash_set_keylist(@Const hash_type arg0, @Cast("char**") @ByPtrPtr byte[] arg1);
public static native @Cast("char**") PointerPointer hash_alloc_keylist(@Const hash_type arg0);
public static native stringlist_type hash_alloc_stringlist(@Const hash_type arg0 );

public static native @Cast("char**") PointerPointer hash_alloc_sorted_keylist(@Const hash_type hash, int hash_get_cmp_value);
// Targeting ../Cmp_Pointer_Pointer.java


public static native @Cast("char**") PointerPointer hash_alloc_key_sorted_list(@Const hash_type hash, Cmp_Pointer_Pointer cmp);
public static native @Cast("bool") boolean hash_key_list_compare(@Const hash_type hash1, @Const hash_type hash2);
public static native void hash_insert_hash_owned_ref(hash_type arg0, @Cast("const char*") BytePointer arg1, @Const Pointer arg2, free_ftype arg3);
public static native void hash_insert_hash_owned_ref(hash_type arg0, String arg1, @Const Pointer arg2, free_ftype arg3);
public static native void hash_resize(hash_type hash, int new_size);

public static native hash_iter_type hash_iter_alloc(@Const hash_type arg0);
public static native void hash_iter_free(hash_iter_type arg0);
public static native @Cast("bool") boolean hash_iter_is_complete(@Const hash_iter_type arg0);
public static native @Cast("const char*") BytePointer hash_iter_get_next_key(hash_iter_type arg0);
public static native Pointer hash_iter_get_next_value(hash_iter_type arg0);
public static native void hash_iter_restart( hash_iter_type iter );

public static native hash_type hash_alloc_from_options(@Const stringlist_type arg0);
public static native @Cast("bool") boolean hash_add_option( hash_type hash, @Cast("const char*") BytePointer key_value);
public static native @Cast("bool") boolean hash_add_option( hash_type hash, String key_value);

public static native int hash_inc_counter(hash_type hash, @Cast("const char*") BytePointer counter_key);
public static native int hash_inc_counter(hash_type hash, String counter_key);
public static native int hash_get_counter(@Const hash_type hash, @Cast("const char*") BytePointer key);
public static native int hash_get_counter(@Const hash_type hash, String key);
public static native void hash_insert_int(hash_type arg0, @Cast("const char*") BytePointer arg1, int arg2);
public static native void hash_insert_int(hash_type arg0, String arg1, int arg2);
public static native int hash_get_int(@Const hash_type arg0, @Cast("const char*") BytePointer arg1);
public static native int hash_get_int(@Const hash_type arg0, String arg1);
public static native void hash_insert_double(hash_type arg0, @Cast("const char*") BytePointer arg1, double arg2);
public static native void hash_insert_double(hash_type arg0, String arg1, double arg2);
public static native double hash_get_double(@Const hash_type arg0, @Cast("const char*") BytePointer arg1);
public static native double hash_get_double(@Const hash_type arg0, String arg1);
public static native void hash_apply( hash_type hash, hash_apply_ftype func);

public static native @Cast("bool") boolean hash_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/util/hash.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/hash.hpp>




// Parsed from ert/util/float_vector.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_float_VECTOR_H
// #define ERT_float_VECTOR_H
// #ifdef __cplusplus
// #endif
// #include <stdio.h>
// #include <stdbool.h>

// #include <ert/util/type_macros.h>
// #include <ert/util/perm_vector.h>
// Targeting ../float_vector_type.java


// Targeting ../float_ftype.java




  public static native int float_vector_lookup_bin( @Const float_vector_type limits, float value, int guess);
  public static native int float_vector_lookup_bin__( @Const float_vector_type limits, float value, int guess);
  public static native void float_vector_inplace_div( float_vector_type vector, @Const float_vector_type inv_factor);
  public static native void float_vector_inplace_mul( float_vector_type vector, @Const float_vector_type factor);
  public static native void float_vector_inplace_add( float_vector_type vector, @Const float_vector_type delta);
  public static native void float_vector_inplace_sub( float_vector_type vector, @Const float_vector_type delta);
  public static native void float_vector_set_read_only( float_vector_type vector, @Cast("bool") boolean read_only);
  public static native @Cast("bool") boolean float_vector_get_read_only( @Const float_vector_type vector );
  public static native void float_vector_memcpy_data( FloatPointer target, @Const float_vector_type src );
  public static native void float_vector_memcpy_data( FloatBuffer target, @Const float_vector_type src );
  public static native void float_vector_memcpy_data( float[] target, @Const float_vector_type src );
  public static native void float_vector_memcpy_from_data( float_vector_type target, @Const FloatPointer src, int src_size );
  public static native void float_vector_memcpy_from_data( float_vector_type target, @Const FloatBuffer src, int src_size );
  public static native void float_vector_memcpy_from_data( float_vector_type target, @Const float[] src, int src_size );
  public static native void float_vector_memcpy(  float_vector_type target, @Const float_vector_type src);
  public static native void float_vector_memcpy_data_block( float_vector_type target, @Const float_vector_type src, int target_offset, int src_offset, int len);
  public static native @Cast("bool") boolean float_vector_growable( @Const float_vector_type vector);
  public static native void float_vector_select_unique(float_vector_type vector);
  public static native float_vector_type float_vector_alloc( int init_size, float arg1 );
  public static native float_vector_type float_vector_alloc_private_wrapper(int init_size, float default_value, FloatPointer data, int alloc_size);
  public static native float_vector_type float_vector_alloc_private_wrapper(int init_size, float default_value, FloatBuffer data, int alloc_size);
  public static native float_vector_type float_vector_alloc_private_wrapper(int init_size, float default_value, float[] data, int alloc_size);
  public static native float_vector_type float_vector_alloc_shared_wrapper(int init_size, float default_value, FloatPointer data, int alloc_size);
  public static native float_vector_type float_vector_alloc_shared_wrapper(int init_size, float default_value, FloatBuffer data, int alloc_size);
  public static native float_vector_type float_vector_alloc_shared_wrapper(int init_size, float default_value, float[] data, int alloc_size);
  public static native float_vector_type float_vector_alloc_strided_copy( @Const float_vector_type src, int start, int stop, int stride );
  public static native float_vector_type float_vector_alloc_copy( @Const float_vector_type src);
  public static native void float_vector_imul(float_vector_type vector, int index, float factor);
  public static native void float_vector_scale(float_vector_type vector, float factor);
  public static native void float_vector_div(float_vector_type vector, float divisor);
  public static native float float_vector_reverse_iget(@Const float_vector_type vector, int index);
  public static native float float_vector_iget(@Const float_vector_type arg0, int arg1);
  public static native float float_vector_safe_iget(@Const float_vector_type arg0, int arg1);
  public static native float float_vector_get_min(@Const float_vector_type vector);
  public static native float float_vector_get_max(@Const float_vector_type vector);
  public static native int float_vector_get_min_index(@Const float_vector_type vector, @Cast("bool") boolean reverse);
  public static native int float_vector_get_max_index(@Const float_vector_type vector, @Cast("bool") boolean reverse);
  public static native float float_vector_iadd( float_vector_type vector, int index, float delta);
  public static native void float_vector_resize( float_vector_type vector, int new_size, float default_value );
  public static native void float_vector_iset(float_vector_type arg0, int arg1, float arg2);
  public static native void float_vector_iset_block(float_vector_type vector, int index, int block_size, float value);
  public static native void float_vector_idel_block( float_vector_type vector, int index, int block_size);
  public static native float float_vector_idel( float_vector_type vector, int index);
  public static native float float_vector_del_value( float_vector_type vector, float del_value);
  public static native void float_vector_insert( float_vector_type vector, int index, float value);
  public static native void float_vector_append(float_vector_type arg0, float arg1);
  public static native void float_vector_free_container(float_vector_type vector);
  public static native void float_vector_free(float_vector_type arg0);
  public static native void float_vector_free__(Pointer arg0);
  public static native void float_vector_free_data(float_vector_type arg0);
  public static native void float_vector_reset(float_vector_type arg0);
  public static native void float_vector_reset__(Pointer __vector);
  public static native int float_vector_size(@Const float_vector_type arg0 );
  public static native void float_vector_lshift(float_vector_type vector, int shift);
  public static native void float_vector_rshift(float_vector_type vector, int shift);
  public static native float float_vector_pop(float_vector_type vector);
  public static native float float_vector_get_first(@Const float_vector_type vector);
  public static native float float_vector_get_last(@Const float_vector_type arg0 );
  public static native FloatPointer float_vector_get_ptr(@Const float_vector_type arg0 );
  public static native FloatPointer float_vector_alloc_data_copy( @Const float_vector_type vector );
  public static native @Const FloatPointer float_vector_get_const_ptr(@Const float_vector_type arg0 );
  public static native @Cast("bool") boolean float_vector_init_linear(float_vector_type vector, float start_value, float end_value, int num_values);
  public static native void float_vector_init_range(float_vector_type vector, float value1, float value2, float delta);
  public static native void float_vector_set_many(float_vector_type arg0, int arg1, @Const FloatPointer arg2, int arg3 );
  public static native void float_vector_set_many(float_vector_type arg0, int arg1, @Const FloatBuffer arg2, int arg3 );
  public static native void float_vector_set_many(float_vector_type arg0, int arg1, @Const float[] arg2, int arg3 );
  public static native void float_vector_set_all(float_vector_type vector, float value);
  public static native void float_vector_append_many(float_vector_type vector, @Const FloatPointer data, int length);
  public static native void float_vector_append_many(float_vector_type vector, @Const FloatBuffer data, int length);
  public static native void float_vector_append_many(float_vector_type vector, @Const float[] data, int length);
  public static native void float_vector_append_vector(float_vector_type vector, @Const float_vector_type other);
  public static native void float_vector_shrink(float_vector_type arg0 );
  public static native float float_vector_sum(@Const float_vector_type arg0 );
  public static native float float_vector_get_default(@Const float_vector_type arg0 );
  public static native void float_vector_set_default(float_vector_type vector, float default_value);
  public static native void float_vector_append_default(float_vector_type vector, float default_value);
  public static native void float_vector_iset_default(float_vector_type vector, int index, float default_value);
  public static native @Cast("bool") boolean float_vector_is_sorted( @Const float_vector_type vector, @Cast("bool") boolean reverse);
  public static native @Cast("bool") boolean float_vector_contains(@Const float_vector_type vector, float value);
  public static native @Cast("bool") boolean float_vector_contains_sorted(@Const float_vector_type vector, float value);
  public static native int float_vector_index(@Const float_vector_type vector, float value);
  public static native int float_vector_index_sorted(@Const float_vector_type vector, float value);
  public static native void float_vector_sort(float_vector_type vector);
  public static native void float_vector_rsort(float_vector_type vector);
  public static native void float_vector_permute(float_vector_type vector, @Const perm_vector_type perm);
  public static native perm_vector_type float_vector_alloc_sort_perm(@Const float_vector_type vector);
  public static native perm_vector_type float_vector_alloc_rsort_perm(@Const float_vector_type vector);
  public static native void float_vector_fprintf(@Const float_vector_type vector, @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer fmt);
  public static native void float_vector_fprintf(@Const float_vector_type vector, @Cast("FILE*") Pointer stream, String name, String fmt);
  public static native void float_vector_fwrite(@Const float_vector_type vector, @Cast("FILE*") Pointer stream);
  public static native float_vector_type float_vector_fread_alloc( @Cast("FILE*") Pointer stream );
  public static native void float_vector_fread( float_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void float_vector_fwrite_data( @Const float_vector_type vector, @Cast("FILE*") Pointer stream );
  public static native void float_vector_fread_data( float_vector_type vector, int size, @Cast("FILE*") Pointer stream);
  public static native @Cast("bool") boolean float_vector_equal(@Const float_vector_type vector1, @Const float_vector_type vector2);
  public static native int float_vector_first_equal(@Const float_vector_type vector1, @Const float_vector_type vector2, int offset);
  public static native int float_vector_first_not_equal(@Const float_vector_type vector1, @Const float_vector_type vector2, int offset);
  public static native void float_vector_apply(float_vector_type vector, float_ftype func);
  public static native int float_vector_count_equal( @Const float_vector_type vector, float cmp_value);
  public static native int float_vector_element_size( @Const float_vector_type vector );
  public static native void float_vector_range_fill(float_vector_type vector, float limit1, float delta, float limit2);
  public static native void float_vector_shift(float_vector_type vector, float delta);

  public static native float_vector_type float_vector_safe_cast( Pointer __arg );
  public static native @Cast("bool") boolean float_vector_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif
//






// Parsed from ert/util/float_vector.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'vector_template.hpp' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_float_VECTOR_CXX
// #define ERT_float_VECTOR_CXX

// #include <ert/util/float_vector.h>

// #endif


// Parsed from ert/util/ert_unique_ptr.hpp

// #ifndef ERT_UNIQUE_PTR
// #define ERT_UNIQUE_PTR

// #include <memory>



// #endif




// Parsed from ert/util/ecl_version.hpp

/*
   Copyright (C) 2016  Equinor ASA, Norway.

   The file 'ecl_version.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ECL_VERSION
// #define ECL_VERSION

// #include <stdbool.h>

// #ifdef __cplusplus
// #endif

public static native @Cast("const char*") BytePointer ecl_version_get_git_commit();
public static native @Cast("const char*") BytePointer ecl_version_get_git_commit_short();
public static native @Cast("const char*") BytePointer ecl_version_get_build_time();
public static native int ecl_version_get_major_version();
public static native int ecl_version_get_minor_version();
public static native @Cast("const char*") BytePointer ecl_version_get_micro_version();
public static native @Cast("bool") boolean ecl_version_is_ert_devel_version();

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/util/ecl_version.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/ecl_version.hpp>




// Parsed from ert/util/build_config.h

// #define HAVE_GMTIME_R
// #define HAVE_TIMEGM
// #define HAVE_LOCALTIME_R
// #define HAVE_REALPATH
// #define HAVE__USLEEP
// #define HAVE_FNMATCH
// #define HAVE_FTRUNCATE
// #define HAVE_POSIX_CHDIR
/* #undef HAVE_WINDOWS_CHDIR */
// #define HAVE_POSIX_GETCWD
/* #undef HAVE_WINDOWS_GETCWD */
// #define HAVE_TZNAME
/* #undef HAVE_ROUND */
// #define HAVE_VA_COPY
// #define HAVE_SIGBUS
// #define HAVE_PTHREAD
// #define HAVE_PID_T
// #define HAVE_EXECINFO
// #define HAVE_FORK
// #define HAVE_POSIX_MKDIR
/* #undef HAVE_WINDOWS_MKDIR */
// #define HAVE_GETPWUID
// #define HAVE_FSYNC
// #define HAVE_CHMOD
// #define HAVE_MODE_T
// #define HAVE_CXX_SHARED_PTR
// #define HAVE_POSIX_UNLINK
/* #undef HAVE_WINDOWS_UNLINK */
/* #undef HAVE_SIGHANDLER_T */

// #define HAVE_POSIX_ACCESS
/* #undef HAVE_WINDOWS__ACCESS */
/* #undef HAVE_WINDOWS_GET_TEMP_PATH */
/* #undef HAVE_WINDOWS_TZNAME */

// #ifdef HAVE_VA_COPY
// #else
// #define UTIL_VA_COPY(target,src) target = src
// #endif


/*
  The HAVE_UTIL_ABORT_INTERCEPT is required to allow testing of the
  util_abort() functionality; in prinicple this could be implemented
  also in the simple util_abort() function without backtrace
  capabilities, but currently it is only implemented in the full
  util_abort_gnu() function.
*/

// #ifdef HAVE_FORK
// #endif


// Parsed from ert/util/build_config.hpp

// #include <ert/util/build_config.h>


// Parsed from ert/util/buffer.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'buffer.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_BUFFER_H
// #define ERT_BUFFER_H

// #ifdef __cplusplus
// #endif
// #include <stdlib.h>
// #include <stdio.h>
// #include <stdbool.h>
// #include <string.h>
// #include <time.h>

// #include <ert/util/ert_api_config.hpp>
// #include <ert/util/type_macros.hpp>
// #include <ert/util/ssize_t.hpp>
// Targeting ../buffer_type.java



  public static native buffer_type buffer_alloc( @Cast("size_t") long buffer_size );
  public static native buffer_type buffer_alloc_private_wrapper(Pointer data, @Cast("size_t") long buffer_size );
  public static native @Cast("bool") boolean buffer_search_replace( buffer_type buffer, @Cast("const char*") BytePointer old_string, @Cast("const char*") BytePointer new_string);
  public static native @Cast("bool") boolean buffer_search_replace( buffer_type buffer, String old_string, String new_string);
  public static native void buffer_shrink_to_fit( buffer_type buffer );
  public static native void buffer_memshift(buffer_type buffer, @Cast("size_t") long offset, @Cast("ssize_t") long shift);
  public static native @Cast("bool") boolean buffer_strstr( buffer_type buffer, @Cast("const char*") BytePointer expr );
  public static native @Cast("bool") boolean buffer_strstr( buffer_type buffer, String expr );
  public static native @Cast("bool") boolean buffer_strchr( buffer_type buffer, int c);
  public static native void buffer_replace_string( buffer_type buffer, @Cast("size_t") long offset, @Cast("size_t") long old_size, @Cast("const char*") BytePointer new_string);
  public static native void buffer_replace_string( buffer_type buffer, @Cast("size_t") long offset, @Cast("size_t") long old_size, String new_string);
  public static native void buffer_replace_data(buffer_type buffer, @Cast("size_t") long offset, @Cast("size_t") long old_size, @Const Pointer new_data, @Cast("size_t") long new_size);

  public static native void buffer_free_container( buffer_type buffer );
  public static native void buffer_free( buffer_type buffer);
  public static native @Cast("size_t") long buffer_fread(buffer_type buffer, Pointer target_ptr, @Cast("size_t") long item_size, @Cast("size_t") long items);
  public static native @Cast("size_t") long buffer_fwrite(buffer_type buffer, @Const Pointer src_ptr, @Cast("size_t") long item_size, @Cast("size_t") long items);
  public static native void buffer_summarize(@Const buffer_type buffer, @Cast("const char*") BytePointer arg1);
  public static native void buffer_summarize(@Const buffer_type buffer, String arg1);

  public static native void buffer_fwrite_char_ptr(buffer_type buffer, @Cast("const char*") BytePointer string_ptr );
  public static native void buffer_fwrite_char_ptr(buffer_type buffer, String string_ptr );
  public static native void buffer_strcat(buffer_type buffer, @Cast("const char*") BytePointer string);
  public static native void buffer_strcat(buffer_type buffer, String string);
  public static native void buffer_fwrite_char(buffer_type buffer, @Cast("char") byte value);
  public static native void buffer_fwrite_int(buffer_type buffer, int value);
  public static native void buffer_fskip_bool(buffer_type buffer);
  public static native void buffer_fwrite_bool(buffer_type buffer, @Cast("bool") boolean value);
  public static native int buffer_fread_int(buffer_type buffer );
  public static native @Cast("bool") boolean buffer_fread_bool(buffer_type buffer);
  public static native long buffer_fread_long(buffer_type buffer);
  public static native void buffer_fskip_long(buffer_type buffer);
  public static native void buffer_store(@Const buffer_type buffer, @Cast("const char*") BytePointer filename);
  public static native void buffer_store(@Const buffer_type buffer, String filename);
  public static native @Cast("size_t") long buffer_get_offset(@Const buffer_type buffer);
  public static native @Cast("size_t") long buffer_get_alloc_size(@Const buffer_type buffer);
  public static native @Cast("size_t") long buffer_get_size(@Const buffer_type buffer);
  public static native @Cast("size_t") long buffer_get_string_size( @Const buffer_type buffer );
  public static native @Cast("size_t") long buffer_get_remaining_size(@Const buffer_type buffer);
  public static native Pointer buffer_get_data(@Const buffer_type buffer);
  public static native Pointer buffer_alloc_data_copy(@Const buffer_type buffer);
  public static native Pointer buffer_iget_data(@Const buffer_type buffer, @Cast("size_t") long offset);
  public static native void buffer_stream_fwrite( @Const buffer_type buffer, @Cast("FILE*") Pointer stream );
  public static native int buffer_fgetc( buffer_type buffer );
  public static native void buffer_fseek(buffer_type buffer, @Cast("ssize_t") long offset, int whence);
  public static native void buffer_fskip(buffer_type buffer, @Cast("ssize_t") long offset);
  public static native void buffer_clear( buffer_type buffer );

  public static native void buffer_fskip_int(buffer_type buffer);
  public static native void buffer_fskip_time_t(buffer_type buffer);
  public static native @ByVal @Cast("time_t*") Pointer buffer_fread_time_t(buffer_type buffer);
  public static native void buffer_fwrite_time_t(buffer_type buffer, @ByVal @Cast("time_t*") Pointer value);
  public static native void buffer_rewind(buffer_type buffer );

  public static native double buffer_fread_double(buffer_type buffer);
  public static native void buffer_fwrite_double(buffer_type buffer, double value);

  public static native @Cast("size_t") long buffer_stream_fwrite_n( @Const buffer_type buffer, @Cast("size_t") long offset, @Cast("ssize_t") long write_size, @Cast("FILE*") Pointer stream );
  public static native void buffer_stream_fprintf( @Const buffer_type buffer, @Cast("FILE*") Pointer stream );
  public static native void buffer_stream_fread( buffer_type buffer, @Cast("size_t") long byte_size, @Cast("FILE*") Pointer stream);
  public static native buffer_type buffer_fread_alloc(@Cast("const char*") BytePointer filename);
  public static native buffer_type buffer_fread_alloc(String filename);
  public static native void buffer_fread_realloc(buffer_type buffer, @Cast("const char*") BytePointer filename);
  public static native void buffer_fread_realloc(buffer_type buffer, String filename);
  public static native void buffer_fprintf(@Const buffer_type buffer, @Cast("const char*") BytePointer fmt, @Cast("FILE*") Pointer stream);
  public static native void buffer_fprintf(@Const buffer_type buffer, String fmt, @Cast("FILE*") Pointer stream);

// #ifdef ERT_HAVE_ZLIB
// #endif


// #include "buffer_string.h"

  public static native @Cast("bool") boolean buffer_is_instance( @Const Pointer __arg );
  public static native buffer_type buffer_safe_cast( Pointer __arg );

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/util/buffer.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/util/buffer.hpp>




// Parsed from ert/geometry/geo_util.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'geo_util.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_GEO_UTIL_H
// #define ERT_GEO_UTIL_H


// #ifdef __cplusplus
// #endif
// #include <stdbool.h>

  /** enum geo_util_xlines_status_enum */
  public static final int
    GEO_UTIL_LINES_CROSSING = 0,
    GEO_UTIL_LINES_PARALLELL = 1,
    GEO_UTIL_LINES_OVERLAPPING = 2,
    GEO_UTIL_LINES_DEGENERATE = 3,
    GEO_UTIL_NOT_CROSSING = 4;

  public static native @Cast("bool") boolean geo_util_inside_polygon__(@Const DoublePointer xlist, @Const DoublePointer ylist, int num_points, double x0, double y0, @Cast("bool") boolean force_edge_inside);
  public static native @Cast("bool") boolean geo_util_inside_polygon__(@Const DoubleBuffer xlist, @Const DoubleBuffer ylist, int num_points, double x0, double y0, @Cast("bool") boolean force_edge_inside);
  public static native @Cast("bool") boolean geo_util_inside_polygon__(@Const double[] xlist, @Const double[] ylist, int num_points, double x0, double y0, @Cast("bool") boolean force_edge_inside);
  public static native @Cast("bool") boolean geo_util_inside_polygon(@Const DoublePointer xlist, @Const DoublePointer ylist, int num_points, double x0, double y0);
  public static native @Cast("bool") boolean geo_util_inside_polygon(@Const DoubleBuffer xlist, @Const DoubleBuffer ylist, int num_points, double x0, double y0);
  public static native @Cast("bool") boolean geo_util_inside_polygon(@Const double[] xlist, @Const double[] ylist, int num_points, double x0, double y0);
  public static native @Cast("geo_util_xlines_status_enum") int geo_util_xlines( @Cast("const double**") PointerPointer points, DoublePointer x0, DoublePointer y0 );
  public static native @Cast("geo_util_xlines_status_enum") int geo_util_xlines( @Const @ByPtrPtr DoublePointer points, DoublePointer x0, DoublePointer y0 );
  public static native @Cast("geo_util_xlines_status_enum") int geo_util_xlines( @Const @ByPtrPtr DoubleBuffer points, DoubleBuffer x0, DoubleBuffer y0 );
  public static native @Cast("geo_util_xlines_status_enum") int geo_util_xlines( @Const @ByPtrPtr double[] points, double[] x0, double[] y0 );
  public static native @Cast("geo_util_xlines_status_enum") int geo_util_xsegments( @Cast("const double**") PointerPointer points, DoublePointer x0, DoublePointer y0 );
  public static native @Cast("geo_util_xlines_status_enum") int geo_util_xsegments( @Const @ByPtrPtr DoublePointer points, DoublePointer x0, DoublePointer y0 );
  public static native @Cast("geo_util_xlines_status_enum") int geo_util_xsegments( @Const @ByPtrPtr DoubleBuffer points, DoubleBuffer x0, DoubleBuffer y0 );
  public static native @Cast("geo_util_xlines_status_enum") int geo_util_xsegments( @Const @ByPtrPtr double[] points, double[] x0, double[] y0 );


// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/geometry/geo_util.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/geometry/geo_util.hpp>




// Parsed from ert/geometry/geo_pointset.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'geo_pointset.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_GEO_POINTSET_H
// #define ERT_GEO_POINTSET_H


// #ifdef __cplusplus
// Targeting ../geo_pointset_type.java




  public static native geo_pointset_type geo_pointset_alloc( @Cast("bool") boolean external_z );
  public static native void geo_pointset_free( geo_pointset_type pointset );
  public static native void geo_pointset_add_xyz( geo_pointset_type pointset, double x, double y, double z);
  public static native int geo_pointset_get_size( @Const geo_pointset_type pointset );
  public static native void geo_pointset_iget_xy( @Const geo_pointset_type pointset, int index, DoublePointer x, DoublePointer y);
  public static native void geo_pointset_iget_xy( @Const geo_pointset_type pointset, int index, DoubleBuffer x, DoubleBuffer y);
  public static native void geo_pointset_iget_xy( @Const geo_pointset_type pointset, int index, double[] x, double[] y);
  public static native @Const DoublePointer geo_pointset_get_zcoord( @Const geo_pointset_type pointset );
  public static native @Cast("bool") boolean geo_pointset_equal( @Const geo_pointset_type pointset1, @Const geo_pointset_type pointset2);
  public static native double geo_pointset_iget_z( @Const geo_pointset_type pointset, int index );
  public static native void geo_pointset_iset_z( geo_pointset_type pointset, int index, double value);
  public static native void geo_pointset_memcpy( @Const geo_pointset_type src, geo_pointset_type target, @Cast("bool") boolean copy_zdata);
  public static native void geo_pointset_shift_z( geo_pointset_type pointset, double value );
  public static native void geo_pointset_assign_z( geo_pointset_type pointset, double value );
  public static native void geo_pointset_scale_z( geo_pointset_type pointset, double value );
  public static native void geo_pointset_imul( geo_pointset_type pointset, @Const geo_pointset_type other );
  public static native void geo_pointset_iadd( geo_pointset_type pointset, @Const geo_pointset_type other );
  public static native void geo_pointset_isub( geo_pointset_type self, @Const geo_pointset_type other );
  public static native void geo_pointset_isqrt( geo_pointset_type pointset );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/geometry/geo_surface.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'geo_surface.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_GEO_SURFACE_H
// #define ERT_GEO_SURFACE_H

// #ifdef __cplusplus
// #endif


// #include <ert/geometry/geo_pointset.hpp>
// Targeting ../geo_surface_type.java



  public static native @Cast("bool") boolean geo_surface_equal_header( @Const geo_surface_type surface1, @Const geo_surface_type surface2 );
  public static native @Cast("bool") boolean geo_surface_equal( @Const geo_surface_type surface1, @Const geo_surface_type surface2);
  public static native void geo_surface_free( geo_surface_type geo_surface );
  public static native void geo_surface_free__( Pointer arg);
  public static native geo_pointset_type geo_surface_get_pointset( @Const geo_surface_type surface );
  public static native geo_surface_type geo_surface_fload_alloc_irap( @Cast("const char*") BytePointer filename, @Cast("bool") boolean loadz);
  public static native geo_surface_type geo_surface_fload_alloc_irap( String filename, @Cast("bool") boolean loadz);
  public static native geo_surface_type geo_surface_alloc_new( int nx, int ny, double xinc, double yinc, double xstart, double ystart, double angle );
  public static native @Cast("bool") boolean geo_surface_fload_irap_zcoord( @Const geo_surface_type surface, @Cast("const char*") BytePointer filename, DoublePointer zlist);
  public static native @Cast("bool") boolean geo_surface_fload_irap_zcoord( @Const geo_surface_type surface, String filename, DoubleBuffer zlist);
  public static native @Cast("bool") boolean geo_surface_fload_irap_zcoord( @Const geo_surface_type surface, @Cast("const char*") BytePointer filename, double[] zlist);
  public static native @Cast("bool") boolean geo_surface_fload_irap_zcoord( @Const geo_surface_type surface, String filename, DoublePointer zlist);
  public static native @Cast("bool") boolean geo_surface_fload_irap_zcoord( @Const geo_surface_type surface, @Cast("const char*") BytePointer filename, DoubleBuffer zlist);
  public static native @Cast("bool") boolean geo_surface_fload_irap_zcoord( @Const geo_surface_type surface, String filename, double[] zlist);
  public static native double geo_surface_iget_zvalue(@Const geo_surface_type surface, int index);
  public static native int geo_surface_get_size( @Const geo_surface_type surface );
  public static native void geo_surface_fprintf_irap( @Const geo_surface_type surface, @Cast("const char*") BytePointer filename );
  public static native void geo_surface_fprintf_irap( @Const geo_surface_type surface, String filename );
  public static native void geo_surface_fprintf_irap_external_zcoord( @Const geo_surface_type surface, @Cast("const char*") BytePointer filename, @Const DoublePointer zcoord);
  public static native void geo_surface_fprintf_irap_external_zcoord( @Const geo_surface_type surface, String filename, @Const DoubleBuffer zcoord);
  public static native void geo_surface_fprintf_irap_external_zcoord( @Const geo_surface_type surface, @Cast("const char*") BytePointer filename, @Const double[] zcoord);
  public static native void geo_surface_fprintf_irap_external_zcoord( @Const geo_surface_type surface, String filename, @Const DoublePointer zcoord);
  public static native void geo_surface_fprintf_irap_external_zcoord( @Const geo_surface_type surface, @Cast("const char*") BytePointer filename, @Const DoubleBuffer zcoord);
  public static native void geo_surface_fprintf_irap_external_zcoord( @Const geo_surface_type surface, String filename, @Const double[] zcoord);
  public static native int geo_surface_get_nx( @Const geo_surface_type surface );
  public static native int geo_surface_get_ny( @Const geo_surface_type surface );
  public static native void geo_surface_iget_xy( @Const geo_surface_type surface, int index, DoublePointer x, DoublePointer y);
  public static native void geo_surface_iget_xy( @Const geo_surface_type surface, int index, DoubleBuffer x, DoubleBuffer y);
  public static native void geo_surface_iget_xy( @Const geo_surface_type surface, int index, double[] x, double[] y);

  public static native void geo_surface_shift( @Const geo_surface_type src, double value);
  public static native void geo_surface_scale( @Const geo_surface_type src, double value);
  public static native void geo_surface_isub( geo_surface_type self, @Const geo_surface_type other);
  public static native void geo_surface_iset_zvalue(geo_surface_type surface, int index, double value);
  public static native void geo_surface_assign_value( @Const geo_surface_type src, double value);
  public static native geo_surface_type geo_surface_alloc_copy( @Const geo_surface_type src, @Cast("bool") boolean copy_zdata);
  public static native void geo_surface_iadd( geo_surface_type self, @Const geo_surface_type other);
  public static native void geo_surface_imul( geo_surface_type self, @Const geo_surface_type other);
  public static native void geo_surface_isqrt( geo_surface_type surface );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/geometry/geo_surface.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/geometry/geo_surface.hpp>




// Parsed from ert/geometry/geo_polygon.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'geo_polygon.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_GEO_POLYGON_H
// #define ERT_GEO_POLYGON_H

// #ifdef __cplusplus
// #endif

// #include <stdbool.h>

// #include <ert/util/type_macros.hpp>
// Targeting ../geo_polygon_type.java



  public static native geo_polygon_type geo_polygon_alloc( @Cast("const char*") BytePointer name );
  public static native geo_polygon_type geo_polygon_alloc( String name );
  public static native void geo_polygon_free( geo_polygon_type polygon );
  public static native void geo_polygon_free__( Pointer arg );
  public static native void geo_polygon_add_point( geo_polygon_type polygon, double x, double y );
  public static native void geo_polygon_add_point_front( geo_polygon_type polygon, double x, double y);
  public static native geo_polygon_type geo_polygon_fload_alloc_irap( @Cast("const char*") BytePointer filename );
  public static native geo_polygon_type geo_polygon_fload_alloc_irap( String filename );
  public static native @Cast("bool") boolean geo_polygon_contains_point( @Const geo_polygon_type polygon, double x, double y);
  public static native @Cast("bool") boolean geo_polygon_contains_point__( @Const geo_polygon_type polygon, double x, double y, @Cast("bool") boolean force_edge_inside);
  public static native void geo_polygon_reset(geo_polygon_type polygon );
  public static native void geo_polygon_fprintf(@Const geo_polygon_type polygon, @Cast("FILE*") Pointer stream);
  public static native void geo_polygon_shift(geo_polygon_type polygon, double x0, double y0);
  public static native void geo_polygon_close( geo_polygon_type polygoon);
  public static native int geo_polygon_get_size(@Const geo_polygon_type polygon );
  public static native void geo_polygon_iget_xy(@Const geo_polygon_type polygon, int index, DoublePointer x, DoublePointer y);
  public static native void geo_polygon_iget_xy(@Const geo_polygon_type polygon, int index, DoubleBuffer x, DoubleBuffer y);
  public static native void geo_polygon_iget_xy(@Const geo_polygon_type polygon, int index, double[] x, double[] y);
  public static native @Cast("bool") boolean geo_polygon_segment_intersects(@Const geo_polygon_type polygon, double x1, double y1, double x2, double y2);
  public static native @Cast("const char*") BytePointer geo_polygon_get_name( @Const geo_polygon_type polygon );
  public static native void geo_polygon_set_name( geo_polygon_type polygon, @Cast("const char*") BytePointer name);
  public static native void geo_polygon_set_name( geo_polygon_type polygon, String name);
  public static native double geo_polygon_get_length( geo_polygon_type polygon );
  public static native @Cast("bool") boolean geo_polygon_equal( @Const geo_polygon_type polygon1, @Const geo_polygon_type polygon2 );

  public static native @Cast("bool") boolean geo_polygon_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/geometry/geo_region.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'geo_region.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #include <stdlib.h>
// #include <stdbool.h>

// #include <ert/util/util.h>
// #include <ert/util/int_vector.hpp>

// #include <ert/geometry/geo_pointset.hpp>
// #include <ert/geometry/geo_polygon.hpp>

// #ifndef ERT_GEO_REGION_H
// #define ERT_GEO_REGION_H


// #ifdef __cplusplus
// Targeting ../geo_region_type.java



  public static native geo_region_type geo_region_alloc( @Const geo_pointset_type pointset, @Cast("bool") boolean preselect);
  public static native void geo_region_free( geo_region_type region );
  public static native void geo_region_free__( Pointer arg );
  public static native void geo_region_reset( geo_region_type region );
  public static native @Const int_vector_type geo_region_get_index_list( geo_region_type region );

  public static native void geo_region_select_inside_polygon( geo_region_type region, @Const geo_polygon_type polygon);
  public static native void geo_region_select_outside_polygon( geo_region_type region, @Const geo_polygon_type polygon);
  public static native void geo_region_deselect_inside_polygon( geo_region_type region, @Const geo_polygon_type polygon);
  public static native void geo_region_deselect_outside_polygon( geo_region_type region, @Const geo_polygon_type polygon);

  public static native void geo_region_select_above_line( geo_region_type region, @Const DoublePointer xcoords, @Const DoublePointer ycoords);
  public static native void geo_region_select_above_line( geo_region_type region, @Const DoubleBuffer xcoords, @Const DoubleBuffer ycoords);
  public static native void geo_region_select_above_line( geo_region_type region, @Const double[] xcoords, @Const double[] ycoords);
  public static native void geo_region_select_below_line( geo_region_type region, @Const DoublePointer xcoords, @Const DoublePointer ycoords);
  public static native void geo_region_select_below_line( geo_region_type region, @Const DoubleBuffer xcoords, @Const DoubleBuffer ycoords);
  public static native void geo_region_select_below_line( geo_region_type region, @Const double[] xcoords, @Const double[] ycoords);
  public static native void geo_region_deselect_above_line( geo_region_type region, @Const DoublePointer xcoords, @Const DoublePointer ycoords);
  public static native void geo_region_deselect_above_line( geo_region_type region, @Const DoubleBuffer xcoords, @Const DoubleBuffer ycoords);
  public static native void geo_region_deselect_above_line( geo_region_type region, @Const double[] xcoords, @Const double[] ycoords);
  public static native void geo_region_deselect_below_line( geo_region_type region, @Const DoublePointer xcoords, @Const DoublePointer ycoords);
  public static native void geo_region_deselect_below_line( geo_region_type region, @Const DoubleBuffer xcoords, @Const DoubleBuffer ycoords);
  public static native void geo_region_deselect_below_line( geo_region_type region, @Const double[] xcoords, @Const double[] ycoords);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/geometry/geo_region.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/geometry/geo_region.hpp>




// Parsed from ert/geometry/geo_polygon_collection.hpp

/*
   Copyright (C) 2014  Equinor ASA, Norway.

   The file 'geo_polygon_collection.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_GEO_POLYGON_COLLECTION_H
// #define ERT_GEO_POLYGON_COLLECTION_H

// #ifdef __cplusplus
// #endif

// #include <stdbool.h>

// #include <ert/util/type_macros.hpp>

// #include <ert/geometry/geo_polygon.hpp>
// Targeting ../geo_polygon_collection_type.java



  public static native geo_polygon_collection_type geo_polygon_collection_alloc( );
  public static native void geo_polygon_collection_free( geo_polygon_collection_type polygons );
  public static native int geo_polygon_collection_size( @Const geo_polygon_collection_type polygons );
  public static native geo_polygon_type geo_polygon_collection_create_polygon( geo_polygon_collection_type polygons, @Cast("const char*") BytePointer name );
  public static native geo_polygon_type geo_polygon_collection_create_polygon( geo_polygon_collection_type polygons, String name );
  public static native @Cast("bool") boolean geo_polygon_collection_has_polygon( @Const geo_polygon_collection_type polygons, @Cast("const char*") BytePointer name);
  public static native @Cast("bool") boolean geo_polygon_collection_has_polygon( @Const geo_polygon_collection_type polygons, String name);
  public static native @Cast("bool") boolean geo_polygon_collection_add_polygon( geo_polygon_collection_type polygons, geo_polygon_type polygon, @Cast("bool") boolean polygon_owner );
  public static native geo_polygon_type geo_polygon_collection_iget_polygon(@Const geo_polygon_collection_type polygons, int index);
  public static native geo_polygon_type geo_polygon_collection_get_polygon(@Const geo_polygon_collection_type polygons, @Cast("const char*") BytePointer polygon_name);
  public static native geo_polygon_type geo_polygon_collection_get_polygon(@Const geo_polygon_collection_type polygons, String polygon_name);

  public static native @Cast("bool") boolean geo_polygon_collection_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/geometry/geo_polygon_collection.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/geometry/geo_polygon_collection.hpp>




// Parsed from ert/geometry/geo_polygon.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/geometry/geo_polygon.hpp>




// Parsed from ert/geometry/geo_pointset.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/geometry/geo_pointset.hpp>




// Parsed from ert/ecl/ecl_type.hpp

/*
   Copyright (C) 2017  Equinor ASA, Norway.

   The file 'ecl_type.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_TYPE_H
// #define ERT_ECL_TYPE_H

// #ifdef __cplusplus
// #endif

// #include <stdlib.h>
// #include <stdbool.h>

/*
  The type of an eclipse keyword is carried by a struct
  ecl_type_struct which contains a type enum, and the size in bytes of
  one such element. These structs are for the most part handled with
  value semantics, and created with macros ECL_INT, ECL_FLOAT and so
  on.

  The macros in C use designated initializers, whereas the C++ macros
  use a constructor, for this reason this file has two slightly
  different code paths for C and C++.
*/

public static final int ECL_STRING8_LENGTH =   8;
public static final int ECL_TYPE_LENGTH =      4;

/** enum ecl_type_enum */
public static final int
  ECL_CHAR_TYPE   = 0,
  ECL_FLOAT_TYPE  = 1,
  ECL_DOUBLE_TYPE = 2,
  ECL_INT_TYPE    = 3,
  ECL_BOOL_TYPE   = 4,
  ECL_MESS_TYPE   = 5,
  ECL_STRING_TYPE = 7;

public static native @MemberGetter double ECL_TYPE_ENUM_DEFS();
public static final double ECL_TYPE_ENUM_DEFS = ECL_TYPE_ENUM_DEFS();


/*
  Character data in ECLIPSE files comes as an array of fixed-length
  string. Each of these strings is 8 characters long. The type name,
  i.e. 'REAL', 'INTE', ... , come as 4 character strings.
*/
// Targeting ../ecl_type_struct.java



// #ifdef __cplusplus

public static native @MemberGetter int ECL_INT();
public static final int ECL_INT = ECL_INT();
public static native @MemberGetter int ECL_FLOAT();
public static final int ECL_FLOAT = ECL_FLOAT();
public static native @MemberGetter int ECL_DOUBLE();
public static final int ECL_DOUBLE = ECL_DOUBLE();
public static native @MemberGetter int ECL_BOOL();
public static final int ECL_BOOL = ECL_BOOL();
public static native @MemberGetter int ECL_CHAR();
public static final int ECL_CHAR = ECL_CHAR();
public static native @MemberGetter int ECL_MESS();
public static final int ECL_MESS = ECL_MESS();
// #define ECL_STRING(size) ecl_data_type{ECL_STRING_TYPE, (size) + 1}

// #else
// #define ECL_STRING(size) (ecl_data_type) {.type = ECL_STRING_TYPE, .eement_size = (size) + 1}

// #endif

// #ifdef __cplusplus
// Targeting ../ecl_data_type.java



public static native @ByVal ecl_data_type ecl_type_create_from_name(@Cast("const char*") BytePointer arg0);
public static native @ByVal ecl_data_type ecl_type_create_from_name(String arg0);
public static native @ByVal ecl_data_type ecl_type_create(@Cast("const ecl_type_enum") int arg0, @Cast("const size_t") long arg1);
public static native @ByVal ecl_data_type ecl_type_create_from_type(@Cast("const ecl_type_enum") int arg0);

public static native @Cast("ecl_type_enum") int ecl_type_get_type(@Const @ByVal ecl_data_type arg0);
public static native @Cast("char*") BytePointer ecl_type_alloc_name(@Const @ByVal ecl_data_type arg0);

public static native int ecl_type_get_sizeof_ctype(@Const @ByVal ecl_data_type arg0);
public static native int ecl_type_get_sizeof_iotype(@Const @ByVal ecl_data_type arg0);

public static native @Cast("bool") boolean ecl_type_is_equal(@Const @ByVal ecl_data_type arg0, @Const @ByVal ecl_data_type arg1);

public static native @Cast("bool") boolean ecl_type_is_numeric(@Const @ByVal ecl_data_type arg0);
public static native @Cast("bool") boolean ecl_type_is_alpha(@Const @ByVal ecl_data_type arg0);
public static native @Cast("bool") boolean ecl_type_is_char(@Const @ByVal ecl_data_type arg0);
public static native @Cast("bool") boolean ecl_type_is_int(@Const @ByVal ecl_data_type arg0);
public static native @Cast("bool") boolean ecl_type_is_float(@Const @ByVal ecl_data_type arg0);
public static native @Cast("bool") boolean ecl_type_is_double(@Const @ByVal ecl_data_type arg0);
public static native @Cast("bool") boolean ecl_type_is_mess(@Const @ByVal ecl_data_type arg0);
public static native @Cast("bool") boolean ecl_type_is_bool(@Const @ByVal ecl_data_type arg0);
public static native @Cast("bool") boolean ecl_type_is_string(@Const @ByVal ecl_data_type arg0);

// Temporary fixup for OPM.
public static native @Cast("char*") BytePointer ecl_type_get_name(@Const @ByVal ecl_data_type arg0);

// #ifdef __cplusplus
// #endif


// #endif


// Parsed from ert/ecl/ecl_util.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_util.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_UTIL_H
// #define ERT_ECL_UTIL_H
// #ifdef __cplusplus
// #endif
// #include <stdbool.h>
// #include <time.h>

// #include <ert/util/stringlist.hpp>
// #include <ert/util/time_t_vector.hpp>
// #include <ert/util/parser.hpp>
// #include <ert/ecl/ecl_type.hpp>


/** enum ecl_file_enum */
public static final int ECL_OTHER_FILE           = 0,
               ECL_RESTART_FILE         = 1,
               ECL_UNIFIED_RESTART_FILE = 2,
               ECL_SUMMARY_FILE         = 4,
               ECL_UNIFIED_SUMMARY_FILE = 8,
               ECL_SUMMARY_HEADER_FILE  = 16,
               ECL_GRID_FILE            = 32,
               ECL_EGRID_FILE           = 64,
               ECL_INIT_FILE            = 128,
               ECL_RFT_FILE             = 256,
               ECL_DATA_FILE            = 512;



  /*
    This enum enumerates the four different ways summary and restart information
    can be stored.
  */


  /** enum ecl_storage_enum */
  public static final int ECL_INVALID_STORAGE       = 0,
                 ECL_BINARY_UNIFIED        = 1,
                 ECL_FORMATTED_UNIFIED     = 2,
                 ECL_BINARY_NON_UNIFIED    = 4,
                 ECL_FORMATTED_NON_UNIFIED = 8;

/*
  The libecl library has been built and tested 99.5% with ECLIPSE100
  as context, but in thye gravity code there is some very limited
  functionality related to ECLIPSE100 versus ECLIPSE300 functionality.

  Observe that numerical values found as part of the INTEHAD keyword
  differ from these values, and are found in the ecl_kw_magic.h
  header.
*/

/** enum ecl_version_enum */
public static final int
  ECLIPSE_UNDEFINED  = 0,
  ECLIPSE100         = 1,
  ECLIPSE300         = 2,
  ECLIPSE300_THERMAL = 3,
  INTERSECT          = 4,
  FRONTSIM           = 5;

/*
  Observe that the numerical enum VALUES matches those found in item
  14 in the INTEHEAD keyword in the ECLIPSE INIT files; i.e. the
  distribution of numerical values 1,2,4 can NOT BE CHANGED.

  The function ecl_util_get_phase_name() can be used to lookup a
  string name from an enum value.

  The phases in a simulation will typically be a sum of these
  fundamental phases, and represented as an integer.
*/

/** enum ecl_phase_enum */
public static final int
  ECL_OIL_PHASE   = 1,
  ECL_GAS_PHASE   = 2,
  ECL_WATER_PHASE = 4;

public static native @MemberGetter double ECL_PHASE_ENUM_DEFS();
public static final double ECL_PHASE_ENUM_DEFS = ECL_PHASE_ENUM_DEFS();
public static final int ECL_PHASE_ENUM_SIZE = 3;

/** enum ert_ecl_unit_enum */
public static final int
  ECL_METRIC_UNITS = 1,
  ECL_FIELD_UNITS  = 2,
  ECL_LAB_UNITS    = 3,
  ECL_PVT_M_UNITS  = 4;


// For unformatted files:
public static final int ECL_BOOL_TRUE_INT =         -1;   // Binary representation: 11111111  11111111  11111111  1111111
public static final int ECL_BOOL_FALSE_INT =         0;   // Binary representation: 00000000  00000000  00000000  0000000
public static final String ECL_COMMENT_STRING =       "--";
public static final int ECL_COMMENT_CHAR =         '-';   // Need to consecutive to make an ECLIPSE comment
public static final String ECL_DATA_TERMINATION =      "/";


/*****************************************************************/
public static native @Cast("bool") boolean ecl_util_unified_file(@Cast("const char*") BytePointer filename);
public static native @Cast("bool") boolean ecl_util_unified_file(String filename);
public static native @Cast("const char*") BytePointer ecl_util_file_type_name( @Cast("ecl_file_enum") int file_type );
public static native @Cast("char*") BytePointer ecl_util_alloc_base_guess(@Cast("const char*") BytePointer arg0);
public static native @Cast("char*") ByteBuffer ecl_util_alloc_base_guess(String arg0);
public static native int ecl_util_filename_report_nr(@Cast("const char*") BytePointer arg0);
public static native int ecl_util_filename_report_nr(String arg0);
public static native @Cast("ecl_file_enum") int ecl_util_inspect_extension(@Cast("const char*") BytePointer ext, @Cast("bool*") BoolPointer _fmt_file, IntPointer _report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_inspect_extension(String ext, @Cast("bool*") boolean[] _fmt_file, IntBuffer _report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_inspect_extension(@Cast("const char*") BytePointer ext, @Cast("bool*") BoolPointer _fmt_file, int[] _report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_inspect_extension(String ext, @Cast("bool*") boolean[] _fmt_file, IntPointer _report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_inspect_extension(@Cast("const char*") BytePointer ext, @Cast("bool*") BoolPointer _fmt_file, IntBuffer _report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_inspect_extension(String ext, @Cast("bool*") boolean[] _fmt_file, int[] _report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_get_file_type(@Cast("const char*") BytePointer filename, @Cast("bool*") BoolPointer fmt_file, IntPointer report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_get_file_type(String filename, @Cast("bool*") boolean[] fmt_file, IntBuffer report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_get_file_type(@Cast("const char*") BytePointer filename, @Cast("bool*") BoolPointer fmt_file, int[] report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_get_file_type(String filename, @Cast("bool*") boolean[] fmt_file, IntPointer report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_get_file_type(@Cast("const char*") BytePointer filename, @Cast("bool*") BoolPointer fmt_file, IntBuffer report_nr);
public static native @Cast("ecl_file_enum") int ecl_util_get_file_type(String filename, @Cast("bool*") boolean[] fmt_file, int[] report_nr);
public static native @Cast("char*") BytePointer ecl_util_alloc_filename(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("ecl_file_enum") int arg2, @Cast("bool") boolean arg3, int arg4);
public static native @Cast("char*") ByteBuffer ecl_util_alloc_filename(String arg0, String arg1, @Cast("ecl_file_enum") int arg2, @Cast("bool") boolean arg3, int arg4);
public static native @Cast("char*") BytePointer ecl_util_alloc_exfilename(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("ecl_file_enum") int arg2, @Cast("bool") boolean arg3, int arg4);
public static native @Cast("char*") ByteBuffer ecl_util_alloc_exfilename(String arg0, String arg1, @Cast("ecl_file_enum") int arg2, @Cast("bool") boolean arg3, int arg4);
public static native void ecl_util_memcpy_typed_data(Pointer arg0, @Const Pointer arg1, @ByVal ecl_data_type arg2, @ByVal ecl_data_type arg3, int arg4 );
public static native void ecl_util_escape_kw(@Cast("char*") BytePointer kw);
public static native void ecl_util_escape_kw(@Cast("char*") ByteBuffer kw);
public static native void ecl_util_escape_kw(@Cast("char*") byte[] kw);
public static native @Cast("bool") boolean ecl_util_alloc_summary_files(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, @Cast("char**") PointerPointer arg3, stringlist_type arg4 );
public static native @Cast("bool") boolean ecl_util_alloc_summary_files(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, @Cast("char**") @ByPtrPtr BytePointer arg3, stringlist_type arg4 );
public static native @Cast("bool") boolean ecl_util_alloc_summary_files(String arg0, String arg1, String arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3, stringlist_type arg4 );
public static native @Cast("bool") boolean ecl_util_alloc_summary_files(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, @Cast("char**") @ByPtrPtr byte[] arg3, stringlist_type arg4 );
public static native @Cast("bool") boolean ecl_util_alloc_summary_files(String arg0, String arg1, String arg2, @Cast("char**") @ByPtrPtr BytePointer arg3, stringlist_type arg4 );
public static native @Cast("bool") boolean ecl_util_alloc_summary_files(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3, stringlist_type arg4 );
public static native @Cast("bool") boolean ecl_util_alloc_summary_files(String arg0, String arg1, String arg2, @Cast("char**") @ByPtrPtr byte[] arg3, stringlist_type arg4 );
public static native void ecl_util_alloc_summary_data_files(@Cast("const char*") BytePointer path, @Cast("const char*") BytePointer base, @Cast("bool") boolean fmt_file, stringlist_type filelist);
public static native void ecl_util_alloc_summary_data_files(String path, String base, @Cast("bool") boolean fmt_file, stringlist_type filelist);
public static native void ecl_util_alloc_restart_files(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2, IntPointer arg3, @Cast("bool*") BoolPointer arg4, @Cast("bool*") BoolPointer arg5);
public static native void ecl_util_alloc_restart_files(String arg0, String arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2, IntBuffer arg3, @Cast("bool*") boolean[] arg4, @Cast("bool*") boolean[] arg5);
public static native void ecl_util_alloc_restart_files(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2, int[] arg3, @Cast("bool*") BoolPointer arg4, @Cast("bool*") BoolPointer arg5);
public static native void ecl_util_alloc_restart_files(String arg0, String arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2, IntPointer arg3, @Cast("bool*") boolean[] arg4, @Cast("bool*") boolean[] arg5);
public static native void ecl_util_alloc_restart_files(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2, IntBuffer arg3, @Cast("bool*") BoolPointer arg4, @Cast("bool*") BoolPointer arg5);
public static native void ecl_util_alloc_restart_files(String arg0, String arg1, @Cast("char***") @ByPtrPtr PointerPointer arg2, int[] arg3, @Cast("bool*") boolean[] arg4, @Cast("bool*") boolean[] arg5);
public static native @ByVal @Cast("time_t*") Pointer ecl_util_get_start_date(@Cast("const char*") BytePointer arg0 );
public static native @ByVal @Cast("time_t*") Pointer ecl_util_get_start_date(String arg0 );
public static native int ecl_util_get_num_cpu(@Cast("const char*") BytePointer data_file);
public static native int ecl_util_get_num_cpu(String data_file);
public static native @Cast("bool") boolean ecl_util_fmt_file(@Cast("const char*") BytePointer filename, @Cast("bool*") BoolPointer __fmt_file);
public static native @Cast("bool") boolean ecl_util_fmt_file(String filename, @Cast("bool*") boolean[] __fmt_file);
public static native @Cast("char*") BytePointer ecl_util_alloc_exfilename_anyfmt(@Cast("const char*") BytePointer path, @Cast("const char*") BytePointer base, @Cast("ecl_file_enum") int file_type, @Cast("bool") boolean start_fmt, int report_nr);
public static native @Cast("char*") ByteBuffer ecl_util_alloc_exfilename_anyfmt(String path, String base, @Cast("ecl_file_enum") int file_type, @Cast("bool") boolean start_fmt, int report_nr);
public static native int ecl_util_get_month_nr(@Cast("const char*") BytePointer month_name);
public static native int ecl_util_get_month_nr(String month_name);
public static native int ecl_util_fname_report_cmp(@Const Pointer f1, @Const Pointer f2);
public static native @ByVal @Cast("time_t*") Pointer ecl_util_make_date(int mday, int month, int year);
public static native @ByVal @Cast("time_t*") Pointer ecl_util_make_date__(int mday, int month, int year, IntPointer year_offset);
public static native @ByVal @Cast("time_t*") Pointer ecl_util_make_date__(int mday, int month, int year, IntBuffer year_offset);
public static native @ByVal @Cast("time_t*") Pointer ecl_util_make_date__(int mday, int month, int year, int[] year_offset);
public static native @ByVal @Cast("time_t*") Pointer ecl_util_make_datetime(int sec, int min, int hour, int mday, int month, int year);
public static native @Cast("ert_ecl_unit_enum") int ecl_util_get_unit_set(@Cast("const char*") BytePointer data_file);
public static native @Cast("ert_ecl_unit_enum") int ecl_util_get_unit_set(String data_file);

public static native @Cast("bool") boolean ecl_util_valid_basename_fmt( @Cast("const char*") BytePointer basename_fmt );
public static native @Cast("bool") boolean ecl_util_valid_basename_fmt( String basename_fmt );
public static native @Cast("bool") boolean ecl_util_valid_basename( @Cast("const char*") BytePointer basename );
public static native @Cast("bool") boolean ecl_util_valid_basename( String basename );
public static native @Cast("const char*") BytePointer ecl_util_get_phase_name( @Cast("ecl_phase_enum") int phase );

public static native int ecl_util_select_filelist( @Cast("const char*") BytePointer path, @Cast("const char*") BytePointer base, @Cast("ecl_file_enum") int file_type, @Cast("bool") boolean fmt_file, stringlist_type filelist);
public static native int ecl_util_select_filelist( String path, String base, @Cast("ecl_file_enum") int file_type, @Cast("bool") boolean fmt_file, stringlist_type filelist);
public static native void ecl_util_append_month_range( time_t_vector_type date_list, @ByVal @Cast("time_t*") Pointer start_date, @ByVal @Cast("time_t*") Pointer end_date, @Cast("bool") boolean force_append_end);
public static native void ecl_util_init_month_range( time_t_vector_type date_list, @ByVal @Cast("time_t*") Pointer start_date, @ByVal @Cast("time_t*") Pointer end_date);
public static native void ecl_util_set_date_values(@ByVal @Cast("time_t*") Pointer t, IntPointer mday, IntPointer month, IntPointer year);
public static native void ecl_util_set_date_values(@ByVal @Cast("time_t*") Pointer t, IntBuffer mday, IntBuffer month, IntBuffer year);
public static native void ecl_util_set_date_values(@ByVal @Cast("time_t*") Pointer t, int[] mday, int[] month, int[] year);
public static native void ecl_util_set_datetime_values(@ByVal @Cast("time_t*") Pointer t, IntPointer sec, IntPointer min, IntPointer hour, IntPointer mday, IntPointer month, IntPointer year);
public static native void ecl_util_set_datetime_values(@ByVal @Cast("time_t*") Pointer t, IntBuffer sec, IntBuffer min, IntBuffer hour, IntBuffer mday, IntBuffer month, IntBuffer year);
public static native void ecl_util_set_datetime_values(@ByVal @Cast("time_t*") Pointer t, int[] sec, int[] min, int[] hour, int[] mday, int[] month, int[] year);
public static native @Cast("bool") boolean ecl_util_path_access(@Cast("const char*") BytePointer ecl_case);
public static native @Cast("bool") boolean ecl_util_path_access(String ecl_case);
// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/fortio.h

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'fortio.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_FORTIO_H
// #define ERT_FORTIO_H
// #ifdef __cplusplus
// #endif

// #include <stdlib.h>
// #include <stdio.h>
// #include <stdbool.h>

// #include <ert/util/util.h>
// #include <ert/util/type_macros.hpp>

/** enum fortio_status_type */
public static final int
  FORTIO_NOENTRY         = 0,    /* File does not exists at all - application error. */
  FORTIO_EOF             = 1,    /* The file / record is empty */
  FORTIO_OK              = 2,    /* The file / record is OK with: [32 bit header | data | 32 bit footer] */
  FORTIO_MISSING_DATA    = 3,
  FORTIO_MISSING_TAIL    = 4,
  FORTIO_HEADER_MISMATCH = 5;
// Targeting ../fortio_type.java



  public static native @Cast("fortio_status_type") int fortio_check_buffer( @Cast("FILE*") Pointer stream, @Cast("bool") boolean endian_flip, @Cast("size_t") long buffer_size );
  public static native @Cast("fortio_status_type") int fortio_check_file( @Cast("const char*") BytePointer filename, @Cast("bool") boolean endian_flip);
  public static native @Cast("fortio_status_type") int fortio_check_file( String filename, @Cast("bool") boolean endian_flip);
  public static native @Cast("bool") boolean fortio_looks_like_fortran_file(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean arg1 );
  public static native @Cast("bool") boolean fortio_looks_like_fortran_file(String arg0, @Cast("bool") boolean arg1 );
  public static native void fortio_copy_record(fortio_type arg0, fortio_type arg1, int arg2, Pointer arg3, @Cast("bool*") BoolPointer arg4);
  public static native void fortio_copy_record(fortio_type arg0, fortio_type arg1, int arg2, Pointer arg3, @Cast("bool*") boolean[] arg4);
  public static native fortio_type fortio_open_reader(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean fmt_file, @Cast("bool") boolean endian_flip_header);
  public static native fortio_type fortio_open_reader(String arg0, @Cast("bool") boolean fmt_file, @Cast("bool") boolean endian_flip_header);
  public static native fortio_type fortio_open_writer(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean fmt_file, @Cast("bool") boolean endian_flip_header);
  public static native fortio_type fortio_open_writer(String arg0, @Cast("bool") boolean fmt_file, @Cast("bool") boolean endian_flip_header);
  public static native fortio_type fortio_open_readwrite(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean fmt_file, @Cast("bool") boolean endian_flip_header);
  public static native fortio_type fortio_open_readwrite(String arg0, @Cast("bool") boolean fmt_file, @Cast("bool") boolean endian_flip_header);
  public static native fortio_type fortio_open_append(@Cast("const char*") BytePointer filename, @Cast("bool") boolean fmt_file, @Cast("bool") boolean endian_flip_header);
  public static native fortio_type fortio_open_append(String filename, @Cast("bool") boolean fmt_file, @Cast("bool") boolean endian_flip_header);
  public static native fortio_type fortio_alloc_FILE_wrapper(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean arg1, @Cast("bool") boolean arg2, @Cast("bool") boolean arg3, @Cast("FILE*") Pointer arg4 );
  public static native fortio_type fortio_alloc_FILE_wrapper(String arg0, @Cast("bool") boolean arg1, @Cast("bool") boolean arg2, @Cast("bool") boolean arg3, @Cast("FILE*") Pointer arg4 );
  public static native void fortio_free_FILE_wrapper(fortio_type arg0);
  public static native void fortio_fclose(fortio_type arg0);
  public static native int fortio_init_read(fortio_type arg0);
  public static native @Cast("bool") boolean fortio_complete_read(fortio_type arg0, int record_size);
  public static native void fortio_init_write(fortio_type arg0, int arg1);
  public static native void fortio_complete_write(fortio_type arg0, int record_size);
  public static native void fortio_fskip_buffer(fortio_type arg0, int arg1 );
  public static native int fortio_fskip_record(fortio_type arg0);
  public static native @Cast("bool") boolean fortio_fread_buffer(fortio_type arg0, @Cast("char*") BytePointer buffer, int buffer_size);
  public static native @Cast("bool") boolean fortio_fread_buffer(fortio_type arg0, @Cast("char*") ByteBuffer buffer, int buffer_size);
  public static native @Cast("bool") boolean fortio_fread_buffer(fortio_type arg0, @Cast("char*") byte[] buffer, int buffer_size);
  public static native void fortio_fwrite_record(fortio_type arg0, @Cast("const char*") BytePointer buffer, int buffer_size);
  public static native void fortio_fwrite_record(fortio_type arg0, String buffer, int buffer_size);
  public static native @Cast("FILE*") Pointer fortio_get_FILE(@Const fortio_type arg0);
  public static native void fortio_fflush(fortio_type arg0 );
  public static native @Cast("bool") boolean fortio_ftruncate_current( fortio_type fortio);
  public static native @Cast("bool") boolean fortio_is_fortio_file(fortio_type arg0 );
  public static native void fortio_rewind(@Const fortio_type fortio);
  public static native @Cast("const char*") BytePointer fortio_filename_ref(@Const fortio_type arg0 );
  public static native @Cast("bool") boolean fortio_fmt_file(@Const fortio_type arg0);
  public static native @Cast("offset_type") long fortio_ftell( @Const fortio_type fortio );
  public static native @Cast("bool") boolean fortio_fseek( fortio_type fortio, @Cast("offset_type") long offset, int whence);
  public static native @Cast("bool") boolean fortio_data_fskip(fortio_type fortio, int element_size, int element_count, int block_count);
  public static native void fortio_data_fseek(fortio_type fortio, @Cast("offset_type") long data_offset, @Cast("size_t") long data_element, int element_size, int element_count, int block_size);
  public static native int fortio_fileno( fortio_type fortio );
  public static native @Cast("bool") boolean fortio_ftruncate( fortio_type fortio, @Cast("offset_type") long size);
  public static native int fortio_fclean(fortio_type fortio);

  public static native @Cast("bool") boolean fortio_fclose_stream( fortio_type fortio );
  public static native @Cast("bool") boolean fortio_fopen_stream( fortio_type fortio );
  public static native @Cast("bool") boolean fortio_stream_is_open( @Const fortio_type fortio );
  public static native @Cast("bool") boolean fortio_assert_stream_open( fortio_type fortio );
  public static native @Cast("bool") boolean fortio_read_at_eof( fortio_type fortio );
  public static native void fortio_fwrite_error(fortio_type fortio);

public static native @Cast("bool") boolean fortio_is_instance( @Const Pointer __arg );
public static native fortio_type fortio_safe_cast( Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_kw.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_kw.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_KW_H
// #define ERT_ECL_KW_H
// #ifdef __cplusplus
// #endif
// #include <stdbool.h>
// #include <stdlib.h>
// #include <stdio.h>
// #include <limits.h>

// #include <ert/util/buffer.hpp>
// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/fortio.h>
// #include <ert/ecl/ecl_util.hpp>
// #include <ert/ecl/ecl_type.hpp>

  public static native @Cast("bool") boolean ecl_kw_is_instance( @Const Pointer __arg );
// Targeting ../ecl_kw_type.java



  /** enum ecl_read_status_enum */
  public static final int
    ECL_KW_READ_OK = 0,
    ECL_KW_READ_FAIL = 1;

/*
  The size of an ecl_kw instance is denoted with an integer. The
  choice of int to store the size obviously limits the maximum size to
  INT_MAX elements. This choice is an historical mistake - it should
  probably have been size_t; however the ecl_kw datastructure is
  tightly bound to the on-disk binary format supplied by Eclipse, and
  there the number of elements is stored as a signed(?) 32 bit
  integer - so using int for size does make some sense-
*/

public static final int ECL_KW_MAX_SIZE =Integer.MAX_VALUE;

/*
  Character data in ECLIPSE files comes as an array of fixed-length
  string. Each of these strings is 8 characters long. The type name,
  i.e. 'REAL', 'INTE', ... , come as 4 character strings.
*/
public static final int ECL_KW_HEADER_DATA_SIZE =   ECL_STRING8_LENGTH + ECL_TYPE_LENGTH + 4;
public static final int ECL_KW_HEADER_FORTIO_SIZE = ECL_KW_HEADER_DATA_SIZE + 8;



  public static native int ecl_kw_first_different( @Const ecl_kw_type kw1, @Const ecl_kw_type kw2, int offset, double abs_epsilon, double rel_epsilon);
  public static native @Cast("size_t") long ecl_kw_fortio_size( @Const ecl_kw_type ecl_kw );
  public static native Pointer ecl_kw_get_ptr(@Const ecl_kw_type ecl_kw);
  public static native void ecl_kw_set_data_ptr(ecl_kw_type ecl_kw, Pointer data);
  public static native void ecl_kw_fwrite_data(@Const ecl_kw_type _ecl_kw, fortio_type fortio);
  public static native @Cast("bool") boolean ecl_kw_fread_realloc_data(ecl_kw_type ecl_kw, fortio_type fortio);
  public static native @ByVal ecl_data_type ecl_kw_get_data_type(@Const ecl_kw_type arg0);
  public static native @Cast("const char*") BytePointer ecl_kw_get_header8(@Const ecl_kw_type arg0);
  public static native @Cast("const char*") BytePointer ecl_kw_get_header(@Const ecl_kw_type ecl_kw );
  public static native ecl_kw_type ecl_kw_alloc_empty();
  public static native @Cast("ecl_read_status_enum") int ecl_kw_fread_header(ecl_kw_type arg0, fortio_type arg1);
  public static native void ecl_kw_set_header_name(ecl_kw_type arg0, @Cast("const char*") BytePointer arg1 );
  public static native void ecl_kw_set_header_name(ecl_kw_type arg0, String arg1 );
  public static native @Cast("bool") boolean ecl_kw_fseek_kw(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean arg1, @Cast("bool") boolean arg2, fortio_type arg3);
  public static native @Cast("bool") boolean ecl_kw_fseek_kw(String arg0, @Cast("bool") boolean arg1, @Cast("bool") boolean arg2, fortio_type arg3);
  public static native @Cast("bool") boolean ecl_kw_fseek_last_kw(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean arg1, fortio_type arg2);
  public static native @Cast("bool") boolean ecl_kw_fseek_last_kw(String arg0, @Cast("bool") boolean arg1, fortio_type arg2);
  public static native void ecl_kw_inplace_update_file(@Const ecl_kw_type arg0, @Cast("const char*") BytePointer arg1, int arg2 );
  public static native void ecl_kw_inplace_update_file(@Const ecl_kw_type arg0, String arg1, int arg2 );
  public static native void ecl_kw_fskip(fortio_type arg0);
  public static native void ecl_kw_alloc_data(ecl_kw_type arg0);
  public static native void ecl_kw_alloc_double_data(ecl_kw_type ecl_kw, DoublePointer values);
  public static native void ecl_kw_alloc_double_data(ecl_kw_type ecl_kw, DoubleBuffer values);
  public static native void ecl_kw_alloc_double_data(ecl_kw_type ecl_kw, double[] values);
  public static native void ecl_kw_alloc_float_data(ecl_kw_type ecl_kw, FloatPointer values);
  public static native void ecl_kw_alloc_float_data(ecl_kw_type ecl_kw, FloatBuffer values);
  public static native void ecl_kw_alloc_float_data(ecl_kw_type ecl_kw, float[] values);
  public static native @Cast("bool") boolean ecl_kw_fread_realloc(ecl_kw_type arg0, fortio_type arg1);
  public static native void ecl_kw_fread(ecl_kw_type arg0, fortio_type arg1 );
  public static native ecl_kw_type ecl_kw_fread_alloc(fortio_type arg0);
  public static native ecl_kw_type ecl_kw_alloc_actnum(@Const ecl_kw_type porv_kw, float porv_limit);
  public static native ecl_kw_type ecl_kw_alloc_actnum_bitmask(@Const ecl_kw_type porv_kw, float porv_limit, int actnum_bitmask);
  public static native void ecl_kw_free_data(ecl_kw_type arg0);
  public static native void ecl_kw_fread_indexed_data(fortio_type fortio, @Cast("offset_type") long data_offset, @ByVal ecl_data_type arg2, int element_count, @Const int_vector_type index_map, @Cast("char*") BytePointer buffer);
  public static native void ecl_kw_fread_indexed_data(fortio_type fortio, @Cast("offset_type") long data_offset, @ByVal ecl_data_type arg2, int element_count, @Const int_vector_type index_map, @Cast("char*") ByteBuffer buffer);
  public static native void ecl_kw_fread_indexed_data(fortio_type fortio, @Cast("offset_type") long data_offset, @ByVal ecl_data_type arg2, int element_count, @Const int_vector_type index_map, @Cast("char*") byte[] buffer);
  public static native void ecl_kw_free(ecl_kw_type arg0);
  public static native void ecl_kw_free__(Pointer arg0);
  public static native ecl_kw_type ecl_kw_alloc_copy(@Const ecl_kw_type arg0);
  public static native ecl_kw_type ecl_kw_alloc_sub_copy( @Const ecl_kw_type src, @Cast("const char*") BytePointer new_kw, int offset, int count);
  public static native ecl_kw_type ecl_kw_alloc_sub_copy( @Const ecl_kw_type src, String new_kw, int offset, int count);
  public static native @Const Pointer ecl_kw_copyc__(@Const Pointer arg0);
  public static native ecl_kw_type ecl_kw_alloc_slice_copy( @Const ecl_kw_type src, int index1, int index2, int stride);
  public static native void ecl_kw_resize( ecl_kw_type ecl_kw, int new_size);
  //void        * ecl_kw_get_data_ref(const ecl_kw_type *);
  public static native Pointer ecl_kw_alloc_data_copy(@Const ecl_kw_type arg0 );
  public static native void ecl_kw_memcpy(ecl_kw_type arg0, @Const ecl_kw_type arg1);
  public static native void ecl_kw_get_memcpy_data(@Const ecl_kw_type arg0, Pointer arg1);
  public static native void ecl_kw_get_memcpy_float_data(@Const ecl_kw_type ecl_kw, FloatPointer target);
  public static native void ecl_kw_get_memcpy_float_data(@Const ecl_kw_type ecl_kw, FloatBuffer target);
  public static native void ecl_kw_get_memcpy_float_data(@Const ecl_kw_type ecl_kw, float[] target);
  public static native void ecl_kw_get_memcpy_double_data(@Const ecl_kw_type ecl_kw, DoublePointer target);
  public static native void ecl_kw_get_memcpy_double_data(@Const ecl_kw_type ecl_kw, DoubleBuffer target);
  public static native void ecl_kw_get_memcpy_double_data(@Const ecl_kw_type ecl_kw, double[] target);
  public static native void ecl_kw_get_memcpy_int_data(@Const ecl_kw_type ecl_kw, IntPointer target);
  public static native void ecl_kw_get_memcpy_int_data(@Const ecl_kw_type ecl_kw, IntBuffer target);
  public static native void ecl_kw_get_memcpy_int_data(@Const ecl_kw_type ecl_kw, int[] target);
  public static native void ecl_kw_set_memcpy_data(ecl_kw_type arg0, @Const Pointer arg1);
  public static native @Cast("bool") boolean ecl_kw_fwrite(@Const ecl_kw_type arg0,  fortio_type arg1);
  public static native void ecl_kw_iget(@Const ecl_kw_type arg0, int arg1, Pointer arg2);
  public static native void ecl_kw_iset(ecl_kw_type ecl_kw, int i, @Const Pointer iptr);
  public static native void ecl_kw_iset_char_ptr( ecl_kw_type ecl_kw, int index, @Cast("const char*") BytePointer s);
  public static native void ecl_kw_iset_char_ptr( ecl_kw_type ecl_kw, int index, String s);
  public static native void ecl_kw_iset_string8(ecl_kw_type ecl_kw, int index, @Cast("const char*") BytePointer s8);
  public static native void ecl_kw_iset_string8(ecl_kw_type ecl_kw, int index, String s8);
  public static native void ecl_kw_iset_string_ptr(ecl_kw_type arg0, int arg1, @Cast("const char*") BytePointer arg2);
  public static native void ecl_kw_iset_string_ptr(ecl_kw_type arg0, int arg1, String arg2);
  public static native @Cast("const char*") BytePointer ecl_kw_iget_string_ptr(@Const ecl_kw_type arg0, int arg1);
  public static native @Cast("const char*") BytePointer ecl_kw_iget_char_ptr( @Const ecl_kw_type ecl_kw, int i);
  public static native Pointer ecl_kw_iget_ptr(@Const ecl_kw_type arg0, int arg1);
  public static native int ecl_kw_get_size(@Const ecl_kw_type arg0);
  public static native @Cast("bool") boolean ecl_kw_ichar_eq(@Const ecl_kw_type arg0, int arg1, @Cast("const char*") BytePointer arg2);
  public static native @Cast("bool") boolean ecl_kw_ichar_eq(@Const ecl_kw_type arg0, int arg1, String arg2);
  public static native ecl_kw_type ecl_kw_alloc( @Cast("const char*") BytePointer header, int size, @ByVal ecl_data_type arg2 );
  public static native ecl_kw_type ecl_kw_alloc( String header, int size, @ByVal ecl_data_type arg2 );
  public static native ecl_kw_type ecl_kw_alloc_new(@Cast("const char*") BytePointer arg0,  int arg1, @ByVal ecl_data_type arg2, @Const Pointer arg3 );
  public static native ecl_kw_type ecl_kw_alloc_new(String arg0,  int arg1, @ByVal ecl_data_type arg2, @Const Pointer arg3 );
  public static native ecl_kw_type ecl_kw_alloc_new_shared(@Cast("const char*") BytePointer arg0,  int arg1, @ByVal ecl_data_type arg2, Pointer arg3 );
  public static native ecl_kw_type ecl_kw_alloc_new_shared(String arg0,  int arg1, @ByVal ecl_data_type arg2, Pointer arg3 );
  public static native ecl_kw_type ecl_kw_alloc_global_copy(@Const ecl_kw_type src, @Const ecl_kw_type actnum);
  public static native void ecl_kw_fwrite_param(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean arg1, @Cast("const char*") BytePointer arg2,  @ByVal ecl_data_type arg3, int arg4, Pointer arg5 );
  public static native void ecl_kw_fwrite_param(String arg0, @Cast("bool") boolean arg1, String arg2,  @ByVal ecl_data_type arg3, int arg4, Pointer arg5 );
  public static native void ecl_kw_fwrite_param_fortio(fortio_type arg0, @Cast("const char*") BytePointer arg1,  @ByVal ecl_data_type arg2, int arg3, Pointer arg4 );
  public static native void ecl_kw_fwrite_param_fortio(fortio_type arg0, String arg1,  @ByVal ecl_data_type arg2, int arg3, Pointer arg4 );
  public static native void ecl_kw_summarize(@Const ecl_kw_type ecl_kw);
  public static native void ecl_kw_fread_double_param(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean arg1, DoublePointer arg2);
  public static native void ecl_kw_fread_double_param(String arg0, @Cast("bool") boolean arg1, DoubleBuffer arg2);
  public static native void ecl_kw_fread_double_param(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean arg1, double[] arg2);
  public static native void ecl_kw_fread_double_param(String arg0, @Cast("bool") boolean arg1, DoublePointer arg2);
  public static native void ecl_kw_fread_double_param(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean arg1, DoubleBuffer arg2);
  public static native void ecl_kw_fread_double_param(String arg0, @Cast("bool") boolean arg1, double[] arg2);
  public static native float ecl_kw_iget_as_float(@Const ecl_kw_type ecl_kw, int i);
  public static native double ecl_kw_iget_as_double(@Const ecl_kw_type ecl_kw, int i);
  public static native void ecl_kw_get_data_as_double(@Const ecl_kw_type arg0, DoublePointer arg1);
  public static native void ecl_kw_get_data_as_double(@Const ecl_kw_type arg0, DoubleBuffer arg1);
  public static native void ecl_kw_get_data_as_double(@Const ecl_kw_type arg0, double[] arg1);
  public static native void ecl_kw_get_data_as_float(@Const ecl_kw_type ecl_kw, FloatPointer float_data);
  public static native void ecl_kw_get_data_as_float(@Const ecl_kw_type ecl_kw, FloatBuffer float_data);
  public static native void ecl_kw_get_data_as_float(@Const ecl_kw_type ecl_kw, float[] float_data);
  public static native @Cast("bool") boolean ecl_kw_name_equal( @Const ecl_kw_type ecl_kw, @Cast("const char*") BytePointer name);
  public static native @Cast("bool") boolean ecl_kw_name_equal( @Const ecl_kw_type ecl_kw, String name);
  public static native @Cast("bool") boolean ecl_kw_header_eq(@Const ecl_kw_type ecl_kw1, @Const ecl_kw_type ecl_kw2);
  public static native @Cast("bool") boolean ecl_kw_equal(@Const ecl_kw_type ecl_kw1, @Const ecl_kw_type ecl_kw2);
  public static native @Cast("bool") boolean ecl_kw_size_and_type_equal( @Const ecl_kw_type ecl_kw1, @Const ecl_kw_type ecl_kw2 );
  public static native @Cast("bool") boolean ecl_kw_icmp_string( @Const ecl_kw_type ecl_kw, int index, @Cast("const char*") BytePointer other_string);
  public static native @Cast("bool") boolean ecl_kw_icmp_string( @Const ecl_kw_type ecl_kw, int index, String other_string);
  public static native @Cast("bool") boolean ecl_kw_numeric_equal(@Const ecl_kw_type ecl_kw1, @Const ecl_kw_type ecl_kw2, double abs_diff, double rel_diff);
  public static native @Cast("bool") boolean ecl_kw_block_equal( @Const ecl_kw_type ecl_kw1, @Const ecl_kw_type ecl_kw2, int cmp_elements);
  public static native @Cast("bool") boolean ecl_kw_data_equal( @Const ecl_kw_type ecl_kw, @Const Pointer data);
  public static native @Cast("bool") boolean ecl_kw_content_equal( @Const ecl_kw_type ecl_kw1, @Const ecl_kw_type ecl_kw2);
  public static native @Cast("bool") boolean ecl_kw_fskip_data__( @ByVal ecl_data_type arg0, int arg1, fortio_type arg2);
  public static native @Cast("bool") boolean ecl_kw_fskip_data(ecl_kw_type ecl_kw, fortio_type fortio);
  public static native @Cast("bool") boolean ecl_kw_fread_data(ecl_kw_type ecl_kw, fortio_type fortio);
  public static native void ecl_kw_fskip_header( fortio_type fortio);
  public static native @Cast("bool") boolean ecl_kw_size_and_numeric_type_equal( @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);
  public static native @Cast("bool") boolean ecl_kw_inplace_safe_div(ecl_kw_type target_kw, @Const ecl_kw_type divisor);
  public static native void ecl_kw_inplace_sqrt( ecl_kw_type kw );


  public static native @Cast("bool") boolean ecl_kw_is_kw_file(fortio_type fortio);

  public static native int ecl_kw_element_sum_int( @Const ecl_kw_type ecl_kw );
  public static native double ecl_kw_element_sum_float( @Const ecl_kw_type ecl_kw );
  public static native void ecl_kw_inplace_inv(ecl_kw_type my_kw);
  public static native void ecl_kw_element_sum(@Const ecl_kw_type arg0, Pointer arg1 );
  public static native void ecl_kw_element_sum_indexed(@Const ecl_kw_type ecl_kw, @Const int_vector_type index_list, Pointer _sum);
  public static native void ecl_kw_max_min(@Const ecl_kw_type arg0, Pointer arg1, Pointer arg2);
  public static native Pointer ecl_kw_get_void_ptr(@Const ecl_kw_type ecl_kw);

  public static native ecl_kw_type ecl_kw_buffer_alloc(buffer_type buffer);
  public static native void ecl_kw_buffer_store(@Const ecl_kw_type ecl_kw, buffer_type buffer);

  public static native void ecl_kw_fprintf_data( @Const ecl_kw_type ecl_kw, @Cast("const char*") BytePointer fmt, @Cast("FILE*") Pointer stream);
  public static native void ecl_kw_fprintf_data( @Const ecl_kw_type ecl_kw, String fmt, @Cast("FILE*") Pointer stream);
  public static native void ecl_kw_memcpy_data( ecl_kw_type target, @Const ecl_kw_type src);

  public static native @Cast("bool") boolean ecl_kw_assert_numeric( @Const ecl_kw_type kw );
  public static native @Cast("bool") boolean ecl_kw_assert_binary( @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);

  public static native void ecl_kw_scalar_set_bool( ecl_kw_type ecl_kw, @Cast("bool") boolean bool_value);
  public static native void ecl_kw_scalar_set__(ecl_kw_type ecl_kw, @Const Pointer value);
  public static native void ecl_kw_scalar_set_float_or_double( ecl_kw_type ecl_kw, double value );


// #define ECL_KW_SCALAR_SET_TYPED_HEADER( ctype ) void ecl_kw_scalar_set_ ## ctype( ecl_kw_type * ecl_kw , ctype value);
  public static native void ecl_kw_scalar_set_int( ecl_kw_type ecl_kw,  int value);
  public static native void ecl_kw_scalar_set_float( ecl_kw_type ecl_kw,  float value);
  public static native void ecl_kw_scalar_set_double( ecl_kw_type ecl_kw,  double value);
// #undef ECL_KW_SCALAR_SET_TYPED_HEADER

  public static native ecl_kw_type ecl_kw_alloc_scatter_copy( @Const ecl_kw_type src_kw, int target_size, @Const IntPointer mapping, Pointer def_value);
  public static native ecl_kw_type ecl_kw_alloc_scatter_copy( @Const ecl_kw_type src_kw, int target_size, @Const IntBuffer mapping, Pointer def_value);
  public static native ecl_kw_type ecl_kw_alloc_scatter_copy( @Const ecl_kw_type src_kw, int target_size, @Const int[] mapping, Pointer def_value);

  public static native void ecl_kw_inplace_add_squared(ecl_kw_type target_kw, @Const ecl_kw_type add_kw);
  public static native void ecl_kw_inplace_add( ecl_kw_type target_kw, @Const ecl_kw_type add_kw);
  public static native void ecl_kw_inplace_sub( ecl_kw_type target_kw, @Const ecl_kw_type sub_kw);
  public static native void ecl_kw_inplace_div( ecl_kw_type target_kw, @Const ecl_kw_type div_kw);
  public static native void ecl_kw_inplace_mul( ecl_kw_type target_kw, @Const ecl_kw_type mul_kw);
  public static native void ecl_kw_inplace_abs( ecl_kw_type kw );

  public static native void ecl_kw_inplace_add_indexed( ecl_kw_type target_kw, @Const int_vector_type index_set, @Const ecl_kw_type add_kw);
  public static native void ecl_kw_inplace_sub_indexed( ecl_kw_type target_kw, @Const int_vector_type index_set, @Const ecl_kw_type sub_kw);
  public static native void ecl_kw_inplace_mul_indexed( ecl_kw_type target_kw, @Const int_vector_type index_set, @Const ecl_kw_type mul_kw);
  public static native void ecl_kw_inplace_div_indexed( ecl_kw_type target_kw, @Const int_vector_type index_set, @Const ecl_kw_type div_kw);
  public static native void ecl_kw_copy_indexed( ecl_kw_type target_kw, @Const int_vector_type index_set, @Const ecl_kw_type src_kw);

  public static native @Cast("bool") boolean ecl_kw_assert_binary_numeric( @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);
// #define ECL_KW_ASSERT_TYPED_BINARY_OP_HEADER( ctype ) bool ecl_kw_assert_binary_ ## ctype( const ecl_kw_type * kw1 , const ecl_kw_type * kw2)
  public static native @Cast("bool") boolean ecl_kw_assert_binary_int( @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);
  public static native @Cast("bool") boolean ecl_kw_assert_binary_float( @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);
  public static native @Cast("bool") boolean ecl_kw_assert_binary_double( @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);
// #undef  ECL_KW_ASSERT_TYPED_BINARY_OP_HEADER

// #define ECL_KW_SCALE_TYPED_HEADER( ctype ) void ecl_kw_scale_ ## ctype (ecl_kw_type * ecl_kw , ctype scale_factor)
  public static native void ecl_kw_scale_int(ecl_kw_type ecl_kw,  int scale_factor);
  public static native void ecl_kw_scale_float(ecl_kw_type ecl_kw,  float scale_factor);
  public static native void ecl_kw_scale_double(ecl_kw_type ecl_kw,  double scale_factor);
// #undef ECL_KW_SCALE_TYPED_HEADER
  public static native void ecl_kw_scale_float_or_double( ecl_kw_type ecl_kw, double scale_factor );


// #define ECL_KW_SHIFT_TYPED_HEADER( ctype ) void ecl_kw_shift_ ## ctype (ecl_kw_type * ecl_kw , ctype shift_factor)
  public static native void ecl_kw_shift_int(ecl_kw_type ecl_kw,  int shift_factor);
  public static native void ecl_kw_shift_float(ecl_kw_type ecl_kw,  float shift_factor);
  public static native void ecl_kw_shift_double(ecl_kw_type ecl_kw,  double shift_factor);
// #undef ECL_KW_SHIFT_TYPED_HEADER
  public static native void ecl_kw_shift_float_or_double( ecl_kw_type ecl_kw, double shift_value );


// #define ECL_KW_IGET_TYPED_HEADER(type) type ecl_kw_iget_ ## type(const ecl_kw_type * , int)
  public static native double ecl_kw_iget_double(@Const ecl_kw_type arg0, int arg1);
  public static native float ecl_kw_iget_float(@Const ecl_kw_type arg0, int arg1);
  public static native int ecl_kw_iget_int(@Const ecl_kw_type arg0, int arg1);
// #undef ECL_KW_IGET_TYPED_HEADER
  public static native @Cast("bool") boolean ecl_kw_iget_bool( @Const ecl_kw_type ecl_kw, int i );


// #define ECL_KW_ISET_TYPED_HEADER(type) void ecl_kw_iset_ ## type(ecl_kw_type * , int , type )
  public static native void ecl_kw_iset_double(ecl_kw_type arg0, int arg1, double arg2 );
  public static native void ecl_kw_iset_float(ecl_kw_type arg0, int arg1, float arg2 );
  public static native void ecl_kw_iset_int(ecl_kw_type arg0, int arg1, int arg2 );
// #undef ECL_KW_ISET_TYPED_HEADER
  public static native void ecl_kw_iset_bool( ecl_kw_type ecl_kw, int i, @Cast("bool") boolean bool_value);


// #define ECL_KW_GET_TYPED_PTR_HEADER(type) type * ecl_kw_get_ ## type ## _ptr(const ecl_kw_type *)
  public static native DoublePointer ecl_kw_get_double_ptr(@Const ecl_kw_type arg0);
  public static native FloatPointer ecl_kw_get_float_ptr(@Const ecl_kw_type arg0);
  public static native IntPointer ecl_kw_get_int_ptr(@Const ecl_kw_type arg0);
  public static native @Cast("bool*") BoolPointer ecl_kw_get_bool_ptr(@Const ecl_kw_type arg0);
// #undef ECL_KW_GET_TYPED_PTR_HEADER


// #define ECL_KW_SET_INDEXED_HEADER(ctype ) void ecl_kw_set_indexed_ ## ctype( ecl_kw_type * ecl_kw, const int_vector_type * index_list , ctype value)
  public static native void ecl_kw_set_indexed_double( ecl_kw_type ecl_kw, @Const int_vector_type index_list,  double value);
  public static native void ecl_kw_set_indexed_float( ecl_kw_type ecl_kw, @Const int_vector_type index_list,  float value);
  public static native void ecl_kw_set_indexed_int( ecl_kw_type ecl_kw, @Const int_vector_type index_list,  int value);
// #undef ECL_KW_SET_INDEXED_HEADER


// #define ECL_KW_SHIFT_INDEXED_HEADER(ctype) void ecl_kw_shift_indexed_ ## ctype( ecl_kw_type * ecl_kw, const int_vector_type * index_list , ctype shift)
  public static native void ecl_kw_shift_indexed_int( ecl_kw_type ecl_kw, @Const int_vector_type index_list,  int shift);
  public static native void ecl_kw_shift_indexed_float( ecl_kw_type ecl_kw, @Const int_vector_type index_list,  float shift);
  public static native void ecl_kw_shift_indexed_double( ecl_kw_type ecl_kw, @Const int_vector_type index_list,  double shift);
// #undef ECL_KW_SHIFT_INDEXED_HEADER


// #define ECL_KW_SCALE_INDEXED_HEADER(ctype) void ecl_kw_scale_indexed_ ## ctype( ecl_kw_type * ecl_kw, const int_vector_type * index_list , ctype scale)
  public static native void ecl_kw_scale_indexed_int( ecl_kw_type ecl_kw, @Const int_vector_type index_list,  int scale);
  public static native void ecl_kw_scale_indexed_float( ecl_kw_type ecl_kw, @Const int_vector_type index_list,  float scale);
  public static native void ecl_kw_scale_indexed_double( ecl_kw_type ecl_kw, @Const int_vector_type index_list,  double scale);
// #undef ECL_KW_SCALE_INDEXED_HEADER


// #define ECL_KW_MAX_MIN_HEADER( ctype ) void ecl_kw_max_min_ ## ctype( const ecl_kw_type * ecl_kw , ctype * _max , ctype * _min)
  public static native void ecl_kw_max_min_int( @Const ecl_kw_type ecl_kw,  IntPointer _max,  IntPointer _min);
  public static native void ecl_kw_max_min_int( @Const ecl_kw_type ecl_kw,  IntBuffer _max,  IntBuffer _min);
  public static native void ecl_kw_max_min_int( @Const ecl_kw_type ecl_kw,  int[] _max,  int[] _min);
  public static native void ecl_kw_max_min_float( @Const ecl_kw_type ecl_kw,  FloatPointer _max,  FloatPointer _min);
  public static native void ecl_kw_max_min_float( @Const ecl_kw_type ecl_kw,  FloatBuffer _max,  FloatBuffer _min);
  public static native void ecl_kw_max_min_float( @Const ecl_kw_type ecl_kw,  float[] _max,  float[] _min);
  public static native void ecl_kw_max_min_double( @Const ecl_kw_type ecl_kw,  DoublePointer _max,  DoublePointer _min);
  public static native void ecl_kw_max_min_double( @Const ecl_kw_type ecl_kw,  DoubleBuffer _max,  DoubleBuffer _min);
  public static native void ecl_kw_max_min_double( @Const ecl_kw_type ecl_kw,  double[] _max,  double[] _min);
// #undef ECL_KW_MAX_MIN_HEADER

  public static native void ecl_kw_fix_uninitialized(ecl_kw_type ecl_kw, int nx, int ny, int nz, @Const IntPointer actnum);
  public static native void ecl_kw_fix_uninitialized(ecl_kw_type ecl_kw, int nx, int ny, int nz, @Const IntBuffer actnum);
  public static native void ecl_kw_fix_uninitialized(ecl_kw_type ecl_kw, int nx, int ny, int nz, @Const int[] actnum);

  public static native @Cast("ecl_type_enum") int ecl_kw_get_type(@Const ecl_kw_type arg0);

// #include <ert/ecl/ecl_kw_grdecl.hpp>

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_kw_grdecl.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_kw_grdecl.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

/*
 This header does not define datatypes; just a couple of functions. It should
 be included from the ecl_kw.h header, so applications do not need to include this
 header explicitly.
*/

// #ifndef ERT_ECL_KW_GRDECL_H
// #define ERT_ECL_KW_GRDECL_H
// #ifdef __cplusplus
// #endif



  public static native @Cast("bool") boolean ecl_kw_grdecl_fseek_kw(@Cast("const char*") BytePointer arg0, @Cast("bool") boolean arg1, @Cast("FILE*") Pointer arg2 );
  public static native @Cast("bool") boolean ecl_kw_grdecl_fseek_kw(String arg0, @Cast("bool") boolean arg1, @Cast("FILE*") Pointer arg2 );

  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl_dynamic__( @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer kw, @Cast("bool") boolean strict, @ByVal ecl_data_type arg3 );
  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl_dynamic__( @Cast("FILE*") Pointer stream, String kw, @Cast("bool") boolean strict, @ByVal ecl_data_type arg3 );
  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl_dynamic( @Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer kw, @ByVal ecl_data_type arg2);
  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl_dynamic( @Cast("FILE*") Pointer stream, String kw, @ByVal ecl_data_type arg2);

  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl_data__(@Cast("FILE*") Pointer stream, @Cast("bool") boolean strict, int size, @ByVal ecl_data_type data_type );
  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl_data(  @Cast("FILE*") Pointer stream, int size, @ByVal ecl_data_type data_type);

  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl__(@Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer kw, @Cast("bool") boolean strict, int size, @ByVal ecl_data_type data_type);
  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl__(@Cast("FILE*") Pointer stream, String kw, @Cast("bool") boolean strict, int size, @ByVal ecl_data_type data_type);
  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl(@Cast("FILE*") Pointer stream, @Cast("const char*") BytePointer kw, int size, @ByVal ecl_data_type data_type);
  public static native ecl_kw_type ecl_kw_fscanf_alloc_grdecl(@Cast("FILE*") Pointer stream, String kw, int size, @ByVal ecl_data_type data_type);

  public static native ecl_kw_type ecl_kw_fscanf_alloc_current_grdecl__( @Cast("FILE*") Pointer stream, @Cast("bool") boolean strict, @ByVal ecl_data_type data_type);
  public static native ecl_kw_type ecl_kw_fscanf_alloc_current_grdecl( @Cast("FILE*") Pointer stream, @ByVal ecl_data_type data_type);

  public static native @Cast("bool") boolean ecl_kw_grdecl_fseek_next_kw( @Cast("FILE*") Pointer stream );
  public static native @Cast("char*") BytePointer ecl_kw_grdecl_alloc_next_header( @Cast("FILE*") Pointer stream );

  public static native void ecl_kw_fprintf_grdecl(@Const ecl_kw_type ecl_kw, @Cast("FILE*") Pointer stream);
  public static native void ecl_kw_fprintf_grdecl__(@Const ecl_kw_type ecl_kw, @Cast("const char*") BytePointer special_header, @Cast("FILE*") Pointer stream);
  public static native void ecl_kw_fprintf_grdecl__(@Const ecl_kw_type ecl_kw, String special_header, @Cast("FILE*") Pointer stream);

// #ifdef __cplusplus
// #endif
// #endif



// Parsed from ert/ecl/ecl_file_kw.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_file_kw.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_FILE_KW_H
// #define ERT_ECL_FILE_KW_H

// #ifdef __cplusplus
// #endif

// #include <stdbool.h>

// #include <ert/util/util.h>

// #include <ert/ecl/ecl_kw.hpp>
// #include <ert/ecl/fortio.h>
// Targeting ../ecl_file_kw_type.java


// Targeting ../inv_map_type.java



  public static native inv_map_type inv_map_alloc();
  public static native ecl_file_kw_type inv_map_get_file_kw( inv_map_type inv_map, @Const ecl_kw_type ecl_kw );
  public static native void inv_map_free( inv_map_type map );
  public static native @Cast("bool") boolean ecl_file_kw_equal( @Const ecl_file_kw_type kw1, @Const ecl_file_kw_type kw2);
  public static native ecl_file_kw_type ecl_file_kw_alloc( @Const ecl_kw_type ecl_kw, @Cast("offset_type") long offset);
  public static native ecl_file_kw_type ecl_file_kw_alloc0( @Cast("const char*") BytePointer header, @ByVal ecl_data_type data_type, int size, @Cast("offset_type") long offset);
  public static native ecl_file_kw_type ecl_file_kw_alloc0( String header, @ByVal ecl_data_type data_type, int size, @Cast("offset_type") long offset);
  public static native void ecl_file_kw_free( ecl_file_kw_type file_kw );
  public static native void ecl_file_kw_free__( Pointer arg );
  public static native ecl_kw_type ecl_file_kw_get_kw( ecl_file_kw_type file_kw, fortio_type fortio, inv_map_type inv_map);
  public static native ecl_kw_type ecl_file_kw_get_kw_ptr( ecl_file_kw_type file_kw );
  public static native ecl_file_kw_type ecl_file_kw_alloc_copy( @Const ecl_file_kw_type src );
  public static native @Cast("const char*") BytePointer ecl_file_kw_get_header( @Const ecl_file_kw_type file_kw );
  public static native int ecl_file_kw_get_size( @Const ecl_file_kw_type file_kw );
  public static native @ByVal ecl_data_type ecl_file_kw_get_data_type(@Const ecl_file_kw_type arg0);
  public static native @Cast("offset_type") long ecl_file_kw_get_offset(@Const ecl_file_kw_type file_kw);
  public static native @Cast("bool") boolean ecl_file_kw_ptr_eq( @Const ecl_file_kw_type file_kw, @Const ecl_kw_type ecl_kw);
  public static native void ecl_file_kw_replace_kw( ecl_file_kw_type file_kw, fortio_type target, ecl_kw_type new_kw );
  public static native @Cast("bool") boolean ecl_file_kw_fskip_data( @Const ecl_file_kw_type file_kw, fortio_type fortio);
  public static native void ecl_file_kw_inplace_fwrite( ecl_file_kw_type file_kw, fortio_type fortio);

  public static native void ecl_file_kw_fwrite( @Const ecl_file_kw_type file_kw, @Cast("FILE*") Pointer stream );
  public static native @Cast("ecl_file_kw_type**") PointerPointer ecl_file_kw_fread_alloc_multiple( @Cast("FILE*") Pointer stream, int num);
  public static native ecl_file_kw_type ecl_file_kw_fread_alloc( @Cast("FILE*") Pointer stream );

  public static native void ecl_file_kw_start_transaction(@Const ecl_file_kw_type file_kw, IntPointer ref_count);
  public static native void ecl_file_kw_start_transaction(@Const ecl_file_kw_type file_kw, IntBuffer ref_count);
  public static native void ecl_file_kw_start_transaction(@Const ecl_file_kw_type file_kw, int[] ref_count);
  public static native void ecl_file_kw_end_transaction(ecl_file_kw_type file_kw, int ref_count);

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/ecl/ecl_file_view.hpp

/*
   Copyright (C) 2016  Equinor ASA, Norway.

   This file is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_ECL_FILE_VIEW_H
// #define ERT_ECL_FILE_VIEW_H

// #include <stdlib.h>
// #include <stdbool.h>

// #include <ert/ecl/ecl_kw.hpp>
// #include <ert/ecl/ecl_file_kw.hpp>
// #include <ert/ecl/ecl_type.hpp>


// #ifdef __cplusplus
// #endif

/** enum ecl_file_flag_type */
public static final int
  ECL_FILE_CLOSE_STREAM  = 1,  /*
                                    This flag will close the underlying FILE object between each access; this is
                                    mainly to save filedescriptors in cases where many ecl_file instances are open at
                                    the same time. */
  //
  ECL_FILE_WRITABLE      = 2;    /*
                                    This flag opens the file in a mode where it can be updated and modified, but it
                                    must still exist and be readable. I.e. this should not compared with the normal:
                                    fopen(filename , "w") where an existing file is truncated to zero upon successfull
                                    open.
                                 */
// Targeting ../ecl_file_view_type.java


// Targeting ../ecl_file_transaction_type.java




  public static native @Cast("bool") boolean ecl_file_view_flags_set( @Const ecl_file_view_type file_view, int query_flags);
  public static native @Cast("bool") boolean ecl_file_view_check_flags( int state_flags, int query_flags);

  public static native ecl_file_view_type ecl_file_view_alloc( fortio_type fortio, IntPointer flags, inv_map_type inv_map, @Cast("bool") boolean owner );
  public static native ecl_file_view_type ecl_file_view_alloc( fortio_type fortio, IntBuffer flags, inv_map_type inv_map, @Cast("bool") boolean owner );
  public static native ecl_file_view_type ecl_file_view_alloc( fortio_type fortio, int[] flags, inv_map_type inv_map, @Cast("bool") boolean owner );
  public static native int ecl_file_view_get_global_index( @Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw, int ith);
  public static native int ecl_file_view_get_global_index( @Const ecl_file_view_type ecl_file_view, String kw, int ith);
  public static native void ecl_file_view_make_index( ecl_file_view_type ecl_file_view );
  public static native @Cast("bool") boolean ecl_file_view_has_kw( @Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw);
  public static native @Cast("bool") boolean ecl_file_view_has_kw( @Const ecl_file_view_type ecl_file_view, String kw);
  public static native ecl_file_kw_type ecl_file_view_iget_file_kw( @Const ecl_file_view_type ecl_file_view, int global_index);
  public static native ecl_file_kw_type ecl_file_view_iget_named_file_kw( @Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw, int ith);
  public static native ecl_file_kw_type ecl_file_view_iget_named_file_kw( @Const ecl_file_view_type ecl_file_view, String kw, int ith);
  public static native ecl_kw_type ecl_file_view_iget_kw( @Const ecl_file_view_type ecl_file_view, int index);
  public static native void ecl_file_view_index_fload_kw(@Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw, int index, @Const int_vector_type index_map, @Cast("char*") BytePointer buffer);
  public static native void ecl_file_view_index_fload_kw(@Const ecl_file_view_type ecl_file_view, String kw, int index, @Const int_vector_type index_map, @Cast("char*") ByteBuffer buffer);
  public static native void ecl_file_view_index_fload_kw(@Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw, int index, @Const int_vector_type index_map, @Cast("char*") byte[] buffer);
  public static native void ecl_file_view_index_fload_kw(@Const ecl_file_view_type ecl_file_view, String kw, int index, @Const int_vector_type index_map, @Cast("char*") BytePointer buffer);
  public static native void ecl_file_view_index_fload_kw(@Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw, int index, @Const int_vector_type index_map, @Cast("char*") ByteBuffer buffer);
  public static native void ecl_file_view_index_fload_kw(@Const ecl_file_view_type ecl_file_view, String kw, int index, @Const int_vector_type index_map, @Cast("char*") byte[] buffer);
  public static native int ecl_file_view_find_kw_value( @Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw, @Const Pointer value);
  public static native int ecl_file_view_find_kw_value( @Const ecl_file_view_type ecl_file_view, String kw, @Const Pointer value);
  public static native @Cast("const char*") BytePointer ecl_file_view_iget_distinct_kw( @Const ecl_file_view_type ecl_file_view, int index);
  public static native int ecl_file_view_get_num_distinct_kw( @Const ecl_file_view_type ecl_file_view );
  public static native int ecl_file_view_get_size( @Const ecl_file_view_type ecl_file_view );
  public static native @ByVal ecl_data_type ecl_file_view_iget_data_type( @Const ecl_file_view_type ecl_file_view, int index);
  public static native int ecl_file_view_iget_size( @Const ecl_file_view_type ecl_file_view, int index);
  public static native @Cast("const char*") BytePointer ecl_file_view_iget_header( @Const ecl_file_view_type ecl_file_view, int index);
  public static native ecl_kw_type ecl_file_view_iget_named_kw( @Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw, int ith);
  public static native ecl_kw_type ecl_file_view_iget_named_kw( @Const ecl_file_view_type ecl_file_view, String kw, int ith);
  public static native @ByVal ecl_data_type ecl_file_view_iget_named_data_type( @Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw, int ith);
  public static native @ByVal ecl_data_type ecl_file_view_iget_named_data_type( @Const ecl_file_view_type ecl_file_view, String kw, int ith);
  public static native int ecl_file_view_iget_named_size( @Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw, int ith);
  public static native int ecl_file_view_iget_named_size( @Const ecl_file_view_type ecl_file_view, String kw, int ith);
  public static native void ecl_file_view_replace_kw( ecl_file_view_type ecl_file_view, ecl_kw_type old_kw, ecl_kw_type new_kw, @Cast("bool") boolean insert_copy);
  public static native @Cast("bool") boolean ecl_file_view_load_all( ecl_file_view_type ecl_file_view );
  public static native void ecl_file_view_add_kw( ecl_file_view_type ecl_file_view, ecl_file_kw_type file_kw);
  public static native void ecl_file_view_free( ecl_file_view_type ecl_file_view );
  public static native void ecl_file_view_free__( Pointer arg );
  public static native int ecl_file_view_get_num_named_kw(@Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer kw);
  public static native int ecl_file_view_get_num_named_kw(@Const ecl_file_view_type ecl_file_view, String kw);
  public static native void ecl_file_view_fwrite( @Const ecl_file_view_type ecl_file_view, fortio_type target, int offset);
  public static native int ecl_file_view_iget_occurence( @Const ecl_file_view_type ecl_file_view, int global_index);
  public static native void ecl_file_view_fprintf_kw_list(@Const ecl_file_view_type ecl_file_view, @Cast("FILE*") Pointer stream);
  public static native ecl_file_view_type ecl_file_view_add_blockview(ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer header, int occurence);
  public static native ecl_file_view_type ecl_file_view_add_blockview(ecl_file_view_type ecl_file_view, String header, int occurence);
  public static native ecl_file_view_type ecl_file_view_add_blockview2(ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer start_kw, @Cast("const char*") BytePointer end_kw, int occurence);
  public static native ecl_file_view_type ecl_file_view_add_blockview2(ecl_file_view_type ecl_file_view, String start_kw, String end_kw, int occurence);
  public static native ecl_file_view_type ecl_file_view_add_restart_view(ecl_file_view_type file_view, int seqnum_index, int report_step, @ByVal @Cast("time_t*") Pointer sim_time, double sim_days);
  public static native ecl_file_view_type ecl_file_view_alloc_blockview(@Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer header, int occurence);
  public static native ecl_file_view_type ecl_file_view_alloc_blockview(@Const ecl_file_view_type ecl_file_view, String header, int occurence);
  public static native ecl_file_view_type ecl_file_view_alloc_blockview2(@Const ecl_file_view_type ecl_file_view, @Cast("const char*") BytePointer start_kw, @Cast("const char*") BytePointer end_kw, int occurence);
  public static native ecl_file_view_type ecl_file_view_alloc_blockview2(@Const ecl_file_view_type ecl_file_view, String start_kw, String end_kw, int occurence);

  public static native void ecl_file_view_add_child( ecl_file_view_type parent, ecl_file_view_type child);
  public static native @Cast("bool") boolean ecl_file_view_drop_flag( ecl_file_view_type file_view, int flag);
  public static native void ecl_file_view_add_flag( ecl_file_view_type file_view, int flag);

  public static native int ecl_file_view_seqnum_index_from_sim_time( ecl_file_view_type parent_map, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native @Cast("bool") boolean ecl_file_view_has_sim_time( @Const ecl_file_view_type ecl_file_view, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native int ecl_file_view_find_sim_time(@Const ecl_file_view_type ecl_file_view, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native double ecl_file_view_iget_restart_sim_days(@Const ecl_file_view_type ecl_file_view, int seqnum_index);
  public static native @ByVal @Cast("time_t*") Pointer ecl_file_view_iget_restart_sim_date(@Const ecl_file_view_type ecl_file_view, int seqnum_index);
  public static native @Cast("bool") boolean ecl_file_view_has_report_step( @Const ecl_file_view_type ecl_file_view, int report_step);

  public static native ecl_file_view_type ecl_file_view_add_summary_view( ecl_file_view_type file_view, int report_step );
  public static native @Cast("const char*") BytePointer ecl_file_view_get_src_file( @Const ecl_file_view_type file_view );
  public static native void ecl_file_view_fclose_stream( ecl_file_view_type file_view );

  public static native void ecl_file_view_write_index(@Const ecl_file_view_type file_view, @Cast("FILE*") Pointer ostream);
  public static native ecl_file_view_type ecl_file_view_fread_alloc( fortio_type fortio, IntPointer flags, inv_map_type inv_map, @Cast("FILE*") Pointer istream );
  public static native ecl_file_view_type ecl_file_view_fread_alloc( fortio_type fortio, IntBuffer flags, inv_map_type inv_map, @Cast("FILE*") Pointer istream );
  public static native ecl_file_view_type ecl_file_view_fread_alloc( fortio_type fortio, int[] flags, inv_map_type inv_map, @Cast("FILE*") Pointer istream );

  public static native ecl_file_transaction_type ecl_file_view_start_transaction(ecl_file_view_type file_view);
  public static native void ecl_file_view_end_transaction( ecl_file_view_type file_view, ecl_file_transaction_type transaction);

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/ecl/ecl_file.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_file.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_FILE_H
// #define ERT_ECL_FILE_H

// #ifdef __cplusplus
// #endif

// #include <stdbool.h>
// #include <time.h>


// #include <ert/ecl/ecl_kw.hpp>
// #include <ert/ecl/ecl_file_kw.hpp>
// #include <ert/ecl/ecl_file_view.hpp>
// #include <ert/ecl/fortio.h>
// #include <ert/ecl/ecl_util.hpp>
// #include <ert/ecl/ecl_type.hpp>



public static native @MemberGetter double ECL_FILE_FLAGS_ENUM_DEFS();
public static final double ECL_FILE_FLAGS_ENUM_DEFS = ECL_FILE_FLAGS_ENUM_DEFS();
public static final int ECL_FILE_FLAGS_ENUM_SIZE = 2;
// Targeting ../ecl_file_type.java


  public static native @Cast("bool") boolean ecl_file_load_all( ecl_file_type ecl_file );
  public static native ecl_file_type ecl_file_open( @Cast("const char*") BytePointer filename, int flags);
  public static native ecl_file_type ecl_file_open( String filename, int flags);
  public static native ecl_file_type ecl_file_fast_open( @Cast("const char*") BytePointer filename, @Cast("const char*") BytePointer index_filename, int flags);
  public static native ecl_file_type ecl_file_fast_open( String filename, String index_filename, int flags);
  public static native @Cast("bool") boolean ecl_file_write_index( @Const ecl_file_type ecl_file, @Cast("const char*") BytePointer index_filename);
  public static native @Cast("bool") boolean ecl_file_write_index( @Const ecl_file_type ecl_file, String index_filename);
  public static native @Cast("bool") boolean ecl_file_index_valid(@Cast("const char*") BytePointer file_name, @Cast("const char*") BytePointer index_file_name);
  public static native @Cast("bool") boolean ecl_file_index_valid(String file_name, String index_file_name);
  public static native void ecl_file_close( ecl_file_type ecl_file );
  public static native void ecl_file_fortio_detach( ecl_file_type ecl_file );
  public static native void ecl_file_free__(Pointer arg);
  public static native ecl_kw_type ecl_file_icopy_named_kw( @Const ecl_file_type ecl_file, @Cast("const char*") BytePointer kw, int ith);
  public static native ecl_kw_type ecl_file_icopy_named_kw( @Const ecl_file_type ecl_file, String kw, int ith);
  public static native ecl_kw_type ecl_file_icopy_kw( @Const ecl_file_type ecl_file, int index);
  public static native @Cast("bool") boolean ecl_file_has_kw( @Const ecl_file_type ecl_file, @Cast("const char*") BytePointer kw);
  public static native @Cast("bool") boolean ecl_file_has_kw( @Const ecl_file_type ecl_file, String kw);
  public static native int ecl_file_get_num_named_kw(@Const ecl_file_type ecl_file, @Cast("const char*") BytePointer kw);
  public static native int ecl_file_get_num_named_kw(@Const ecl_file_type ecl_file, String kw);
  public static native int ecl_file_get_size( @Const ecl_file_type ecl_file );
  public static native int ecl_file_get_num_distinct_kw(@Const ecl_file_type ecl_file);
  public static native @Cast("const char*") BytePointer ecl_file_iget_distinct_kw(@Const ecl_file_type ecl_file, int index);
  public static native @Cast("const char*") BytePointer ecl_file_get_src_file( @Const ecl_file_type ecl_file );
  public static native int ecl_file_iget_occurence( @Const ecl_file_type ecl_file, int index);
  public static native @Cast("ecl_version_enum") int ecl_file_get_ecl_version( @Const ecl_file_type file );
  public static native void ecl_file_fwrite_fortio(@Const ecl_file_type ec_file, fortio_type fortio, int offset);
  public static native void ecl_file_fwrite(@Const ecl_file_type ecl_file, @Cast("const char*") BytePointer arg1, @Cast("bool") boolean fmt_file );
  public static native void ecl_file_fwrite(@Const ecl_file_type ecl_file, String arg1, @Cast("bool") boolean fmt_file );

  public static native void ecl_file_replace_kw( ecl_file_type ecl_file, ecl_kw_type old_kw, ecl_kw_type new_kw, @Cast("bool") boolean insert_copy);
  public static native int ecl_file_get_phases( @Const ecl_file_type init_file );
  public static native void ecl_file_fprintf_kw_list( @Const ecl_file_type ecl_file, @Cast("FILE*") Pointer stream );

  public static native @Cast("bool") boolean ecl_file_writable( @Const ecl_file_type ecl_file );
  public static native int ecl_file_get_flags( @Const ecl_file_type ecl_file );
  public static native void ecl_file_set_flags( ecl_file_type ecl_file, int new_flags );
  public static native @Cast("bool") boolean ecl_file_flags_set( @Const ecl_file_type ecl_file, int flags);



  public static native ecl_file_kw_type ecl_file_iget_file_kw( @Const ecl_file_type file, int global_index);
  public static native ecl_file_kw_type ecl_file_iget_named_file_kw( @Const ecl_file_type file, @Cast("const char*") BytePointer kw, int ith);
  public static native ecl_file_kw_type ecl_file_iget_named_file_kw( @Const ecl_file_type file, String kw, int ith);
  public static native ecl_kw_type ecl_file_iget_kw( @Const ecl_file_type file, int global_index);
  public static native @ByVal ecl_data_type ecl_file_iget_data_type( @Const ecl_file_type file, int global_index);
  public static native int ecl_file_iget_size( @Const ecl_file_type file, int global_index);
  public static native @Cast("const char*") BytePointer ecl_file_iget_header( @Const ecl_file_type file, int global_index);
  public static native ecl_kw_type ecl_file_iget_named_kw( @Const ecl_file_type file, @Cast("const char*") BytePointer kw, int ith);
  public static native ecl_kw_type ecl_file_iget_named_kw( @Const ecl_file_type file, String kw, int ith);
  public static native @ByVal ecl_data_type ecl_file_iget_named_data_type( @Const ecl_file_type file, @Cast("const char*") BytePointer kw, int ith);
  public static native @ByVal ecl_data_type ecl_file_iget_named_data_type( @Const ecl_file_type file, String kw, int ith);
  public static native int ecl_file_iget_named_size( @Const ecl_file_type file, @Cast("const char*") BytePointer kw, int ith);
  public static native int ecl_file_iget_named_size( @Const ecl_file_type file, String kw, int ith);
  public static native void ecl_file_indexed_read(@Const ecl_file_type file, @Cast("const char*") BytePointer kw, int index, @Const int_vector_type index_map, @Cast("char*") BytePointer buffer);
  public static native void ecl_file_indexed_read(@Const ecl_file_type file, String kw, int index, @Const int_vector_type index_map, @Cast("char*") ByteBuffer buffer);
  public static native void ecl_file_indexed_read(@Const ecl_file_type file, @Cast("const char*") BytePointer kw, int index, @Const int_vector_type index_map, @Cast("char*") byte[] buffer);
  public static native void ecl_file_indexed_read(@Const ecl_file_type file, String kw, int index, @Const int_vector_type index_map, @Cast("char*") BytePointer buffer);
  public static native void ecl_file_indexed_read(@Const ecl_file_type file, @Cast("const char*") BytePointer kw, int index, @Const int_vector_type index_map, @Cast("char*") ByteBuffer buffer);
  public static native void ecl_file_indexed_read(@Const ecl_file_type file, String kw, int index, @Const int_vector_type index_map, @Cast("char*") byte[] buffer);

  public static native ecl_file_view_type ecl_file_get_global_blockview( ecl_file_type ecl_file, @Cast("const char*") BytePointer kw, int occurence);
  public static native ecl_file_view_type ecl_file_get_global_blockview( ecl_file_type ecl_file, String kw, int occurence);
  public static native ecl_file_view_type ecl_file_alloc_global_blockview( ecl_file_type ecl_file, @Cast("const char*") BytePointer kw, int occurence);
  public static native ecl_file_view_type ecl_file_alloc_global_blockview( ecl_file_type ecl_file, String kw, int occurence);
  public static native ecl_file_view_type ecl_file_get_global_view( ecl_file_type ecl_file );
  public static native ecl_file_view_type ecl_file_get_active_view( ecl_file_type ecl_file );
  //bool               ecl_file_writable( const ecl_file_type * ecl_file );
  public static native @Cast("bool") boolean ecl_file_save_kw( @Const ecl_file_type ecl_file, @Const ecl_kw_type ecl_kw);
  public static native @Cast("bool") boolean ecl_file_has_kw_ptr( @Const ecl_file_type ecl_file, @Const ecl_kw_type ecl_kw);

/*****************************************************************/
/*               R E S T A R T  F I L E S                        */

  public static native double ecl_file_iget_restart_sim_days( @Const ecl_file_type restart_file, int index );
  public static native @ByVal @Cast("time_t*") Pointer ecl_file_iget_restart_sim_date( @Const ecl_file_type restart_file, int occurence );
  public static native int ecl_file_get_restart_index( @Const ecl_file_type restart_file, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native @Cast("bool") boolean ecl_file_has_report_step( @Const ecl_file_type ecl_file, int report_step);
  public static native @Cast("bool") boolean ecl_file_has_sim_time( @Const ecl_file_type ecl_file, @ByVal @Cast("time_t*") Pointer sim_time);


  public static native void ecl_file_close_fortio_stream(ecl_file_type ecl_file);

  public static native ecl_file_view_type ecl_file_get_restart_view( ecl_file_type ecl_file, int input_index, int report_step, @ByVal @Cast("time_t*") Pointer sim_time, double sim_days);
  public static native ecl_file_view_type ecl_file_get_summary_view( ecl_file_type ecl_file, int report_step );

/*****************************************************************/
/* SUMMARY FILES */

  public static native @Cast("bool") boolean ecl_file_is_instance( @Const Pointer __arg );

  //Deprecated:

  public static native void ecl_file_push_block( ecl_file_type ecl_file );
  public static native void ecl_file_pop_block( ecl_file_type ecl_file );
  public static native @Cast("bool") boolean ecl_file_subselect_block( ecl_file_type ecl_file, @Cast("const char*") BytePointer kw, int occurence);
  public static native @Cast("bool") boolean ecl_file_subselect_block( ecl_file_type ecl_file, String kw, int occurence);
  public static native @Cast("bool") boolean ecl_file_select_block( ecl_file_type ecl_file, @Cast("const char*") BytePointer kw, int occurence);
  public static native @Cast("bool") boolean ecl_file_select_block( ecl_file_type ecl_file, String kw, int occurence);

  public static native @Cast("bool") boolean ecl_file_select_rstblock_sim_time( ecl_file_type ecl_file, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native @Cast("bool") boolean ecl_file_select_rstblock_report_step( ecl_file_type ecl_file, int report_step);
  public static native @Cast("bool") boolean ecl_file_iselect_rstblock( ecl_file_type ecl_file, int seqnum_index );
  public static native ecl_file_type ecl_file_open_rstblock_report_step( @Cast("const char*") BytePointer filename, int report_step, int flags);
  public static native ecl_file_type ecl_file_open_rstblock_report_step( String filename, int report_step, int flags);
  public static native ecl_file_type ecl_file_open_rstblock_sim_time( @Cast("const char*") BytePointer filename, @ByVal @Cast("time_t*") Pointer sim_time, int flags);
  public static native ecl_file_type ecl_file_open_rstblock_sim_time( String filename, @ByVal @Cast("time_t*") Pointer sim_time, int flags);
  public static native ecl_file_type ecl_file_iopen_rstblock( @Cast("const char*") BytePointer filename, int seqnum_index, int flags);
  public static native ecl_file_type ecl_file_iopen_rstblock( String filename, int seqnum_index, int flags);


// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_rsthead.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_RSTHEAD.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_RSTHEAD_H
// #define ERT_ECL_RSTHEAD_H

// #ifdef __cplusplus
// #endif

// #include <time.h>

// #include <ert/ecl/ecl_file.hpp>
// #include <ert/ecl/ecl_file_view.hpp>
// #include <ert/ecl/ecl_kw.hpp>
// Targeting ../ecl_rsthead_type.java





  public static native void ecl_rsthead_free( ecl_rsthead_type rsthead );
  public static native ecl_rsthead_type ecl_rsthead_alloc_from_kw( int report_step, @Const ecl_kw_type intehead_kw, @Const ecl_kw_type doubhead_kw, @Const ecl_kw_type logihead_kw );
  public static native ecl_rsthead_type ecl_rsthead_alloc( @Const ecl_file_view_type rst_file, int report_step);
  public static native ecl_rsthead_type ecl_rsthead_alloc_empty();
  public static native @ByVal @Cast("time_t*") Pointer ecl_rsthead_date( @Const ecl_kw_type intehead_kw );
  public static native void ecl_rsthead_fprintf( @Const ecl_rsthead_type header, @Cast("FILE*") Pointer stream);
  public static native void ecl_rsthead_fprintf_struct( @Const ecl_rsthead_type header, @Cast("FILE*") Pointer stream);
  public static native @Cast("bool") boolean ecl_rsthead_equal( @Const ecl_rsthead_type header1, @Const ecl_rsthead_type header2);
  public static native double ecl_rsthead_get_sim_days( @Const ecl_rsthead_type header );
  public static native int ecl_rsthead_get_report_step( @Const ecl_rsthead_type header );
  public static native @ByVal @Cast("time_t*") Pointer ecl_rsthead_get_sim_time( @Const ecl_rsthead_type header );
  public static native int ecl_rsthead_get_nxconz( @Const ecl_rsthead_type rsthead );
  public static native int ecl_rsthead_get_ncwmax( @Const ecl_rsthead_type rsthead );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl_well/well_conn.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'well_conn.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_WELL_CONN_H
// #define ERT_WELL_CONN_H



// #include <stdbool.h>

// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/ecl_rsthead.hpp>

// #ifdef __cplusplus
// #endif

  /** enum well_conn_dir_enum */
  public static final int
    well_conn_dirX  = 1,
    well_conn_dirY  = 2,
    well_conn_dirZ  = 3,
    well_conn_fracX = 4,
    well_conn_fracY = 5;
// Targeting ../well_conn_type.java




  public static native void well_conn_free( well_conn_type conn);
  public static native void well_conn_free__( Pointer arg );

  public static native well_conn_type well_conn_alloc( int i, int j, int k, double connection_factor, @Cast("well_conn_dir_enum") int dir, @Cast("bool") boolean open);
  public static native well_conn_type well_conn_alloc_MSW( int i, int j, int k, double connection_factor, @Cast("well_conn_dir_enum") int dir, @Cast("bool") boolean open, int segment);
  public static native well_conn_type well_conn_alloc_fracture( int i, int j, int k, double connection_factor, @Cast("well_conn_dir_enum") int dir, @Cast("bool") boolean open);
  public static native well_conn_type well_conn_alloc_fracture_MSW( int i, int j, int k, double connection_factor, @Cast("well_conn_dir_enum") int dir, @Cast("bool") boolean open, int segment);

  public static native @Cast("bool") boolean well_conn_MSW(@Const well_conn_type conn);

  public static native well_conn_type well_conn_alloc_from_kw( @Const ecl_kw_type icon_kw, @Const ecl_kw_type scon_kw, @Const ecl_kw_type xcon_kw, @Const ecl_rsthead_type header, int well_nr, int conn_nr);
  public static native well_conn_type well_conn_alloc_wellhead( @Const ecl_kw_type iwel_kw, @Const ecl_rsthead_type header, int well_nr);

  public static native int well_conn_get_i(@Const well_conn_type conn);
  public static native int well_conn_get_j(@Const well_conn_type conn);
  public static native int well_conn_get_k(@Const well_conn_type conn);
  public static native @Cast("well_conn_dir_enum") int well_conn_get_dir(@Const well_conn_type conn);
  public static native @Cast("bool") boolean well_conn_open( @Const well_conn_type conn );
  public static native int well_conn_get_segment_id( @Const well_conn_type conn );
  public static native @Cast("bool") boolean well_conn_fracture_connection( @Const well_conn_type conn);
  public static native @Cast("bool") boolean well_conn_matrix_connection( @Const well_conn_type conn);
  public static native @Cast("bool") boolean well_conn_equal( @Const well_conn_type conn1, @Const well_conn_type conn2);
  public static native double well_conn_get_connection_factor( @Const well_conn_type conn );

  public static native double well_conn_get_oil_rate(@Const well_conn_type conn);
  public static native double well_conn_get_gas_rate(@Const well_conn_type conn);
  public static native double well_conn_get_water_rate(@Const well_conn_type conn);
  public static native double well_conn_get_volume_rate(@Const well_conn_type conn);

  public static native double well_conn_get_oil_rate_si(@Const well_conn_type conn);
  public static native double well_conn_get_gas_rate_si(@Const well_conn_type conn);
  public static native double well_conn_get_water_rate_si(@Const well_conn_type conn);
  public static native double well_conn_get_volume_rate_si(@Const well_conn_type conn);


public static native @Cast("bool") boolean well_conn_is_instance( @Const Pointer __arg );
  public static native well_conn_type well_conn_safe_cast( Pointer __arg );


// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl_well/well_conn_collection.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'well_conn_collection.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_WELL_CONN_COLLECTION_H
// #define ERT_WELL_CONN_COLLECTION_H


// #ifdef __cplusplus
// #endif

// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/ecl_kw.hpp>

// #include <ert/ecl_well/well_conn.hpp>
// Targeting ../well_conn_collection_type.java



public static native well_conn_collection_type well_conn_collection_alloc();
public static native void well_conn_collection_free(well_conn_collection_type wellcc);
public static native void well_conn_collection_free__(Pointer arg);
public static native int well_conn_collection_get_size(@Const well_conn_collection_type wellcc);
public static native @Const well_conn_type well_conn_collection_iget_const(@Const well_conn_collection_type wellcc,
                                                       int index);
public static native well_conn_type well_conn_collection_iget(@Const well_conn_collection_type wellcc,
                                                 int index);
public static native void well_conn_collection_add(well_conn_collection_type wellcc,
                                                well_conn_type conn);
public static native void well_conn_collection_add_ref(well_conn_collection_type wellcc,
                                                    well_conn_type conn);
public static native int well_conn_collection_load_from_kw(well_conn_collection_type wellcc,
                                                         @Const ecl_kw_type iwel_kw,
                                                         @Const ecl_kw_type icon_kw,
                                                         @Const ecl_kw_type scon_kw,
                                                         @Const ecl_kw_type xcon_kw,
                                                         int iwell,
                                                         @Const ecl_rsthead_type rst_head);

public static native @Cast("bool") boolean well_conn_collection_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl_well/well_const.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'well_const.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_WELL_CONST_H
// #define ERT_WELL_CONST_H

// #ifdef __cplusplus
// #endif

public static final int WELL_SEGMENT_OFFSET = 1;
public static final int WELL_BRANCH_OFFSET =  1;

public static final int ECLIPSE_WELL_SEGMENT_OFFSET =                 1;
public static final int ECLIPSE_WELL_BRANCH_OFFSET =                  1;

/* These values are taken from the ISEG description in table 6.1 in ECLIPSE file formats reference. */
public static final int ECLIPSE_WELL_SEGMENT_OUTLET_END_VALUE =       0;
public static final int ECLIPSE_WELL_SEGMENT_BRANCH_MAIN_STEM_VALUE = 1;
public static final int ECLIPSE_WELL_SEGMENT_INACTIVE_VALUE =         0;
public static final int ECLIPSE_CONN_NORMAL_WELL_SEGMENT_VALUE =      0;

public static final int WELL_SEGMENT_OUTLET_END_VALUE =        (WELL_SEGMENT_OFFSET + ECLIPSE_WELL_SEGMENT_OUTLET_END_VALUE       - ECLIPSE_WELL_SEGMENT_OFFSET); // -1
public static final int WELL_SEGMENT_BRANCH_MAIN_STEM_VALUE =  (WELL_BRANCH_OFFSET  + ECLIPSE_WELL_SEGMENT_BRANCH_MAIN_STEM_VALUE - ECLIPSE_WELL_BRANCH_OFFSET);  //  0
public static final int WELL_SEGMENT_BRANCH_INACTIVE_VALUE =   (WELL_BRANCH_OFFSET  + ECLIPSE_WELL_SEGMENT_INACTIVE_VALUE         - ECLIPSE_WELL_BRANCH_OFFSET);  // -1
public static final int CONN_NORMAL_WELL_SEGMENT_VALUE =       (WELL_SEGMENT_OFFSET + ECLIPSE_CONN_NORMAL_WELL_SEGMENT_VALUE      - ECLIPSE_WELL_SEGMENT_OFFSET);



/*
  Observe that the values given as _ITEM are not indices which can
  be directly used in the IWEL or ICON keywords; an offset must be
  added.
*/

public static final int IWEL_HEADI_INDEX =               0;
public static final int IWEL_HEADJ_INDEX =               1;
public static final int IWEL_HEADK_INDEX =               2;
public static final int IWEL_CONNECTIONS_INDEX =         4;
public static final int IWEL_GROUP_INDEX =               5;
public static final int IWEL_TYPE_INDEX =                6;
public static final int IWEL_STATUS_INDEX =             10;
public static final int IWEL_LGR_INDEX =                42;
public static final int IWEL_SEGMENTED_WELL_NR_INDEX =  70;

public static final int IWEL_HEADI_ITEM =               0;
public static final int IWEL_HEADJ_ITEM =               1;
public static final int IWEL_HEADK_ITEM =               2;
public static final int IWEL_CONNECTIONS_ITEM =         4;
public static final int IWEL_GROUP_ITEM =               5;
public static final int IWEL_TYPE_ITEM =                6;
public static final int IWEL_STATUS_ITEM =             10;
public static final int IWEL_LGR_ITEM =                42;
public static final int IWEL_SEGMENTED_WELL_NR_ITEM =  70;

public static final int IWEL_SEGMENTED_WELL_NR_NORMAL_VALUE = -1;
public static final int ISEG_OUTLET_INDEX =        1;
public static final int ISEG_BRANCH_INDEX =        3;

public static final int XWEL_RES_WRAT_ITEM =        1;
public static final int XWEL_RES_GRAT_ITEM =        2;
public static final int XWEL_RES_ORAT_ITEM =        3;
public static final int XWEL_RESV_ITEM =        4;


public static final int ICON_IC_INDEX =         0;
public static final int ICON_I_INDEX =          1;
public static final int ICON_J_INDEX =          2;
public static final int ICON_K_INDEX =          3;
public static final int ICON_STATUS_INDEX =     5;
public static final int ICON_DIRECTION_INDEX = 13;
public static final int ICON_SEGMENT_INDEX =   14;

public static final int ICON_IC_ITEM =         0;
public static final int ICON_I_ITEM =          1;
public static final int ICON_J_ITEM =          2;
public static final int ICON_K_ITEM =          3;
public static final int ICON_STATUS_ITEM =     5;
public static final int ICON_DIRECTION_ITEM = 13;
public static final int ICON_SEGMENT_ITEM =   14;

public static final int ICON_DIRX =                 1;
public static final int ICON_DIRY =                 2;
public static final int ICON_DIRZ =                 3;
public static final int ICON_FRACX =                4;
public static final int ICON_FRACY =                5;
public static final int ICON_DEFAULT_DIR_VALUE =    0;
public static final int ICON_DEFAULT_DIR_TARGET =   ICON_DIRZ;

public static final int SCON_CF_INDEX =              0;

public static final int XCON_ORAT_INDEX =            0;
public static final int XCON_WRAT_INDEX =            1;
public static final int XCON_GRAT_INDEX =            2;
public static final int XCON_QR_INDEX =             49;

public static final int RSEG_LENGTH_INDEX =       0;
public static final int RSEG_DIAMETER_INDEX =     2;
public static final int RSEG_TOTAL_LENGTH_INDEX = 6;
public static final int RSEG_DEPTH_INDEX =        7;

/*
  The ECLIPSE documentation says that a certain item in the IWEL array
  should indicate the type of the well, the available types are the
  ones given in the enum below. Unfortunately it turns out that when
  the well is closed the integer value in the IWEL array can be 0, if
  the well is indeed closed we accept this zero - otherwise we fail
  hard. Theese hoops are in the well_state_alloc() routine.
*/

public static final int IWEL_UNDOCUMENTED_ZERO = 0;
public static final int IWEL_PRODUCER =          1;
public static final int IWEL_OIL_INJECTOR =      2;
public static final int IWEL_WATER_INJECTOR =    3;
public static final int IWEL_GAS_INJECTOR =      4;

  /** enum well_type_enum */
  public static final int
    ERT_UNDOCUMENTED_ZERO   = 0,   // Deprecated - retained for Resinsight compatibility
    ECL_WELL_ZERO           = 0,

    ERT_PRODUCER            = 1,   // Deprecated
    ECL_WELL_PRODUCER       = 1,

    ERT_OIL_INJECTOR        = 2,   // Deprecated
    ECL_WELL_OIL_INJECTOR   = 2,

    ERT_WATER_INJECTOR      = 3,   // Deprecated
    ECL_WELL_WATER_INJECTOR = 3,

    ERT_GAS_INJECTOR        = 4,   // Deprecated
    ECL_WELL_GAS_INJECTOR   = 4;

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/ecl_well/well_rseg_loader.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'well_info.c' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_WELL_RSEG_LOADER_H
// #define ERT_WELL_RSEG_LOADER_H


// #ifdef __cplusplus
// #endif

// #include <ert/ecl/ecl_file_view.hpp>
// Targeting ../well_rseg_loader_type.java



  public static native well_rseg_loader_type well_rseg_loader_alloc(ecl_file_view_type rst_view);
  public static native void well_rseg_loader_free(well_rseg_loader_type well_rseg_loader);

  public static native int well_rseg_loader_element_count(@Const well_rseg_loader_type well_rseg_loader);
  public static native DoublePointer well_rseg_loader_load_values(@Const well_rseg_loader_type well_rseg_loader, int rseg_offset);

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/ecl_well/well_segment.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'well_segment.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_WELL_SEGMENT_H
// #define ERT_WELL_SEGMENT_H


// #ifdef __cplusplus
// #endif

// #include <stdbool.h>

// #include <ert/ecl/ecl_kw.hpp>
// #include <ert/ecl/ecl_rsthead.hpp>

// #include <ert/ecl_well/well_conn_collection.hpp>
// #include <ert/ecl_well/well_conn.hpp>
// #include <ert/ecl_well/well_rseg_loader.hpp>
// Targeting ../well_segment_type.java



  public static native well_segment_type well_segment_alloc_from_kw( @Const ecl_kw_type iseg_kw, @Const well_rseg_loader_type rseg_loader, @Const ecl_rsthead_type header, int well_nr, int segment_index, int segment_id);
  public static native well_segment_type well_segment_alloc(int segment_id, int outlet_segment_id, int branch_id, @Const DoublePointer rseg_data);
  public static native well_segment_type well_segment_alloc(int segment_id, int outlet_segment_id, int branch_id, @Const DoubleBuffer rseg_data);
  public static native well_segment_type well_segment_alloc(int segment_id, int outlet_segment_id, int branch_id, @Const double[] rseg_data);
  public static native void well_segment_free(well_segment_type segment );
  public static native void well_segment_free__(Pointer arg);

  public static native @Cast("bool") boolean well_segment_active( @Const well_segment_type segment );
  public static native @Cast("bool") boolean well_segment_main_stem( @Const well_segment_type segment );
  public static native @Cast("bool") boolean well_segment_nearest_wellhead( @Const well_segment_type segment );

  public static native int well_segment_get_link_count( @Const well_segment_type segment );
  public static native int well_segment_get_branch_id( @Const well_segment_type segment );
  public static native int well_segment_get_outlet_id( @Const well_segment_type segment );
  public static native int well_segment_get_id( @Const well_segment_type segment );
  public static native well_segment_type well_segment_get_outlet( @Const well_segment_type segment );
  public static native @Cast("bool") boolean well_segment_link( well_segment_type segment, well_segment_type outlet_segment );
  public static native void well_segment_link_strict( well_segment_type segment, well_segment_type outlet_segment );
  public static native @Cast("bool") boolean well_segment_has_grid_connections( @Const well_segment_type segment, @Cast("const char*") BytePointer grid_name);
  public static native @Cast("bool") boolean well_segment_has_grid_connections( @Const well_segment_type segment, String grid_name);
  public static native @Cast("bool") boolean well_segment_has_global_grid_connections( @Const well_segment_type segment);
  public static native @Cast("bool") boolean well_segment_add_connection( well_segment_type segment, @Cast("const char*") BytePointer grid_name, well_conn_type conn);
  public static native @Cast("bool") boolean well_segment_add_connection( well_segment_type segment, String grid_name, well_conn_type conn);
  public static native @Const well_conn_collection_type well_segment_get_connections(@Const well_segment_type segment, @Cast("const char*") BytePointer grid_name );
  public static native @Const well_conn_collection_type well_segment_get_connections(@Const well_segment_type segment, String grid_name );
  public static native @Const well_conn_collection_type well_segment_get_global_connections(@Const well_segment_type segment );
  public static native @Cast("bool") boolean well_segment_well_is_MSW(int well_nr, @Const ecl_kw_type iwel_kw, @Const ecl_rsthead_type rst_head);

  public static native double well_segment_get_depth( @Const well_segment_type segment );
  public static native double well_segment_get_length( @Const well_segment_type segment );
  public static native double well_segment_get_total_length( @Const well_segment_type segment );
  public static native double well_segment_get_diameter( @Const well_segment_type segment );

  public static native @Cast("bool") boolean well_segment_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl_well/well_branch_collection.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'well_branch_collection.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_WELL_BRANCH_COLLECTION_H
// #define ERT_WELL_BRANCH_COLLECTION_H


// #ifdef __cplusplus
// #endif

// #include <stdbool.h>

// #include <ert/util/type_macros.hpp>

// #include <ert/ecl_well/well_segment.hpp>
// Targeting ../well_branch_collection_type.java



  public static native well_branch_collection_type well_branch_collection_alloc();
  public static native void well_branch_collection_free( well_branch_collection_type branches );
  public static native void well_branch_collection_free__( Pointer arg );
  public static native @Cast("bool") boolean well_branch_collection_has_branch( @Const well_branch_collection_type branches, int branch_id);
  public static native int well_branch_collection_get_size( @Const well_branch_collection_type branches );
  public static native @Const well_segment_type well_branch_collection_iget_start_segment( @Const well_branch_collection_type branches, int index );
  public static native @Const well_segment_type well_branch_collection_get_start_segment( @Const well_branch_collection_type branches, int branch_id);
  public static native @Cast("bool") boolean well_branch_collection_add_start_segment( well_branch_collection_type branches, well_segment_type start_segment);

  public static native @Cast("bool") boolean well_branch_collection_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl_well/well_segment_collection.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

                   The file 'well_segment_collection.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_WELL_SEGMENT_COLLECTION_H
// #define ERT_WELL_SEGMENT_COLLECTION_H


// #ifdef __cplusplus
// #endif

// #include <stdbool.h>

// #include <ert/ecl/ecl_kw.hpp>

// #include <ert/ecl_well/well_segment.hpp>
// #include <ert/ecl_well/well_conn_collection.hpp>
// #include <ert/ecl_well/well_branch_collection.hpp>
// #include <ert/ecl_well/well_rseg_loader.hpp>
// Targeting ../well_segment_collection_type.java



  public static native well_segment_collection_type well_segment_collection_alloc();
  public static native void well_segment_collection_free(well_segment_collection_type segment_collection );
  public static native int well_segment_collection_get_size( @Const well_segment_collection_type segment_collection );
  public static native void well_segment_collection_add( well_segment_collection_type segment_collection, well_segment_type segment);
  public static native @Cast("bool") boolean well_segment_collection_has_segment( @Const well_segment_collection_type segment_collection, int segment_id);
  public static native well_segment_type well_segment_collection_get( @Const well_segment_collection_type segment_collection, int segment_id);
  public static native well_segment_type well_segment_collection_iget( @Const well_segment_collection_type segment_collection, int index);
  public static native int well_segment_collection_load_from_kw( well_segment_collection_type segment_collection, int well_nr,
                                                                         @Const ecl_kw_type iwel_kw,
                                                                         @Const ecl_kw_type iseg_kw,
                                                                         @Const well_rseg_loader_type rseg_loader,
                                                                         @Const ecl_rsthead_type rst_head,
                                                                         @Cast("bool") boolean load_segment_information, @Cast("bool*") BoolPointer is_MSW_well);
  public static native int well_segment_collection_load_from_kw( well_segment_collection_type segment_collection, int well_nr,
                                                                         @Const ecl_kw_type iwel_kw,
                                                                         @Const ecl_kw_type iseg_kw,
                                                                         @Const well_rseg_loader_type rseg_loader,
                                                                         @Const ecl_rsthead_type rst_head,
                                                                         @Cast("bool") boolean load_segment_information, @Cast("bool*") boolean[] is_MSW_well);

  public static native void well_segment_collection_link(@Const well_segment_collection_type segment_collection);
  public static native void well_segment_collection_add_connections(well_segment_collection_type segment_collection,
                                                                           @Cast("const char*") BytePointer grid_name,
                                                                           @Const well_conn_collection_type connections);
  public static native void well_segment_collection_add_connections(well_segment_collection_type segment_collection,
                                                                           String grid_name,
                                                                           @Const well_conn_collection_type connections);
  public static native void well_segment_collection_add_branches( @Const well_segment_collection_type segment_collection,
                                                                         well_branch_collection_type branches );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_coarse_cell.hpp

/*
   Copyright (C) 2012  Equinor ASA, Norway.

   This file is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_COARSE_CELL_H
// #define ERT_ECL_COARSE_CELL_H


// #ifdef __cplusplus
// Targeting ../ecl_coarse_cell_type.java



public static native @Cast("bool") boolean ecl_coarse_cell_equal(@Const ecl_coarse_cell_type coarse_cell1,
                                  @Const ecl_coarse_cell_type coarse_cell2);
public static native ecl_coarse_cell_type ecl_coarse_cell_alloc();
public static native void ecl_coarse_cell_update(ecl_coarse_cell_type coarse_cell,
                                   int i,
                                   int j,
                                   int k,
                                   int global_index);
public static native void ecl_coarse_cell_free(ecl_coarse_cell_type coarse_cell);
public static native void ecl_coarse_cell_free__(Pointer arg);

public static native int ecl_coarse_cell_get_i1(@Const ecl_coarse_cell_type coarse_cell);
public static native int ecl_coarse_cell_get_j1(@Const ecl_coarse_cell_type coarse_cell);
public static native int ecl_coarse_cell_get_k1(@Const ecl_coarse_cell_type coarse_cell);
public static native int ecl_coarse_cell_get_i2(@Const ecl_coarse_cell_type coarse_cell);
public static native int ecl_coarse_cell_get_j2(@Const ecl_coarse_cell_type coarse_cell);
public static native int ecl_coarse_cell_get_k2(@Const ecl_coarse_cell_type coarse_cell);
public static native @Const IntPointer ecl_coarse_cell_get_box_ptr(@Const ecl_coarse_cell_type coarse_cell);

public static native int ecl_coarse_cell_get_size(@Const ecl_coarse_cell_type coarse_cell);
public static native int ecl_coarse_cell_iget_cell_index(ecl_coarse_cell_type coarse_cell,
                                            int group_index);
public static native @Const IntPointer ecl_coarse_cell_get_index_ptr(ecl_coarse_cell_type coarse_cell);
public static native @Const int_vector_type ecl_coarse_cell_get_index_vector(ecl_coarse_cell_type coarse_cell);

public static native void ecl_coarse_cell_reset_active_index(ecl_coarse_cell_type coarse_cell);
public static native void ecl_coarse_cell_update_index(ecl_coarse_cell_type coarse_cell,
                                  int global_index,
                                  IntPointer active_index,
                                  IntPointer active_fracture_index,
                                  int active_value);
public static native void ecl_coarse_cell_update_index(ecl_coarse_cell_type coarse_cell,
                                  int global_index,
                                  IntBuffer active_index,
                                  IntBuffer active_fracture_index,
                                  int active_value);
public static native void ecl_coarse_cell_update_index(ecl_coarse_cell_type coarse_cell,
                                  int global_index,
                                  int[] active_index,
                                  int[] active_fracture_index,
                                  int active_value);
public static native int ecl_coarse_cell_get_active_index(@Const ecl_coarse_cell_type coarse_cell);
public static native int ecl_coarse_cell_get_active_fracture_index(@Const ecl_coarse_cell_type coarse_cell);
public static native int ecl_coarse_cell_iget_active_cell_index(@Const ecl_coarse_cell_type coarse_cell,
                                            int index);
public static native int ecl_coarse_cell_iget_active_value(@Const ecl_coarse_cell_type coarse_cell,
                                       int index);
public static native int ecl_coarse_cell_get_num_active(@Const ecl_coarse_cell_type coarse_cell);
public static native void ecl_coarse_cell_fprintf(@Const ecl_coarse_cell_type coarse_cell,
                             @Cast("FILE*") Pointer stream);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/nnc_vector.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'nnc_vector.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_NNC_VECTOR_H
// #define ERT_NNC_VECTOR_H

// #include <ert/util/int_vector.hpp>
// #include <ert/util/type_macros.hpp>
// Targeting ../nnc_vector_type.java



// #ifdef __cplusplus
// #include <vector>
  public static native @StdVector IntPointer nnc_vector_get_grid_index_list(@Const nnc_vector_type nnc_vector);
  public static native @StdVector IntPointer nnc_vector_get_nnc_index_list(@Const nnc_vector_type nnc_vector);
// #endif

// #ifdef __cplusplus
// #endif

  public static native @Cast("bool") boolean nnc_vector_is_instance( @Const Pointer __arg );

  public static native int nnc_vector_iget_nnc_index( @Const nnc_vector_type nnc_vector, int index );
  public static native int nnc_vector_iget_grid_index( @Const nnc_vector_type nnc_vector, int index );
  public static native nnc_vector_type nnc_vector_alloc(int lgr_nr);
  public static native nnc_vector_type nnc_vector_alloc_copy(@Const nnc_vector_type src_vector);
  public static native void nnc_vector_free( nnc_vector_type nnc_vector );
  public static native void nnc_vector_add_nnc(nnc_vector_type nnc_vector, int global_cell_number, int nnc_index);
  public static native int nnc_vector_get_lgr_nr(@Const nnc_vector_type nnc_vector );
  public static native void nnc_vector_free__(Pointer arg);
  public static native int nnc_vector_get_size( @Const nnc_vector_type nnc_vector );
  public static native @Cast("bool") boolean nnc_vector_equal( @Const nnc_vector_type nnc_vector1, @Const nnc_vector_type nnc_vector2);

// #ifdef __cplusplus
// #endif
// #endif



// Parsed from ert/ecl/nnc_info.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'nnc_info.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_NNC_INFO_H
// #define ERT_NNC_INFO_H

// #include <ert/util/int_vector.hpp>
// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/nnc_vector.hpp>
// Targeting ../nnc_info_type.java



// #ifdef __cplusplus
// #include <vector>
  public static native @StdVector IntPointer nnc_info_get_grid_index_list(@Const nnc_info_type nnc_info, int lgr_nr);
  public static native @StdVector IntPointer nnc_info_iget_grid_index_list(@Const nnc_info_type nnc_info, int lgr_index);
  public static native @StdVector IntPointer nnc_info_get_self_grid_index_list(@Const nnc_info_type nnc_info);
// #endif

// #ifdef __cplusplus
// #endif

  public static native @Cast("bool") boolean nnc_info_is_instance( @Const Pointer __arg );

  public static native nnc_info_type nnc_info_alloc(int lgr_nr);
  public static native void nnc_info_free( nnc_info_type nnc_info );
  public static native void nnc_info_add_nnc(nnc_info_type nnc_info, int lgr_nr, int global_cell_number, int nnc_index);

  public static native nnc_vector_type nnc_info_iget_vector( @Const nnc_info_type nnc_info, int lgr_index);

  public static native nnc_vector_type nnc_info_get_vector( @Const nnc_info_type nnc_info, int lgr_nr);

  public static native nnc_vector_type nnc_info_get_self_vector( @Const nnc_info_type nnc_info );

  public static native int nnc_info_get_lgr_nr(@Const nnc_info_type nnc_info );
  public static native int nnc_info_get_size( @Const nnc_info_type nnc_info );
  public static native int nnc_info_get_total_size( @Const nnc_info_type nnc_info );
  public static native void nnc_info_fprintf(@Const nnc_info_type nnc_info, @Cast("FILE*") Pointer stream);

  public static native @Cast("bool") boolean nnc_info_equal( @Const nnc_info_type nnc_info1, @Const nnc_info_type nnc_info2 );
  public static native nnc_info_type nnc_info_alloc_copy( @Const nnc_info_type src_info );
  public static native @Cast("bool") boolean nnc_info_has_grid_index_list( @Const nnc_info_type nnc_info, int lgr_nr );

// #ifdef __cplusplus
// #endif
// #endif



// Parsed from ert/ecl/grid_dims.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'grid_dims.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_GRID_DIMS_H
// #define ERT_GRID_DIMS_H
// #ifdef __cplusplus
// Targeting ../grid_dims_type.java



  public static native void grid_dims_init( grid_dims_type dims, int nx, int ny, int nz, int nactive);
  public static native grid_dims_type grid_dims_alloc( int nx, int ny, int nz, int nactive);
  public static native void grid_dims_free( grid_dims_type dims );
  public static native void grid_dims_free__( Pointer arg);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_grid.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_grid.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_GRID_H
// #define ERT_ECL_GRID_H

// #include <stdbool.h>

// #include <ert/util/double_vector.hpp>
// #include <ert/util/int_vector.hpp>
// #include <ert/util/stringlist.hpp>

// #include <ert/ecl/ecl_coarse_cell.hpp>
// #include <ert/ecl/ecl_kw.hpp>
// #include <ert/ecl/grid_dims.hpp>
// #include <ert/ecl/nnc_info.hpp>

// #ifdef __cplusplus
// #endif

// #define ECL_GRID_COORD_SIZE(nx,ny)    (((nx) + 1) * ((ny) + 1) * 6)
// #define ECL_GRID_ZCORN_SIZE(nx,ny,nz) (((nx) * (ny) * (nz) * 8))

public static final String ECL_GRID_GLOBAL_GRID =   "Global";  // used as key in hash tables over grids.
public static final int ECL_GRID_MAINGRID_LGR_NR = 0;
// Targeting ../block_function_ftype.java


// Targeting ../ecl_grid_type.java



  public static native @Cast("bool") boolean ecl_grid_have_coarse_cells( @Const ecl_grid_type main_grid );
  public static native @Cast("bool") boolean ecl_grid_cell_in_coarse_group1( @Const ecl_grid_type main_grid, int global_index );
  public static native @Cast("bool") boolean ecl_grid_cell_in_coarse_group3( @Const ecl_grid_type main_grid, int i, int j, int k);
  public static native int ecl_grid_get_num_coarse_groups( @Const ecl_grid_type main_grid );
  public static native ecl_coarse_cell_type ecl_grid_iget_coarse_group( @Const ecl_grid_type ecl_grid, int coarse_nr );
  public static native ecl_coarse_cell_type ecl_grid_get_cell_coarse_group1( @Const ecl_grid_type ecl_grid, int global_index);
  public static native ecl_coarse_cell_type ecl_grid_get_cell_coarse_group3( @Const ecl_grid_type ecl_grid, int i, int j, int k);

  public static native int ecl_grid_get_cell_twist1( @Const ecl_grid_type ecl_grid, int global_index );
  public static native int ecl_grid_get_cell_twist3( @Const ecl_grid_type ecl_grid, int i, int j, int k);

  public static native void ecl_grid_get_column_property(@Const ecl_grid_type ecl_grid, @Const ecl_kw_type ecl_kw, int i, int j, double_vector_type column);
  public static native int ecl_grid_get_global_index_from_xy_top( @Const ecl_grid_type ecl_grid, double x, double y);
  public static native int ecl_grid_get_global_index_from_xy_bottom( @Const ecl_grid_type ecl_grid, double x, double y);
  public static native ecl_grid_type ecl_grid_alloc_dx_dy_dz_tops( int nx, int ny, int nz, @Const DoublePointer dx, @Const DoublePointer dy, @Const DoublePointer dz, @Const DoublePointer tops, @Const IntPointer actnum);
  public static native ecl_grid_type ecl_grid_alloc_dx_dy_dz_tops( int nx, int ny, int nz, @Const DoubleBuffer dx, @Const DoubleBuffer dy, @Const DoubleBuffer dz, @Const DoubleBuffer tops, @Const IntBuffer actnum);
  public static native ecl_grid_type ecl_grid_alloc_dx_dy_dz_tops( int nx, int ny, int nz, @Const double[] dx, @Const double[] dy, @Const double[] dz, @Const double[] tops, @Const int[] actnum);

  public static native void ecl_grid_get_cell_corner_xyz3(@Const ecl_grid_type grid, int i, int j, int k, int corner_nr, DoublePointer xpos, DoublePointer ypos, DoublePointer zpos );
  public static native void ecl_grid_get_cell_corner_xyz3(@Const ecl_grid_type grid, int i, int j, int k, int corner_nr, DoubleBuffer xpos, DoubleBuffer ypos, DoubleBuffer zpos );
  public static native void ecl_grid_get_cell_corner_xyz3(@Const ecl_grid_type grid, int i, int j, int k, int corner_nr, double[] xpos, double[] ypos, double[] zpos );
  public static native void ecl_grid_get_cell_corner_xyz1(@Const ecl_grid_type grid, int global_index, int corner_nr, DoublePointer xpos, DoublePointer ypos, DoublePointer zpos );
  public static native void ecl_grid_get_cell_corner_xyz1(@Const ecl_grid_type grid, int global_index, int corner_nr, DoubleBuffer xpos, DoubleBuffer ypos, DoubleBuffer zpos );
  public static native void ecl_grid_get_cell_corner_xyz1(@Const ecl_grid_type grid, int global_index, int corner_nr, double[] xpos, double[] ypos, double[] zpos );
  public static native void ecl_grid_get_corner_xyz(@Const ecl_grid_type grid, int i, int j, int k, DoublePointer xpos, DoublePointer ypos, DoublePointer zpos );
  public static native void ecl_grid_get_corner_xyz(@Const ecl_grid_type grid, int i, int j, int k, DoubleBuffer xpos, DoubleBuffer ypos, DoubleBuffer zpos );
  public static native void ecl_grid_get_corner_xyz(@Const ecl_grid_type grid, int i, int j, int k, double[] xpos, double[] ypos, double[] zpos );

  public static native double ecl_grid_get_cell_dx1A( @Const ecl_grid_type grid, int active_index);
  public static native double ecl_grid_get_cell_dy1A( @Const ecl_grid_type grid, int active_index);
  public static native double ecl_grid_get_cell_dz1A( @Const ecl_grid_type grid, int active_index );
  public static native double ecl_grid_get_cell_thickness1A( @Const ecl_grid_type grid, int active_index );

  public static native double ecl_grid_get_cell_dx1( @Const ecl_grid_type grid, int global_index );
  public static native double ecl_grid_get_cell_dy1( @Const ecl_grid_type grid, int global_index );
  public static native double ecl_grid_get_cell_dz1( @Const ecl_grid_type grid, int global_index );
  public static native double ecl_grid_get_cell_thickness1( @Const ecl_grid_type grid, int global_index );

  public static native double ecl_grid_get_cell_dx3( @Const ecl_grid_type grid, int i, int j, int k);
  public static native double ecl_grid_get_cell_dy3( @Const ecl_grid_type grid, int i, int j, int k);
  public static native double ecl_grid_get_cell_dz3( @Const ecl_grid_type grid, int i, int j, int k);
  public static native double ecl_grid_get_cell_thickness3( @Const ecl_grid_type grid, int i, int j, int k);

  public static native void ecl_grid_get_distance(@Const ecl_grid_type grid, int global_index1, int global_index2, DoublePointer dx, DoublePointer dy, DoublePointer dz);
  public static native void ecl_grid_get_distance(@Const ecl_grid_type grid, int global_index1, int global_index2, DoubleBuffer dx, DoubleBuffer dy, DoubleBuffer dz);
  public static native void ecl_grid_get_distance(@Const ecl_grid_type grid, int global_index1, int global_index2, double[] dx, double[] dy, double[] dz);
  public static native double ecl_grid_get_cdepth1A(@Const ecl_grid_type grid, int active_index);
  public static native double ecl_grid_get_cdepth1(@Const ecl_grid_type grid, int global_index);
  public static native double ecl_grid_get_cdepth3(@Const ecl_grid_type grid, int i, int j, int k);
  public static native int ecl_grid_get_global_index_from_xy( @Const ecl_grid_type ecl_grid, int k, @Cast("bool") boolean lower_layer, double x, double y);
  public static native @Cast("bool") boolean ecl_grid_cell_contains_xyz1( @Const ecl_grid_type ecl_grid, int global_index, double x, double y, double z);
  public static native @Cast("bool") boolean ecl_grid_cell_contains_xyz3( @Const ecl_grid_type ecl_grid, int i, int j, int k, double x, double y, double z );
  public static native double ecl_grid_get_cell_volume1( @Const ecl_grid_type ecl_grid, int global_index );
  public static native double ecl_grid_get_cell_volume3( @Const ecl_grid_type ecl_grid, int i, int j, int k);
  public static native double ecl_grid_get_cell_volume1A( @Const ecl_grid_type ecl_grid, int active_index );
  public static native @Cast("bool") boolean ecl_grid_cell_contains1(@Const ecl_grid_type grid, int global_index, double x, double y, double z);
  public static native @Cast("bool") boolean ecl_grid_cell_contains3(@Const ecl_grid_type grid, int i, int j,int k, double x, double y, double z);
  public static native int ecl_grid_get_global_index_from_xyz(ecl_grid_type grid, double x, double y, double z, int start_index);
  public static native @Cast("bool") boolean ecl_grid_get_ijk_from_xyz(ecl_grid_type grid, double x, double y, double z, int start_index, IntPointer i, IntPointer j, IntPointer k );
  public static native @Cast("bool") boolean ecl_grid_get_ijk_from_xyz(ecl_grid_type grid, double x, double y, double z, int start_index, IntBuffer i, IntBuffer j, IntBuffer k );
  public static native @Cast("bool") boolean ecl_grid_get_ijk_from_xyz(ecl_grid_type grid, double x, double y, double z, int start_index, int[] i, int[] j, int[] k );
  public static native @Cast("bool") boolean ecl_grid_get_ij_from_xy( @Const ecl_grid_type grid, double x, double y, int k, IntPointer i, IntPointer j);
  public static native @Cast("bool") boolean ecl_grid_get_ij_from_xy( @Const ecl_grid_type grid, double x, double y, int k, IntBuffer i, IntBuffer j);
  public static native @Cast("bool") boolean ecl_grid_get_ij_from_xy( @Const ecl_grid_type grid, double x, double y, int k, int[] i, int[] j);
  public static native @Cast("const char*") BytePointer ecl_grid_get_name( @Const ecl_grid_type arg0 );
  public static native int ecl_grid_get_active_index3(@Const ecl_grid_type ecl_grid, int i, int j, int k);
  public static native int ecl_grid_get_active_index1(@Const ecl_grid_type ecl_grid, int global_index);
  public static native int ecl_grid_get_active_fracture_index3(@Const ecl_grid_type ecl_grid, int i, int j, int k);
  public static native int ecl_grid_get_active_fracture_index1(@Const ecl_grid_type ecl_grid, int global_index);
  public static native @Cast("bool") boolean ecl_grid_cell_active3(@Const ecl_grid_type arg0, int arg1, int arg2, int arg3 );
  public static native @Cast("bool") boolean ecl_grid_cell_active1(@Const ecl_grid_type arg0, int arg1);
  public static native @Cast("bool") boolean ecl_grid_ijk_valid(@Const ecl_grid_type arg0, int arg1, int arg2, int arg3 );
  public static native int ecl_grid_get_global_index3(@Const ecl_grid_type arg0, int arg1, int arg2, int arg3 );
  public static native int ecl_grid_get_global_index1A(@Const ecl_grid_type ecl_grid, int active_index);
  public static native int ecl_grid_get_global_index1F(@Const ecl_grid_type ecl_grid, int active_fracture_index);

  public static native @Const nnc_info_type ecl_grid_get_cell_nnc_info3( @Const ecl_grid_type grid, int i, int j, int k);
  public static native @Const nnc_info_type ecl_grid_get_cell_nnc_info1( @Const ecl_grid_type grid, int global_index);
  public static native void ecl_grid_add_self_nnc( ecl_grid_type grid1, int g1, int g2, int nnc_index);
  public static native void ecl_grid_add_self_nnc_list( ecl_grid_type grid, @Const IntPointer g1_list, @Const IntPointer g2_list, int num_nnc );
  public static native void ecl_grid_add_self_nnc_list( ecl_grid_type grid, @Const IntBuffer g1_list, @Const IntBuffer g2_list, int num_nnc );
  public static native void ecl_grid_add_self_nnc_list( ecl_grid_type grid, @Const int[] g1_list, @Const int[] g2_list, int num_nnc );

  public static native ecl_grid_type ecl_grid_alloc_GRDECL_kw( int nx, int ny, int nz, @Const ecl_kw_type zcorn_kw, @Const ecl_kw_type coord_kw, @Const ecl_kw_type actnum_kw, @Const ecl_kw_type mapaxes_kw );
  public static native ecl_grid_type ecl_grid_alloc_GRDECL_data(int arg0, int arg1, int arg2, @Const FloatPointer arg3, @Const FloatPointer arg4, @Const IntPointer arg5, @Cast("bool") boolean apply_mapaxes, @Const FloatPointer mapaxes);
  public static native ecl_grid_type ecl_grid_alloc_GRDECL_data(int arg0, int arg1, int arg2, @Const FloatBuffer arg3, @Const FloatBuffer arg4, @Const IntBuffer arg5, @Cast("bool") boolean apply_mapaxes, @Const FloatBuffer mapaxes);
  public static native ecl_grid_type ecl_grid_alloc_GRDECL_data(int arg0, int arg1, int arg2, @Const float[] arg3, @Const float[] arg4, @Const int[] arg5, @Cast("bool") boolean apply_mapaxes, @Const float[] mapaxes);
  public static native ecl_grid_type ecl_grid_alloc_GRID_data(int num_coords, int nx, int ny, int nz, int coords_size, @Cast("int**") PointerPointer coords, @Cast("float**") PointerPointer corners, @Cast("bool") boolean apply_mapaxes, @Const FloatPointer mapaxes);
  public static native ecl_grid_type ecl_grid_alloc_GRID_data(int num_coords, int nx, int ny, int nz, int coords_size, @ByPtrPtr IntPointer coords, @ByPtrPtr FloatPointer corners, @Cast("bool") boolean apply_mapaxes, @Const FloatPointer mapaxes);
  public static native ecl_grid_type ecl_grid_alloc_GRID_data(int num_coords, int nx, int ny, int nz, int coords_size, @ByPtrPtr IntBuffer coords, @ByPtrPtr FloatBuffer corners, @Cast("bool") boolean apply_mapaxes, @Const FloatBuffer mapaxes);
  public static native ecl_grid_type ecl_grid_alloc_GRID_data(int num_coords, int nx, int ny, int nz, int coords_size, @ByPtrPtr int[] coords, @ByPtrPtr float[] corners, @Cast("bool") boolean apply_mapaxes, @Const float[] mapaxes);
  public static native ecl_grid_type ecl_grid_alloc(@Cast("const char*") BytePointer arg0 );
  public static native ecl_grid_type ecl_grid_alloc(String arg0 );
  public static native ecl_grid_type ecl_grid_alloc_ext_actnum(@Cast("const char*") BytePointer arg0, @Const IntPointer ext_actnum);
  public static native ecl_grid_type ecl_grid_alloc_ext_actnum(String arg0, @Const IntBuffer ext_actnum);
  public static native ecl_grid_type ecl_grid_alloc_ext_actnum(@Cast("const char*") BytePointer arg0, @Const int[] ext_actnum);
  public static native ecl_grid_type ecl_grid_alloc_ext_actnum(String arg0, @Const IntPointer ext_actnum);
  public static native ecl_grid_type ecl_grid_alloc_ext_actnum(@Cast("const char*") BytePointer arg0, @Const IntBuffer ext_actnum);
  public static native ecl_grid_type ecl_grid_alloc_ext_actnum(String arg0, @Const int[] ext_actnum);
  public static native ecl_grid_type ecl_grid_load_case( @Cast("const char*") BytePointer case_input );
  public static native ecl_grid_type ecl_grid_load_case( String case_input );
  public static native ecl_grid_type ecl_grid_load_case__( @Cast("const char*") BytePointer case_input, @Cast("bool") boolean apply_mapaxes);
  public static native ecl_grid_type ecl_grid_load_case__( String case_input, @Cast("bool") boolean apply_mapaxes);
  public static native ecl_grid_type ecl_grid_alloc_rectangular( int nx, int ny, int nz, double dx, double dy, double dz, @Const IntPointer actnum);
  public static native ecl_grid_type ecl_grid_alloc_rectangular( int nx, int ny, int nz, double dx, double dy, double dz, @Const IntBuffer actnum);
  public static native ecl_grid_type ecl_grid_alloc_rectangular( int nx, int ny, int nz, double dx, double dy, double dz, @Const int[] actnum);
  public static native ecl_grid_type ecl_grid_alloc_regular( int nx, int ny, int nz, @Const DoublePointer ivec, @Const DoublePointer jvec, @Const DoublePointer kvec, @Const IntPointer actnum);
  public static native ecl_grid_type ecl_grid_alloc_regular( int nx, int ny, int nz, @Const DoubleBuffer ivec, @Const DoubleBuffer jvec, @Const DoubleBuffer kvec, @Const IntBuffer actnum);
  public static native ecl_grid_type ecl_grid_alloc_regular( int nx, int ny, int nz, @Const double[] ivec, @Const double[] jvec, @Const double[] kvec, @Const int[] actnum);
  public static native ecl_grid_type ecl_grid_alloc_dxv_dyv_dzv( int nx, int ny, int nz, @Const DoublePointer dxv, @Const DoublePointer dyv, @Const DoublePointer dzv, @Const IntPointer actnum);
  public static native ecl_grid_type ecl_grid_alloc_dxv_dyv_dzv( int nx, int ny, int nz, @Const DoubleBuffer dxv, @Const DoubleBuffer dyv, @Const DoubleBuffer dzv, @Const IntBuffer actnum);
  public static native ecl_grid_type ecl_grid_alloc_dxv_dyv_dzv( int nx, int ny, int nz, @Const double[] dxv, @Const double[] dyv, @Const double[] dzv, @Const int[] actnum);
  public static native ecl_grid_type ecl_grid_alloc_dxv_dyv_dzv_depthz( int nx, int ny, int nz, @Const DoublePointer dxv, @Const DoublePointer dyv, @Const DoublePointer dzv, @Const DoublePointer depthz, @Const IntPointer actnum);
  public static native ecl_grid_type ecl_grid_alloc_dxv_dyv_dzv_depthz( int nx, int ny, int nz, @Const DoubleBuffer dxv, @Const DoubleBuffer dyv, @Const DoubleBuffer dzv, @Const DoubleBuffer depthz, @Const IntBuffer actnum);
  public static native ecl_grid_type ecl_grid_alloc_dxv_dyv_dzv_depthz( int nx, int ny, int nz, @Const double[] dxv, @Const double[] dyv, @Const double[] dzv, @Const double[] depthz, @Const int[] actnum);
  public static native ecl_kw_type ecl_grid_alloc_volume_kw( @Const ecl_grid_type grid, @Cast("bool") boolean active_size);
  public static native ecl_kw_type ecl_grid_alloc_mapaxes_kw( @Const ecl_grid_type grid );
  public static native ecl_kw_type ecl_grid_alloc_coord_kw( @Const ecl_grid_type grid);

  public static native @Cast("bool") boolean ecl_grid_exists( @Cast("const char*") BytePointer case_input );
  public static native @Cast("bool") boolean ecl_grid_exists( String case_input );
  public static native @Cast("char*") BytePointer ecl_grid_alloc_case_filename( @Cast("const char*") BytePointer case_input );
  public static native @Cast("char*") ByteBuffer ecl_grid_alloc_case_filename( String case_input );

  public static native void ecl_grid_free(ecl_grid_type arg0 );
  public static native void ecl_grid_free__( Pointer arg );
  public static native @ByVal grid_dims_type ecl_grid_iget_dims( @Const ecl_grid_type grid, int grid_nr);
  public static native void ecl_grid_get_dims(@Const ecl_grid_type arg0, IntPointer arg1, IntPointer arg2, IntPointer arg3, IntPointer arg4);
  public static native void ecl_grid_get_dims(@Const ecl_grid_type arg0, IntBuffer arg1, IntBuffer arg2, IntBuffer arg3, IntBuffer arg4);
  public static native void ecl_grid_get_dims(@Const ecl_grid_type arg0, int[] arg1, int[] arg2, int[] arg3, int[] arg4);
  public static native int ecl_grid_get_nz( @Const ecl_grid_type grid );
  public static native int ecl_grid_get_nx( @Const ecl_grid_type grid );
  public static native int ecl_grid_get_ny( @Const ecl_grid_type grid );
  public static native int ecl_grid_get_nactive( @Const ecl_grid_type grid );
  public static native int ecl_grid_get_nactive_fracture( @Const ecl_grid_type grid );
  public static native int ecl_grid_get_active_index(@Const ecl_grid_type arg0, int arg1, int arg2, int arg3 );
  public static native void ecl_grid_summarize(@Const ecl_grid_type arg0 );
  public static native void ecl_grid_get_ijk1(@Const ecl_grid_type arg0, int global_index, IntPointer arg2, IntPointer arg3, IntPointer arg4);
  public static native void ecl_grid_get_ijk1(@Const ecl_grid_type arg0, int global_index, IntBuffer arg2, IntBuffer arg3, IntBuffer arg4);
  public static native void ecl_grid_get_ijk1(@Const ecl_grid_type arg0, int global_index, int[] arg2, int[] arg3, int[] arg4);
  public static native void ecl_grid_get_ijk1A(@Const ecl_grid_type arg0, int active_index, IntPointer arg2, IntPointer arg3, IntPointer arg4);
  public static native void ecl_grid_get_ijk1A(@Const ecl_grid_type arg0, int active_index, IntBuffer arg2, IntBuffer arg3, IntBuffer arg4);
  public static native void ecl_grid_get_ijk1A(@Const ecl_grid_type arg0, int active_index, int[] arg2, int[] arg3, int[] arg4);
  public static native void ecl_grid_get_ijk_from_active_index(@Const ecl_grid_type arg0, int arg1, IntPointer arg2, IntPointer arg3, IntPointer arg4 );
  public static native void ecl_grid_get_ijk_from_active_index(@Const ecl_grid_type arg0, int arg1, IntBuffer arg2, IntBuffer arg3, IntBuffer arg4 );
  public static native void ecl_grid_get_ijk_from_active_index(@Const ecl_grid_type arg0, int arg1, int[] arg2, int[] arg3, int[] arg4 );

  public static native void ecl_grid_get_xyz3(@Const ecl_grid_type arg0, int arg1, int arg2, int arg3, DoublePointer arg4, DoublePointer arg5, DoublePointer arg6);
  public static native void ecl_grid_get_xyz3(@Const ecl_grid_type arg0, int arg1, int arg2, int arg3, DoubleBuffer arg4, DoubleBuffer arg5, DoubleBuffer arg6);
  public static native void ecl_grid_get_xyz3(@Const ecl_grid_type arg0, int arg1, int arg2, int arg3, double[] arg4, double[] arg5, double[] arg6);
  public static native void ecl_grid_get_xyz1(@Const ecl_grid_type grid, int global_index, DoublePointer xpos, DoublePointer ypos, DoublePointer zpos);
  public static native void ecl_grid_get_xyz1(@Const ecl_grid_type grid, int global_index, DoubleBuffer xpos, DoubleBuffer ypos, DoubleBuffer zpos);
  public static native void ecl_grid_get_xyz1(@Const ecl_grid_type grid, int global_index, double[] xpos, double[] ypos, double[] zpos);
  public static native void ecl_grid_get_xyz1A(@Const ecl_grid_type grid, int active_index, DoublePointer xpos, DoublePointer ypos, DoublePointer zpos);
  public static native void ecl_grid_get_xyz1A(@Const ecl_grid_type grid, int active_index, DoubleBuffer xpos, DoubleBuffer ypos, DoubleBuffer zpos);
  public static native void ecl_grid_get_xyz1A(@Const ecl_grid_type grid, int active_index, double[] xpos, double[] ypos, double[] zpos);

  public static native @Cast("bool") boolean ecl_grid_get_xyz_inside1(@Const ecl_grid_type grid, int global_index, DoublePointer xpos, DoublePointer ypos, DoublePointer zpos);
  public static native @Cast("bool") boolean ecl_grid_get_xyz_inside1(@Const ecl_grid_type grid, int global_index, DoubleBuffer xpos, DoubleBuffer ypos, DoubleBuffer zpos);
  public static native @Cast("bool") boolean ecl_grid_get_xyz_inside1(@Const ecl_grid_type grid, int global_index, double[] xpos, double[] ypos, double[] zpos);
  public static native @Cast("bool") boolean ecl_grid_get_xyz_inside3(@Const ecl_grid_type grid, int i, int j, int k, DoublePointer xpos, DoublePointer ypos, DoublePointer zpos);
  public static native @Cast("bool") boolean ecl_grid_get_xyz_inside3(@Const ecl_grid_type grid, int i, int j, int k, DoubleBuffer xpos, DoubleBuffer ypos, DoubleBuffer zpos);
  public static native @Cast("bool") boolean ecl_grid_get_xyz_inside3(@Const ecl_grid_type grid, int i, int j, int k, double[] xpos, double[] ypos, double[] zpos);

  public static native int ecl_grid_get_global_size( @Const ecl_grid_type ecl_grid );
  public static native @Cast("bool") boolean ecl_grid_compare(@Const ecl_grid_type g1, @Const ecl_grid_type g2, @Cast("bool") boolean include_lgr, @Cast("bool") boolean include_nnc, @Cast("bool") boolean verbose);
  public static native int ecl_grid_get_active_size( @Const ecl_grid_type ecl_grid );

  public static native double ecl_grid_get_bottom1(@Const ecl_grid_type grid, int global_index);
  public static native double ecl_grid_get_bottom3(@Const ecl_grid_type grid, int i, int j, int k);
  public static native double ecl_grid_get_bottom1A(@Const ecl_grid_type grid, int active_index);
  public static native double ecl_grid_get_top1(@Const ecl_grid_type grid, int global_index);
  public static native double ecl_grid_get_top3(@Const ecl_grid_type grid, int i, int j, int k);
  public static native double ecl_grid_get_top1A(@Const ecl_grid_type grid, int active_index);
  public static native double ecl_grid_get_top2(@Const ecl_grid_type grid, int i, int j);
  public static native double ecl_grid_get_bottom2(@Const ecl_grid_type grid, int i, int j);
  public static native int ecl_grid_locate_depth( @Const ecl_grid_type grid, double depth, int i, int j );

  public static native void ecl_grid_alloc_blocking_variables(ecl_grid_type arg0, int arg1 );
  public static native void ecl_grid_init_blocking(ecl_grid_type arg0 );
  public static native double ecl_grid_block_eval3d(ecl_grid_type grid, int i, int j, int k,block_function_ftype blockf );
  public static native int ecl_grid_get_block_count3d(@Const ecl_grid_type ecl_grid, int i, int j, int k);
  public static native @Cast("bool") boolean ecl_grid_block_value_3d(ecl_grid_type arg0, double arg1, double arg2,double arg3, double arg4);

  public static native @Cast("bool") boolean ecl_grid_cell_invalid1(@Const ecl_grid_type ecl_grid, int global_index);
  public static native @Cast("bool") boolean ecl_grid_cell_invalid3(@Const ecl_grid_type ecl_grid, int i, int j, int k);
  public static native double ecl_grid_cell_invalid1A(@Const ecl_grid_type grid, int active_index);

  public static native @Cast("bool") boolean ecl_grid_cell_valid1(@Const ecl_grid_type ecl_grid, int global_index);
  public static native @Cast("bool") boolean ecl_grid_cell_valid3(@Const ecl_grid_type ecl_grid, int i, int j, int k);
  public static native double ecl_grid_cell_valid1A(@Const ecl_grid_type grid, int active_index);

  public static native void ecl_grid_dump(@Const ecl_grid_type grid, @Cast("FILE*") Pointer stream);
  public static native void ecl_grid_dump_ascii(ecl_grid_type grid, @Cast("bool") boolean active_only, @Cast("FILE*") Pointer stream);
  public static native void ecl_grid_dump_ascii_cell1(ecl_grid_type grid, int global_index, @Cast("FILE*") Pointer stream, @Const DoublePointer offset);
  public static native void ecl_grid_dump_ascii_cell1(ecl_grid_type grid, int global_index, @Cast("FILE*") Pointer stream, @Const DoubleBuffer offset);
  public static native void ecl_grid_dump_ascii_cell1(ecl_grid_type grid, int global_index, @Cast("FILE*") Pointer stream, @Const double[] offset);
  public static native void ecl_grid_dump_ascii_cell3(ecl_grid_type grid, int i, int j, int k, @Cast("FILE*") Pointer stream, @Const DoublePointer offset);
  public static native void ecl_grid_dump_ascii_cell3(ecl_grid_type grid, int i, int j, int k, @Cast("FILE*") Pointer stream, @Const DoubleBuffer offset);
  public static native void ecl_grid_dump_ascii_cell3(ecl_grid_type grid, int i, int j, int k, @Cast("FILE*") Pointer stream, @Const double[] offset);

  /* lgr related functions */
  public static native @Const ecl_grid_type ecl_grid_get_cell_lgr3(@Const ecl_grid_type grid, int i, int j, int k);
  public static native @Const ecl_grid_type ecl_grid_get_cell_lgr1A(@Const ecl_grid_type grid, int active_index);
  public static native @Const ecl_grid_type ecl_grid_get_cell_lgr1(@Const ecl_grid_type grid, int global_index );
  public static native int ecl_grid_get_num_lgr(@Const ecl_grid_type main_grid );
  public static native int ecl_grid_get_lgr_nr( @Const ecl_grid_type ecl_grid );
  public static native int ecl_grid_get_lgr_nr_from_name( @Const ecl_grid_type grid, @Cast("const char*") BytePointer name);
  public static native int ecl_grid_get_lgr_nr_from_name( @Const ecl_grid_type grid, String name);
  public static native ecl_grid_type ecl_grid_iget_lgr(@Const ecl_grid_type main_grid, int lgr_index);
  public static native ecl_grid_type ecl_grid_get_lgr_from_lgr_nr(@Const ecl_grid_type main_grid, int lgr_nr);
  public static native ecl_grid_type ecl_grid_get_lgr(@Const ecl_grid_type main_grid, @Cast("const char*") BytePointer __lgr_name);
  public static native ecl_grid_type ecl_grid_get_lgr(@Const ecl_grid_type main_grid, String __lgr_name);
  public static native @Cast("bool") boolean ecl_grid_has_lgr(@Const ecl_grid_type main_grid, @Cast("const char*") BytePointer __lgr_name);
  public static native @Cast("bool") boolean ecl_grid_has_lgr(@Const ecl_grid_type main_grid, String __lgr_name);
  public static native @Cast("bool") boolean ecl_grid_has_lgr_nr(@Const ecl_grid_type main_grid, int lgr_nr);
  public static native @Cast("const char*") BytePointer ecl_grid_iget_lgr_name( @Const ecl_grid_type ecl_grid, int lgr_index);
  public static native @Cast("const char*") BytePointer ecl_grid_get_lgr_name( @Const ecl_grid_type ecl_grid, int lgr_nr);
  public static native stringlist_type ecl_grid_alloc_lgr_name_list(@Const ecl_grid_type ecl_grid);
  public static native int ecl_grid_get_parent_cell1( @Const ecl_grid_type grid, int global_index);
  public static native int ecl_grid_get_parent_cell3( @Const ecl_grid_type grid, int i, int j, int k);
  public static native @Const ecl_grid_type ecl_grid_get_global_grid( @Const ecl_grid_type grid );
  public static native @Cast("bool") boolean ecl_grid_is_lgr( @Const ecl_grid_type ecl_grid );

  public static native double ecl_grid_get_property(@Const ecl_grid_type ecl_grid, @Const ecl_kw_type ecl_kw, int i, int j, int k);
  public static native float ecl_grid_get_float_property(@Const ecl_grid_type ecl_grid, @Const ecl_kw_type ecl_kw, int i, int j, int k);
  public static native double ecl_grid_get_double_property(@Const ecl_grid_type ecl_grid, @Const ecl_kw_type ecl_kw, int i, int j, int k);
  public static native int ecl_grid_get_int_property(@Const ecl_grid_type ecl_grid, @Const ecl_kw_type ecl_kw, int i, int j, int k);

  public static native void ecl_grid_grdecl_fprintf_kw( @Const ecl_grid_type ecl_grid, @Const ecl_kw_type ecl_kw, @Cast("const char*") BytePointer special_header, @Cast("FILE*") Pointer stream, double double_default);
  public static native void ecl_grid_grdecl_fprintf_kw( @Const ecl_grid_type ecl_grid, @Const ecl_kw_type ecl_kw, String special_header, @Cast("FILE*") Pointer stream, double double_default);
  public static native @Cast("bool") boolean ecl_grid_test_lgr_consistency( @Const ecl_grid_type ecl_grid );

  public static native void ecl_grid_fwrite_dims( @Const ecl_grid_type grid, fortio_type init_file,  @Cast("ert_ecl_unit_enum") int output_unit);
  public static native void ecl_grid_fwrite_depth( @Const ecl_grid_type grid, fortio_type init_file, @Cast("ert_ecl_unit_enum") int ouput_unit);

  public static native void ecl_grid_fwrite_EGRID(  ecl_grid_type grid, @Cast("const char*") BytePointer filename, @Cast("bool") boolean metric_output);
  public static native void ecl_grid_fwrite_EGRID(  ecl_grid_type grid, String filename, @Cast("bool") boolean metric_output);
  public static native void ecl_grid_fwrite_EGRID2( ecl_grid_type grid, @Cast("const char*") BytePointer filename, @Cast("ert_ecl_unit_enum") int output_unit);
  public static native void ecl_grid_fwrite_EGRID2( ecl_grid_type grid, String filename, @Cast("ert_ecl_unit_enum") int output_unit);

  public static native void ecl_grid_fwrite_GRID( @Const ecl_grid_type grid, @Cast("const char*") BytePointer filename);
  public static native void ecl_grid_fwrite_GRID( @Const ecl_grid_type grid, String filename);
  public static native void ecl_grid_fwrite_GRID2( @Const ecl_grid_type grid, @Cast("const char*") BytePointer filename, @Cast("ert_ecl_unit_enum") int output_unit);
  public static native void ecl_grid_fwrite_GRID2( @Const ecl_grid_type grid, String filename, @Cast("ert_ecl_unit_enum") int output_unit);

  public static native void ecl_grid_fprintf_grdecl(  ecl_grid_type grid, @Cast("FILE*") Pointer stream );
  public static native void ecl_grid_fprintf_grdecl2(  ecl_grid_type grid, @Cast("FILE*") Pointer stream, @Cast("ert_ecl_unit_enum") int output_unit);

  public static native int ecl_grid_zcorn_index__(int nx, int ny, int i, int j, int k, int c);
  public static native int ecl_grid_zcorn_index(@Const ecl_grid_type grid, int i, int j, int k, int c);
  public static native ecl_grid_type ecl_grid_alloc_EGRID(@Cast("const char*") BytePointer grid_file, @Cast("bool") boolean apply_mapaxes );
  public static native ecl_grid_type ecl_grid_alloc_EGRID(String grid_file, @Cast("bool") boolean apply_mapaxes );
  public static native ecl_grid_type ecl_grid_alloc_GRID(@Cast("const char*") BytePointer grid_file, @Cast("bool") boolean apply_mapaxes );
  public static native ecl_grid_type ecl_grid_alloc_GRID(String grid_file, @Cast("bool") boolean apply_mapaxes );

  public static native FloatPointer ecl_grid_alloc_zcorn_data( @Const ecl_grid_type grid );
  public static native ecl_kw_type ecl_grid_alloc_zcorn_kw( @Const ecl_grid_type grid );
  public static native IntPointer ecl_grid_alloc_actnum_data( @Const ecl_grid_type grid );
  public static native ecl_kw_type ecl_grid_alloc_actnum_kw( @Const ecl_grid_type grid );
  public static native ecl_kw_type ecl_grid_alloc_hostnum_kw( @Const ecl_grid_type grid );
  public static native ecl_kw_type ecl_grid_alloc_gridhead_kw( int nx, int ny, int nz, int grid_nr);
  public static native ecl_grid_type ecl_grid_alloc_copy( @Const ecl_grid_type src_grid );
  public static native ecl_grid_type ecl_grid_alloc_processed_copy( @Const ecl_grid_type src_grid, @Const DoublePointer zcorn, @Const IntPointer actnum);
  public static native ecl_grid_type ecl_grid_alloc_processed_copy( @Const ecl_grid_type src_grid, @Const DoubleBuffer zcorn, @Const IntBuffer actnum);
  public static native ecl_grid_type ecl_grid_alloc_processed_copy( @Const ecl_grid_type src_grid, @Const double[] zcorn, @Const int[] actnum);

  public static native void ecl_grid_ri_export( @Const ecl_grid_type ecl_grid, DoublePointer ri_points);
  public static native void ecl_grid_ri_export( @Const ecl_grid_type ecl_grid, DoubleBuffer ri_points);
  public static native void ecl_grid_ri_export( @Const ecl_grid_type ecl_grid, double[] ri_points);
  public static native void ecl_grid_cell_ri_export( @Const ecl_grid_type ecl_grid, int global_index, DoublePointer ri_points);
  public static native void ecl_grid_cell_ri_export( @Const ecl_grid_type ecl_grid, int global_index, DoubleBuffer ri_points);
  public static native void ecl_grid_cell_ri_export( @Const ecl_grid_type ecl_grid, int global_index, double[] ri_points);

  public static native @Cast("bool") boolean ecl_grid_dual_grid( @Const ecl_grid_type ecl_grid );
  public static native int ecl_grid_get_num_nnc( @Const ecl_grid_type grid );

  public static native @Cast("bool") boolean ecl_grid_cell_regular3( @Const ecl_grid_type ecl_grid, int i,int j,int k);
  public static native @Cast("bool") boolean ecl_grid_cell_regular1( @Const ecl_grid_type ecl_grid, int global_index);

  public static native void ecl_grid_init_zcorn_data( @Const ecl_grid_type grid, FloatPointer zcorn );
  public static native void ecl_grid_init_zcorn_data( @Const ecl_grid_type grid, FloatBuffer zcorn );
  public static native void ecl_grid_init_zcorn_data( @Const ecl_grid_type grid, float[] zcorn );
  public static native void ecl_grid_init_zcorn_data_double( @Const ecl_grid_type grid, DoublePointer zcorn );
  public static native void ecl_grid_init_zcorn_data_double( @Const ecl_grid_type grid, DoubleBuffer zcorn );
  public static native void ecl_grid_init_zcorn_data_double( @Const ecl_grid_type grid, double[] zcorn );
  public static native int ecl_grid_get_zcorn_size( @Const ecl_grid_type grid );

  public static native void ecl_grid_init_coord_data( @Const ecl_grid_type grid, FloatPointer coord );
  public static native void ecl_grid_init_coord_data( @Const ecl_grid_type grid, FloatBuffer coord );
  public static native void ecl_grid_init_coord_data( @Const ecl_grid_type grid, float[] coord );
  public static native void ecl_grid_init_coord_data_double( @Const ecl_grid_type grid, DoublePointer coord );
  public static native void ecl_grid_init_coord_data_double( @Const ecl_grid_type grid, DoubleBuffer coord );
  public static native void ecl_grid_init_coord_data_double( @Const ecl_grid_type grid, double[] coord );
  public static native int ecl_grid_get_coord_size( @Const ecl_grid_type ecl_grid);

  public static native void ecl_grid_init_actnum_data( @Const ecl_grid_type grid, IntPointer actnum );
  public static native void ecl_grid_init_actnum_data( @Const ecl_grid_type grid, IntBuffer actnum );
  public static native void ecl_grid_init_actnum_data( @Const ecl_grid_type grid, int[] actnum );
  public static native @Cast("bool") boolean ecl_grid_use_mapaxes( @Const ecl_grid_type grid );
  public static native void ecl_grid_init_mapaxes_data_double( @Const ecl_grid_type grid, DoublePointer mapaxes);
  public static native void ecl_grid_init_mapaxes_data_double( @Const ecl_grid_type grid, DoubleBuffer mapaxes);
  public static native void ecl_grid_init_mapaxes_data_double( @Const ecl_grid_type grid, double[] mapaxes);
  public static native void ecl_grid_reset_actnum( ecl_grid_type grid, @Const IntPointer actnum );
  public static native void ecl_grid_reset_actnum( ecl_grid_type grid, @Const IntBuffer actnum );
  public static native void ecl_grid_reset_actnum( ecl_grid_type grid, @Const int[] actnum );
  public static native void ecl_grid_compressed_kw_copy( @Const ecl_grid_type grid, ecl_kw_type target_kw, @Const ecl_kw_type src_kw);
  public static native void ecl_grid_global_kw_copy( @Const ecl_grid_type grid, ecl_kw_type target_kw, @Const ecl_kw_type src_kw);
  public static native void ecl_grid_export_cell_corners1(@Const ecl_grid_type grid, int global_index, DoublePointer x, DoublePointer y, DoublePointer z);
  public static native void ecl_grid_export_cell_corners1(@Const ecl_grid_type grid, int global_index, DoubleBuffer x, DoubleBuffer y, DoubleBuffer z);
  public static native void ecl_grid_export_cell_corners1(@Const ecl_grid_type grid, int global_index, double[] x, double[] y, double[] z);

  public static native @Cast("ert_ecl_unit_enum") int ecl_grid_get_unit_system(@Const ecl_grid_type grid);
  public static native void ecl_grid_export_index(@Const ecl_grid_type grid, IntPointer global_index, IntPointer index_data, @Cast("bool") boolean active_only);
  public static native void ecl_grid_export_index(@Const ecl_grid_type grid, IntBuffer global_index, IntBuffer index_data, @Cast("bool") boolean active_only);
  public static native void ecl_grid_export_index(@Const ecl_grid_type grid, int[] global_index, int[] index_data, @Cast("bool") boolean active_only);
  public static native void ecl_grid_export_data_as_int( int index_size, @Const IntPointer global_index, @Const ecl_kw_type kw, IntPointer output);
  public static native void ecl_grid_export_data_as_int( int index_size, @Const IntBuffer global_index, @Const ecl_kw_type kw, IntBuffer output);
  public static native void ecl_grid_export_data_as_int( int index_size, @Const int[] global_index, @Const ecl_kw_type kw, int[] output);
  public static native void ecl_grid_export_data_as_double( int index_size, @Const IntPointer data_index, @Const ecl_kw_type kw, DoublePointer output);
  public static native void ecl_grid_export_data_as_double( int index_size, @Const IntBuffer data_index, @Const ecl_kw_type kw, DoubleBuffer output);
  public static native void ecl_grid_export_data_as_double( int index_size, @Const int[] data_index, @Const ecl_kw_type kw, double[] output);
  public static native void ecl_grid_export_volume( @Const ecl_grid_type grid, int index_size, @Const IntPointer global_index, DoublePointer output );
  public static native void ecl_grid_export_volume( @Const ecl_grid_type grid, int index_size, @Const IntBuffer global_index, DoubleBuffer output );
  public static native void ecl_grid_export_volume( @Const ecl_grid_type grid, int index_size, @Const int[] global_index, double[] output );
  public static native void ecl_grid_export_position( @Const ecl_grid_type grid, int index_size, @Const IntPointer global_index, DoublePointer output);
  public static native void ecl_grid_export_position( @Const ecl_grid_type grid, int index_size, @Const IntBuffer global_index, DoubleBuffer output);
  public static native void ecl_grid_export_position( @Const ecl_grid_type grid, int index_size, @Const int[] global_index, double[] output);
  public static native void export_corners( @Const ecl_grid_type grid, int index_size, @Const IntPointer global_index, DoublePointer output);
  public static native void export_corners( @Const ecl_grid_type grid, int index_size, @Const IntBuffer global_index, DoubleBuffer output);
  public static native void export_corners( @Const ecl_grid_type grid, int index_size, @Const int[] global_index, double[] output);

  public static native @Cast("bool") boolean ecl_grid_is_instance( @Const Pointer __arg );
  public static native ecl_grid_type ecl_grid_safe_cast( Pointer __arg );

// #ifdef __cplusplus

  @Namespace("ecl") public static native ecl_grid_type ecl_grid_alloc_GRDECL_data(int nx,
                                               int ny,
                                               int nz,
                                               @Const DoublePointer zcorn,
                                               @Const DoublePointer coord,
                                               @Const IntPointer actnum,
                                               @Cast("bool") boolean apply_mapaxes,
                                               @Const FloatPointer mapaxes);
  @Namespace("ecl") public static native ecl_grid_type ecl_grid_alloc_GRDECL_data(int nx,
                                               int ny,
                                               int nz,
                                               @Const DoubleBuffer zcorn,
                                               @Const DoubleBuffer coord,
                                               @Const IntBuffer actnum,
                                               @Cast("bool") boolean apply_mapaxes,
                                               @Const FloatBuffer mapaxes);
  @Namespace("ecl") public static native ecl_grid_type ecl_grid_alloc_GRDECL_data(int nx,
                                               int ny,
                                               int nz,
                                               @Const double[] zcorn,
                                               @Const double[] coord,
                                               @Const int[] actnum,
                                               @Cast("bool") boolean apply_mapaxes,
                                               @Const float[] mapaxes);



// #ifdef __cplusplus
// #endif

// #endif
// #endif


// Parsed from ert/ecl_well/well_state.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'well_state.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_WELL_STATE_H
// #define ERT_WELL_STATE_H


// #include <time.h>

// #include <ert/ecl/ecl_file.hpp>
// #include <ert/ecl/ecl_grid.hpp>

// #include <ert/ecl_well/well_conn.hpp>
// #include <ert/ecl_well/well_const.hpp>
// #include <ert/ecl_well/well_conn_collection.hpp>
// #include <ert/ecl_well/well_segment_collection.hpp>
// #include <ert/ecl_well/well_branch_collection.hpp>

// #ifdef __cplusplus
// #endif

public static final String GLOBAL_GRID_NAME =   "GLOBAL";
// Targeting ../well_state_type.java



  public static native well_state_type well_state_alloc(@Cast("const char*") BytePointer well_name, int global_well_nr, @Cast("bool") boolean open, @Cast("well_type_enum") int type, int report_nr, @ByVal @Cast("time_t*") Pointer valid_from);
  public static native well_state_type well_state_alloc(String well_name, int global_well_nr, @Cast("bool") boolean open, @Cast("well_type_enum") int type, int report_nr, @ByVal @Cast("time_t*") Pointer valid_from);
  public static native well_state_type well_state_alloc_from_file( ecl_file_type ecl_file, @Const ecl_grid_type grid, int report_step, int well_nr, @Cast("bool") boolean load_segment_information);
  public static native well_state_type well_state_alloc_from_file2( ecl_file_view_type file_view, @Const ecl_grid_type grid, int report_nr,  int global_well_nr,@Cast("bool") boolean load_segment_information);

  public static native void well_state_add_connections2( well_state_type well_state,
                                      @Const ecl_grid_type grid,
                                      ecl_file_view_type rst_view,
                                      int well_nr);

  public static native void well_state_add_connections( well_state_type well_state,
                                     @Const ecl_grid_type grid,
                                     ecl_file_type rst_file,
                                     int well_nr);

  public static native @Cast("bool") boolean well_state_add_MSW( well_state_type well_state,
                             ecl_file_type rst_file,
                             int well_nr,
                             @Cast("bool") boolean load_segment_information);


  public static native @Cast("bool") boolean well_state_add_MSW2( well_state_type well_state,
                              ecl_file_view_type rst_view,
                              int well_nr,
                              @Cast("bool") boolean load_segment_information);


  public static native @Cast("bool") boolean well_state_is_MSW( @Const well_state_type well_state);

  public static native @Cast("bool") boolean well_state_has_segment_data(@Const well_state_type well_state);

  public static native well_segment_collection_type well_state_get_segments( @Const well_state_type well_state );
  public static native well_branch_collection_type well_state_get_branches( @Const well_state_type well_state );


  public static native void well_state_free( well_state_type well );
  public static native @Cast("const char*") BytePointer well_state_get_name( @Const well_state_type well );
  public static native int well_state_get_report_nr( @Const well_state_type well_state );
  public static native @ByVal @Cast("time_t*") Pointer well_state_get_sim_time( @Const well_state_type well_state );
  public static native @Cast("well_type_enum") int well_state_get_type( @Const well_state_type well_state);
  public static native @Cast("bool") boolean well_state_is_open( @Const well_state_type well_state );
  public static native int well_state_get_well_nr( @Const well_state_type well_state );

  public static native @Const well_conn_type well_state_get_global_wellhead( @Const well_state_type well_state );
  public static native @Const well_conn_type well_state_iget_wellhead( @Const well_state_type well_state, int grid_nr);
  public static native @Const well_conn_type well_state_get_wellhead( @Const well_state_type well_state, @Cast("const char*") BytePointer grid_name);
  public static native @Const well_conn_type well_state_get_wellhead( @Const well_state_type well_state, String grid_name);

  public static native @Cast("well_type_enum") int well_state_translate_ecl_type_int(int int_type);

  public static native @Const well_conn_collection_type well_state_get_grid_connections( @Const well_state_type well_state, @Cast("const char*") BytePointer grid_name);
  public static native @Const well_conn_collection_type well_state_get_grid_connections( @Const well_state_type well_state, String grid_name);
  public static native @Const well_conn_collection_type well_state_get_global_connections( @Const well_state_type well_state );
  public static native @Cast("bool") boolean well_state_has_grid_connections( @Const well_state_type well_state, @Cast("const char*") BytePointer grid_name);
  public static native @Cast("bool") boolean well_state_has_grid_connections( @Const well_state_type well_state, String grid_name);
  public static native @Cast("bool") boolean well_state_has_global_connections( @Const well_state_type well_state );

  public static native double well_state_get_oil_rate( @Const well_state_type well_state );
  public static native double well_state_get_gas_rate( @Const well_state_type well_state );
  public static native double well_state_get_water_rate( @Const well_state_type well_state);
  public static native double well_state_get_volume_rate( @Const well_state_type well_state);
  public static native double well_state_get_water_rate_si( @Const well_state_type well_state);
  public static native double well_state_get_oil_rate_si( @Const well_state_type well_state );
  public static native double well_state_get_volume_rate_si( @Const well_state_type well_state);
  public static native double well_state_get_gas_rate_si( @Const well_state_type well_state );


  public static native @Cast("bool") boolean well_state_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/ecl_well/well_ts.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'well_ts.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_WELL_TS_H
// #define ERT_WELL_TS_H


// #include <ert/ecl_well/well_state.hpp>

// #ifdef __cplusplus
// Targeting ../well_ts_type.java



  public static native void well_ts_free( well_ts_type well_ts );
  public static native void well_ts_add_well( well_ts_type well_ts, well_state_type well_state );
  public static native well_ts_type well_ts_alloc( @Cast("const char*") BytePointer well_name );
  public static native well_ts_type well_ts_alloc( String well_name );
  public static native void well_ts_free__( Pointer arg );
  public static native well_state_type well_ts_get_state_from_sim_time( @Const well_ts_type well_ts, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native well_state_type well_ts_get_state_from_report( @Const well_ts_type well_ts, int report_nr);
  public static native well_state_type well_ts_iget_state( @Const well_ts_type well_ts, int index);
  public static native int well_ts_get_size( @Const well_ts_type well_ts);
  public static native @Cast("const char*") BytePointer well_ts_get_name( @Const well_ts_type well_ts);
  public static native well_state_type well_ts_get_first_state( @Const well_ts_type well_ts);
  public static native well_state_type well_ts_get_last_state( @Const well_ts_type well_ts);

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/ecl_well/well_ts.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_ts.hpp>




// Parsed from ert/ecl_well/well_state.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_state.hpp>




// Parsed from ert/ecl_well/well_segment_collection.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_segment_collection.hpp>




// Parsed from ert/ecl_well/well_segment.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_segment.hpp>




// Parsed from ert/ecl_well/well_rseg_loader.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_rseg_loader.hpp>




// Parsed from ert/ecl_well/well_info.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'well_info.c' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_WELL_INFO_H
// #define ERT_WELL_INFO_H



// #include <ert/ecl/ecl_file.hpp>
// #include <ert/ecl/ecl_grid.hpp>

// #include <ert/ecl_well/well_ts.hpp>

// #ifdef __cplusplus
// Targeting ../well_info_type.java



  public static native well_info_type well_info_alloc(@Const ecl_grid_type grid);
  public static native void well_info_add_UNRST_wells2( well_info_type well_info, ecl_file_view_type rst_view, @Cast("bool") boolean load_segment_information);
  public static native void well_info_add_UNRST_wells( well_info_type well_info, ecl_file_type rst_file, @Cast("bool") boolean load_segment_information);
  public static native void well_info_add_wells( well_info_type well_info, ecl_file_type rst_file, int report_nr, @Cast("bool") boolean load_segment_information);
  public static native void well_info_add_wells2( well_info_type well_info, ecl_file_view_type rst_view, int report_nr, @Cast("bool") boolean load_segment_information);
  public static native void well_info_load_rstfile( well_info_type well_info, @Cast("const char*") BytePointer filename, @Cast("bool") boolean load_segment_information);
  public static native void well_info_load_rstfile( well_info_type well_info, String filename, @Cast("bool") boolean load_segment_information);
  public static native void well_info_load_rst_eclfile( well_info_type well_info, ecl_file_type rst_file, @Cast("bool") boolean load_segment_information);
  public static native void well_info_free( well_info_type well_info );

  public static native well_ts_type well_info_get_ts( @Const well_info_type well_info, @Cast("const char*") BytePointer well_name);
  public static native well_ts_type well_info_get_ts( @Const well_info_type well_info, String well_name);
  public static native int well_info_get_num_wells( @Const well_info_type well_info );
  public static native @Cast("const char*") BytePointer well_info_iget_well_name( @Const well_info_type well_info, int well_index);
  public static native @Cast("bool") boolean well_info_has_well( well_info_type well_info, @Cast("const char*") BytePointer well_name );
  public static native @Cast("bool") boolean well_info_has_well( well_info_type well_info, String well_name );

  public static native well_state_type well_info_get_state_from_time( @Const well_info_type well_info, @Cast("const char*") BytePointer well_name, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native well_state_type well_info_get_state_from_time( @Const well_info_type well_info, String well_name, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native well_state_type well_info_get_state_from_report( @Const well_info_type well_info, @Cast("const char*") BytePointer well_name, int report_step );
  public static native well_state_type well_info_get_state_from_report( @Const well_info_type well_info, String well_name, int report_step );
  public static native well_state_type well_info_iget_state( @Const well_info_type well_info, @Cast("const char*") BytePointer well_name, int time_index);
  public static native well_state_type well_info_iget_state( @Const well_info_type well_info, String well_name, int time_index);
  public static native well_state_type well_info_iiget_state( @Const well_info_type well_info, int well_index, int time_index);

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/ecl_well/well_info.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_info.hpp>




// Parsed from ert/ecl_well/well_const.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_const.hpp>




// Parsed from ert/ecl_well/well_conn_collection.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_conn_collection.hpp>




// Parsed from ert/ecl_well/well_conn.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_conn.hpp>




// Parsed from ert/ecl_well/well_branch_collection.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl_well/well_branch_collection.hpp>




// Parsed from ert/ecl/smspec_node.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <stdbool.h>
// #include <stdio.h>

// #ifndef ERT_SMSPEC_NODE_H
// #define ERT_SMSPEC_NODE_H

// #ifdef __cplusplus
// #endif

public static final String DUMMY_WELL = ":+:+:+:+";
// #define IS_DUMMY_WELL(well) (strcmp((well) , DUMMY_WELL) == 0)
public static final int SMSPEC_PARAMS_INDEX_INVALID = -77;


public static final String SMSPEC_TIME_KEYWORD = "TIME";
public static final int SMSPEC_TIME_NUMS_VALUE =     -32676;

public static final String SMSPEC_YEARS_KEYWORD = "YEARS";
public static final int SMSPEC_YEARS_NUMS_VALUE =     -32676;

/** enum ecl_smspec_var_type */
public static final int ECL_SMSPEC_INVALID_VAR            = 0,
              ECL_SMSPEC_FIELD_VAR              = 1,   /* X */
              ECL_SMSPEC_REGION_VAR             = 2,   /* X */
              ECL_SMSPEC_GROUP_VAR              = 3,   /* X */
              ECL_SMSPEC_WELL_VAR               = 4,   /* X */
              ECL_SMSPEC_SEGMENT_VAR            = 5,   /* X */
              ECL_SMSPEC_BLOCK_VAR              = 6,   /* X */
              ECL_SMSPEC_AQUIFER_VAR            = 7,
              ECL_SMSPEC_COMPLETION_VAR         = 8,   /* X */
              ECL_SMSPEC_NETWORK_VAR            = 9,
              ECL_SMSPEC_REGION_2_REGION_VAR    = 10,
              ECL_SMSPEC_LOCAL_BLOCK_VAR        = 11,   /* X */
              ECL_SMSPEC_LOCAL_COMPLETION_VAR   = 12,   /* X */
              ECL_SMSPEC_LOCAL_WELL_VAR         = 13,   /* X */
              ECL_SMSPEC_MISC_VAR               = 14;     /* X */

public static final int SMSPEC_NUMS_INVALID =   -991199;
public static final int SMSPEC_NUMS_WELL =       1;
public static final int SMSPEC_NUMS_GROUP =      2;
public static final int SMSPEC_NUMS_FIELD =      0;

public static final int SMSPEC_TYPE_ID = 61550451;

  public static native @Cast("char*") BytePointer smspec_alloc_block_ijk_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, int i, int j, int k);
  public static native @Cast("char*") ByteBuffer smspec_alloc_block_ijk_key( String join_string, String keyword, int i, int j, int k);
  public static native @Cast("char*") BytePointer smspec_alloc_completion_ijk_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer wgname, int i, int j, int k);
  public static native @Cast("char*") ByteBuffer smspec_alloc_completion_ijk_key( String join_string, String keyword, String wgname, int i, int j, int k);
  public static native @Cast("char*") BytePointer smspec_alloc_completion_num_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer wgname, int num);
  public static native @Cast("char*") ByteBuffer smspec_alloc_completion_num_key( String join_string, String keyword, String wgname, int num);
  public static native @Cast("char*") BytePointer smspec_alloc_group_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer wgname);
  public static native @Cast("char*") ByteBuffer smspec_alloc_group_key( String join_string, String keyword, String wgname);
  public static native @Cast("char*") BytePointer smspec_alloc_well_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer wgname);
  public static native @Cast("char*") ByteBuffer smspec_alloc_well_key( String join_string, String keyword, String wgname);
  public static native @Cast("char*") BytePointer smspec_alloc_region_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, int num);
  public static native @Cast("char*") ByteBuffer smspec_alloc_region_key( String join_string, String keyword, int num);
  public static native @Cast("char*") BytePointer smspec_alloc_region_2_region_r1r2_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, int r1, int r2);
  public static native @Cast("char*") ByteBuffer smspec_alloc_region_2_region_r1r2_key( String join_string, String keyword, int r1, int r2);
  public static native @Cast("char*") BytePointer smspec_alloc_region_2_region_num_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, int num);
  public static native @Cast("char*") ByteBuffer smspec_alloc_region_2_region_num_key( String join_string, String keyword, int num);
  public static native @Cast("char*") BytePointer smspec_alloc_segment_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer wgname, int num);
  public static native @Cast("char*") ByteBuffer smspec_alloc_segment_key( String join_string, String keyword, String wgname, int num);
  public static native @Cast("char*") BytePointer smspec_alloc_block_num_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, int num);
  public static native @Cast("char*") ByteBuffer smspec_alloc_block_num_key( String join_string, String keyword, int num);
  public static native @Cast("char*") BytePointer smspec_alloc_local_well_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer lgr_name, @Cast("const char*") BytePointer wgname);
  public static native @Cast("char*") ByteBuffer smspec_alloc_local_well_key( String join_string, String keyword, String lgr_name, String wgname);
  public static native @Cast("char*") BytePointer smspec_alloc_local_block_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer lgr_name, int i, int j, int k);
  public static native @Cast("char*") ByteBuffer smspec_alloc_local_block_key( String join_string, String keyword, String lgr_name, int i, int j, int k);
  public static native @Cast("char*") BytePointer smspec_alloc_local_completion_key( @Cast("const char*") BytePointer join_string, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer lgr_name, @Cast("const char*") BytePointer wgname, int i, int j, int k);
  public static native @Cast("char*") ByteBuffer smspec_alloc_local_completion_key( String join_string, String keyword, String lgr_name, String wgname, int i, int j, int k);

  public static native @Cast("bool") boolean smspec_node_identify_total(@Cast("const char*") BytePointer keyword, @Cast("ecl_smspec_var_type") int var_type);
  public static native @Cast("bool") boolean smspec_node_identify_total(String keyword, @Cast("ecl_smspec_var_type") int var_type);
  public static native @Cast("bool") boolean smspec_node_identify_rate(@Cast("const char*") BytePointer keyword);
  public static native @Cast("bool") boolean smspec_node_identify_rate(String keyword);

  public static native @Cast("bool") boolean smspec_node_equal( @Const Pointer node1,  @Const Pointer node2);

  public static native void smspec_node_init( Pointer smspec_node,
                           @Cast("ecl_smspec_var_type") int var_type,
                           @Cast("const char*") BytePointer wgname,
                           @Cast("const char*") BytePointer keyword,
                           @Cast("const char*") BytePointer unit,
                           @Cast("const char*") BytePointer key_join_string,
                           @Const IntPointer grid_dims,
                           int num);
  public static native void smspec_node_init( Pointer smspec_node,
                           @Cast("ecl_smspec_var_type") int var_type,
                           String wgname,
                           String keyword,
                           String unit,
                           String key_join_string,
                           @Const IntBuffer grid_dims,
                           int num);
  public static native void smspec_node_init( Pointer smspec_node,
                           @Cast("ecl_smspec_var_type") int var_type,
                           @Cast("const char*") BytePointer wgname,
                           @Cast("const char*") BytePointer keyword,
                           @Cast("const char*") BytePointer unit,
                           @Cast("const char*") BytePointer key_join_string,
                           @Const int[] grid_dims,
                           int num);
  public static native void smspec_node_init( Pointer smspec_node,
                           @Cast("ecl_smspec_var_type") int var_type,
                           String wgname,
                           String keyword,
                           String unit,
                           String key_join_string,
                           @Const IntPointer grid_dims,
                           int num);
  public static native void smspec_node_init( Pointer smspec_node,
                           @Cast("ecl_smspec_var_type") int var_type,
                           @Cast("const char*") BytePointer wgname,
                           @Cast("const char*") BytePointer keyword,
                           @Cast("const char*") BytePointer unit,
                           @Cast("const char*") BytePointer key_join_string,
                           @Const IntBuffer grid_dims,
                           int num);
  public static native void smspec_node_init( Pointer smspec_node,
                           @Cast("ecl_smspec_var_type") int var_type,
                           String wgname,
                           String keyword,
                           String unit,
                           String key_join_string,
                           @Const int[] grid_dims,
                           int num);

  public static native Pointer smspec_node_alloc( int param_index,
                              @Cast("const char*") BytePointer keyword,
                              @Cast("const char*") BytePointer wgname,
                              int num,
                              @Cast("const char*") BytePointer unit,
                              @Const IntPointer grid_dims,
                              float default_value,
                              @Cast("const char*") BytePointer key_join_string);
  public static native Pointer smspec_node_alloc( int param_index,
                              String keyword,
                              String wgname,
                              int num,
                              String unit,
                              @Const IntBuffer grid_dims,
                              float default_value,
                              String key_join_string);
  public static native Pointer smspec_node_alloc( int param_index,
                              @Cast("const char*") BytePointer keyword,
                              @Cast("const char*") BytePointer wgname,
                              int num,
                              @Cast("const char*") BytePointer unit,
                              @Const int[] grid_dims,
                              float default_value,
                              @Cast("const char*") BytePointer key_join_string);
  public static native Pointer smspec_node_alloc( int param_index,
                              String keyword,
                              String wgname,
                              int num,
                              String unit,
                              @Const IntPointer grid_dims,
                              float default_value,
                              String key_join_string);
  public static native Pointer smspec_node_alloc( int param_index,
                              @Cast("const char*") BytePointer keyword,
                              @Cast("const char*") BytePointer wgname,
                              int num,
                              @Cast("const char*") BytePointer unit,
                              @Const IntBuffer grid_dims,
                              float default_value,
                              @Cast("const char*") BytePointer key_join_string);
  public static native Pointer smspec_node_alloc( int param_index,
                              String keyword,
                              String wgname,
                              int num,
                              String unit,
                              @Const int[] grid_dims,
                              float default_value,
                              String key_join_string);

  public static native Pointer smspec_node_alloc_lgr( @Cast("ecl_smspec_var_type") int var_type,
                                              @Cast("const char*") BytePointer wgname,
                                              @Cast("const char*") BytePointer keyword,
                                              @Cast("const char*") BytePointer unit,
                                              @Cast("const char*") BytePointer lgr,
                                              @Cast("const char*") BytePointer key_join_string,
                                              int lgr_i, int lgr_j, int lgr_k,
                                              int param_index,
                                              float default_value);
  public static native Pointer smspec_node_alloc_lgr( @Cast("ecl_smspec_var_type") int var_type,
                                              String wgname,
                                              String keyword,
                                              String unit,
                                              String lgr,
                                              String key_join_string,
                                              int lgr_i, int lgr_j, int lgr_k,
                                              int param_index,
                                              float default_value);

  public static native Pointer smspec_node_alloc_copy( @Const Pointer arg0 );

  public static native void smspec_node_free( Pointer index );
  public static native void smspec_node_free__(Pointer arg);
  public static native void smspec_node_set_params_index( Pointer smspec_node, int params_index);
  public static native int smspec_node_get_params_index( @Const Pointer smspec_node );
  public static native @Cast("const char*") BytePointer smspec_node_get_gen_key1( @Const Pointer smspec_node);
  public static native @Cast("const char*") BytePointer smspec_node_get_gen_key2( @Const Pointer smspec_node);
  public static native @Cast("ecl_smspec_var_type") int smspec_node_get_var_type( @Const Pointer smspec_node);
  public static native int smspec_node_get_num( @Const Pointer smspec_node);
  public static native @Cast("const char*") BytePointer smspec_node_get_wgname( @Const Pointer smspec_node);
  public static native @Cast("const char*") BytePointer smspec_node_get_keyword( @Const Pointer smspec_node);
  public static native @Cast("const char*") BytePointer smspec_node_get_unit( @Const Pointer smspec_node);
  public static native @Cast("bool") boolean smspec_node_is_rate( @Const Pointer smspec_node );
  public static native @Cast("bool") boolean smspec_node_is_total( @Const Pointer smspec_node );
  public static native @Cast("bool") boolean smspec_node_is_historical( @Const Pointer smspec_node );
  public static native @Cast("bool") boolean smspec_node_need_nums( @Const Pointer smspec_node );
  public static native void smspec_node_fprintf( @Const Pointer smspec_node, @Cast("FILE*") Pointer stream);

  public static native float smspec_node_get_default( @Const Pointer smspec_node);

  public static native @Const IntPointer smspec_node_get_ijk( @Const Pointer smpsec_node );
  public static native @Cast("const char*") BytePointer smspec_node_get_lgr_name( @Const Pointer smpsec_node );
  public static native @Const IntPointer smspec_node_get_lgr_ijk( @Const Pointer smpsec_node );

  public static native int smspec_node_get_R1( @Const Pointer smpsec_node );
  public static native int smspec_node_get_R2( @Const Pointer smpsec_node );

  public static native @Cast("bool") boolean smspec_node_lt( @Const Pointer node1,  @Const Pointer node2);
  public static native @Cast("bool") boolean smspec_node_gt( @Const Pointer node1,  @Const Pointer node2);
  public static native int smspec_node_cmp( @Const Pointer node1, @Const Pointer node2);
  public static native int smspec_node_cmp__( @Const Pointer node1, @Const Pointer node2);

// #ifdef __cplusplus
// #endif
// #endif




// Parsed from ert/ecl/smspec_node.hpp

/*
  Copyright (C) 2012  Equinor ASA, Norway.

  The file 'smspec_node.h' is part of ERT - Ensemble based Reservoir Tool.

  ERT is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  ERT is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.

  See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
  for more details.
*/


// #ifndef ERT_SMSPEC_NODE_HPP
// #define ERT_SMSPEC_NODE_HPP

// #include <stdbool.h>
// #include <stdio.h>

// #include <string>
// #include <array>

// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/smspec_node.h>
// Targeting ../smspec_node.java





// #endif


// Parsed from ert/ecl/nnc_vector.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/nnc_vector.hpp>




// Parsed from ert/ecl/nnc_info.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/nnc_info.hpp>




// Parsed from ert/ecl/layer.hpp

/*
   Copyright (C) 2014  Equinor ASA, Norway.

   The file 'layer.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_LAYER_H
// #define ERT_LAYER_H


// #include <ert/util/int_vector.hpp>
// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/ecl_grid.hpp>

// #ifdef __cplusplus
// #endif

/*
   The elements in this enum are (ab)used as indexes into a int[] vector;
   i.e. the must span the values 0..3.
*/

  /** enum edge_dir_enum */
  public static final int
    RIGHT_EDGE  = 0,
    LEFT_EDGE   = 1,
    TOP_EDGE    = 2,
    BOTTOM_EDGE = 3;
// Targeting ../int_point2d_type.java


// Targeting ../layer_type.java



  public static native @Cast("bool") boolean layer_iget_left_barrier( @Const layer_type layer, int i, int j);
  public static native @Cast("bool") boolean layer_iget_bottom_barrier( @Const layer_type layer, int i, int j);
  public static native int layer_get_nx( @Const layer_type layer );
  public static native int layer_get_ny( @Const layer_type layer );
  public static native void layer_fprintf_cell( @Const layer_type layer, int i, int j, @Cast("FILE*") Pointer stream);
  public static native void layer_fprintf( @Const layer_type layer, @Cast("FILE*") Pointer stream);
  public static native void layer_fprintf_box( @Const layer_type layer, @Cast("FILE*") Pointer stream, int i1, int i2, int j1, int j2);
  public static native layer_type layer_alloc(int nx, int ny);
  public static native void layer_free( layer_type layer );
  public static native int layer_replace_cell_values( layer_type layer, int old_value, int new_value);
  public static native @Cast("bool") boolean layer_iget_active( @Const layer_type layer, int i, int j);
  public static native int layer_iget_cell_value( @Const layer_type layer, int i, int j);
  public static native void layer_iset_cell_value( layer_type layer, int i, int j, int value);
  public static native int layer_iget_edge_value( @Const layer_type layer, int i, int j, @Cast("edge_dir_enum") int dir);
  public static native @Cast("bool") boolean layer_cell_on_edge( @Const layer_type layer, int i, int j);
  public static native int layer_get_cell_sum( @Const layer_type layer );
  public static native @Cast("bool") boolean layer_trace_block_content( layer_type layer, @Cast("bool") boolean erase, int start_i, int start_j, int value, int_vector_type i_list, int_vector_type j_list);
  public static native @Cast("bool") boolean layer_cell_contact( @Const layer_type layer, int i1, int j1, int i2, int j2);
  public static native void layer_add_interp_barrier( layer_type layer, int c1, int c2);
  public static native void layer_add_ijbarrier( layer_type layer, int i1, int j1, int i2, int j2 );
  public static native void layer_add_barrier( layer_type layer, int c1, int c2);
  public static native void layer_memcpy(layer_type target_layer, @Const layer_type src_layer);
  public static native void layer_update_active( layer_type layer, @Const ecl_grid_type grid, int k);
  public static native void layer_clear_cells( layer_type layer);
  public static native void layer_update_connected_cells( layer_type layer, int i, int j, int org_value, int new_value);
  public static native void layer_assign( layer_type layer, int value);

  public static native void layer_cells_equal( @Const layer_type layer, int value, int_vector_type i_list, int_vector_type j_list);
  public static native int layer_count_equal( @Const layer_type layer, int value );

public static native @Cast("bool") boolean layer_is_instance( @Const Pointer __arg );
public static native layer_type layer_safe_cast( Pointer __arg );


// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/layer.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/layer.hpp>




// Parsed from ert/ecl/grid_dims.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/grid_dims.hpp>




// Parsed from ert/ecl/fault_block.hpp

/*
   Copyright (C) 2014  Equinor ASA, Norway.

   The file 'fault_block.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_FAULT_BLOCK_H
// #define ERT_FAULT_BLOCK_H
// #ifdef __cplusplus
// #endif

// #include <ert/util/int_vector.hpp>
// #include <ert/util/double_vector.hpp>
// #include <ert/util/type_macros.hpp>

// #include <ert/geometry/geo_polygon_collection.hpp>

// #include <ert/ecl/ecl_grid.hpp>
// #include <ert/ecl/ecl_kw.hpp>
// Targeting ../fault_block_type.java



  public static native void fault_block_free__( Pointer arg);
  public static native int fault_block_get_size( @Const fault_block_type block );
  public static native double fault_block_get_xc( fault_block_type fault_block );
  public static native double fault_block_get_yc( fault_block_type fault_block );
  public static native int fault_block_get_id( @Const fault_block_type block );
  public static native void fault_block_export_cell(@Const fault_block_type fault_block, int index, IntPointer i, IntPointer j, IntPointer k, DoublePointer x, DoublePointer y, DoublePointer z);
  public static native void fault_block_export_cell(@Const fault_block_type fault_block, int index, IntBuffer i, IntBuffer j, IntBuffer k, DoubleBuffer x, DoubleBuffer y, DoubleBuffer z);
  public static native void fault_block_export_cell(@Const fault_block_type fault_block, int index, int[] i, int[] j, int[] k, double[] x, double[] y, double[] z);
  public static native void fault_block_assign_to_region( fault_block_type fault_block, int region_id );
  public static native @Const int_vector_type fault_block_get_region_list( @Const fault_block_type fault_block );
  public static native int fault_block_iget_j(@Const fault_block_type fault_block, int index);
  public static native int fault_block_iget_i(@Const fault_block_type fault_block, int index);
  public static native void fault_block_add_cell( fault_block_type fault_block, int i, int j);
  public static native @Cast("bool") boolean fault_block_trace_edge( @Const fault_block_type block, double_vector_type x_list, double_vector_type y_list, int_vector_type cell_list);
  public static native @Const int_vector_type fault_block_get_global_index_list( @Const fault_block_type fault_block);
  public static native void fault_block_copy_content(fault_block_type target_block, @Const fault_block_type src_block );
  public static native void fault_block_list_neighbours( @Const fault_block_type block, @Cast("bool") boolean connected_only, @Const geo_polygon_collection_type polylines, int_vector_type neighbour_list);

  public static native @Cast("bool") boolean fault_block_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/fault_block_layer.hpp

/*
   Copyright (C) 2014  Equinor ASA, Norway.

   The file 'fault_block_layer.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_FAULT_BLOCK_LAYER_H
// #define ERT_FAULT_BLOCK_LAYER_H
// #ifdef __cplusplus
// #endif

// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/ecl_grid.hpp>
// #include <ert/ecl/ecl_kw.hpp>
// #include <ert/ecl/fault_block.hpp>
// #include <ert/ecl/layer.hpp>

  public static native @Cast("bool") boolean fault_block_layer_is_instance( @Const Pointer __arg );
// Targeting ../fault_block_layer_type.java



  public static native fault_block_layer_type fault_block_layer_alloc( @Const ecl_grid_type grid, int k);
  public static native void fault_block_layer_free( fault_block_layer_type layer );
  public static native void fault_block_layer_free__( Pointer arg );
  public static native @Cast("bool") boolean fault_block_layer_has_block( @Const fault_block_layer_type layer, int block_id);
  public static native void fault_block_layer_del_block( fault_block_layer_type layer, int block_id);
  public static native fault_block_type fault_block_layer_add_block( fault_block_layer_type layer, int block_id);
  public static native fault_block_type fault_block_layer_get_block( @Const fault_block_layer_type layer, int block_id);
  public static native fault_block_type fault_block_layer_iget_block( @Const fault_block_layer_type layer, int storage_index);
  public static native fault_block_type fault_block_layer_safe_get_block( fault_block_layer_type layer, int block_id);
  public static native int fault_block_layer_get_max_id( @Const fault_block_layer_type layer );
  public static native int fault_block_layer_get_next_id( @Const fault_block_layer_type layer );
  public static native int fault_block_layer_get_size( @Const fault_block_layer_type layer);
  public static native @Cast("bool") boolean fault_block_layer_scan_kw( fault_block_layer_type layer, @Const ecl_kw_type fault_block_kw);
  public static native @Cast("bool") boolean fault_block_layer_load_kw( fault_block_layer_type layer, @Const ecl_kw_type fault_block_kw);
  public static native int fault_block_layer_get_k( @Const fault_block_layer_type layer );
  public static native void fault_block_layer_scan_layer( fault_block_layer_type fault_layer, layer_type layer);
  public static native void fault_block_layer_insert_block_content( fault_block_layer_type layer, @Const fault_block_type src_block);
  public static native @Cast("bool") boolean fault_block_layer_export( @Const fault_block_layer_type layer, ecl_kw_type faultblock_kw);
  public static native @Const ecl_grid_type fault_block_layer_get_grid( @Const fault_block_layer_type layer );
  public static native layer_type fault_block_layer_get_layer( @Const fault_block_layer_type layer );


// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/fault_block_layer.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/fault_block_layer.hpp>




// Parsed from ert/ecl/fault_block.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/fault_block.hpp>




// Parsed from ert/ecl/ecl_util.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_util.hpp>




// Parsed from ert/ecl/ecl_units.hpp

/*
   Copyright (C) 2017  Equinor ASA, Norway.

   The file 'ecl_units.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ECL_UNITS_H
// #define ECL_UNITS_H

// #ifdef __cplusplus
// #endif

public static native double ECL_UNITS_CUBIC(double x);
public static native double ECL_UNITS_MILLI(double x);
public static native double ECL_UNITS_MEGA(double x);

public static final double ECL_UNITS_LENGTH_INCH =   0.0254;
public static final double ECL_UNITS_LENGTH_FEET =   12 * ECL_UNITS_LENGTH_INCH;

public static native @MemberGetter double ECL_UNITS_VOLUME_GALLON();
public static final double ECL_UNITS_VOLUME_GALLON = ECL_UNITS_VOLUME_GALLON();
public static native @MemberGetter double ECL_UNITS_VOLUME_BARREL();
public static final double ECL_UNITS_VOLUME_BARREL = ECL_UNITS_VOLUME_BARREL();
public static final double ECL_UNITS_VOLUME_LITER =        0.001;
public static native @MemberGetter double ECL_UNITS_VOLUME_MILLI_LITER();
public static final double ECL_UNITS_VOLUME_MILLI_LITER = ECL_UNITS_VOLUME_MILLI_LITER();
public static native @MemberGetter double ECL_UNITS_VOLUME_GAS_FIELD();
public static final double ECL_UNITS_VOLUME_GAS_FIELD = ECL_UNITS_VOLUME_GAS_FIELD();

public static final int ECL_UNITS_TIME_HOUR = 3600;
public static final int ECL_UNITS_TIME_DAY =  24 * ECL_UNITS_TIME_HOUR;


// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_units.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_units.hpp>




// Parsed from ert/ecl/ecl_type.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_type.hpp>




// Parsed from ert/ecl/ecl_smspec.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_smspec.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_SMSPEC
// #define ERT_ECL_SMSPEC


// #include <time.h>
// #include <stdbool.h>

// #include <ert/util/float_vector.hpp>
// #include <ert/util/stringlist.hpp>

// #include <ert/ecl/ecl_util.hpp>
// #include <ert/ecl/smspec_node.hpp>
// Targeting ../ecl_smspec_type.java



// #ifdef __cplusplus
// #include <vector>
public static native @StdVector FloatPointer ecl_smspec_get_params_default( @Const ecl_smspec_type ecl_smspec );
public static native @Const @ByRef smspec_node ecl_smspec_get_well_var_node( @Const ecl_smspec_type smspec, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var);
public static native @Const @ByRef smspec_node ecl_smspec_get_well_var_node( @Const ecl_smspec_type smspec, String well, String var);
public static native @Const @ByRef smspec_node ecl_smspec_get_group_var_node( @Const ecl_smspec_type smspec, @Cast("const char*") BytePointer group, @Cast("const char*") BytePointer var);
public static native @Const @ByRef smspec_node ecl_smspec_get_group_var_node( @Const ecl_smspec_type smspec, String group, String var);
public static native @Const @ByRef smspec_node ecl_smspec_get_field_var_node( @Const ecl_smspec_type smspec, @Cast("const char*") BytePointer var);
public static native @Const @ByRef smspec_node ecl_smspec_get_field_var_node( @Const ecl_smspec_type smspec, String var);
public static native @Const @ByRef smspec_node ecl_smspec_get_region_var_node(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer region_var, int region_nr);
public static native @Const @ByRef smspec_node ecl_smspec_get_region_var_node(@Const ecl_smspec_type ecl_smspec, String region_var, int region_nr);
public static native @Const @ByRef smspec_node ecl_smspec_get_misc_var_node(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer var);
public static native @Const @ByRef smspec_node ecl_smspec_get_misc_var_node(@Const ecl_smspec_type ecl_smspec, String var);
public static native @Const @ByRef smspec_node ecl_smspec_get_block_var_node(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer block_var, int block_nr);
public static native @Const @ByRef smspec_node ecl_smspec_get_block_var_node(@Const ecl_smspec_type ecl_smspec, String block_var, int block_nr);
public static native @Const @ByRef smspec_node ecl_smspec_get_block_var_node_ijk(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer block_var, int i, int j, int k);
public static native @Const @ByRef smspec_node ecl_smspec_get_block_var_node_ijk(@Const ecl_smspec_type ecl_smspec, String block_var, int i, int j, int k);
public static native @Const @ByRef smspec_node ecl_smspec_get_well_completion_var_node(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var, int cell_nr);
public static native @Const @ByRef smspec_node ecl_smspec_get_well_completion_var_node(@Const ecl_smspec_type ecl_smspec, String well, String var, int cell_nr);
public static native @Const @ByRef smspec_node ecl_smspec_get_general_var_node( @Const ecl_smspec_type smspec, @Cast("const char*") BytePointer lookup_kw );
public static native @Const @ByRef smspec_node ecl_smspec_get_general_var_node( @Const ecl_smspec_type smspec, String lookup_kw );
public static native @Const @ByRef smspec_node ecl_smspec_iget_node_w_node_index( @Const ecl_smspec_type smspec, int node_index );
public static native @Const @ByRef smspec_node ecl_smspec_iget_node_w_params_index( @Const ecl_smspec_type smspec, int params_index );
public static native @Const @ByRef smspec_node ecl_smspec_iget_node(@Const ecl_smspec_type smspec, int index);
// #endif

// #ifdef __cplusplus
// #endif


/**
   These are the different variable types, see table 3.4 in the
   ECLIPFE file format docuemntation for naming conventions.
   <p>
   Only the variable types marked with "X" below are supported in the
   remaining implementation. To add support for a new variable type
   the functions smspec_node_alloc(), ecl_smsepec_fread_header() and
   ecl_smspec_install_gen_key() must be updated.
*/

  public static native IntPointer ecl_smspec_alloc_mapping( @Const ecl_smspec_type self, @Const ecl_smspec_type other);
  public static native @Const IntPointer ecl_smspec_get_index_map( @Const ecl_smspec_type smspec );
  public static native @Cast("ecl_smspec_var_type") int ecl_smspec_iget_var_type( @Const ecl_smspec_type smspec, int index );
  public static native @Cast("bool") boolean ecl_smspec_needs_num( @Cast("ecl_smspec_var_type") int var_type );
  public static native @Cast("bool") boolean ecl_smspec_needs_wgname( @Cast("ecl_smspec_var_type") int var_type );
  public static native @Cast("const char*") BytePointer ecl_smspec_get_var_type_name( @Cast("ecl_smspec_var_type") int var_type );
  public static native @Cast("ecl_smspec_var_type") int ecl_smspec_identify_var_type(@Cast("const char*") BytePointer var);
  public static native @Cast("ecl_smspec_var_type") int ecl_smspec_identify_var_type(String var);
  public static native ecl_smspec_type ecl_smspec_alloc_empty(@Cast("bool") boolean write_mode, @Cast("const char*") BytePointer key_join_string);
  public static native ecl_smspec_type ecl_smspec_alloc_empty(@Cast("bool") boolean write_mode, String key_join_string);

  public static native ecl_smspec_type ecl_smspec_alloc_restart_writer( @Cast("const char*") BytePointer key_join_string, @Cast("const char*") BytePointer restart_case, int restart_step, @ByVal @Cast("time_t*") Pointer sim_start, @Cast("bool") boolean time_in_days, int nx, int ny, int nz);
  public static native ecl_smspec_type ecl_smspec_alloc_restart_writer( String key_join_string, String restart_case, int restart_step, @ByVal @Cast("time_t*") Pointer sim_start, @Cast("bool") boolean time_in_days, int nx, int ny, int nz);

  public static native ecl_smspec_type ecl_smspec_alloc_writer( @Cast("const char*") BytePointer key_join_string,  @ByVal @Cast("time_t*") Pointer sim_start, @Cast("bool") boolean time_in_days, int nx, int ny, int nz);
  public static native ecl_smspec_type ecl_smspec_alloc_writer( String key_join_string,  @ByVal @Cast("time_t*") Pointer sim_start, @Cast("bool") boolean time_in_days, int nx, int ny, int nz);
  public static native void ecl_smspec_fwrite( @Const ecl_smspec_type smspec, @Cast("const char*") BytePointer ecl_case, @Cast("bool") boolean fmt_file );
  public static native void ecl_smspec_fwrite( @Const ecl_smspec_type smspec, String ecl_case, @Cast("bool") boolean fmt_file );

  public static native ecl_smspec_type ecl_smspec_fread_alloc(@Cast("const char*") BytePointer header_file, @Cast("const char*") BytePointer key_join_string, @Cast("bool") boolean include_restart);
  public static native ecl_smspec_type ecl_smspec_fread_alloc(String header_file, String key_join_string, @Cast("bool") boolean include_restart);
  public static native void ecl_smspec_free( ecl_smspec_type arg0);

  public static native int ecl_smspec_get_date_day_index( @Const ecl_smspec_type smspec );
  public static native int ecl_smspec_get_date_month_index( @Const ecl_smspec_type smspec );
  public static native int ecl_smspec_get_date_year_index( @Const ecl_smspec_type smspec );


  public static native int ecl_smspec_get_well_var_params_index(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var);
  public static native int ecl_smspec_get_well_var_params_index(@Const ecl_smspec_type ecl_smspec, String well, String var);
  public static native @Cast("bool") boolean ecl_smspec_has_well_var(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var);
  public static native @Cast("bool") boolean ecl_smspec_has_well_var(@Const ecl_smspec_type ecl_smspec, String well, String var);

  public static native int ecl_smspec_get_group_var_params_index(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer group, @Cast("const char*") BytePointer var);
  public static native int ecl_smspec_get_group_var_params_index(@Const ecl_smspec_type ecl_smspec, String group, String var);
  public static native @Cast("bool") boolean ecl_smspec_has_group_var(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer group, @Cast("const char*") BytePointer var);
  public static native @Cast("bool") boolean ecl_smspec_has_group_var(@Const ecl_smspec_type ecl_smspec, String group, String var);

  public static native int ecl_smspec_get_field_var_params_index(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer var);
  public static native int ecl_smspec_get_field_var_params_index(@Const ecl_smspec_type ecl_smspec, String var);
  public static native @Cast("bool") boolean ecl_smspec_has_field_var(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer var);
  public static native @Cast("bool") boolean ecl_smspec_has_field_var(@Const ecl_smspec_type ecl_smspec, String var);

  public static native int ecl_smspec_get_region_var_params_index(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer region_var, int region_nr);
  public static native int ecl_smspec_get_region_var_params_index(@Const ecl_smspec_type ecl_smspec, String region_var, int region_nr);
  public static native @Cast("bool") boolean ecl_smspec_has_region_var(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer region_var, int region_nr);
  public static native @Cast("bool") boolean ecl_smspec_has_region_var(@Const ecl_smspec_type ecl_smspec, String region_var, int region_nr);

  public static native int ecl_smspec_get_misc_var_params_index(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer var);
  public static native int ecl_smspec_get_misc_var_params_index(@Const ecl_smspec_type ecl_smspec, String var);
  public static native @Cast("bool") boolean ecl_smspec_has_misc_var(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer var);
  public static native @Cast("bool") boolean ecl_smspec_has_misc_var(@Const ecl_smspec_type ecl_smspec, String var);

  public static native int ecl_smspec_get_block_var_params_index(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer block_var, int block_nr);
  public static native int ecl_smspec_get_block_var_params_index(@Const ecl_smspec_type ecl_smspec, String block_var, int block_nr);
  public static native @Cast("bool") boolean ecl_smspec_has_block_var(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer block_var, int block_nr);
  public static native @Cast("bool") boolean ecl_smspec_has_block_var(@Const ecl_smspec_type ecl_smspec, String block_var, int block_nr);

  public static native int ecl_smspec_get_block_var_params_index_ijk(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer block_var, int i, int j, int k);
  public static native int ecl_smspec_get_block_var_params_index_ijk(@Const ecl_smspec_type ecl_smspec, String block_var, int i, int j, int k);
  public static native @Cast("bool") boolean ecl_smspec_has_block_var_ijk(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer block_var, int i, int j, int k);
  public static native @Cast("bool") boolean ecl_smspec_has_block_var_ijk(@Const ecl_smspec_type ecl_smspec, String block_var, int i, int j, int k);

  public static native int ecl_smspec_get_well_completion_var_params_index(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var, int cell_nr);
  public static native int ecl_smspec_get_well_completion_var_params_index(@Const ecl_smspec_type ecl_smspec, String well, String var, int cell_nr);
  public static native @Cast("bool") boolean ecl_smspec_has_well_completion_var(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var, int cell_nr);
  public static native @Cast("bool") boolean ecl_smspec_has_well_completion_var(@Const ecl_smspec_type ecl_smspec, String well, String var, int cell_nr);

  public static native int ecl_smspec_get_general_var_params_index(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer lookup_kw);
  public static native int ecl_smspec_get_general_var_params_index(@Const ecl_smspec_type ecl_smspec, String lookup_kw);
  public static native @Cast("bool") boolean ecl_smspec_has_general_var(@Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer lookup_kw);
  public static native @Cast("bool") boolean ecl_smspec_has_general_var(@Const ecl_smspec_type ecl_smspec, String lookup_kw);
  public static native @Cast("const char*") BytePointer ecl_smspec_get_general_var_unit( @Const ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer lookup_kw);
  public static native String ecl_smspec_get_general_var_unit( @Const ecl_smspec_type ecl_smspec, String lookup_kw);


  //bool                ecl_smspec_general_is_total(const ecl_smspec_type * ecl_smspec , const char * gen_key);
  //bool                ecl_smspec_is_rate(const ecl_smspec_type * smspec , int kw_index);
  //ecl_smspec_var_type ecl_smspec_iget_var_type( const ecl_smspec_type * smspec , int index );
  //const char *        ecl_smspec_iget_unit( const ecl_smspec_type * smspec , int index );
  //int                 ecl_smspec_iget_num( const ecl_smspec_type * smspec , int index );
  //const char *        ecl_smspec_iget_wgname( const ecl_smspec_type * smspec , int index );
  //const char *        ecl_smspec_iget_keyword( const ecl_smspec_type * smspec , int index );




  public static native void ecl_smspec_select_matching_general_var_list( @Const ecl_smspec_type smspec, @Cast("const char*") BytePointer pattern, stringlist_type keys);
  public static native void ecl_smspec_select_matching_general_var_list( @Const ecl_smspec_type smspec, String pattern, stringlist_type keys);
  public static native stringlist_type ecl_smspec_alloc_matching_general_var_list(@Const ecl_smspec_type smspec, @Cast("const char*") BytePointer pattern);
  public static native stringlist_type ecl_smspec_alloc_matching_general_var_list(@Const ecl_smspec_type smspec, String pattern);

  public static native int ecl_smspec_get_time_seconds( @Const ecl_smspec_type ecl_smspec );
  public static native int ecl_smspec_get_time_index( @Const ecl_smspec_type ecl_smspec );
  public static native @ByVal @Cast("time_t*") Pointer ecl_smspec_get_start_time(@Const ecl_smspec_type arg0 );
  /*****************************************************************/
  public static native @Cast("bool") boolean ecl_smspec_get_formatted( @Const ecl_smspec_type ecl_smspec);
  public static native @Cast("const char*") BytePointer ecl_smspec_get_header_file( @Const ecl_smspec_type ecl_smspec );
  public static native stringlist_type ecl_smspec_alloc_well_list( @Const ecl_smspec_type smspec, @Cast("const char*") BytePointer pattern);
  public static native stringlist_type ecl_smspec_alloc_well_list( @Const ecl_smspec_type smspec, String pattern);
  public static native stringlist_type ecl_smspec_alloc_group_list( @Const ecl_smspec_type smspec, @Cast("const char*") BytePointer pattern);
  public static native stringlist_type ecl_smspec_alloc_group_list( @Const ecl_smspec_type smspec, String pattern);
  public static native stringlist_type ecl_smspec_alloc_well_var_list( @Const ecl_smspec_type smspec );
  public static native @Cast("const char*") BytePointer ecl_smspec_get_simulation_path(@Const ecl_smspec_type ecl_smspec);
  public static native int ecl_smspec_get_first_step(@Const ecl_smspec_type ecl_smspec);
  public static native int ecl_smspec_get_restart_step(@Const ecl_smspec_type ecl_smspec);
  public static native @Cast("const char*") BytePointer ecl_smspec_get_restart_case( @Const ecl_smspec_type ecl_smspec);
  public static native @Cast("const char*") BytePointer ecl_smspec_get_join_string( @Const ecl_smspec_type smspec);

  public static native @Const IntPointer ecl_smspec_get_grid_dims( @Const ecl_smspec_type smspec );
  public static native int ecl_smspec_get_params_size( @Const ecl_smspec_type smspec );
  public static native int ecl_smspec_num_nodes( @Const ecl_smspec_type smspec);

  public static native @Cast("char*") BytePointer ecl_smspec_alloc_well_key( @Const ecl_smspec_type smspec, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer wgname);
  public static native @Cast("char*") ByteBuffer ecl_smspec_alloc_well_key( @Const ecl_smspec_type smspec, String keyword, String wgname);
  public static native @Cast("bool") boolean ecl_smspec_equal( @Const ecl_smspec_type self, @Const ecl_smspec_type other);

  // void                       ecl_smspec_sort( ecl_smspec_type * smspec );
  public static native @Cast("ert_ecl_unit_enum") int ecl_smspec_get_unit_system(@Const ecl_smspec_type smspec);


// #ifdef __cplusplus
// #endif

public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec, @Const @ByRef smspec_node node);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer keyword, int num, @Cast("const char*") BytePointer unit, float default_value);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec, String keyword, int num, String unit, float default_value);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer unit, float default_value);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec, String keyword, String unit, float default_value);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer wgname, @Cast("const char*") BytePointer unit, float default_value);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec, String keyword, String wgname, String unit, float default_value);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer wgname, int num, @Cast("const char*") BytePointer unit, float default_value);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec, String keyword, String wgname, int num, String unit, float default_value);

public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec,
                                                  int params_index,
                                                  @Cast("const char*") BytePointer keyword,
                                                  @Cast("const char*") BytePointer wgname,
                                                  int num,
                                                  @Cast("const char*") BytePointer unit,
                                                  float default_value);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec,
                                                  int params_index,
                                                  String keyword,
                                                  String wgname,
                                                  int num,
                                                  String unit,
                                                  float default_value);

public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec,
                                                  int params_index,
                                                  @Cast("const char*") BytePointer keyword,
                                                  @Cast("const char*") BytePointer wgname,
                                                  int num,
                                                  @Cast("const char*") BytePointer unit,
                                                  @Cast("const char*") BytePointer lgr,
                                                  int lgr_i, int lgr_j, int lgr_k,
                                                  float default_value);
public static native @Const smspec_node ecl_smspec_add_node(ecl_smspec_type ecl_smspec,
                                                  int params_index,
                                                  String keyword,
                                                  String wgname,
                                                  int num,
                                                  String unit,
                                                  String lgr,
                                                  int lgr_i, int lgr_j, int lgr_k,
                                                  float default_value);




// #endif


// Parsed from ert/ecl/ecl_sum_tstep.hpp

 /*
   Copyright (C) 2012  Equinor ASA, Norway.

   The file 'ecl_sum_tstep.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_SUM_TSTEP_H
// #define ERT_ECL_SUM_TSTEP_H

// #include <ert/util/int_vector.hpp>

// #include <ert/ecl/ecl_smspec.hpp>
// #include <ert/ecl/ecl_kw.hpp>

// #ifdef __cplusplus
// Targeting ../ecl_sum_tstep_type.java



  public static native ecl_sum_tstep_type ecl_sum_tstep_alloc_remap_copy( @Const ecl_sum_tstep_type src, @Const ecl_smspec_type new_smspec, float default_value, @Const IntPointer params_map);
  public static native ecl_sum_tstep_type ecl_sum_tstep_alloc_remap_copy( @Const ecl_sum_tstep_type src, @Const ecl_smspec_type new_smspec, float default_value, @Const IntBuffer params_map);
  public static native ecl_sum_tstep_type ecl_sum_tstep_alloc_remap_copy( @Const ecl_sum_tstep_type src, @Const ecl_smspec_type new_smspec, float default_value, @Const int[] params_map);
  public static native ecl_sum_tstep_type ecl_sum_tstep_alloc_copy( @Const ecl_sum_tstep_type src );
  public static native void ecl_sum_tstep_free( ecl_sum_tstep_type ministep );
  public static native void ecl_sum_tstep_free__( Pointer __ministep);
  public static native ecl_sum_tstep_type ecl_sum_tstep_alloc_from_file(int report_step,
                                                       int ministep_nr,
                                                       @Const ecl_kw_type params_kw,
                                                       @Cast("const char*") BytePointer src_file,
                                                       @Const ecl_smspec_type smspec);
  public static native ecl_sum_tstep_type ecl_sum_tstep_alloc_from_file(int report_step,
                                                       int ministep_nr,
                                                       @Const ecl_kw_type params_kw,
                                                       String src_file,
                                                       @Const ecl_smspec_type smspec);

  public static native ecl_sum_tstep_type ecl_sum_tstep_alloc_new( int report_step, int ministep, float sim_seconds, @Const ecl_smspec_type smspec );

  public static native void ecl_sum_tstep_set_from_node( ecl_sum_tstep_type tstep, @Const @ByRef smspec_node smspec_node, float value);
  public static native double ecl_sum_tstep_get_from_node( @Const ecl_sum_tstep_type tstep, @Const @ByRef smspec_node smspec_node);

  public static native double ecl_sum_tstep_iget(@Const ecl_sum_tstep_type ministep, int index);
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_tstep_get_sim_time(@Const ecl_sum_tstep_type ministep);
  public static native double ecl_sum_tstep_get_sim_days(@Const ecl_sum_tstep_type ministep);
  public static native double ecl_sum_tstep_get_sim_seconds(@Const ecl_sum_tstep_type ministep);

  public static native int ecl_sum_tstep_get_report(@Const ecl_sum_tstep_type ministep);
  public static native int ecl_sum_tstep_get_ministep(@Const ecl_sum_tstep_type ministep);

  public static native void ecl_sum_tstep_fwrite( @Const ecl_sum_tstep_type ministep, @Const IntPointer index_map, int index_map_size, fortio_type fortio);
  public static native void ecl_sum_tstep_fwrite( @Const ecl_sum_tstep_type ministep, @Const IntBuffer index_map, int index_map_size, fortio_type fortio);
  public static native void ecl_sum_tstep_fwrite( @Const ecl_sum_tstep_type ministep, @Const int[] index_map, int index_map_size, fortio_type fortio);
  public static native void ecl_sum_tstep_iset( ecl_sum_tstep_type tstep, int index, float value);

  /** scales with value; equivalent to iset( iget() * scalar) */
  public static native void ecl_sum_tstep_iscale(ecl_sum_tstep_type tstep, int index, float scalar);

  /** adds addend to tstep[index]; equivalent to iset( iget() + addend) */
  public static native void ecl_sum_tstep_ishift(ecl_sum_tstep_type tstep, int index, float addend);


  public static native void ecl_sum_tstep_set_from_key( ecl_sum_tstep_type tstep, @Cast("const char*") BytePointer gen_key, float value);
  public static native void ecl_sum_tstep_set_from_key( ecl_sum_tstep_type tstep, String gen_key, float value);
  public static native double ecl_sum_tstep_get_from_key( @Const ecl_sum_tstep_type tstep, @Cast("const char*") BytePointer gen_key);
  public static native double ecl_sum_tstep_get_from_key( @Const ecl_sum_tstep_type tstep, String gen_key);
  public static native @Cast("bool") boolean ecl_sum_tstep_has_key(@Const ecl_sum_tstep_type tstep, @Cast("const char*") BytePointer gen_key);
  public static native @Cast("bool") boolean ecl_sum_tstep_has_key(@Const ecl_sum_tstep_type tstep, String gen_key);

  public static native @Cast("bool") boolean ecl_sum_tstep_sim_time_equal( @Const ecl_sum_tstep_type tstep1, @Const ecl_sum_tstep_type tstep2 );

  public static native ecl_sum_tstep_type ecl_sum_tstep_safe_cast( Pointer __arg );
  public static native @Const ecl_sum_tstep_type ecl_sum_tstep_safe_cast_const( @Const Pointer __arg );



// #ifdef __cplusplus


// #endif
// #endif


// Parsed from ert/ecl/ecl_sum.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_sum.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_SUM_H
// #define ERT_ECL_SUM_H

// #include <stdlib.h>
// #include <stdbool.h>
// #include <time.h>

// #include <ert/util/stringlist.hpp>
// #include <ert/util/time_t_vector.hpp>
// #include <ert/util/double_vector.hpp>

// #include <ert/ecl/ecl_smspec.hpp>
// #include <ert/ecl/ecl_sum_tstep.hpp>
// #include <ert/ecl/smspec_node.hpp>

// #ifdef __cplusplus
// Targeting ../ecl_sum_fmt_type.java


// Targeting ../ecl_sum_vector_type.java


// Targeting ../ecl_sum_type.java



  public static native void ecl_sum_fmt_init_summary_x( @Const ecl_sum_type ecl_sum, ecl_sum_fmt_type fmt );
  public static native double ecl_sum_get_from_sim_time( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time, @Const smspec_node node);
  public static native double ecl_sum_get_from_sim_days( @Const ecl_sum_type ecl_sum, double sim_days, @Const smspec_node node);
  public static native double ecl_sum_time2days( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time);

  public static native void ecl_sum_set_unified( ecl_sum_type ecl_sum, @Cast("bool") boolean unified );
  public static native void ecl_sum_set_fmt_case( ecl_sum_type ecl_sum, @Cast("bool") boolean fmt_case );

  public static native int ecl_sum_get_report_step_from_time( @Const ecl_sum_type sum, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native int ecl_sum_get_report_step_from_days( @Const ecl_sum_type sum, double sim_days);
  public static native @Cast("bool") boolean ecl_sum_check_sim_time( @Const ecl_sum_type sum, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native @Cast("bool") boolean ecl_sum_check_sim_days( @Const ecl_sum_type sum, double sim_days);
  public static native @Cast("const char*") BytePointer ecl_sum_get_keyword( @Const ecl_sum_type sum, @Cast("const char*") BytePointer gen_key );
  public static native String ecl_sum_get_keyword( @Const ecl_sum_type sum, String gen_key );
  public static native @Cast("const char*") BytePointer ecl_sum_get_wgname( @Const ecl_sum_type sum, @Cast("const char*") BytePointer gen_key );
  public static native String ecl_sum_get_wgname( @Const ecl_sum_type sum, String gen_key );
  public static native @Cast("const char*") BytePointer ecl_sum_get_unit( @Const ecl_sum_type sum, @Cast("const char*") BytePointer gen_key );
  public static native String ecl_sum_get_unit( @Const ecl_sum_type sum, String gen_key );
  public static native int ecl_sum_get_num( @Const ecl_sum_type sum, @Cast("const char*") BytePointer gen_key );
  public static native int ecl_sum_get_num( @Const ecl_sum_type sum, String gen_key );

  public static native double ecl_sum_iget( @Const ecl_sum_type ecl_sum, int time_index, int param_index);
  public static native int ecl_sum_iget_num( @Const ecl_sum_type sum, int param_index );
  public static native @Cast("const char*") BytePointer ecl_sum_iget_wgname( @Const ecl_sum_type sum, int param_index );
  public static native @Cast("const char*") BytePointer ecl_sum_iget_keyword( @Const ecl_sum_type sum, int param_index );
  public static native int ecl_sum_get_data_length( @Const ecl_sum_type ecl_sum );
  public static native double ecl_sum_iget_from_sim_time( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time, int param_index);
  public static native double ecl_sum_iget_from_sim_days( @Const ecl_sum_type ecl_sum, double sim_days, int param_index );



  public static native void ecl_sum_summarize( @Const ecl_sum_type ecl_sum, @Cast("FILE*") Pointer stream );
  public static native @Cast("bool") boolean ecl_sum_general_is_total(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key);
  public static native @Cast("bool") boolean ecl_sum_general_is_total(@Const ecl_sum_type ecl_sum, String gen_key);
  public static native void ecl_sum_free_data(ecl_sum_type arg0 );
  public static native void ecl_sum_free__(Pointer arg0 );
  public static native void ecl_sum_free(ecl_sum_type arg0 );
  public static native ecl_sum_type ecl_sum_fread_alloc(@Cast("const char*") BytePointer arg0, @Const stringlist_type data_files, @Cast("const char*") BytePointer key_join_string, @Cast("bool") boolean include_restart, @Cast("bool") boolean lazy_load, int file_options);
  public static native ecl_sum_type ecl_sum_fread_alloc(String arg0, @Const stringlist_type data_files, String key_join_string, @Cast("bool") boolean include_restart, @Cast("bool") boolean lazy_load, int file_options);
  public static native ecl_sum_type ecl_sum_fread_alloc_case(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer key_join_string);
  public static native ecl_sum_type ecl_sum_fread_alloc_case(String arg0, String key_join_string);
  public static native ecl_sum_type ecl_sum_fread_alloc_case__(@Cast("const char*") BytePointer input_file, @Cast("const char*") BytePointer key_join_string, @Cast("bool") boolean include_restart);
  public static native ecl_sum_type ecl_sum_fread_alloc_case__(String input_file, String key_join_string, @Cast("bool") boolean include_restart);
  public static native ecl_sum_type ecl_sum_fread_alloc_case2__(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer key_join_string, @Cast("bool") boolean include_restart, @Cast("bool") boolean lazy_load, int file_options);
  public static native ecl_sum_type ecl_sum_fread_alloc_case2__(String arg0, String key_join_string, @Cast("bool") boolean include_restart, @Cast("bool") boolean lazy_load, int file_options);
  public static native ecl_sum_type ecl_sum_alloc_resample(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer ecl_case, @Const time_t_vector_type times, @Cast("bool") boolean lower_extrapolation, @Cast("bool") boolean upper_extrapolation);
  public static native ecl_sum_type ecl_sum_alloc_resample(@Const ecl_sum_type ecl_sum, String ecl_case, @Const time_t_vector_type times, @Cast("bool") boolean lower_extrapolation, @Cast("bool") boolean upper_extrapolation);
  public static native @Cast("bool") boolean ecl_sum_case_exists( @Cast("const char*") BytePointer input_file );
  public static native @Cast("bool") boolean ecl_sum_case_exists( String input_file );

  /* Accessor functions : */
  public static native double ecl_sum_get_well_var(@Const ecl_sum_type ecl_sum, int time_index, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_well_var(@Const ecl_sum_type ecl_sum, int time_index, String well, String var);
  public static native @Cast("bool") boolean ecl_sum_has_well_var(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var);
  public static native @Cast("bool") boolean ecl_sum_has_well_var(@Const ecl_sum_type ecl_sum, String well, String var);
  public static native double ecl_sum_get_well_var_from_sim_days( @Const ecl_sum_type ecl_sum, double sim_days, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_well_var_from_sim_days( @Const ecl_sum_type ecl_sum, double sim_days, String well, String var);
  public static native double ecl_sum_get_well_var_from_sim_time( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_well_var_from_sim_time( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time, String well, String var);

  public static native double ecl_sum_get_group_var(@Const ecl_sum_type ecl_sum, int time_index, @Cast("const char*") BytePointer group, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_group_var(@Const ecl_sum_type ecl_sum, int time_index, String group, String var);
  public static native @Cast("bool") boolean ecl_sum_has_group_var(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer group, @Cast("const char*") BytePointer var);
  public static native @Cast("bool") boolean ecl_sum_has_group_var(@Const ecl_sum_type ecl_sum, String group, String var);

  public static native double ecl_sum_get_field_var(@Const ecl_sum_type ecl_sum, int time_index, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_field_var(@Const ecl_sum_type ecl_sum, int time_index, String var);
  public static native @Cast("bool") boolean ecl_sum_has_field_var(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer var);
  public static native @Cast("bool") boolean ecl_sum_has_field_var(@Const ecl_sum_type ecl_sum, String var);
  public static native double ecl_sum_get_field_var_from_sim_days( @Const ecl_sum_type ecl_sum, double sim_days, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_field_var_from_sim_days( @Const ecl_sum_type ecl_sum, double sim_days, String var);
  public static native double ecl_sum_get_field_var_from_sim_time( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_field_var_from_sim_time( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time, String var);

  public static native double ecl_sum_get_block_var(@Const ecl_sum_type ecl_sum, int time_index, @Cast("const char*") BytePointer block_var, int block_nr);
  public static native double ecl_sum_get_block_var(@Const ecl_sum_type ecl_sum, int time_index, String block_var, int block_nr);
  public static native int ecl_sum_get_block_var_index(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer block_var, int block_nr);
  public static native int ecl_sum_get_block_var_index(@Const ecl_sum_type ecl_sum, String block_var, int block_nr);
  public static native @Cast("bool") boolean ecl_sum_has_block_var(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer block_var, int block_nr);
  public static native @Cast("bool") boolean ecl_sum_has_block_var(@Const ecl_sum_type ecl_sum, String block_var, int block_nr);
  public static native double ecl_sum_get_block_var_ijk(@Const ecl_sum_type ecl_sum, int time_index, @Cast("const char*") BytePointer block_var, int i, int j, int k);
  public static native double ecl_sum_get_block_var_ijk(@Const ecl_sum_type ecl_sum, int time_index, String block_var, int i, int j, int k);
  public static native int ecl_sum_get_block_var_index_ijk(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer block_var, int i, int j, int k);
  public static native int ecl_sum_get_block_var_index_ijk(@Const ecl_sum_type ecl_sum, String block_var, int i, int j, int k);
  public static native @Cast("bool") boolean ecl_sum_has_block_var_ijk(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer block_var, int i, int j, int k);
  public static native @Cast("bool") boolean ecl_sum_has_block_var_ijk(@Const ecl_sum_type ecl_sum, String block_var, int i, int j, int k);

  public static native double ecl_sum_get_region_var(@Const ecl_sum_type ecl_sum, int time_index, @Cast("const char*") BytePointer var, int region_nr);
  public static native double ecl_sum_get_region_var(@Const ecl_sum_type ecl_sum, int time_index, String var, int region_nr);
  public static native @Cast("bool") boolean ecl_sum_has_region_var(@Const ecl_sum_type ecl_sum,  @Cast("const char*") BytePointer var, int region_nr);
  public static native @Cast("bool") boolean ecl_sum_has_region_var(@Const ecl_sum_type ecl_sum,  String var, int region_nr);

  public static native double ecl_sum_get_misc_var(@Const ecl_sum_type ecl_sum, int time_index, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_misc_var(@Const ecl_sum_type ecl_sum, int time_index, String var);
  public static native int ecl_sum_get_misc_var_index(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer var);
  public static native int ecl_sum_get_misc_var_index(@Const ecl_sum_type ecl_sum, String var);
  public static native @Cast("bool") boolean ecl_sum_has_misc_var(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer var);
  public static native @Cast("bool") boolean ecl_sum_has_misc_var(@Const ecl_sum_type ecl_sum, String var);

  public static native double ecl_sum_get_well_completion_var(@Const ecl_sum_type ecl_sum, int time_index, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var, int cell_nr);
  public static native double ecl_sum_get_well_completion_var(@Const ecl_sum_type ecl_sum, int time_index, String well, String var, int cell_nr);
  public static native int ecl_sum_get_well_completion_var_index(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var, int cell_nr);
  public static native int ecl_sum_get_well_completion_var_index(@Const ecl_sum_type ecl_sum, String well, String var, int cell_nr);
  public static native @Cast("bool") boolean ecl_sum_has_well_completion_var(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer well, @Cast("const char*") BytePointer var, int cell_nr);
  public static native @Cast("bool") boolean ecl_sum_has_well_completion_var(@Const ecl_sum_type ecl_sum, String well, String var, int cell_nr);

  public static native double ecl_sum_get_general_var(@Const ecl_sum_type ecl_sum, int time_index, @Cast("const char*") BytePointer lookup_kw);
  public static native double ecl_sum_get_general_var(@Const ecl_sum_type ecl_sum, int time_index, String lookup_kw);
  public static native int ecl_sum_get_general_var_params_index(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer lookup_kw);
  public static native int ecl_sum_get_general_var_params_index(@Const ecl_sum_type ecl_sum, String lookup_kw);
  public static native @Const smspec_node ecl_sum_get_general_var_node(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer lookup_kw);
  public static native @Const smspec_node ecl_sum_get_general_var_node(@Const ecl_sum_type ecl_sum, String lookup_kw);
  public static native @Cast("bool") boolean ecl_sum_has_general_var(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer lookup_kw);
  public static native @Cast("bool") boolean ecl_sum_has_general_var(@Const ecl_sum_type ecl_sum, String lookup_kw);
  public static native @Cast("bool") boolean ecl_sum_has_key(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer lookup_kw);
  public static native @Cast("bool") boolean ecl_sum_has_key(@Const ecl_sum_type ecl_sum, String lookup_kw);
  public static native double ecl_sum_get_general_var_from_sim_days( @Const ecl_sum_type ecl_sum, double sim_days, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_general_var_from_sim_days( @Const ecl_sum_type ecl_sum, double sim_days, String var);
  public static native double ecl_sum_get_general_var_from_sim_time( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time, @Cast("const char*") BytePointer var);
  public static native double ecl_sum_get_general_var_from_sim_time( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time, String var);
  public static native @Cast("const char*") BytePointer ecl_sum_get_general_var_unit( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer var);
  public static native String ecl_sum_get_general_var_unit( @Const ecl_sum_type ecl_sum, String var);
  public static native @Cast("ert_ecl_unit_enum") int ecl_sum_get_unit_system(@Const ecl_sum_type ecl_sum);

  /***************/
  public static native void ecl_sum_fprintf(@Const ecl_sum_type arg0, @Cast("FILE*") Pointer arg1, @Const stringlist_type arg2, @Cast("bool") boolean report_only, @Const ecl_sum_fmt_type fmt);




  /* Time related functions */
  public static native int ecl_sum_get_restart_step(@Const ecl_sum_type ecl_sum);
  public static native int ecl_sum_get_first_gt( @Const ecl_sum_type ecl_sum, int param_index, double _limit);
  public static native int ecl_sum_get_first_lt( @Const ecl_sum_type ecl_sum, int param_index, double _limit);
  public static native int ecl_sum_get_last_report_step( @Const ecl_sum_type ecl_sum );
  public static native int ecl_sum_get_first_report_step( @Const ecl_sum_type ecl_sum );
  public static native @Cast("bool") boolean ecl_sum_has_report_step(@Const ecl_sum_type ecl_sum, int report_step );
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_get_report_time( @Const ecl_sum_type ecl_sum, int report_step );
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_iget_sim_time( @Const ecl_sum_type ecl_sum, int index );
  public static native double ecl_sum_iget_sim_days( @Const ecl_sum_type ecl_sum, int time_index);
  public static native int ecl_sum_iget_report_step( @Const ecl_sum_type ecl_sum, int internal_index );
  public static native double ecl_sum_iget_general_var(@Const ecl_sum_type ecl_sum, int internal_index, @Cast("const char*") BytePointer lookup_kw);
  public static native double ecl_sum_iget_general_var(@Const ecl_sum_type ecl_sum, int internal_index, String lookup_kw);


  public static native double_vector_type ecl_sum_alloc_data_vector( @Const ecl_sum_type ecl_sum, int data_index, @Cast("bool") boolean report_only);
  public static native time_t_vector_type ecl_sum_alloc_time_vector( @Const ecl_sum_type ecl_sum, @Cast("bool") boolean report_only);
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_get_data_start( @Const ecl_sum_type ecl_sum );
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_get_end_time( @Const ecl_sum_type ecl_sum);
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_get_start_time(@Const ecl_sum_type arg0 );

  public static native @Cast("const char*") BytePointer ecl_sum_get_base(@Const ecl_sum_type ecl_sum );
  public static native @Cast("const char*") BytePointer ecl_sum_get_path(@Const ecl_sum_type ecl_sum );
  public static native @Cast("const char*") BytePointer ecl_sum_get_abs_path(@Const ecl_sum_type ecl_sum );
  public static native @Const ecl_sum_type ecl_sum_get_restart_case(@Const ecl_sum_type ecl_sum);
  public static native @Cast("const char*") BytePointer ecl_sum_get_case(@Const ecl_sum_type arg0 );
  public static native @Cast("bool") boolean ecl_sum_same_case( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer input_file );
  public static native @Cast("bool") boolean ecl_sum_same_case( @Const ecl_sum_type ecl_sum, String input_file );

  public static native void ecl_sum_resample_from_sim_days(@Const ecl_sum_type ecl_sum,
                                        @Const double_vector_type sim_days,
                                        double_vector_type value,
                                        @Cast("const char*") BytePointer gen_key);
  public static native void ecl_sum_resample_from_sim_days(@Const ecl_sum_type ecl_sum,
                                        @Const double_vector_type sim_days,
                                        double_vector_type value,
                                        String gen_key);
  public static native void ecl_sum_resample_from_sim_time(@Const ecl_sum_type ecl_sum,
                                        @Const time_t_vector_type sim_time,
                                        double_vector_type value,
                                        @Cast("const char*") BytePointer gen_key);
  public static native void ecl_sum_resample_from_sim_time(@Const ecl_sum_type ecl_sum,
                                        @Const time_t_vector_type sim_time,
                                        double_vector_type value,
                                        String gen_key);
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_time_from_days( @Const ecl_sum_type ecl_sum, double sim_days );
  public static native double ecl_sum_days_from_time( @Const ecl_sum_type ecl_sum, @ByVal @Cast("time_t*") Pointer sim_time );
  public static native double ecl_sum_get_sim_length( @Const ecl_sum_type ecl_sum );
  public static native double ecl_sum_get_first_day( @Const ecl_sum_type ecl_sum );

  /*****************************************************************/
  public static native stringlist_type ecl_sum_alloc_well_list( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer pattern);
  public static native stringlist_type ecl_sum_alloc_well_list( @Const ecl_sum_type ecl_sum, String pattern);
  public static native stringlist_type ecl_sum_alloc_group_list( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer pattern);
  public static native stringlist_type ecl_sum_alloc_group_list( @Const ecl_sum_type ecl_sum, String pattern);
  public static native stringlist_type ecl_sum_alloc_well_var_list( @Const ecl_sum_type ecl_sum );
  public static native stringlist_type ecl_sum_alloc_matching_general_var_list(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer pattern);
  public static native stringlist_type ecl_sum_alloc_matching_general_var_list(@Const ecl_sum_type ecl_sum, String pattern);
  public static native void ecl_sum_select_matching_general_var_list( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer pattern, stringlist_type keys);
  public static native void ecl_sum_select_matching_general_var_list( @Const ecl_sum_type ecl_sum, String pattern, stringlist_type keys);
  public static native ecl_smspec_type ecl_sum_get_smspec( @Const ecl_sum_type ecl_sum );
  public static native @Cast("ecl_smspec_var_type") int ecl_sum_identify_var_type(@Cast("const char*") BytePointer var);
  public static native @Cast("ecl_smspec_var_type") int ecl_sum_identify_var_type(String var);
  public static native @Cast("ecl_smspec_var_type") int ecl_sum_get_var_type( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key);
  public static native @Cast("ecl_smspec_var_type") int ecl_sum_get_var_type( @Const ecl_sum_type ecl_sum, String gen_key);
  public static native @Cast("bool") boolean ecl_sum_var_is_rate( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key);
  public static native @Cast("bool") boolean ecl_sum_var_is_rate( @Const ecl_sum_type ecl_sum, String gen_key);
  public static native @Cast("bool") boolean ecl_sum_var_is_total( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key);
  public static native @Cast("bool") boolean ecl_sum_var_is_total( @Const ecl_sum_type ecl_sum, String gen_key);

  public static native int ecl_sum_iget_report_end( @Const ecl_sum_type ecl_sum, int report_step );
  public static native ecl_sum_type ecl_sum_alloc_restart_writer2( @Cast("const char*") BytePointer ecl_case,
                                                         @Cast("const char*") BytePointer restart_case,
                                                         int restart_step,
                                                         @Cast("bool") boolean fmt_output,
                                                         @Cast("bool") boolean unified,
                                                         @Cast("const char*") BytePointer key_join_string,
                                                         @ByVal @Cast("time_t*") Pointer sim_start,
                                                         @Cast("bool") boolean time_in_days,
                                                         int nx,
                                                         int ny,
                                                         int nz);
  public static native ecl_sum_type ecl_sum_alloc_restart_writer2( String ecl_case,
                                                         String restart_case,
                                                         int restart_step,
                                                         @Cast("bool") boolean fmt_output,
                                                         @Cast("bool") boolean unified,
                                                         String key_join_string,
                                                         @ByVal @Cast("time_t*") Pointer sim_start,
                                                         @Cast("bool") boolean time_in_days,
                                                         int nx,
                                                         int ny,
                                                         int nz);
  public static native void ecl_sum_set_case( ecl_sum_type ecl_sum, @Cast("const char*") BytePointer input_arg);
  public static native void ecl_sum_set_case( ecl_sum_type ecl_sum, String input_arg);

  public static native ecl_sum_type ecl_sum_alloc_restart_writer(@Cast("const char*") BytePointer ecl_case,
                                                @Cast("const char*") BytePointer restart_case,
                                                @Cast("bool") boolean fmt_output,
                                                @Cast("bool") boolean unified,
                                                @Cast("const char*") BytePointer key_join_string,
                                                @ByVal @Cast("time_t*") Pointer sim_start,
                                                @Cast("bool") boolean time_in_days,
                                                int nx,
                                                int ny,
                                                int nz);
  public static native ecl_sum_type ecl_sum_alloc_restart_writer(String ecl_case,
                                                String restart_case,
                                                @Cast("bool") boolean fmt_output,
                                                @Cast("bool") boolean unified,
                                                String key_join_string,
                                                @ByVal @Cast("time_t*") Pointer sim_start,
                                                @Cast("bool") boolean time_in_days,
                                                int nx,
                                                int ny,
                                                int nz);
  public static native ecl_sum_type ecl_sum_alloc_writer(@Cast("const char*") BytePointer ecl_case,
                                               @Cast("bool") boolean fmt_output,
                                               @Cast("bool") boolean unified,
                                               @Cast("const char*") BytePointer key_join_string,
                                               @ByVal @Cast("time_t*") Pointer sim_start,
                                               @Cast("bool") boolean time_in_days,
                                               int nx, int ny, int nz);
  public static native ecl_sum_type ecl_sum_alloc_writer(String ecl_case,
                                               @Cast("bool") boolean fmt_output,
                                               @Cast("bool") boolean unified,
                                               String key_join_string,
                                               @ByVal @Cast("time_t*") Pointer sim_start,
                                               @Cast("bool") boolean time_in_days,
                                               int nx, int ny, int nz);
  public static native void ecl_sum_fwrite( @Const ecl_sum_type ecl_sum );
  public static native @Cast("bool") boolean ecl_sum_can_write( @Const ecl_sum_type ecl_sum );
  public static native void ecl_sum_fwrite_smspec( @Const ecl_sum_type ecl_sum );
  public static native @Const smspec_node ecl_sum_add_smspec_node(ecl_sum_type ecl_sum, @Const smspec_node node);
  public static native @Const smspec_node ecl_sum_add_var(ecl_sum_type ecl_sum,
                                          @Cast("const char*") BytePointer keyword,
                                          @Cast("const char*") BytePointer wgname,
                                          int num,
                                          @Cast("const char*") BytePointer unit,
                                          float default_value);
  public static native @Const smspec_node ecl_sum_add_var(ecl_sum_type ecl_sum,
                                          String keyword,
                                          String wgname,
                                          int num,
                                          String unit,
                                          float default_value);
  public static native ecl_sum_tstep_type ecl_sum_add_tstep( ecl_sum_type ecl_sum, int report_step, double sim_seconds);

  public static native @Cast("bool") boolean ecl_sum_is_oil_producer( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer well);
  public static native @Cast("bool") boolean ecl_sum_is_oil_producer( @Const ecl_sum_type ecl_sum, String well);
  public static native @Cast("char*") BytePointer ecl_sum_alloc_well_key( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer keyword, @Cast("const char*") BytePointer wgname);
  public static native @Cast("char*") ByteBuffer ecl_sum_alloc_well_key( @Const ecl_sum_type ecl_sum, String keyword, String wgname);
  public static native @Cast("bool") boolean ecl_sum_report_step_equal( @Const ecl_sum_type ecl_sum1, @Const ecl_sum_type ecl_sum2);
  public static native @Cast("bool") boolean ecl_sum_report_step_compatible( @Const ecl_sum_type ecl_sum1, @Const ecl_sum_type ecl_sum2);
  public static native void ecl_sum_export_csv(@Const ecl_sum_type ecl_sum,
                                             @Cast("const char*") BytePointer filename,
                                             @Const stringlist_type var_list,
                                             @Cast("const char*") BytePointer date_format,
                                             @Cast("const char*") BytePointer sep);
  public static native void ecl_sum_export_csv(@Const ecl_sum_type ecl_sum,
                                             String filename,
                                             @Const stringlist_type var_list,
                                             String date_format,
                                             String sep);


  public static native double_vector_type ecl_sum_alloc_seconds_solution( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key, double cmp_value, @Cast("bool") boolean rates_clamp_lower);
  public static native double_vector_type ecl_sum_alloc_seconds_solution( @Const ecl_sum_type ecl_sum, String gen_key, double cmp_value, @Cast("bool") boolean rates_clamp_lower);
  public static native double_vector_type ecl_sum_alloc_days_solution( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key, double cmp_value, @Cast("bool") boolean rates_clamp_lower);
  public static native double_vector_type ecl_sum_alloc_days_solution( @Const ecl_sum_type ecl_sum, String gen_key, double cmp_value, @Cast("bool") boolean rates_clamp_lower);
  public static native time_t_vector_type ecl_sum_alloc_time_solution( @Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key, double cmp_value, @Cast("bool") boolean rates_clamp_lower);
  public static native time_t_vector_type ecl_sum_alloc_time_solution( @Const ecl_sum_type ecl_sum, String gen_key, double cmp_value, @Cast("bool") boolean rates_clamp_lower);

  public static native double ecl_sum_iget_last_value(@Const ecl_sum_type ecl_sum, int param_index);
  public static native double ecl_sum_get_last_value_gen_key(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key);
  public static native double ecl_sum_get_last_value_gen_key(@Const ecl_sum_type ecl_sum, String gen_key);
  public static native double ecl_sum_get_last_value_node(@Const ecl_sum_type ecl_sum, @Const smspec_node node);
  public static native double ecl_sum_iget_first_value(@Const ecl_sum_type ecl_sum, int param_index);
  public static native double ecl_sum_get_first_value_gen_key(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key);
  public static native double ecl_sum_get_first_value_gen_key(@Const ecl_sum_type ecl_sum, String gen_key);
  public static native double ecl_sum_get_first_value_node(@Const ecl_sum_type ecl_sum, @Const smspec_node node);

  public static native void ecl_sum_init_datetime64_vector(@Const ecl_sum_type ecl_sum, @Cast("int64_t*") LongPointer data, int multiplier);
  public static native void ecl_sum_init_datetime64_vector(@Const ecl_sum_type ecl_sum, @Cast("int64_t*") LongBuffer data, int multiplier);
  public static native void ecl_sum_init_datetime64_vector(@Const ecl_sum_type ecl_sum, @Cast("int64_t*") long[] data, int multiplier);
  public static native void ecl_sum_init_double_vector_interp(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key, @Const time_t_vector_type time_points, DoublePointer data);
  public static native void ecl_sum_init_double_vector_interp(@Const ecl_sum_type ecl_sum, String gen_key, @Const time_t_vector_type time_points, DoubleBuffer data);
  public static native void ecl_sum_init_double_vector_interp(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key, @Const time_t_vector_type time_points, double[] data);
  public static native void ecl_sum_init_double_vector_interp(@Const ecl_sum_type ecl_sum, String gen_key, @Const time_t_vector_type time_points, DoublePointer data);
  public static native void ecl_sum_init_double_vector_interp(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key, @Const time_t_vector_type time_points, DoubleBuffer data);
  public static native void ecl_sum_init_double_vector_interp(@Const ecl_sum_type ecl_sum, String gen_key, @Const time_t_vector_type time_points, double[] data);
  public static native void ecl_sum_init_double_vector(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key, DoublePointer data);
  public static native void ecl_sum_init_double_vector(@Const ecl_sum_type ecl_sum, String gen_key, DoubleBuffer data);
  public static native void ecl_sum_init_double_vector(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key, double[] data);
  public static native void ecl_sum_init_double_vector(@Const ecl_sum_type ecl_sum, String gen_key, DoublePointer data);
  public static native void ecl_sum_init_double_vector(@Const ecl_sum_type ecl_sum, @Cast("const char*") BytePointer gen_key, DoubleBuffer data);
  public static native void ecl_sum_init_double_vector(@Const ecl_sum_type ecl_sum, String gen_key, double[] data);
  public static native void ecl_sum_init_double_frame(@Const ecl_sum_type ecl_sum, @Const ecl_sum_vector_type keywords, DoublePointer data);
  public static native void ecl_sum_init_double_frame(@Const ecl_sum_type ecl_sum, @Const ecl_sum_vector_type keywords, DoubleBuffer data);
  public static native void ecl_sum_init_double_frame(@Const ecl_sum_type ecl_sum, @Const ecl_sum_vector_type keywords, double[] data);
  public static native void ecl_sum_init_double_frame_interp(@Const ecl_sum_type ecl_sum, @Const ecl_sum_vector_type keywords, @Const time_t_vector_type time_points, DoublePointer data);
  public static native void ecl_sum_init_double_frame_interp(@Const ecl_sum_type ecl_sum, @Const ecl_sum_vector_type keywords, @Const time_t_vector_type time_points, DoubleBuffer data);
  public static native void ecl_sum_init_double_frame_interp(@Const ecl_sum_type ecl_sum, @Const ecl_sum_vector_type keywords, @Const time_t_vector_type time_points, double[] data);
  public static native @Cast("bool") boolean ecl_sum_is_instance( @Const Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_sum_vector.hpp

/*
  Copyright (C) 2014  Equinor ASA, Norway.

  The file 'ecl_sum_vector.h' is part of ERT - Ensemble based Reservoir Tool.

  ERT is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  ERT is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.

  See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
  for more details.
*/

// #ifndef ERT_ECL_SUM_VECTOR_H
// #define ERT_ECL_SUM_VECTOR_H

// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/ecl_sum.hpp>

// #ifdef __cplusplus
// #endif

  public static native void ecl_sum_vector_free( ecl_sum_vector_type keylist );
  public static native ecl_sum_vector_type ecl_sum_vector_alloc(@Const ecl_sum_type ecl_sum, @Cast("bool") boolean add_keywords);

  public static native @Cast("bool") boolean ecl_sum_vector_add_key( ecl_sum_vector_type keylist, @Cast("const char*") BytePointer key);
  public static native @Cast("bool") boolean ecl_sum_vector_add_key( ecl_sum_vector_type keylist, String key);
  public static native void ecl_sum_vector_add_keys( ecl_sum_vector_type keylist, @Cast("const char*") BytePointer pattern);
  public static native void ecl_sum_vector_add_keys( ecl_sum_vector_type keylist, String pattern);

  public static native @Cast("const char*") BytePointer ecl_sum_vector_iget_key(@Const ecl_sum_vector_type ecl_sum_vector, int index);
  public static native @Cast("bool") boolean ecl_sum_vector_iget_is_rate(@Const ecl_sum_vector_type ecl_sum_vector, int index);
  public static native int ecl_sum_vector_iget_param_index(@Const ecl_sum_vector_type ecl_sum_vector, int index);
  public static native int ecl_sum_vector_get_size(@Const ecl_sum_vector_type ecl_sum_vector);
  public static native @Cast("bool") boolean ecl_sum_vector_iget_valid(@Const ecl_sum_vector_type ecl_sum_vector, int index);

  public static native ecl_sum_vector_type ecl_sum_vector_alloc_layout_copy(@Const ecl_sum_vector_type src_vector, @Const ecl_sum_type ecl_sum);


  public static native @Cast("bool") boolean ecl_sum_vector_is_instance( @Const Pointer __arg );


// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_sum_vector.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_sum_vector.hpp>




// Parsed from ert/ecl/ecl_sum_tstep.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_sum_tstep.hpp>




// Parsed from ert/ecl/ecl_sum_index.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_sum_index.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_SUM_INDEX_H
// #define ERT_ECL_SUM_INDEX_H

// #ifdef __cplusplus
// Targeting ../ecl_sum_index_type.java



// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_sum_index.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_sum_index.hpp>




// Parsed from ert/ecl/ecl_sum_data.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_sum_data.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_SUM_DATA_H
// #define ERT_ECL_SUM_DATA_H


// #include <stdlib.h>
// #include <stdint.h>
// #include <time.h>

// #include <ert/util/time_t_vector.hpp>
// #include <ert/util/double_vector.hpp>
// #include <ert/util/stringlist.hpp>

// #include <ert/ecl/ecl_sum_tstep.hpp>
// #include <ert/ecl/smspec_node.hpp>
// #include <ert/ecl/ecl_sum_vector.hpp>

// #ifdef __cplusplus
// Targeting ../ecl_sum_data_type.java



  public static native void ecl_sum_data_reset_self_map( ecl_sum_data_type data );
  public static native void ecl_sum_data_add_case(ecl_sum_data_type self, @Const ecl_sum_data_type other);
  public static native void ecl_sum_data_fwrite_step( @Const ecl_sum_data_type data, @Cast("const char*") BytePointer ecl_case, @Cast("bool") boolean fmt_case, @Cast("bool") boolean unified, int report_step);
  public static native void ecl_sum_data_fwrite_step( @Const ecl_sum_data_type data, String ecl_case, @Cast("bool") boolean fmt_case, @Cast("bool") boolean unified, int report_step);
  public static native void ecl_sum_data_fwrite( @Const ecl_sum_data_type data, @Cast("const char*") BytePointer ecl_case, @Cast("bool") boolean fmt_case, @Cast("bool") boolean unified);
  public static native void ecl_sum_data_fwrite( @Const ecl_sum_data_type data, String ecl_case, @Cast("bool") boolean fmt_case, @Cast("bool") boolean unified);
  public static native @Cast("bool") boolean ecl_sum_data_can_write(@Const ecl_sum_data_type data);
  public static native @Cast("bool") boolean ecl_sum_data_fread( ecl_sum_data_type data, @Const stringlist_type filelist, @Cast("bool") boolean lazy_load, int file_options);
  public static native ecl_sum_data_type ecl_sum_data_alloc_writer( ecl_smspec_type smspec );
  public static native ecl_sum_data_type ecl_sum_data_alloc( ecl_smspec_type smspec);
  public static native double ecl_sum_data_time2days( @Const ecl_sum_data_type data, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native int ecl_sum_data_get_report_step_from_time(@Const ecl_sum_data_type data, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native int ecl_sum_data_get_report_step_from_days(@Const ecl_sum_data_type data, double days);
  public static native @Cast("bool") boolean ecl_sum_data_check_sim_time( @Const ecl_sum_data_type data, @ByVal @Cast("time_t*") Pointer sim_time);
  public static native @Cast("bool") boolean ecl_sum_data_check_sim_days( @Const ecl_sum_data_type data, double sim_days);
  public static native int ecl_sum_data_get_num_ministep( @Const ecl_sum_data_type data );
  public static native double_vector_type ecl_sum_data_alloc_data_vector( @Const ecl_sum_data_type data, int data_index, @Cast("bool") boolean report_only);
  public static native void ecl_sum_data_init_time_vector( @Const ecl_sum_data_type data, time_t_vector_type time_vector, @Cast("bool") boolean report_only);
  public static native time_t_vector_type ecl_sum_data_alloc_time_vector( @Const ecl_sum_data_type data, @Cast("bool") boolean report_only);
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_data_get_data_start( @Const ecl_sum_data_type data );
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_data_get_report_time( @Const ecl_sum_data_type data, int report_step);
  public static native double ecl_sum_data_get_first_day( @Const ecl_sum_data_type data);
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_data_get_sim_start( @Const ecl_sum_data_type data );
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_data_get_sim_end( @Const ecl_sum_data_type data );
  public static native double ecl_sum_data_get_sim_length( @Const ecl_sum_data_type data );
  public static native void ecl_sum_data_summarize(@Const ecl_sum_data_type data, @Cast("FILE*") Pointer stream);
  public static native double ecl_sum_data_iget( @Const ecl_sum_data_type data, int internal_index, int params_index );

  public static native double ecl_sum_data_iget_sim_days( @Const ecl_sum_data_type arg0, int arg1 );
  public static native @ByVal @Cast("time_t*") Pointer ecl_sum_data_iget_sim_time( @Const ecl_sum_data_type arg0, int arg1 );
  public static native void ecl_sum_data_get_interp_vector( @Const ecl_sum_data_type data, @ByVal @Cast("time_t*") Pointer sim_time, @Const ecl_sum_vector_type keylist, double_vector_type results);

  public static native @Cast("bool") boolean ecl_sum_data_has_report_step(@Const ecl_sum_data_type arg0, int arg1 );

  public static native ecl_sum_data_type ecl_sum_data_fread_alloc( ecl_smspec_type arg0, @Const stringlist_type filelist, @Cast("bool") boolean include_restart, @Cast("bool") boolean lazy_load);
  public static native void ecl_sum_data_free( ecl_sum_data_type arg0 );
  public static native int ecl_sum_data_get_last_report_step( @Const ecl_sum_data_type data );
  public static native int ecl_sum_data_get_first_report_step( @Const ecl_sum_data_type data );

  public static native double ecl_sum_data_get_from_sim_time( @Const ecl_sum_data_type data, @ByVal @Cast("time_t*") Pointer sim_time, @Const @ByRef smspec_node smspec_node);
  public static native double ecl_sum_data_get_from_sim_days( @Const ecl_sum_data_type data, double sim_days, @Const @ByRef smspec_node smspec_node);

  public static native int ecl_sum_data_get_length( @Const ecl_sum_data_type data );
  public static native int ecl_sum_data_iget_report_step(@Const ecl_sum_data_type data, int internal_index);
  public static native int ecl_sum_data_iget_report_end( @Const ecl_sum_data_type data, int report_step );
  public static native ecl_sum_tstep_type ecl_sum_data_add_new_tstep( ecl_sum_data_type data, int report_step, double sim_seconds);
  public static native @Cast("bool") boolean ecl_sum_data_report_step_equal( @Const ecl_sum_data_type data1, @Const ecl_sum_data_type data2);
  public static native @Cast("bool") boolean ecl_sum_data_report_step_compatible( @Const ecl_sum_data_type data1, @Const ecl_sum_data_type data2);
  public static native void ecl_sum_data_fwrite_interp_csv_line(@Const ecl_sum_data_type data, @ByVal @Cast("time_t*") Pointer sim_time, @Const ecl_sum_vector_type keylist, @Cast("FILE*") Pointer fp);
  public static native double ecl_sum_data_get_last_value(@Const ecl_sum_data_type data, int param_index);
  public static native double ecl_sum_data_iget_last_value(@Const ecl_sum_data_type data, int param_index);
  public static native double ecl_sum_data_iget_first_value(@Const ecl_sum_data_type data, int param_index);
  public static native void ecl_sum_data_init_double_vector(@Const ecl_sum_data_type data, int params_index, DoublePointer output_data);
  public static native void ecl_sum_data_init_double_vector(@Const ecl_sum_data_type data, int params_index, DoubleBuffer output_data);
  public static native void ecl_sum_data_init_double_vector(@Const ecl_sum_data_type data, int params_index, double[] output_data);
  public static native void ecl_sum_data_init_datetime64_vector(@Const ecl_sum_data_type data, @Cast("int64_t*") LongPointer output_data, int multiplier);
  public static native void ecl_sum_data_init_datetime64_vector(@Const ecl_sum_data_type data, @Cast("int64_t*") LongBuffer output_data, int multiplier);
  public static native void ecl_sum_data_init_datetime64_vector(@Const ecl_sum_data_type data, @Cast("int64_t*") long[] output_data, int multiplier);

  public static native void ecl_sum_data_init_double_frame(@Const ecl_sum_data_type data, @Const ecl_sum_vector_type keywords, DoublePointer output_data);
  public static native void ecl_sum_data_init_double_frame(@Const ecl_sum_data_type data, @Const ecl_sum_vector_type keywords, DoubleBuffer output_data);
  public static native void ecl_sum_data_init_double_frame(@Const ecl_sum_data_type data, @Const ecl_sum_vector_type keywords, double[] output_data);
  public static native double_vector_type ecl_sum_data_alloc_seconds_solution( @Const ecl_sum_data_type data, @Const @ByRef smspec_node node, double value, @Cast("bool") boolean rates_clamp_lower);
  public static native void ecl_sum_data_init_double_frame_interp(@Const ecl_sum_data_type data,
                                                                   @Const ecl_sum_vector_type keywords,
                                                                   @Const time_t_vector_type time_points,
                                                                   DoublePointer output_data);
  public static native void ecl_sum_data_init_double_frame_interp(@Const ecl_sum_data_type data,
                                                                   @Const ecl_sum_vector_type keywords,
                                                                   @Const time_t_vector_type time_points,
                                                                   DoubleBuffer output_data);
  public static native void ecl_sum_data_init_double_frame_interp(@Const ecl_sum_data_type data,
                                                                   @Const ecl_sum_vector_type keywords,
                                                                   @Const time_t_vector_type time_points,
                                                                   double[] output_data);

  public static native void ecl_sum_data_init_double_vector_interp(@Const ecl_sum_data_type data,
                                                @Const @ByRef smspec_node smspec_node,
                                                @Const time_t_vector_type time_points,
                                                DoublePointer output_data);
  public static native void ecl_sum_data_init_double_vector_interp(@Const ecl_sum_data_type data,
                                                @Const @ByRef smspec_node smspec_node,
                                                @Const time_t_vector_type time_points,
                                                DoubleBuffer output_data);
  public static native void ecl_sum_data_init_double_vector_interp(@Const ecl_sum_data_type data,
                                                @Const @ByRef smspec_node smspec_node,
                                                @Const time_t_vector_type time_points,
                                                double[] output_data);


// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_sum_data.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_sum_data.hpp>




// Parsed from ert/ecl/ecl_sum.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_sum.hpp>




// Parsed from ert/ecl/ecl_region.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_region.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_REGION_H
// #define ERT_ECL_REGION_H
// #include <stdbool.h>

// #include <ert/util/int_vector.hpp>

// #include <ert/geometry/geo_polygon.hpp>

// #include <ert/ecl/ecl_grid.hpp>
// #include <ert/ecl/layer.hpp>

// #ifdef __cplusplus
// #endif

/** enum ecl_region_select_cmd */
public static final int
  SELECT_ALL           = 0,
  DESELECT_ALL         = 1,
  SELECT_FROM_IJK      = 2,
  DESELECT_FROM_IJK    = 3,
  SELECT_FROM_I        = 4,
  DSELECT_FROM_I       = 5,
  SELECT_FROM_J        = 6,
  DSELECT_FROM_J       = 7,
  SELECT_FROM_K        = 8,
  DSELECT_FROM_K       = 9,
  SELECT_EQUAL         = 10,
  DESELECT_EQUAL       = 11,
  SELECT_IN_INTERVAL   = 12,
  DESELECT_IN_INTERVAL = 13,
  INVERT_SELECTION     = 14;
// Targeting ../ecl_region_type.java



  public static native void ecl_region_unlock( ecl_region_type region );
  public static native void ecl_region_lock( ecl_region_type region );
  public static native void ecl_region_reset( ecl_region_type ecl_region );
  public static native ecl_region_type ecl_region_alloc_copy( @Const ecl_region_type ecl_region );
  public static native ecl_region_type ecl_region_alloc( @Const ecl_grid_type ecl_grid, @Cast("bool") boolean preselect);
  public static native void ecl_region_free( ecl_region_type region );
  public static native void ecl_region_free__( Pointer __region );

  public static native @Const int_vector_type ecl_region_get_active_list( ecl_region_type region );
  public static native @Const int_vector_type ecl_region_get_global_list( ecl_region_type region );
  public static native @Const int_vector_type ecl_region_get_global_active_list( ecl_region_type region );

  public static native @Cast("bool") boolean ecl_region_contains_ijk( @Const ecl_region_type ecl_region, int i, int j, int k);
  public static native @Cast("bool") boolean ecl_region_contains_global( @Const ecl_region_type ecl_region, int global_index);
  public static native @Cast("bool") boolean ecl_region_contains_active( @Const ecl_region_type ecl_region, int active_index);

  public static native void ecl_region_select_true( ecl_region_type region, @Const ecl_kw_type ecl_kw);

  public static native void ecl_region_invert_selection( ecl_region_type region );
  public static native void ecl_region_select_all( ecl_region_type region);
  public static native void ecl_region_deselect_all( ecl_region_type region );
  public static native void ecl_region_deselect_true( ecl_region_type region, @Const ecl_kw_type ecl_kw);
  public static native void ecl_region_select_false( ecl_region_type region, @Const ecl_kw_type ecl_kw);

  public static native void ecl_region_select_in_interval( ecl_region_type region, @Const ecl_kw_type ecl_kw, float min_value, float max_value);
  public static native void ecl_region_deselect_in_interval( ecl_region_type region, @Const ecl_kw_type ecl_kw, float min_value, float max_value);

  public static native void ecl_region_select_equal( ecl_region_type region, @Const ecl_kw_type ecl_kw, int value);
  public static native void ecl_region_deselect_equal( ecl_region_type region, @Const ecl_kw_type ecl_kw, int value);

  public static native void ecl_region_select_inactive_cells( ecl_region_type region );
  public static native void ecl_region_deselect_inactive_cells( ecl_region_type region );
  public static native void ecl_region_select_active_cells( ecl_region_type region );
  public static native void ecl_region_deselect_active_cells( ecl_region_type region );

  public static native void ecl_region_select_from_ijkbox( ecl_region_type region, int i1, int i2, int j1, int j2, int k1, int k2);
  public static native void ecl_region_deselect_from_ijkbox( ecl_region_type region, int i1, int i2, int j1, int j2, int k1, int k2);

  public static native void ecl_region_select_i1i2( ecl_region_type region, int i1, int i2);
  public static native void ecl_region_deselect_i1i2( ecl_region_type region, int i1, int i2);
  public static native void ecl_region_select_j1j2( ecl_region_type region, int j1, int j2);
  public static native void ecl_region_deselect_j1j2( ecl_region_type region, int j1, int i2);
  public static native void ecl_region_select_k1k2( ecl_region_type region, int k1, int k2);
  public static native void ecl_region_deselect_k1k2( ecl_region_type region, int k1, int i2);

  public static native void ecl_region_select_shallow_cells( ecl_region_type region, double depth_limit );
  public static native void ecl_region_deselect_shallow_cells( ecl_region_type region, double depth_limit );
  public static native void ecl_region_select_deep_cells( ecl_region_type region, double depth_limit );
  public static native void ecl_region_deselect_deep_cells( ecl_region_type region, double depth_limit );

  public static native void ecl_region_select_thin_cells( ecl_region_type ecl_region, double dz_limit );
  public static native void ecl_region_deselect_thin_cells( ecl_region_type ecl_region, double dz_limit );
  public static native void ecl_region_select_thick_cells( ecl_region_type ecl_region, double dz_limit );
  public static native void ecl_region_deselect_thick_cells( ecl_region_type ecl_region, double dz_limit );

  public static native void ecl_region_select_small_cells( ecl_region_type ecl_region, double volum_limit );
  public static native void ecl_region_deselect_small_cells( ecl_region_type ecl_region, double volum_limit );
  public static native void ecl_region_select_large_cells( ecl_region_type ecl_region, double volum_limit );
  public static native void ecl_region_deselect_large_cells( ecl_region_type ecl_region, double volum_limit );

  public static native void ecl_region_select_global_index( ecl_region_type ecl_region, int global_index);
  public static native void ecl_region_deselect_global_index( ecl_region_type ecl_region, int global_index);

  public static native void ecl_region_select_active_index( ecl_region_type ecl_region, int active_index);
  public static native void ecl_region_deselect_active_index( ecl_region_type ecl_region, int active_index);

  public static native void ecl_region_intersection( ecl_region_type region, @Const ecl_region_type new_region );
  public static native void ecl_region_union( ecl_region_type region, @Const ecl_region_type new_region );
  public static native void ecl_region_subtract( ecl_region_type region, @Const ecl_region_type new_region);
  public static native void ecl_region_xor( ecl_region_type region, @Const ecl_region_type new_region);

  public static native void ecl_region_select_smaller( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, float _limit);
  public static native void ecl_region_deselect_smaller( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, float _limit);
  public static native void ecl_region_select_larger( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, float _limit);
  public static native void ecl_region_deselect_larger( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, float _limit);

  public static native void ecl_region_cmp_select_less( ecl_region_type ecl_region, @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);
  public static native void ecl_region_cmp_deselect_less( ecl_region_type ecl_region, @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);
  public static native void ecl_region_cmp_select_more( ecl_region_type ecl_region, @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);
  public static native void ecl_region_cmp_deselect_more( ecl_region_type ecl_region, @Const ecl_kw_type kw1, @Const ecl_kw_type kw2);

  public static native void ecl_region_select_in_cylinder( ecl_region_type region, double x0, double y0, double R);
  public static native void ecl_region_deselect_in_cylinder( ecl_region_type region, double x0, double y0, double R);
  public static native void ecl_region_select_in_zcylinder( ecl_region_type region, double x0, double y0, double R, double z1, double z2);
  public static native void ecl_region_deselect_in_zcylinder( ecl_region_type region, double x0, double y0, double R, double z1, double z2);

  public static native void ecl_region_select_above_plane( ecl_region_type region, @Const DoublePointer n, @Const DoublePointer p);
  public static native void ecl_region_select_above_plane( ecl_region_type region, @Const DoubleBuffer n, @Const DoubleBuffer p);
  public static native void ecl_region_select_above_plane( ecl_region_type region, @Const double[] n, @Const double[] p);
  public static native void ecl_region_select_below_plane( ecl_region_type region, @Const DoublePointer n, @Const DoublePointer p);
  public static native void ecl_region_select_below_plane( ecl_region_type region, @Const DoubleBuffer n, @Const DoubleBuffer p);
  public static native void ecl_region_select_below_plane( ecl_region_type region, @Const double[] n, @Const double[] p);
  public static native void ecl_region_deselect_above_plane( ecl_region_type region, @Const DoublePointer n, @Const DoublePointer p);
  public static native void ecl_region_deselect_above_plane( ecl_region_type region, @Const DoubleBuffer n, @Const DoubleBuffer p);
  public static native void ecl_region_deselect_above_plane( ecl_region_type region, @Const double[] n, @Const double[] p);
  public static native void ecl_region_deselect_below_plane( ecl_region_type region, @Const DoublePointer n, @Const DoublePointer p);
  public static native void ecl_region_deselect_below_plane( ecl_region_type region, @Const DoubleBuffer n, @Const DoubleBuffer p);
  public static native void ecl_region_deselect_below_plane( ecl_region_type region, @Const double[] n, @Const double[] p);

  public static native void ecl_region_select_inside_polygon( ecl_region_type region, @Const geo_polygon_type polygon);
  public static native void ecl_region_deselect_inside_polygon( ecl_region_type region, @Const geo_polygon_type polygon);
  public static native void ecl_region_select_outside_polygon( ecl_region_type region, @Const geo_polygon_type polygon);
  public static native void ecl_region_deselect_outside_polygon( ecl_region_type region, @Const geo_polygon_type polygon);

  public static native void ecl_region_select_from_layer( ecl_region_type region, @Const layer_type layer, int k, int layer_value);
  public static native void ecl_region_deselect_from_layer( ecl_region_type region, @Const layer_type layer, int k, int layer_value);
  public static native void ecl_region_deselect_false( ecl_region_type region, @Const ecl_kw_type ecl_kw);


/*****************************************************************/
/* Functions to manipulate ecl_kw instances . */

  public static native void ecl_region_set_kw_int( ecl_region_type ecl_region, ecl_kw_type ecl_kw, int value, @Cast("bool") boolean force_active);
  public static native void ecl_region_set_kw_float( ecl_region_type ecl_region, ecl_kw_type ecl_kw, float value, @Cast("bool") boolean force_active);
  public static native void ecl_region_set_kw_double( ecl_region_type ecl_region, ecl_kw_type ecl_kw, double value, @Cast("bool") boolean force_active);
  public static native void ecl_region_kw_copy( ecl_region_type ecl_region, ecl_kw_type ecl_kw, @Const ecl_kw_type src_kw, @Cast("bool") boolean force_active);
  public static native int ecl_region_get_kw_size( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, @Cast("bool") boolean force_active);

  public static native void ecl_region_kw_iadd( ecl_region_type ecl_region, ecl_kw_type ecl_kw, @Const ecl_kw_type delta_kw, @Cast("bool") boolean force_active);
  public static native void ecl_region_kw_idiv( ecl_region_type ecl_region, ecl_kw_type ecl_kw, @Const ecl_kw_type div_kw, @Cast("bool") boolean force_active);
  public static native void ecl_region_kw_imul( ecl_region_type ecl_region, ecl_kw_type ecl_kw, @Const ecl_kw_type mul_kw, @Cast("bool") boolean force_active);
  public static native void ecl_region_kw_isub( ecl_region_type ecl_region, ecl_kw_type ecl_kw, @Const ecl_kw_type delta_kw, @Cast("bool") boolean force_active);

  public static native @Cast("bool") boolean ecl_region_equal( @Const ecl_region_type region1, @Const ecl_region_type region2);

  public static native void ecl_region_scale_kw_float( ecl_region_type ecl_region, ecl_kw_type ecl_kw, float value, @Cast("bool") boolean force_active);
  public static native void ecl_region_scale_kw_double( ecl_region_type ecl_region, ecl_kw_type ecl_kw, double value, @Cast("bool") boolean force_active);
  public static native void ecl_region_scale_kw_int( ecl_region_type ecl_region, ecl_kw_type ecl_kw, int value, @Cast("bool") boolean force_active);
  public static native void ecl_region_shift_kw_int( ecl_region_type ecl_region, ecl_kw_type ecl_kw, int value, @Cast("bool") boolean force_active);
  public static native void ecl_region_shift_kw_double( ecl_region_type ecl_region, ecl_kw_type ecl_kw, double value, @Cast("bool") boolean force_active);
  public static native void ecl_region_shift_kw_float( ecl_region_type ecl_region, ecl_kw_type ecl_kw, float value, @Cast("bool") boolean force_active);

  public static native @Const int_vector_type ecl_region_get_kw_index_list( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, @Cast("bool") boolean force_active);


/*****************************************************************/
/* set/get the name */
  public static native void ecl_region_set_name( ecl_region_type region, @Cast("const char*") BytePointer name );
  public static native void ecl_region_set_name( ecl_region_type region, String name );
  public static native @Cast("const char*") BytePointer ecl_region_get_name( @Const ecl_region_type region );

/*****************************************************************/
/* Cpp compat/legacy/cruft functions. */
  public static native int ecl_region_get_active_size_cpp(  ecl_region_type region );
  public static native int ecl_region_get_global_size_cpp( ecl_region_type region );
  public static native @Const IntPointer ecl_region_get_active_list_cpp( ecl_region_type region );
  public static native @Const IntPointer ecl_region_get_global_list_cpp(  ecl_region_type region );


/*****************************************************************/

  public static native double ecl_region_sum_kw_double( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, @Cast("bool") boolean force_active);
  public static native int ecl_region_sum_kw_int( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, @Cast("bool") boolean force_active);
  public static native float ecl_region_sum_kw_float( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, @Cast("bool") boolean force_active);
  public static native int ecl_region_sum_kw_bool( ecl_region_type ecl_region, @Const ecl_kw_type ecl_kw, @Cast("bool") boolean force_active);



public static native @Cast("bool") boolean ecl_region_is_instance( @Const Pointer __arg );
public static native ecl_region_type ecl_region_safe_cast( Pointer __arg );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_subsidence.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_subsidence.h' is part of ERT - Ensemble based
   Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_SUBSIDENCE_H
// #define ERT_ECL_SUBSIDENCE_H
// #ifdef __cplusplus
// #endif

// #include <ert/ecl/ecl_file.hpp>
// #include <ert/ecl/ecl_file_view.hpp>
// #include <ert/ecl/ecl_grid.hpp>
// #include <ert/ecl/ecl_region.hpp>
// Targeting ../ecl_subsidence_type.java


// Targeting ../ecl_subsidence_survey_type.java




  public static native void ecl_subsidence_free( ecl_subsidence_type ecl_subsidence_config );
  public static native ecl_subsidence_type ecl_subsidence_alloc( @Const ecl_grid_type ecl_grid, @Const ecl_file_type init_file );
  public static native ecl_subsidence_survey_type ecl_subsidence_add_survey_PRESSURE( ecl_subsidence_type subsidence,
                                                                     @Cast("const char*") BytePointer name, @Const ecl_file_view_type restart_view );
  public static native ecl_subsidence_survey_type ecl_subsidence_add_survey_PRESSURE( ecl_subsidence_type subsidence,
                                                                     String name, @Const ecl_file_view_type restart_view );

  public static native @Cast("bool") boolean ecl_subsidence_has_survey( @Const ecl_subsidence_type subsidence, @Cast("const char*") BytePointer name);
  public static native @Cast("bool") boolean ecl_subsidence_has_survey( @Const ecl_subsidence_type subsidence, String name);
  public static native double ecl_subsidence_eval( @Const ecl_subsidence_type subsidence,
                                                      @Cast("const char*") BytePointer base, @Cast("const char*") BytePointer monitor,
                                                      ecl_region_type region,
                                                      double utm_x, double utm_y, double depth, double compressibility, double poisson_ratio);
  public static native double ecl_subsidence_eval( @Const ecl_subsidence_type subsidence,
                                                      String base, String monitor,
                                                      ecl_region_type region,
                                                      double utm_x, double utm_y, double depth, double compressibility, double poisson_ratio);

  public static native double ecl_subsidence_eval_geertsma( @Const ecl_subsidence_type subsidence, @Cast("const char*") BytePointer base, @Cast("const char*") BytePointer monitor, ecl_region_type region,
                                         double utm_x, double utm_y, double depth,
                                         double youngs_modulus, double poisson_ratio, double seabed);
  public static native double ecl_subsidence_eval_geertsma( @Const ecl_subsidence_type subsidence, String base, String monitor, ecl_region_type region,
                                         double utm_x, double utm_y, double depth,
                                         double youngs_modulus, double poisson_ratio, double seabed);

  public static native double ecl_subsidence_eval_geertsma_rporv( @Const ecl_subsidence_type subsidence, @Cast("const char*") BytePointer base, @Cast("const char*") BytePointer monitor, ecl_region_type region,
                                         double utm_x, double utm_y, double depth,
                                         double youngs_modulus, double poisson_ratio, double seabed);
  public static native double ecl_subsidence_eval_geertsma_rporv( @Const ecl_subsidence_type subsidence, String base, String monitor, ecl_region_type region,
                                         double utm_x, double utm_y, double depth,
                                         double youngs_modulus, double poisson_ratio, double seabed);




// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_subsidence.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_subsidence.hpp>




// Parsed from ert/ecl/ecl_smspec.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_smspec.hpp>




// Parsed from ert/ecl/ecl_rsthead.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_rsthead.hpp>




// Parsed from ert/ecl/ecl_rst_file.hpp

/*
   Copyright (C) 2012  Equinor ASA, Norway.

   The file 'ecl_rst_file.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_ECL_RST_FILE_H
// #define ERT_ECL_RST_FILE_H

// #include <ert/ecl/ecl_rsthead.hpp>

// #ifdef __cplusplus
// Targeting ../ecl_rst_file_type.java




  public static native ecl_rst_file_type ecl_rst_file_open_read( @Cast("const char*") BytePointer filename );
  public static native ecl_rst_file_type ecl_rst_file_open_read( String filename );
  public static native ecl_rst_file_type ecl_rst_file_open_write( @Cast("const char*") BytePointer filename );
  public static native ecl_rst_file_type ecl_rst_file_open_write( String filename );
  public static native ecl_rst_file_type ecl_rst_file_open_append( @Cast("const char*") BytePointer filename );
  public static native ecl_rst_file_type ecl_rst_file_open_append( String filename );
  public static native ecl_rst_file_type ecl_rst_file_open_write_seek( @Cast("const char*") BytePointer filename, int report_step);
  public static native ecl_rst_file_type ecl_rst_file_open_write_seek( String filename, int report_step);
  public static native void ecl_rst_file_close( ecl_rst_file_type rst_file );

  public static native void ecl_rst_file_start_solution( ecl_rst_file_type rst_file );
  public static native void ecl_rst_file_end_solution( ecl_rst_file_type rst_file );
  public static native void ecl_rst_file_fwrite_header( ecl_rst_file_type rst_file, int seqnum, ecl_rsthead_type rsthead_data );
  public static native void ecl_rst_file_add_kw(ecl_rst_file_type rst_file, @Const ecl_kw_type ecl_kw );
  public static native @Cast("offset_type") long ecl_rst_file_ftell(@Const ecl_rst_file_type rst_file );

// #ifdef __cplusplus
// #endif

// #endif


// Parsed from ert/ecl/ecl_rst_file.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_rst_file.hpp>




// Parsed from ert/ecl/ecl_rft_cell.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_rft_cell.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_RFT_CELL_H
// #define ERT_ECL_RFT_CELL_H
// #ifdef __cplusplus
// #endif

// #include <ert/util/type_macros.hpp>

public static final int ECL_RFT_CELL_INVALID_VALUE = -1;
// Targeting ../ecl_rft_cell_type.java






public static native @Cast("bool") boolean ecl_rft_cell_is_instance( @Const Pointer __arg );

  public static native ecl_rft_cell_type ecl_rft_cell_alloc_PLT( int i,
                                                int j,
                                                int k,
                                                double depth,
                                                double pressure,
                                                double orat,
                                                double grat,
                                                double wrat,
                                                double connection_start,
                                                double connection_end,
                                                double flowrate,
                                                double oil_flowrate,
                                                double gas_flowrate,
                                                double water_flowrate);

  public static native ecl_rft_cell_type ecl_rft_cell_alloc_RFT( int i, int j, int k, double depth, double pressure, double swat, double sgas);
  public static native void ecl_rft_cell_free( ecl_rft_cell_type cell );
  public static native void ecl_rft_cell_free__( Pointer arg);

  public static native @Cast("bool") boolean ecl_rft_cell_ijk_equal( @Const ecl_rft_cell_type cell, int i, int j, int k);
  public static native void ecl_rft_cell_get_ijk( @Const ecl_rft_cell_type cell, IntPointer i, IntPointer j, IntPointer k);
  public static native void ecl_rft_cell_get_ijk( @Const ecl_rft_cell_type cell, IntBuffer i, IntBuffer j, IntBuffer k);
  public static native void ecl_rft_cell_get_ijk( @Const ecl_rft_cell_type cell, int[] i, int[] j, int[] k);
  public static native int ecl_rft_cell_get_i( @Const ecl_rft_cell_type cell );
  public static native int ecl_rft_cell_get_j( @Const ecl_rft_cell_type cell );
  public static native int ecl_rft_cell_get_k( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_depth( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_pressure( @Const ecl_rft_cell_type cell );

  public static native double ecl_rft_cell_get_swat( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_sgas( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_soil( @Const ecl_rft_cell_type cell );

  public static native double ecl_rft_cell_get_wrat( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_grat( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_orat( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_connection_start( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_connection_end( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_flowrate( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_oil_flowrate( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_gas_flowrate( @Const ecl_rft_cell_type cell );
  public static native double ecl_rft_cell_get_water_flowrate( @Const ecl_rft_cell_type cell );

  public static native int ecl_rft_cell_cmp__( @Const Pointer arg1, @Const Pointer arg2);
  public static native int ecl_rft_cell_cmp( @Const ecl_rft_cell_type cell1, @Const ecl_rft_cell_type cell2);
  public static native @Cast("bool") boolean ecl_rft_cell_lt( @Const ecl_rft_cell_type cell1, @Const ecl_rft_cell_type cell2);
// #ifdef __cplusplus
// #endif

// #endif



// Parsed from ert/ecl/ecl_rft_node.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_rft_node.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_RFT_NODE_H
// #define ERT_ECL_RFT_NODE_H
// #ifdef __cplusplus
// #endif
// #include <stdbool.h>

// #include <ert/ecl/ecl_file_view.hpp>
// #include <ert/ecl/ecl_file.hpp>
// #include <ert/ecl/ecl_rft_cell.hpp>

/** enum ecl_rft_enum */
public static final int RFT     = 1,
               PLT     = 2,
               SEGMENT = 3; /* Not really implemented */
// Targeting ../ecl_rft_node_type.java



public static native void ecl_rft_node_inplace_sort_cells( ecl_rft_node_type rft_node );
public static native @Const ecl_rft_cell_type ecl_rft_node_iget_cell_sorted( ecl_rft_node_type rft_node, int index);
public static native @Const ecl_rft_cell_type ecl_rft_node_iget_cell( @Const ecl_rft_node_type rft_node, int index);
public static native @Const ecl_rft_cell_type ecl_rft_node_lookup_ijk( @Const ecl_rft_node_type rft_node, int i, int j, int k);
public static native void ecl_rft_node_fprintf_rft_obs(@Const ecl_rft_node_type arg0, double arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, double arg4 );
public static native void ecl_rft_node_fprintf_rft_obs(@Const ecl_rft_node_type arg0, double arg1, String arg2, String arg3, double arg4 );
public static native ecl_rft_node_type ecl_rft_node_alloc(@Const ecl_file_view_type rft_view );
public static native void ecl_rft_node_free(ecl_rft_node_type arg0 );
public static native void ecl_rft_node_free__(Pointer arg0 );
public static native @ByVal @Cast("time_t*") Pointer ecl_rft_node_get_date(@Const ecl_rft_node_type arg0 );
public static native int ecl_rft_node_get_size(@Const ecl_rft_node_type arg0 );
public static native @Cast("const char*") BytePointer ecl_rft_node_get_well_name( @Const ecl_rft_node_type rft_node );
public static native void ecl_rft_node_iget_ijk( @Const ecl_rft_node_type rft_node, int index, IntPointer i, IntPointer j, IntPointer k);
public static native void ecl_rft_node_iget_ijk( @Const ecl_rft_node_type rft_node, int index, IntBuffer i, IntBuffer j, IntBuffer k);
public static native void ecl_rft_node_iget_ijk( @Const ecl_rft_node_type rft_node, int index, int[] i, int[] j, int[] k);

public static native @Cast("bool") boolean ecl_rft_node_is_RFT( @Const ecl_rft_node_type rft_node );
public static native @Cast("bool") boolean ecl_rft_node_is_PLT( @Const ecl_rft_node_type rft_node );
public static native @Cast("bool") boolean ecl_rft_node_is_SEGMENT( @Const ecl_rft_node_type rft_node );
public static native @Cast("bool") boolean ecl_rft_node_is_MSW( @Const ecl_rft_node_type rft_node );

public static native double ecl_rft_node_iget_pressure( @Const ecl_rft_node_type rft_node, int index);
public static native double ecl_rft_node_iget_depth( @Const ecl_rft_node_type rft_node, int index);
public static native double ecl_rft_node_iget_wrat( @Const ecl_rft_node_type rft_node, int index);
public static native double ecl_rft_node_iget_grat( @Const ecl_rft_node_type rft_node, int index);
public static native double ecl_rft_node_iget_orat( @Const ecl_rft_node_type rft_node, int index);

public static native double ecl_rft_node_iget_swat( @Const ecl_rft_node_type rft_node, int index);
public static native double ecl_rft_node_iget_sgas( @Const ecl_rft_node_type rft_node, int index);
public static native double ecl_rft_node_iget_soil( @Const ecl_rft_node_type rft_node, int index);
public static native void ecl_rft_node_fwrite(@Const ecl_rft_node_type rft_node, fortio_type fortio, @Cast("ert_ecl_unit_enum") int unit_set);
public static native double ecl_rft_node_get_days(@Const ecl_rft_node_type rft_node );
public static native int ecl_rft_node_cmp( @Const ecl_rft_node_type n1, @Const ecl_rft_node_type n2);
public static native @Cast("bool") boolean ecl_rft_node_lt(@Const ecl_rft_node_type n1, @Const ecl_rft_node_type n2);

public static native void ecl_rft_node_append_cell( ecl_rft_node_type rft_node, ecl_rft_cell_type cell);
public static native ecl_rft_node_type ecl_rft_node_alloc_new(@Cast("const char*") BytePointer well_name, @Cast("const char*") BytePointer data_type_string, @ByVal @Cast("const time_t*") Pointer recording_date, double days);
public static native ecl_rft_node_type ecl_rft_node_alloc_new(String well_name, String data_type_string, @ByVal @Cast("const time_t*") Pointer recording_date, double days);

public static native @Cast("ecl_rft_enum") int ecl_rft_node_get_type(@Const ecl_rft_node_type rft_node);

// #ifdef __cplusplus
// #endif
// #endif



// Parsed from ert/ecl/ecl_rft_node.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_rft_node.hpp>




// Parsed from ert/ecl/ecl_rft_file.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_rft_file.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_RFT_FILE_H
// #define ERT_ECL_RFT_FILE_H
// #ifdef __cplusplus
// #endif
// #include <stdbool.h>

// #include <ert/util/stringlist.hpp>

// #include <ert/ecl/ecl_rft_node.hpp>
// #include <ert/util/vector.hpp>
// #include <ert/util/int_vector.hpp>
// Targeting ../ecl_rft_file_type.java



public static native @Cast("char*") BytePointer ecl_rft_file_alloc_case_filename(@Cast("const char*") BytePointer case_input );
public static native @Cast("char*") ByteBuffer ecl_rft_file_alloc_case_filename(String case_input );
public static native @Cast("const char*") BytePointer ecl_rft_file_get_filename( @Const ecl_rft_file_type rft_file );
public static native ecl_rft_file_type ecl_rft_file_alloc_case(@Cast("const char*") BytePointer case_input );
public static native ecl_rft_file_type ecl_rft_file_alloc_case(String case_input );
public static native @Cast("bool") boolean ecl_rft_file_case_has_rft( @Cast("const char*") BytePointer case_input );
public static native @Cast("bool") boolean ecl_rft_file_case_has_rft( String case_input );
public static native ecl_rft_file_type ecl_rft_file_alloc(@Cast("const char*") BytePointer arg0 );
public static native ecl_rft_file_type ecl_rft_file_alloc(String arg0 );
public static native void ecl_rft_file_free(ecl_rft_file_type arg0 );
public static native void ecl_rft_file_block(@Const ecl_rft_file_type arg0, double arg1, @Cast("const char*") BytePointer arg2, int arg3, @Const DoublePointer arg4, IntPointer arg5, IntPointer arg6, IntPointer arg7);
public static native void ecl_rft_file_block(@Const ecl_rft_file_type arg0, double arg1, String arg2, int arg3, @Const DoubleBuffer arg4, IntBuffer arg5, IntBuffer arg6, IntBuffer arg7);
public static native void ecl_rft_file_block(@Const ecl_rft_file_type arg0, double arg1, @Cast("const char*") BytePointer arg2, int arg3, @Const double[] arg4, int[] arg5, int[] arg6, int[] arg7);
public static native void ecl_rft_file_block(@Const ecl_rft_file_type arg0, double arg1, String arg2, int arg3, @Const DoublePointer arg4, IntPointer arg5, IntPointer arg6, IntPointer arg7);
public static native void ecl_rft_file_block(@Const ecl_rft_file_type arg0, double arg1, @Cast("const char*") BytePointer arg2, int arg3, @Const DoubleBuffer arg4, IntBuffer arg5, IntBuffer arg6, IntBuffer arg7);
public static native void ecl_rft_file_block(@Const ecl_rft_file_type arg0, double arg1, String arg2, int arg3, @Const double[] arg4, int[] arg5, int[] arg6, int[] arg7);
public static native void ecl_rft_file_fprintf_rft_obs(@Const ecl_rft_file_type arg0, double arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4, double arg5);
public static native void ecl_rft_file_fprintf_rft_obs(@Const ecl_rft_file_type arg0, double arg1, String arg2, String arg3, String arg4, double arg5);
public static native ecl_rft_node_type ecl_rft_file_get_node(@Const ecl_rft_file_type arg0, @Cast("const char*") BytePointer arg1 );
public static native ecl_rft_node_type ecl_rft_file_get_node(@Const ecl_rft_file_type arg0, String arg1 );


public static native int ecl_rft_file_get_size__( @Const ecl_rft_file_type rft_file, @Cast("const char*") BytePointer well_pattern, @ByVal @Cast("time_t*") Pointer recording_time);
public static native int ecl_rft_file_get_size__( @Const ecl_rft_file_type rft_file, String well_pattern, @ByVal @Cast("time_t*") Pointer recording_time);
public static native int ecl_rft_file_get_size( @Const ecl_rft_file_type rft_file);
public static native ecl_rft_node_type ecl_rft_file_get_well_time_rft( @Const ecl_rft_file_type rft_file, @Cast("const char*") BytePointer well, @ByVal @Cast("time_t*") Pointer recording_time);
public static native ecl_rft_node_type ecl_rft_file_get_well_time_rft( @Const ecl_rft_file_type rft_file, String well, @ByVal @Cast("time_t*") Pointer recording_time);
public static native ecl_rft_node_type ecl_rft_file_iget_node( @Const ecl_rft_file_type rft_file, int index);
public static native ecl_rft_node_type ecl_rft_file_iget_well_rft( @Const ecl_rft_file_type rft_file, @Cast("const char*") BytePointer well, int index);
public static native ecl_rft_node_type ecl_rft_file_iget_well_rft( @Const ecl_rft_file_type rft_file, String well, int index);
public static native @Cast("bool") boolean ecl_rft_file_has_well( @Const ecl_rft_file_type rft_file, @Cast("const char*") BytePointer well);
public static native @Cast("bool") boolean ecl_rft_file_has_well( @Const ecl_rft_file_type rft_file, String well);
public static native int ecl_rft_file_get_well_occurences( @Const ecl_rft_file_type rft_file, @Cast("const char*") BytePointer well);
public static native int ecl_rft_file_get_well_occurences( @Const ecl_rft_file_type rft_file, String well);
public static native stringlist_type ecl_rft_file_alloc_well_list(@Const ecl_rft_file_type rft_file );
public static native int ecl_rft_file_get_num_wells( @Const ecl_rft_file_type rft_file );
public static native void ecl_rft_file_free__( Pointer arg);
public static native void ecl_rft_file_update(@Cast("const char*") BytePointer rft_file_name,  @Cast("ecl_rft_node_type**") PointerPointer nodes,int num_nodes, @Cast("ert_ecl_unit_enum") int unit_set);
public static native void ecl_rft_file_update(@Cast("const char*") BytePointer rft_file_name,  @ByPtrPtr ecl_rft_node_type nodes,int num_nodes, @Cast("ert_ecl_unit_enum") int unit_set);
public static native void ecl_rft_file_update(String rft_file_name,  @ByPtrPtr ecl_rft_node_type nodes,int num_nodes, @Cast("ert_ecl_unit_enum") int unit_set);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_rft_file.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_rft_file.hpp>




// Parsed from ert/ecl/ecl_rft_cell.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_rft_cell.hpp>




// Parsed from ert/ecl/ecl_region.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_region.hpp>




// Parsed from ert/ecl/ecl_nnc_geometry.hpp

/*
   Copyright (C) 2017  Equinor ASA, Norway.

   The file 'ecl_nnc_geometry.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_NNC_GEOMETRY_H
// #define ERT_NNC_GEOMETRY_H

// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/ecl_grid.hpp>

// #ifdef __cplusplus
// Targeting ../ecl_nnc_geometry_type.java


// Targeting ../ecl_nnc_pair_type.java


// Targeting ../ecl_nnc_pair_struct.java



public static native @Cast("bool") boolean ecl_nnc_geometry_is_instance( @Const Pointer __arg );
public static native void ecl_nnc_geometry_free( ecl_nnc_geometry_type nnc_geo);
public static native ecl_nnc_geometry_type ecl_nnc_geometry_alloc( @Const ecl_grid_type grid );
public static native int ecl_nnc_geometry_size( @Const ecl_nnc_geometry_type nnc_geo );
public static native @Const ecl_nnc_pair_type ecl_nnc_geometry_iget( @Const ecl_nnc_geometry_type nnc_geo, int index);
public static native @Cast("bool") boolean ecl_nnc_geometry_same_kw( @Const ecl_nnc_pair_type nnc1, @Const ecl_nnc_pair_type nnc2);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_nnc_geometry.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_nnc_geometry.hpp>




// Parsed from ert/ecl/ecl_nnc_export.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'ecl_nnc_export.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/


// #ifndef ERT_ECL_NNC_EXPORT
// #define ERT_ECL_NNC_EXPORT


// #include <math.h>

// #include <ert/ecl/ecl_grid.hpp>
// #include <ert/ecl/ecl_file.hpp>
// #include <ert/ecl/ecl_kw.hpp>

// #ifdef __cplusplus
// #endif

public static final int ERT_ECL_DEFAULT_NNC_TRANS =Integer.MAX_VALUE;
// Targeting ../ecl_nnc_type.java




public static native @Cast("bool") boolean ecl_nnc_intersect_format(@Const ecl_grid_type grid, @Const ecl_file_type init_file);
  public static native int ecl_nnc_export_get_size( @Const ecl_grid_type grid, @Const ecl_file_type init_file );
  public static native int ecl_nnc_export( @Const ecl_grid_type grid, @Const ecl_file_type init_file, ecl_nnc_type nnc_data);

  public static native ecl_kw_type ecl_nnc_export_get_tranx_kw( @Const ecl_grid_type grid, @Const ecl_file_type init_file,  int lgr_nr1, int lgr_nr2 );
  public static native ecl_kw_type ecl_nnc_export_get_tranll_kw( @Const ecl_grid_type grid, @Const ecl_file_type init_file,  int lgr_nr1, int lgr_nr2 );
  public static native ecl_kw_type ecl_nnc_export_get_tran_kw( @Const ecl_file_type init_file, @Cast("const char*") BytePointer kw, int lgr_nr );
  public static native ecl_kw_type ecl_nnc_export_get_tran_kw( @Const ecl_file_type init_file, String kw, int lgr_nr );

  public static native @Cast("bool") boolean ecl_nnc_equal( @Const ecl_nnc_type nnc1, @Const ecl_nnc_type nnc2);
  public static native int ecl_nnc_sort_cmp( @Const ecl_nnc_type nnc1, @Const ecl_nnc_type nnc2);
  public static native void ecl_nnc_sort( ecl_nnc_type nnc_list, int size);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_nnc_export.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_nnc_export.hpp>




// Parsed from ert/ecl/ecl_nnc_data.hpp

/*
   Copyright (C) 2017  Equinor ASA, Norway.

   The file 'ecl_nnc_geometry.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ECL_NNC_DATA_H
// #define ECL_NNC_DATA_H

// #include <ert/util/type_macros.hpp>

// #include <ert/ecl/ecl_nnc_geometry.hpp>
// #include <ert/ecl/ecl_nnc_export.hpp>

// #ifdef __cplusplus
// Targeting ../ecl_nnc_data_type.java



public static native ecl_nnc_data_type ecl_nnc_data_alloc_tran(@Const ecl_grid_type grid, @Const ecl_nnc_geometry_type nnc_geo, @Const ecl_file_view_type init_file);
public static native ecl_nnc_data_type ecl_nnc_data_alloc_wat_flux(@Const ecl_grid_type grid, @Const ecl_nnc_geometry_type nnc_geo, @Const ecl_file_view_type init_file);
public static native ecl_nnc_data_type ecl_nnc_data_alloc_oil_flux(@Const ecl_grid_type grid, @Const ecl_nnc_geometry_type nnc_geo, @Const ecl_file_view_type init_file);
public static native ecl_nnc_data_type ecl_nnc_data_alloc_gas_flux(@Const ecl_grid_type grid, @Const ecl_nnc_geometry_type nnc_geo, @Const ecl_file_view_type init_file);
public static native void ecl_nnc_data_free(ecl_nnc_data_type data);

public static native int ecl_nnc_data_get_size(ecl_nnc_data_type data);
public static native @Const DoublePointer ecl_nnc_data_get_values( @Const ecl_nnc_data_type data );

public static native double ecl_nnc_data_iget_value(@Const ecl_nnc_data_type data, int index);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_nnc_data.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_nnc_data.hpp>




// Parsed from ert/ecl/ecl_kw_magic.hpp

// #ifndef ERT_ECL_KW_MAGIC_H
// #define ERT_ECL_KW_MAGIC_H

// #ifdef __cplusplus
// #endif

/*
   This header file contains names and indices of ECLIPSE keywords
   which have special significance in various files. Observe that many
   of the keywords like e.g. INTEHEAD occur in many different file
   types, with partly overlapping layout and values.
 */

/*****************************************************************/
/*                INIT files:                                    */
/*****************************************************************/

public static final String PORO_KW =      "PORO";
public static final String PORV_KW =      "PORV";
public static final String AQUIFER_KW =   "AQUIFERN";
public static final String INTEHEAD_KW =  "INTEHEAD";
public static final String LOGIHEAD_KW =  "LOGIHEAD";
public static final String DOUBHEAD_KW =  "DOUBHEAD";
public static final String RPORV_KW =     "RPORV";
public static final String PORMOD_KW =    "PORV_MOD";

public static final String PVTNUM_KW =    "PVTNUM";
public static final String LGRHEADI_KW =  "LGRHEADI";
public static final int LGRHEADI_LGR_NR_INDEX = 0;
public static final String LGRJOIN_KW =   "LGRJOIN";


/*
  The table in the INIT file are organized with one large data keyword
  'TAB' and one keyword 'TABDIMS' which describe the layout of the
  data in the TAB keyword.

  For each of the tables there 'TABDIMS_xxx_OFFSET_ITEM' which points
  to an element in the 'TABDIMS' vector which contains the starting
  address of table 'xxx' in the 'TAB' keyword, then there are one or
  several integer values describing how many values/tables there
  are. In addition there is an assumed number of columns which is not
  explicitly stored in the TABDIMS keyword.

  The input format is quite flexible with respect to the size of the
  individual tables and subtables, but the representation in the INIT
  file is based on fixed length columns and equal sized tables, where
  all inactive elements have the default value 2e20.

  Assume the following PVTO input:


    PVTO
           1.55203         1.00000     1.15907572        0.64345
                          25.00000     1.15319788        0.67619
                          50.00000     1.14759314        0.70959 /

           28.04570       25.00000     1.17415042        0.63294
                          50.00000     1.16792401        0.66638
                          75.00000     1.16222385        0.69918
                         100.00000     1.15212320        0.76297 /

           35.62113       50.00000     1.19208190        0.61538
                          75.00000     1.18568689        0.64790
                         100.00000     1.17982339        0.67985
                         125.00000     1.17441865        0.71127
                         150.00000     1.16941365        0.74217 /

    /
           20.66588        1.00000     1.15642614        0.57010
                          25.00000     1.15051027        0.59831
                          50.00000     1.14487540        0.62703 /

           27.65815       25.00000     1.17402576        0.56928
                          50.00000     1.16771923        0.59875
                          75.00000     1.16195281        0.62760
                         100.00000     1.15665041        0.65588
    /

This is the PVTO table, and it is described by the constants
TABDIMS_IBPVTO_OFFSET_ITEM, TABDIMS_JBPVTO_OFFSET_ITEM,
TABDIMS_NRPVTO_ITEM, TABDIMS_NPPVTO_ITEM and TABDIMS_NTPVTO_ITEM. Observe the following:

 1. There are 3 GOR values in the first table and 2 in the second,
    this is the number of composition nodes -
    TABDIMS_NRPVTO_ITEM. Since there are 3 in the first table and 2 in
    the second the value of TABDIMS[ TABDIMS_NRPVTO_ITEM ] >= 3.

 2. The GOR node values (1.55203, 28.04570, 35.62113) and (20.66588,
    27.65815) are stored separately at offset
    TABDIMS[ TABDIMS_JBPVTO_OFFSET_ITEM ] in the TAB array.

 3. The length of the longest column is 5 elements so the value of
    TABDIMS[ TABDIMS_NPPVTO_ITEM ] >= 5.

 4. The actual table data starts at offset TABDIMS[
    TABDIMS_IBPVTO_ITEM] in the TAB table.

When packing the actual data into the TAB array the indices are
running as row,GOR,table,column - with row fastest. All in all the
linear vector for this PVTO table will look like:

  1.00000  \              \                     \                           \
 25.00000  |              |                     |                           |
 50.00000  | NPPVTO = 5   |                     |                           |
   *       |              |                     |                           |
   *       |              |                     |                           |
-----------/              |                     |                           |
 25.00000                 |                     |                           |
 50.00000                 |                     |                           |
 75.00000                 | NRPVTO = 3          |                           |
100.00000                 |                     |                           |
   *                      |                     |                           |
-----------               |                     |                           |
 50.00000                 |                     |                           |
 75.00000                 |                     |                           |
100.00000                 |                     |                           |
125.00000                 |                     |                           |
150.00000                 |                     |                           |
===========               /                     |  NTPVTO = 2               |
  1.00000                                       |                           |
 25.00000                                       |                           |
 50.00000                                       |                           |
   *                                            |                           |
   *                                            |                           |  Three columns -
-----------                                     |                           |  (not in TABDIMS)
 25.00000                                       |                           |
 50.00000                                       |                           |
 75.00000                                       |                           |
100.00000                                       |                           |
   *                                            |                           |
-----------                                     |                           |
*                                               |                           |
*                                               |                           |
*                                               |                           |
*                                               |                           |
*                                               |                           |
@@@@@@@@@@@                                     /                           |
1.15907572                                                                  |
1.15319788                                                                  |
1.14759314                                                                  |
 *                                                                          |
 *                                                                          |
-----------                                                                 |
1.17415042                                                                  |
1.16792401                                                                  |
1.16222385                                                                  |
1.15212320                                                                  |
 *                                                                          |
-----------                                                                 |
1.19208190                                                                  |
1.18568689                                                                  |
1.17982339                                                                  |
1.17441865                                                                  |
1.16941365                                                                  |
===========                                                                 |
1.15642614                                                                  |
1.15051027                                                                  |
1.14487540                                                                  |
 *                                                                          |
 *                                                                          |
-----------                                                                 |
1.17402576                                                                  |
1.16771923                                                                  |
1.16195281                                                                  |
1.15665041                                                                  |
 *                                                                          |
-----------                                                                 |
*                                                                           |
*                                                                           |
*                                                                           |
*                                                                           |
*                                                                           |
@@@@@@@@@@@                                                                 |
0.64345                                                                     |
0.67619                                                                     |
0.70959                                                                     |
 *                                                                          |
 *                                                                          |
-----------                                                                 |
0.63294                                                                     |
0.66638                                                                     |
0.69918                                                                     |
0.76297                                                                     |
 *                                                                          |
-----------                                                                 |
0.61538                                                                     |
0.64790                                                                     |
0.67985                                                                     |
0.71127                                                                     |
0.74217                                                                     |
===========                                                                 |
0.57010                                                                     |
0.59831                                                                     |
0.62703                                                                     |
 *                                                                          |
 *                                                                          |
-----------                                                                 |
0.56928                                                                     |
0.59875                                                                     |
0.62760                                                                     |
0.65588                                                                     |
 *                                                                          |
-----------                                                                 |
*                                                                           |
*                                                                           |
*                                                                           |
*                                                                           |
*                                                                           |
                                                                            /

In this vector representation the different composition subtable
columns are separated by '----', the different main tables are
separated by '======' and the columns are separated by '@@@@'. Default
values (2e20) are denoted with '*'.

*/
public static final int TABDIMS_SIZE =                100;

public static final int TABDIMS_TAB_SIZE_ITEM =       0;

public static final int TABDIMS_IBROCK_OFFSET_ITEM =  1;
public static final int TABDIMS_NTROCK_ITEM =         2;

public static final int TABDIMS_IBROCC_OFFSET_ITEM =  3;
public static final int TABDIMS_NPROCC_ITEM =         4;

public static final int TABDIMS_IBPVTO_OFFSET_ITEM =  6;
public static final int TABDIMS_JBPVTO_OFFSET_ITEM =  7;
public static final int TABDIMS_NRPVTO_ITEM =         8;
public static final int TABDIMS_NPPVTO_ITEM =         9;
public static final int TABDIMS_NTPVTO_ITEM =        10;

public static final int TABDIMS_IBPVTW_OFFSET_ITEM = 11;
public static final int TABDIMS_NTPVTW_ITEM =        12;

public static final int TABDIMS_IBPVTG_OFFSET_ITEM = 13;
public static final int TABDIMS_JBPVTG_OFFSET_ITEM = 14;
public static final int TABDIMS_NRPVTG_ITEM =        15;
public static final int TABDIMS_NPPVTG_ITEM =        16;
public static final int TABDIMS_NTPVTG_ITEM =        17;

public static final int TABDIMS_IBDENS_OFFSET_ITEM = 18;
public static final int TABDIMS_NTDENS_ITEM =        19;

public static final int TABDIMS_IBSWFN_OFFSET_ITEM = 20;
public static final int TABDIMS_NSSWFN_ITEM =        21;
public static final int TABDIMS_NTSWFN_ITEM =        22;

public static final int TABDIMS_IBSGFN_OFFSET_ITEM = 23;
public static final int TABDIMS_NSSGFN_ITEM =        24;
public static final int TABDIMS_NTSGFN_ITEM =        25;

public static final int TABDIMS_IBSOFN_OFFSET_ITEM = 26;
public static final int TABDIMS_IBSWCO_OFFSET_ITEM = 27;
public static final int TABDIMS_NSSOFN_ITEM =        28;
public static final int TABDIMS_NTSOFN_ITEM =        29;

public static final int TABDIMS_IBVETB_OFFSET_ITEM = 40;
public static final int TABDIMS_NSVETB_ITEM =        41;
public static final int TABDIMS_NTVETB_ITEM =        42;

public static final int TABDIMS_IBTHPR_OFFSET_ITEM = 43;
public static final int TABDIMS_IBSLIM_ITEM =        44;
public static final int TABDIMS_NSENDP_ITEM =        45;
public static final int TABDIMS_NTENDP_ITEM =        46;

public static final int TABDIMS_IBRTEM_OFFSET_ITEM = 47;
public static final int TABDIMS_IBCTOL_ITEM =        48;

public static final int TABDIMS_IBLANG_OFFSET_ITEM = 50;     // LANGMUIR Table
public static final int TABDIMS_NCLANG_ITEM =        51;     // LANGMUIR Table
public static final int TABDIMS_NSLANG_ITEM =        52;     // LANGMUIR Table
public static final int TABDIMS_NTLANG_ITEM =        53;     // LANGMUIR Table

public static final int TABDIMS_IBLNG2_OFFSET_ITEM = 54;     // LANGSOLV Table
public static final int TABDIMS_IBCADP_OFFSET_ITEM = 55;     // COALPP Table
public static final int TABDIMS_IBCADS_OFFSET_ITEM = 56;     // COALADS Table
public static final int TABDIMS_IBROCP_OFFSET_ITEM = 57;     // ROCKPAMA Table
public static final int TABDIMS_NTRPMA_ITEM =        58;     // ROCKPAMA Table


/*
   Observe that many of the elements in the INTEHEAD keyword is shared
   between the restart and init files. The ones listed below here are
   in both the INIT and the restart files. In addition the restart
   files have many well related items which are only in the restart
   files.
*/


public static final int INTEHEAD_UNIT_INDEX =      2;
public static final int INTEHEAD_NX_INDEX =        8;
public static final int INTEHEAD_NY_INDEX =        9;
public static final int INTEHEAD_NZ_INDEX =       10;
public static final int INTEHEAD_NACTIVE_INDEX =  11;
public static final int INTEHEAD_PHASE_INDEX =    14;
public static final int INTEHEAD_DAY_INDEX =      64;
public static final int INTEHEAD_MONTH_INDEX =    65;
public static final int INTEHEAD_YEAR_INDEX =     66;
public static final int INTEHEAD_TIMESTEP_INDEX = 67;
public static final int INTEHEAD_REPORT_STEP =    68;
public static final int INTEHEAD_IPROG_INDEX =    94;

// The value seems to be: report_step - 1; might be previous?
public static final int INTEHEAD_REPORT_INDEX =   219;


public static final int INTEHEAD_METRIC_VALUE =              1;
public static final int INTEHEAD_ECLIPSE100_VALUE =        100;
public static final int INTEHEAD_ECLIPSE300_VALUE =        300;
public static final int INTEHEAD_ECLIPSE300THERMAL_VALUE = 500;
public static final int INTEHEAD_INTERSECT_VALUE =         700;
public static final int INTEHEAD_FRONTSIM_VALUE =          800;

public static final int INTEHEAD_INIT_SIZE =                95;
public static final int INTEHEAD_RESTART_SIZE =             180;

public static final int LOGIHEAD_ECLIPSE300_RADIAL_INDEX =   3;
public static final int LOGIHEAD_ECLIPSE100_RADIAL_INDEX =   4;
public static final int LOGIHEAD_DUALP_INDEX =              14;
public static final int LOGIHEAD_INIT_SIZE =                80;
public static final int LOGIHEAD_RESTART_SIZE =             15;


public static final int LOGIHEAD_RS_INDEX =                           0;
public static final int LOGIHEAD_RV_INDEX =                           1;
public static final int LOGIHEAD_DIR_RELPERM_INDEX =                  2;
/*-----------------------------------------------------------------*/
public static final int LOGIHEAD_REV_RELPERM100_INDEX =               3;   /* The indices for reversible relperm and */
public static final int LOGIHEAD_RADIAL100_INDEX =                    4;   /* use of radial grids is interchanged between */
public static final int LOGIHEAD_REV_RELPERM300_INDEX =               4;   /* ECLIPSE100 and ECLIPSE300. */
public static final int LOGIHEAD_RADIAL300_INDEX =                    3;
/*-----------------------------------------------------------------*/
public static final int LOGIHEAD_HYSTERISIS_INDEX =                   6;
public static final int LOGIHEAD_ENDPOINT_SCALING_INDEX =            16;
public static final int LOGIHEAD_DIR_ENDPOINT_SCALING_INDEX =        17;
public static final int LOGIHEAD_REV_ENDPOINT_SCALING_INDEX =        18;
public static final int LOGIHEAD_ALT_ENDPOINT_SCALING_INDEX =        19;
public static final int LOGIHEAD_MISC_DISPLACEMENT_INDEX =           35;
public static final int LOGIHEAD_CONSTANT_OILCOMPR_INDEX =          (39-1); /* Constant oil compressibility (PVCDO)? */
public static final int LOGIHEAD_SCALE_WATER_PC_AT_MAX_SAT_INDEX =   55;
public static final int LOGIHEAD_SCALE_GAS_PC_AT_MAX_SAT_INDEX =     56;




public static final int DOUBHEAD_INIT_SIZE =                 1;
public static final int DOUBHEAD_RESTART_SIZE =              1;


/*****************************************************************/
/*                RESTART files:                                 */
/*****************************************************************/

public static final String SEQNUM_KW =    "SEQNUM";       /* Contains the report step as the only data; not
                                       present in non-unified files, where the report
                                       step must be inferred from the filename. */
public static final String STARTSOL_KW =  "STARTSOL";
public static final String ENDSOL_KW =    "ENDSOL";

public static final String XWEL_KW =      "XWEL";
public static final String IWEL_KW =      "IWEL";
public static final String ZWEL_KW =      "ZWEL";
public static final String ICON_KW =      "ICON";
public static final String SCON_KW =      "SCON";
public static final String XCON_KW =      "XCON";
public static final String ISEG_KW =      "ISEG";
public static final String RSEG_KW =      "RSEG";

public static final String ECLIPSE100_OIL_DEN_KW =   "OIL_DEN";
public static final String ECLIPSE100_GAS_DEN_KW =   "GAS_DEN";
public static final String ECLIPSE100_WATER_DEN_KW = "WAT_DEN";

public static final String ECLIPSE300_OIL_DEN_KW =   "DENO";
public static final String ECLIPSE300_GAS_DEN_KW =   "DENG";
public static final String ECLIPSE300_WATER_DEN_KW = "DENW";

public static final String FIPGAS_KW =               "FIPGAS";
public static final String FIPWAT_KW =               "FIPWAT";
public static final String FIPOIL_KW =               "FIPOIL";
public static final String RFIPGAS_KW =              "RFIPGAS";
public static final String RFIPWAT_KW =              "RFIPWAT";
public static final String RFIPOIL_KW =              "RFIPOIL";

public static final String FLRWATNNC_KW =             "FLRWATN+"; //nnc wtr flux, grid1 == grid2
public static final String FLROILNNC_KW =             "FLROILN+"; //nnc oil flux, grid1 == grid2
public static final String FLRGASNNC_KW =             "FLRGASN+"; //nnc gas flux, grid1 == grid2

public static final String FLRWATLG_KW =              "FLRWATL+"; //nnc wtr flux, grid1 == 0, grid != 0
public static final String FLROILLG_KW =              "FLROILL+"; //nnc oil flux, grid1 == 0, grid != 0
public static final String FLRGASLG_KW =              "FLRGASL+"; //nnc gas flux, grid1 == 0, grid != 0

public static final String FLRWATLL_KW =              "FLRWATA+"; //nnc wtr flux, grid1 != 0, grid2 != 0, grid1 != grid2
public static final String FLROILLL_KW =              "FLROILA+"; //nnc oil flux, grid1 != 0, grid2 != 0, grid1 != grid2
public static final String FLRGASLL_KW =              "FLRGASA+"; //nnc gas flux, grid1 != 0, grid2 != 0, grid1 != grid2

public static final int INTEHEAD_NWELLS_INDEX =  16;     // Number of wells
public static final int INTEHEAD_NIWELZ_INDEX =  24;     // Number of elements pr. well in the IWEL array.
public static final int INTEHEAD_NXWELZ_INDEX =  26;     // Number of elements pr. well in the XWEL array.
public static final int INTEHEAD_NZWELZ_INDEX =  27;     // Number of 8 character words pr. well

public static final int INTEHEAD_NCWMAX_INDEX =  17;     // Maximum number of completions per well
public static final int INTEHEAD_NWGMAX_INDEX =  19;     // Maximum number of wells in any group
public static final int INTEHEAD_NGMAXZ_INDEX =  20;     // Maximum number of groups in field
public static final int INTEHEAD_NSWELZ_INDEX =  25;

public static final int INTEHEAD_NICONZ_INDEX =  32;     // Number of elements pr completion in the ICON array.
public static final int INTEHEAD_NSCONZ_INDEX =  33;     // Number of elements pr completion in the SCON array
public static final int INTEHEAD_NXCONZ_INDEX =  34;     // Number of elements pr completion in the XCON array
public static final int INTEHEAD_NIGRPZ_INDEX =  36;     // Number of elements pr group in the IGRP array.


public static final int INTEHEAD_NSWLMX_INDEX =  175;
public static final int INTEHEAD_NSEGMX_INDEX =  176;
public static final int INTEHEAD_NLBRMX_INDEX =  177;
public static final int INTEHEAD_NISEGZ_INDEX =  178;
public static final int INTEHEAD_NRSEGZ_INDEX =  179;
public static final int INTEHEAD_NILBRZ_INDEX =  180;

public static final int DOUBHEAD_DAYS_INDEX = 0;

/*****************************************************************/
/*                     Summary files                             */
/*****************************************************************/

/* Summary header file */
public static final String MINISTEP_KW =  "MINISTEP";
public static final String STARTDAT_KW =  "STARTDAT";   /* Intgere keyword containing day,month,year. */
public static final String WGNAMES_KW =   "WGNAMES";    /* The names of wells/groups for the summary vectors. */
public static final String NAMES_KW =     "NAMES";      /* Alias for WGNAMES_KW. */
public static final String KEYWORDS_KW =  "KEYWORDS";   /* The variable type for the various summary vectors. */
public static final String UNITS_KW =     "UNITS";      /* The units, i.e SM^3/DAY the summary vectors. */
public static final String DIMENS_KW =    "DIMENS";     /* The dimensions of the grid - also used in the GRID files. */
public static final String NUMS_KW =      "NUMS";       /* Extra numeric qualifiers for the summary variables, like cell number. */
public static final String LGRS_KW =      "LGRS";       /* The lgr name for a vector originating from an lgr. */
public static final String NUMLX_KW =     "NUMLX";      /* For block variables defined in a an lgr this is i coordinate in the lgr. */
public static final String NUMLY_KW =     "NUMLY";      /* ... j coordinate in the lgr. */
public static final String NUMLZ_KW =     "NUMLZ";      /* ... k coordinate in the lgr. */


/* Magic indices used to locate day,month,year from the STARTDAT keyword. */
public static final int STARTDAT_DAY_INDEX =          0;
public static final int STARTDAT_MONTH_INDEX =        1;
public static final int STARTDAT_YEAR_INDEX =         2;
public static final int STARTDAT_HOUR_INDEX =         3;
public static final int STARTDAT_MINUTE_INDEX =       4;
public static final int STARTDAT_MICRO_SECOND_INDEX = 5;
public static final int STARTDAT_SIZE =               6;


/* Magic indices uset to locate the grid dimensions from the DIMENS
   keyword in the SMSPEC files. Observe that these magic indices
   differ from the magic indices used to look up grid dimensions from
   the DIMENS keyword in GRID files.  */
public static final int DIMENS_SMSPEC_SIZE_INDEX =           0;
public static final int DIMENS_SMSPEC_NX_INDEX =             1;
public static final int DIMENS_SMSPEC_NY_INDEX =             2;
public static final int DIMENS_SMSPEC_NZ_INDEX =             3;
public static final int DIMENS_SMSPEC_RESTART_STEP_INDEX =   5;
public static final int DIMENS_SIZE =                        6;

public static final int INTEHEAD_SMSPEC_SIZE =        2;
public static final int INTEHEAD_SMSPEC_UNIT_INDEX =  0;
public static final int INTEHEAD_SMSPEC_IPROG_INDEX = 1;


/* Summary data files: */
public static final String SEQHDR_KW =    "SEQHDR";      // Contains a single 'magic' integer - not used in libecl.
public static final String PARAMS_KW =    "PARAMS";      // Contains the actual summary data for one timestep.    // Scalar integer - contains the timestep number.

public static final int SEQHDR_SIZE =  1;

public static final String RESTART_KW =    "RESTART";
public static final int SUMMARY_RESTART_SIZE = 8;

/*
   There are no magic indices in the summary data files, for all
   interesting data the table created from the ecl_smspec file must be
   consulted.
*/


/*****************************************************************/
/*                        RFT Files                              */
/*****************************************************************/
/* The files with extension .RFT can contain three quite different
   types of information: RFT / PLT / SEGMENT, this is indicated by an
   element of the WELLETC keyword. The keywords below are organized in
   common keywords, keywords for RFTs and keywords for PLTs. The
   special information for SEGMENT data is not internalized at all,
   and there are also several additional keywords for the PLTs which
   are not internalized. */


/* Common keywords */
public static final String TIME_KW =      "TIME";     /* The days since simulation start when
                                   an RFT is performed, also used as
                                   block header when splitting an RFT
                                   file into different wells and timesteps. */
public static final String DATE_KW =      "DATE";     /* The date of an RFT as integers: (day,month,year). */
public static final String WELLETC_KW =   "WELLETC";  /* The type of date RFT|PLT|SEGMENT and well name are
                                   extracted from this keyword. */
public static final String CONIPOS_KW =   "CONIPOS";  /* The i-index of the connections in the well. */
public static final String CONJPOS_KW =   "CONJPOS";  /* The j-index ... */
public static final String CONKPOS_KW =   "CONKPOS";  /* The k-index ... */
public static final String HOSTGRID_KW =  "HOSTGRID";

/* RFT keywords */
public static final String SWAT_KW =      "SWAT";     /* The kewyord containing SWAT. */
public static final String SGAS_KW =      "SGAS";     /* The kewyord containing SGAS. */
public static final String PRESSURE_KW =  "PRESSURE"; /* The kewyord containing PRESSURE. */
public static final String DEPTH_KW =     "DEPTH";    /* The depth of the connection. */

/* PLT keywords */
public static final String CONDEPTH_KW =  "CONDEPTH"; /* The depth of the connection. */
public static final String CONWRAT_KW =   "CONWRAT";  /* Water rate in a connection. */
public static final String CONGRAT_KW =   "CONGRAT";  /* Gas ... */
public static final String CONORAT_KW =   "CONORAT";  /* Oil ... */
public static final String CONPRES_KW =   "CONPRES";  /* Pressure ... */
public static final String CONLENST_KW =  "CONLENST"; /* Length along MSW well */
public static final String CONLENEN_KW =  "CONLENEN"; /* Length to connection end for MSW well */
public static final String CONVTUB_KW =   "CONVTUB";  /* Volumetric flow at tubing head conditions. */
public static final String CONOTUB_KW =   "CONOTUB";  /* Volumetric oil flow at tubing head conditions. */
public static final String CONGTUB_KW =   "CONGTUB";  /* Volumetric gas flow at tubing head conditions. */
public static final String CONWTUB_KW =   "CONWTUB";  /* Volumetric water flow at tubing head conditions. */


public static final int WELLETC_TYPE_INDEX =  5; /* At this keyword the WELLETC keyword contains a string
                                 containing 'R', 'P' , or 'S' for RFT, PLT or SEGMENT data
                                 respectively.*/
public static final int WELLETC_NAME_INDEX =  1; /* The name of well being investigated is on this index of
                                 the WELLETC keyword. */

/* Magic indices used to get day,month,year from the DATE
   keyword. */
public static final int DATE_DAY_INDEX =   0;
public static final int DATE_MONTH_INDEX = 1;
public static final int DATE_YEAR_INDEX =  2;


/*****************************************************************/
/*                     GRID and EGRID files.                     */
/*****************************************************************/
/* GRID and EGRID files have very different structure, and only a few
   keywords are shared. */


/* Common keywords */
public static final String SPECGRID_KW =    "SPECGRID";
public static final int SPECGRID_NX_INDEX =  0;
public static final int SPECGRID_NY_INDEX =  1;
public static final int SPECGRID_NZ_INDEX =  2;
public static final String MAPAXES_KW =     "MAPAXES";    /* Keyword used to transform from grid coordinates to
                                       world coordinates. */
public static final String LGR_KW =         "LGR";        /* Name of LGR; for GRID files it can contain two elements,
                                       the second element will be the name of the parent. */
public static final String MAPUNITS_KW =    "MAPUNITS";
public static final String GRIDUNIT_KW =    "GRIDUNIT";

public static final String NNC1_KW =        "NNC1";      /*Upstream cell numbers for non-neighbour connections*/
public static final String NNC2_KW =        "NNC2";      /*Downstream cell numbers for non-neighbour connections*/
public static final String NNCL_KW =        "NNCL";      /*Cell numbers for LGR cells that are connected to global grid cells*/
public static final String NNCG_KW =        "NNCG";      /*Cell numbers for global cells connected to LGR cells*/

public static final String NNCHEAD_KW =     "NNCHEAD";   /*Non-neighbour connection header*/
public static final int NNCHEAD_SIZE =        10;
public static final int NNCHEAD_NUMNNC_INDEX =  0;    /*Item 1 in non-neighbour connection header: number of NNCs. Only present for main grid*/
public static final int NNCHEAD_LGR_INDEX =     1;    /*Item 2 in non-neighbour connection header: LGR number (0 for global grid)*/

public static final String NNCHEADA_KW =    "NNCHEADA";  /*Header for NNC's between two amalgamated LGRs*/
public static final String NNA1_KW =        "NNA1";      /*Cell numbers in connecting local grid ILOC1*/
public static final String NNA2_KW =        "NNA2";      /*Cell numbers in connecting local grid ILOC2*/
public static final int NNCHEADA_ILOC1_INDEX = 0;     /*ILOC1: Index of first LGR*/
public static final int NNCHEADA_ILOC2_INDEX = 1;     /*ILOC2: Index of second LGR*/
public static final int NNA_NUMNNC_INDEX =     0;     /*Item 1 in NNA1 or NNA2 is number of NNCs*/

public static final String TRANNNC_KW =     "TRANNNC";
public static final String TRANGL_KW =      "TRANGL";
public static final String TRANLL_KW =      "TRANLL";

/* EGRID keywords */
public static final String LGR_PARENT_KW =  "LGRPARNT";   /* The name of the parent for an LGR. */
public static final String COORDS_KW =      "COORDS";     /* The (x,y) coordinates of the top and bottom of the pillars constituting the grid. */
public static final String ZCORN_KW =       "ZCORN";      /* Z coordinate where pillars cross planes. */
public static final String ACTNUM_KW =      "ACTNUM";     /* Integer flag of with active=0,1. */
public static final String HOSTNUM_KW =     "HOSTNUM";    /* For cells in LGR - pointing back to cell nr in
                                       parent grid. */
public static final String FILEHEAD_KW =    "FILEHEAD";
public static final String ENDGRID_KW =     "ENDGRID";
public static final String ENDLGR_KW =      "ENDLGR";
public static final String CORSNUM_KW =     "CORSNUM";

/* GRID keywords */
public static final String GRIDHEAD_KW =    "GRIDHEAD";   /* Header information for GRID files. */
public static final String COORD_KW =       "COORD";      /* Header information for one cell in GRID file. */
public static final String CORNERS_KW =     "CORNERS";    /* Vector containing (x,y,z) x 8 elements - all corners in a cell. */     /* The dimensions of the grid. */
public static final String RADIAL_KW =      "RADIAL";

public static final String GLOBAL_STRING =  "GLOBAL";

public static final int GRIDHEAD_TYPE_INDEX =    0;
public static final int GRIDHEAD_NX_INDEX =      1;
public static final int GRIDHEAD_NY_INDEX =      2;
public static final int GRIDHEAD_NZ_INDEX =      3;
public static final int GRIDHEAD_LGR_INDEX =     4;
public static final int GRIDHEAD_NUMRES_INDEX = 24;
public static final int GRIDHEAD_SIZE =        100;

/* Observe that these indices are one value lower than the values used
   in the ecl_smspec file. */
public static final int DIMENS_NX_INDEX =     0;
public static final int DIMENS_NY_INDEX =     1;
public static final int DIMENS_NZ_INDEX =     2;

public static final int FILEHEAD_VERSION_INDEX =   0;
public static final int FILEHEAD_YEAR_INDEX =      1;
public static final int FILEHEAD_COMPAT_INDEX =    3;
public static final int FILEHEAD_TYPE_INDEX =      4;
public static final int FILEHEAD_DUALP_INDEX =     5;
public static final int FILEHEAD_ORGFORMAT_INDEX = 6;

public static final int GRIDHEAD_GRIDTYPE_CORNERPOINT = 1;
public static final int FILEHEAD_GRIDTYPE_CORNERPOINT = 0;

public static final int FILEHEAD_ORGTYPE_CORNERPOINT =  1;
public static final int FILEHEAD_SINGLE_POROSITY =      0;
public static final int FILEHEAD_DUAL_POROSITY =        1;
public static final int FILEHEAD_DUAL_PERMEABILITY =    2;


public static final int CELL_NOT_ACTIVE =          0;
public static final int CELL_ACTIVE_MATRIX =       1;
public static final int CELL_ACTIVE =              CELL_ACTIVE_MATRIX;
public static final int CELL_ACTIVE_FRACTURE =     2;



// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_kw_magic.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_kw_magic.hpp>




// Parsed from ert/ecl/ecl_kw_grdecl.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_kw_grdecl.hpp>




// Parsed from ert/ecl/ecl_kw.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_kw.hpp>




// Parsed from ert/ecl/ecl_io_config.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_io_config.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_IO_CONFIG_H
// #define ERT_ECL_IO_CONFIG_H
// #ifdef __cplusplus
// Targeting ../ecl_io_config_type.java



/* Modifiers */
public static native void ecl_io_config_set_formatted(ecl_io_config_type arg0, @Cast("bool") boolean arg1 );
public static native void ecl_io_config_set_unified_restart(ecl_io_config_type arg0, @Cast("bool") boolean arg1 );
public static native void ecl_io_config_set_unified_summary(ecl_io_config_type arg0, @Cast("bool") boolean arg1 );


/* Accesors */
public static native @Cast("bool") boolean ecl_io_config_get_formatted(ecl_io_config_type arg0);
public static native @Cast("bool") boolean ecl_io_config_get_unified_restart(ecl_io_config_type arg0);
public static native @Cast("bool") boolean ecl_io_config_get_unified_summary(ecl_io_config_type arg0);


/* Allocater & destructor */
public static native ecl_io_config_type ecl_io_config_alloc(@Cast("bool") boolean arg0,@Cast("bool") boolean arg1,@Cast("bool") boolean arg2);
public static native void ecl_io_config_free(ecl_io_config_type arg0 );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_io_config.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_io_config.hpp>




// Parsed from ert/ecl/ecl_init_file.hpp

/*
   Copyright (C) 2012 Equinor ASA, Norway.

   The file 'ecl_init_file.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_INIT_FILE_H
// #define ERT_ECL_INIT_FILE_H

// #include <time.h>

// #include <ert/ecl/fortio.h>
// #include <ert/ecl/ecl_kw.hpp>
// #include <ert/ecl/ecl_grid.hpp>
// #include <ert/ecl/ecl_util.hpp>

// #ifdef __cplusplus
// #endif

  public static native void ecl_init_file_fwrite_header( fortio_type fortio, @Const ecl_grid_type grid, @Const ecl_kw_type poro, @Cast("ert_ecl_unit_enum") int unit_system, int phases, @ByVal @Cast("time_t*") Pointer start_date);


// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_init_file.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_init_file.hpp>




// Parsed from ert/ecl/ecl_grid_dims.hpp

/*
   Copyright (C) 2013  Equinor ASA, Norway.

   The file 'ecl_grid_dims.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_GRID_DIMS_H
// #define ERT_ECL_GRID_DIMS_H
// #ifdef __cplusplus
// #endif

// #include <ert/ecl/grid_dims.hpp>
// Targeting ../ecl_grid_dims_type.java



  public static native ecl_grid_dims_type ecl_grid_dims_alloc( @Cast("const char*") BytePointer grid_file, @Cast("const char*") BytePointer data_file);
  public static native ecl_grid_dims_type ecl_grid_dims_alloc( String grid_file, String data_file);
  public static native void ecl_grid_dims_free( ecl_grid_dims_type grid_dims );
  public static native int ecl_grid_dims_get_num_grids( @Const ecl_grid_dims_type grid_dims);
  public static native @Const grid_dims_type ecl_grid_dims_iget_dims( @Const ecl_grid_dims_type grid_dims, int grid_nr );

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_grid_dims.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_grid_dims.hpp>




// Parsed from ert/ecl/ecl_grid.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_grid.hpp>




// Parsed from detail/ecl/ecl_grid_cache.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_grid_cache.h' is part of ERT - Ensemble based
   Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_GRID_CACHE_H
// #define ERT_ECL_GRID_CACHE_H

// #include <vector>

// #include <ert/ecl/ecl_grid.hpp>
// Targeting ../ecl_grid_cache.java




// #endif


// Parsed from ert/ecl/ecl_grav_common.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_grav_common.h' is part of ERT - Ensemble based
   Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_GRAV_COMMON_H
// #define ERT_ECL_GRAV_COMMON_H

// #include <stdbool.h>

// #include <ert/ecl/ecl_file.hpp>
// #include "detail/ecl/ecl_grid_cache.hpp"

// #ifdef __cplusplus
// #endif

  public static native @Cast("bool*") BoolPointer ecl_grav_common_alloc_aquifer_cell(@Const @ByRef ecl_grid_cache grid_cache,
                                              @Const ecl_file_type init_file);

  public static native double ecl_grav_common_eval_biot_savart(@Const @ByRef ecl_grid_cache grid_cache,
                                            ecl_region_type region,
                                            @Cast("const bool*") BoolPointer aquifer,
                                            @Const DoublePointer weight,
                                            double utm_x,
                                            double utm_y,
                                            double depth);
  public static native double ecl_grav_common_eval_biot_savart(@Const @ByRef ecl_grid_cache grid_cache,
                                            ecl_region_type region,
                                            @Cast("const bool*") boolean[] aquifer,
                                            @Const DoubleBuffer weight,
                                            double utm_x,
                                            double utm_y,
                                            double depth);
  public static native double ecl_grav_common_eval_biot_savart(@Const @ByRef ecl_grid_cache grid_cache,
                                            ecl_region_type region,
                                            @Cast("const bool*") BoolPointer aquifer,
                                            @Const double[] weight,
                                            double utm_x,
                                            double utm_y,
                                            double depth);
  public static native double ecl_grav_common_eval_biot_savart(@Const @ByRef ecl_grid_cache grid_cache,
                                            ecl_region_type region,
                                            @Cast("const bool*") boolean[] aquifer,
                                            @Const DoublePointer weight,
                                            double utm_x,
                                            double utm_y,
                                            double depth);
  public static native double ecl_grav_common_eval_biot_savart(@Const @ByRef ecl_grid_cache grid_cache,
                                            ecl_region_type region,
                                            @Cast("const bool*") BoolPointer aquifer,
                                            @Const DoubleBuffer weight,
                                            double utm_x,
                                            double utm_y,
                                            double depth);
  public static native double ecl_grav_common_eval_biot_savart(@Const @ByRef ecl_grid_cache grid_cache,
                                            ecl_region_type region,
                                            @Cast("const bool*") boolean[] aquifer,
                                            @Const double[] weight,
                                            double utm_x,
                                            double utm_y,
                                            double depth);

  public static native double ecl_grav_common_eval_geertsma(@Const @ByRef ecl_grid_cache grid_cache,
                                         ecl_region_type region,
                                         @Cast("const bool*") BoolPointer aquifer,
                                         @Const DoublePointer weight,
                                         double utm_x,
                                         double utm_y,
                                         double depth,
                                         double poisson_ratio,
                                         double seabed);
  public static native double ecl_grav_common_eval_geertsma(@Const @ByRef ecl_grid_cache grid_cache,
                                         ecl_region_type region,
                                         @Cast("const bool*") boolean[] aquifer,
                                         @Const DoubleBuffer weight,
                                         double utm_x,
                                         double utm_y,
                                         double depth,
                                         double poisson_ratio,
                                         double seabed);
  public static native double ecl_grav_common_eval_geertsma(@Const @ByRef ecl_grid_cache grid_cache,
                                         ecl_region_type region,
                                         @Cast("const bool*") BoolPointer aquifer,
                                         @Const double[] weight,
                                         double utm_x,
                                         double utm_y,
                                         double depth,
                                         double poisson_ratio,
                                         double seabed);
  public static native double ecl_grav_common_eval_geertsma(@Const @ByRef ecl_grid_cache grid_cache,
                                         ecl_region_type region,
                                         @Cast("const bool*") boolean[] aquifer,
                                         @Const DoublePointer weight,
                                         double utm_x,
                                         double utm_y,
                                         double depth,
                                         double poisson_ratio,
                                         double seabed);
  public static native double ecl_grav_common_eval_geertsma(@Const @ByRef ecl_grid_cache grid_cache,
                                         ecl_region_type region,
                                         @Cast("const bool*") BoolPointer aquifer,
                                         @Const DoubleBuffer weight,
                                         double utm_x,
                                         double utm_y,
                                         double depth,
                                         double poisson_ratio,
                                         double seabed);
  public static native double ecl_grav_common_eval_geertsma(@Const @ByRef ecl_grid_cache grid_cache,
                                         ecl_region_type region,
                                         @Cast("const bool*") boolean[] aquifer,
                                         @Const double[] weight,
                                         double utm_x,
                                         double utm_y,
                                         double depth,
                                         double poisson_ratio,
                                         double seabed);

// #ifdef __cplusplus

// #endif
// #endif


// Parsed from ert/ecl/ecl_grav_common.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_grav_common.hpp>




// Parsed from ert/ecl/ecl_file.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_file.hpp>




// Parsed from ert/ecl/ecl_grav_calc.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_grav.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef  ERT_ECL_GRAV_CALC_H
// #define  ERT_ECL_GRAV_CALC_H
// #ifdef __cplusplus
// #endif

// #include <ert/ecl/ecl_kw.h>
// #include <ert/ecl/ecl_grid.h>
// #include <ert/ecl/ecl_file.h>

public static native double ecl_grav_phase_deltag( double utm_x,
                              double utm_y,
                              double tvd,
                              @Const ecl_grid_type grid,
                              @Const ecl_file_type init_file,
                              @Const ecl_kw_type sat_kw1,
                              @Const ecl_kw_type rho_kw1,
                              @Const ecl_kw_type porv_kw1,
                              @Const ecl_kw_type sat_kw2,
                              @Const ecl_kw_type rho_kw2,
                              @Const ecl_kw_type porv_kw2);



// #ifdef __cplusplus
// #endif
// #endif



// Parsed from ert/ecl/ecl_grav_calc.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_grav_calc.hpp>




// Parsed from ert/ecl/ecl_grav.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   This file is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_GRAV_H
// #define ERT_ECL_GRAV_H

// #include <ert/ecl/ecl_file.hpp>
// #include <ert/ecl/ecl_file_view.hpp>
// #include <ert/ecl/ecl_grid.hpp>
// #include <ert/ecl/ecl_region.hpp>

// #ifdef __cplusplus
// Targeting ../ecl_grav_type.java


// Targeting ../ecl_grav_survey_type.java




public static native void ecl_grav_free( ecl_grav_type ecl_grav_config );
public static native ecl_grav_type ecl_grav_alloc( @Const ecl_grid_type ecl_grid, @Const ecl_file_type init_file );
public static native ecl_grav_survey_type ecl_grav_add_survey_FIP( ecl_grav_type grav, @Cast("const char*") BytePointer name, @Const ecl_file_view_type restart_file );
public static native ecl_grav_survey_type ecl_grav_add_survey_FIP( ecl_grav_type grav, String name, @Const ecl_file_view_type restart_file );
public static native ecl_grav_survey_type ecl_grav_add_survey_PORMOD( ecl_grav_type grav, @Cast("const char*") BytePointer name, @Const ecl_file_view_type restart_file );
public static native ecl_grav_survey_type ecl_grav_add_survey_PORMOD( ecl_grav_type grav, String name, @Const ecl_file_view_type restart_file );
public static native ecl_grav_survey_type ecl_grav_add_survey_RPORV( ecl_grav_type grav, @Cast("const char*") BytePointer name, @Const ecl_file_view_type restart_file );
public static native ecl_grav_survey_type ecl_grav_add_survey_RPORV( ecl_grav_type grav, String name, @Const ecl_file_view_type restart_file );
public static native ecl_grav_survey_type ecl_grav_add_survey_RFIP( ecl_grav_type grav, @Cast("const char*") BytePointer name, @Const ecl_file_view_type restart_file );
public static native ecl_grav_survey_type ecl_grav_add_survey_RFIP( ecl_grav_type grav, String name, @Const ecl_file_view_type restart_file );
public static native double ecl_grav_eval( @Const ecl_grav_type grav, @Cast("const char*") BytePointer base, @Cast("const char*") BytePointer monitor, ecl_region_type region, double utm_x, double utm_y, double depth, int phase_mask);
public static native double ecl_grav_eval( @Const ecl_grav_type grav, String base, String monitor, ecl_region_type region, double utm_x, double utm_y, double depth, int phase_mask);
public static native void ecl_grav_new_std_density( ecl_grav_type grav, @Cast("ecl_phase_enum") int phase, double default_density);
public static native void ecl_grav_add_std_density( ecl_grav_type grav, @Cast("ecl_phase_enum") int phase, int pvtnum, double density);

// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_grav.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_grav.hpp>




// Parsed from ert/ecl/ecl_file_view.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_file_view.hpp>




// Parsed from ert/ecl/ecl_file_kw.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_file_kw.hpp>




// Parsed from ert/ecl/ecl_endian_flip.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_endian_flip.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_ENDIAN_FLIP_H
// #define ERT_ECL_ENDIAN_FLIP_H
// #ifdef __cplusplus
// #endif

// #include <stdbool.h>

/**
   This header file checks if the ECLIPSE endianness and the hardware
   endianness are equal, and defines the macro ECL_ENDIAN_FLIP
   accordingly.
   <p>
   All the ecl_xxx functions will use the ECL_ENDIAN_FLIP macro to
   determine whether the endian flip should be performed. When opening
   a fortio instance explicitly you can use the ECL_ENDIAN_FLIP macro
   to get the endianness correct (for ECLIPSE usage that is).
*/

public static final int __LITTLE_ENDIAN = 1234;
public static final int __BIG_ENDIAN = 4321;
public static final int ECLIPSE_BYTE_ORDER = __BIG_ENDIAN;   // Alternatively: __LITTLE_ENDIAN

// #ifdef BYTE_ORDER
//   #if  BYTE_ORDER == ECLIPSE_BYTE_ORDER
    public static final int ECL_ENDIAN_FLIP =FALSE;
//   #else
//   #endif
// #else
//   #ifdef WIN32    // Unconditional byte flip on Windows.
//   #else
//     #error: The macro BYTE_ORDER is not defined?
//   #endif
// #endif

// #undef ECLIPSE_BYTE_ORDER


// #ifdef __cplusplus
// #endif
// #endif


// Parsed from ert/ecl/ecl_endian_flip.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_endian_flip.hpp>




// Parsed from ert/ecl/ecl_coarse_cell.h

/*
  Warning: The libecl code has changed to be compiled as a C++ project. This
  header file is retained for a period for compatibility, but you are encouraged
  to switch to include the new hpp header directly in your code.
*/

// #include <ert/ecl/ecl_coarse_cell.hpp>




// Parsed from ert/ecl/ecl_box.hpp

/*
   Copyright (C) 2011  Equinor ASA, Norway.

   The file 'ecl_box.h' is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_BOX_H
// #define ERT_ECL_BOX_H

// #include <vector>
// #include <ert/ecl/ecl_grid.hpp>
// Targeting ../ecl_box.java




// #endif


// Parsed from ert/ecl/FortIO.hpp

/*
  Copyright 2015 Equinor ASA.

  This file is part of the Open Porous Media project (OPM).

  OPM is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  OPM is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with OPM.  If not, see <http://www.gnu.org/licenses/>.
*/

// #ifndef OPM_ERT_FORTIO_KW
// #define OPM_ERT_FORTIO_KW

// #include <fstream>
// #include <string>
// #include <memory>

// #include <ert/ecl/fortio.h>
// #include <ert/ecl/ecl_endian_flip.hpp>

// #include <ert/util/ert_unique_ptr.hpp>
// Targeting ../FortIO.java





// #endif


// Parsed from ert/ecl/EclKW.hpp

/*
  Copyright 2015 Equinor ASA.

  This file is part of the Open Porous Media project (OPM).

  OPM is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  OPM is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with OPM.  If not, see <http://www.gnu.org/licenses/>.
*/

// #ifndef OPM_ERT_ECL_KW
// #define OPM_ERT_ECL_KW

// #include <string>
// #include <memory>
// #include <vector>
// #include <stdexcept>
// #include <type_traits>

// #include <ert/util/ert_unique_ptr.hpp>
// #include <ert/ecl/ecl_kw.hpp>
// #include <ert/ecl/ecl_type.hpp>
// #include <ert/ecl/FortIO.hpp>
// Targeting ../ecl_type.java



    /*
      Both std::string and char* are mapped to the eight character string type
      ECL_CHAR_TYPE. That implies that the variable length string type
      ECL_STRING is invisible from this API.
    */











/*
  The current implementation of "string" and "bool" storage in the underlying C
  ecl_kw structure does not lend itself to easily implement operator[]. We have
  therefore explicitly deleted them here.
*/

















/*
  Will write an ecl_kw instance to the open Fortio file.
*/

/*
  Will write an empty ecl_kw instance of type 'MESS' to the Fortio file.
*/
@Namespace("ERT") public static native void write_mess(@ByRef FortIO fortio, @StdString BytePointer kw);
@Namespace("ERT") public static native void write_mess(@ByRef FortIO fortio, @StdString String kw);



// #endif


// Parsed from ert/ecl/EclFilename.hpp

/*
   Copyright (C) 2017  Equinor ASA, Norway.

   This file is part of ERT - Ensemble based Reservoir Tool.

   ERT is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   ERT is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or
   FITNESS FOR A PARTICULAR PURPOSE.

   See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
   for more details.
*/

// #ifndef ERT_ECL_FILEMAME_HPP
// #define ERT_ECL_FILEMAME_HPP
// #include <string>

// #include <ert/ecl/ecl_util.hpp>
    @Namespace("ERT") public static native @StdString BytePointer EclFilename( @StdString BytePointer base, @Cast("ecl_file_enum") int file_type, int report_step, @Cast("bool") boolean fmt_file/*=false*/);
    @Namespace("ERT") public static native @StdString BytePointer EclFilename( @StdString BytePointer base, @Cast("ecl_file_enum") int file_type, int report_step);
    @Namespace("ERT") public static native @StdString String EclFilename( @StdString String base, @Cast("ecl_file_enum") int file_type, int report_step, @Cast("bool") boolean fmt_file/*=false*/);
    @Namespace("ERT") public static native @StdString String EclFilename( @StdString String base, @Cast("ecl_file_enum") int file_type, int report_step);
    @Namespace("ERT") public static native @StdString BytePointer EclFilename( @StdString BytePointer base, @Cast("ecl_file_enum") int file_type, @Cast("bool") boolean fmt_file/*=false*/);
    @Namespace("ERT") public static native @StdString BytePointer EclFilename( @StdString BytePointer base, @Cast("ecl_file_enum") int file_type);
    @Namespace("ERT") public static native @StdString String EclFilename( @StdString String base, @Cast("ecl_file_enum") int file_type, @Cast("bool") boolean fmt_file/*=false*/);
    @Namespace("ERT") public static native @StdString String EclFilename( @StdString String base, @Cast("ecl_file_enum") int file_type);

    @Namespace("ERT") public static native @StdString BytePointer EclFilename( @StdString BytePointer path, @StdString BytePointer base, @Cast("ecl_file_enum") int file_type, int report_step, @Cast("bool") boolean fmt_file/*=false*/);
    @Namespace("ERT") public static native @StdString BytePointer EclFilename( @StdString BytePointer path, @StdString BytePointer base, @Cast("ecl_file_enum") int file_type, int report_step);
    @Namespace("ERT") public static native @StdString String EclFilename( @StdString String path, @StdString String base, @Cast("ecl_file_enum") int file_type, int report_step, @Cast("bool") boolean fmt_file/*=false*/);
    @Namespace("ERT") public static native @StdString String EclFilename( @StdString String path, @StdString String base, @Cast("ecl_file_enum") int file_type, int report_step);
    @Namespace("ERT") public static native @StdString BytePointer EclFilename( @StdString BytePointer path, @StdString BytePointer base, @Cast("ecl_file_enum") int file_type, @Cast("bool") boolean fmt_file/*=false*/);
    @Namespace("ERT") public static native @StdString BytePointer EclFilename( @StdString BytePointer path, @StdString BytePointer base, @Cast("ecl_file_enum") int file_type);
    @Namespace("ERT") public static native @StdString String EclFilename( @StdString String path, @StdString String base, @Cast("ecl_file_enum") int file_type, @Cast("bool") boolean fmt_file/*=false*/);
    @Namespace("ERT") public static native @StdString String EclFilename( @StdString String path, @StdString String base, @Cast("ecl_file_enum") int file_type);

    @Namespace("ERT") public static native @Cast("ecl_file_enum") int EclFiletype( @StdString BytePointer filename );
    @Namespace("ERT") public static native @Cast("ecl_file_enum") int EclFiletype( @StdString String filename );

// #endif


}
