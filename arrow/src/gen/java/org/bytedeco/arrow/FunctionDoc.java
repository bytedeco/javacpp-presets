// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.arrow;

import org.bytedeco.arrow.Function;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.arrow.global.arrow.*;


@Namespace("arrow::compute") @NoOffset @Properties(inherit = org.bytedeco.arrow.presets.arrow.class)
public class FunctionDoc extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FunctionDoc(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public FunctionDoc(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public FunctionDoc position(long position) {
        return (FunctionDoc)super.position(position);
    }
    @Override public FunctionDoc getPointer(long i) {
        return new FunctionDoc((Pointer)this).offsetAddress(i);
    }

  /** \brief A one-line summary of the function, using a verb.
   * 
   *  For example, "Add two numeric arrays or scalars". */
  public native @StdString String summary(); public native FunctionDoc summary(String setter);

  /** \brief A detailed description of the function, meant to follow the summary. */
  
  ///
  public native @StdString String description(); public native FunctionDoc description(String setter);

  /** \brief Symbolic names (identifiers) for the function arguments.
   * 
   *  Some bindings may use this to generate nicer function signatures. */
  public native @ByRef StringVector arg_names(); public native FunctionDoc arg_names(StringVector setter);

  // TODO add argument descriptions?

  /** \brief Name of the options class, if any. */
  public native @StdString String options_class(); public native FunctionDoc options_class(String setter);

  public FunctionDoc() { super((Pointer)null); allocate(); }
  private native void allocate();

  public FunctionDoc(@StdString String summary, @StdString String description,
                @ByVal StringVector arg_names, @StdString String options_class/*=""*/) { super((Pointer)null); allocate(summary, description, arg_names, options_class); }
  private native void allocate(@StdString String summary, @StdString String description,
                @ByVal StringVector arg_names, @StdString String options_class/*=""*/);
  public FunctionDoc(@StdString String summary, @StdString String description,
                @ByVal StringVector arg_names) { super((Pointer)null); allocate(summary, description, arg_names); }
  private native void allocate(@StdString String summary, @StdString String description,
                @ByVal StringVector arg_names);
  public FunctionDoc(@StdString BytePointer summary, @StdString BytePointer description,
                @ByVal StringVector arg_names, @StdString BytePointer options_class/*=""*/) { super((Pointer)null); allocate(summary, description, arg_names, options_class); }
  private native void allocate(@StdString BytePointer summary, @StdString BytePointer description,
                @ByVal StringVector arg_names, @StdString BytePointer options_class/*=""*/);
  public FunctionDoc(@StdString BytePointer summary, @StdString BytePointer description,
                @ByVal StringVector arg_names) { super((Pointer)null); allocate(summary, description, arg_names); }
  private native void allocate(@StdString BytePointer summary, @StdString BytePointer description,
                @ByVal StringVector arg_names);

  public static native @Const @ByRef FunctionDoc Empty();
}
